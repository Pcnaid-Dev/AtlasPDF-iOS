
#Main Repo Codebase

```text

naid-dev-atlaspdf-ios/
    ├── README.md
    ├── ci_scripts/
    │   └── ci_post_clone.sh
    ├── pdfexpert/
    │   ├── Montserrat-Bold.ttf
    │   ├── Montserrat-ExtraBold.ttf
    │   ├── Montserrat-Medium.ttf
    │   ├── Montserrat-Regular.ttf
    │   ├── PdfExpert.entitlements
    │   ├── .DS_Store
    │   ├── Applicaction/
    │   │   ├── AppDelegate.swift
    │   │   ├── Constants.swift
    │   │   ├── PdfExpertApp.swift
    │   │   └── SceneDelegate.swift
    │   ├── InternalUtils/
    │   │   ├── ImageCropper.swift
    │   │   ├── PdfScanUtility.swift
    │   │   ├── PdfUtility.swift
    │   │   ├── SharedErrors.swift
    │   │   ├── SharedStorage.swift
    │   │   ├── SubscriptionViewUtility.swift
    │   │   ├── View+Internal.swift
    │   │   └── View+Preview.swift
    │   ├── Models/
    │   │   ├── AppTrackingTransparency.swift
    │   │   ├── AppTrackingTransparencyImpl.swift
    │   │   ├── AttibutionManagerImpl.swift
    │   │   ├── AttributionManager.swift
    │   │   ├── ConfigService.swift
    │   │   ├── RemoteConfigManager.swift
    │   │   ├── Store.swift
    │   │   ├── StoreImpl.swift
    │   │   ├── .DS_Store
    │   │   ├── Analytics/
    │   │   │   ├── AnalyticsDefaultParameters.swift
    │   │   │   ├── AnalyticsManager.swift
    │   │   │   ├── AnalyticsManagerImpl.swift
    │   │   │   ├── AnalyticsPlatform.swift
    │   │   │   ├── BranchAnalyticsPlatform.swift
    │   │   │   └── FirebaseAnalyticsPlatform.swift
    │   │   ├── Entities/
    │   │   │   ├── ChatPdfInitParams.swift
    │   │   │   ├── ChatPdfMessage.swift
    │   │   │   ├── ChatPdfRef.swift
    │   │   │   ├── ChatPdfSetupData.swift
    │   │   │   ├── Pdf.swift
    │   │   │   ├── PickedImage.swift
    │   │   │   ├── ProjectInfo.swift
    │   │   │   ├── Signature.swift
    │   │   │   └── SuggestedFields.swift
    │   │   ├── Network/
    │   │   │   ├── NetworkUtility.swift
    │   │   │   └── ChatPdf/
    │   │   │       ├── ChatPdfManager.swift
    │   │   │       ├── ChatPdfManagerImpl.swift
    │   │   │       ├── ChatPdfManagerMock.swift
    │   │   │       └── Mapping/
    │   │   │           ├── ChatPdfMessage+Decodable.swift
    │   │   │           ├── ChatPdfRef+Decodable.swift
    │   │   │           └── ChatPdfSetupData+Decodable.swift
    │   │   └── Persistence/
    │   │       ├── CacheManager.swift
    │   │       ├── CacheManagerImpl.swift
    │   │       ├── Repository.swift
    │   │       ├── RepositoryImpl.swift
    │   │       └── CoreData/
    │   │           ├── CDPdf.swift
    │   │           ├── CDSignature.swift
    │   │           ├── CDSuggestedFields.swift
    │   │           ├── Persistence.swift
    │   │           └── Persistable/
    │   │               ├── Pdf+Persistable.swift
    │   │               ├── Persistable.swift
    │   │               ├── Signature+Persistable.swift
    │   │               └── SuggestedFields+Persistable.swift
    │   ├── Preview Content/
    │   │   └── Preview Assets.xcassets/
    │   │       └── Contents.json
    │   ├── Resources/
    │   │   ├── InfoTemplate.plist
    │   │   ├── .DS_Store
    │   │   ├── Animations/
    │   │   │   ├── loading.json
    │   │   │   └── pdf-scanning.json
    │   │   ├── AppCoreData.xcdatamodeld/
    │   │   │   ├── .xccurrentversion
    │   │   │   └── PdfExpert.xcdatamodel/
    │   │   │       └── contents
    │   │   ├── Assets.xcassets/
    │   │   │   ├── Contents.json
    │   │   │   ├── .DS_Store
    │   │   │   ├── AccentColor.colorset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── AppIcon.appiconset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── AppIconStaging.appiconset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── archive_empty.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── camera.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── edit_add_file.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── edit_add_text.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── edit_compression.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── edit_fill_form.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── edit_margins.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── edit_option_compress.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── edit_option_password_lock.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── edit_option_password_unlock.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── edit_option_split.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── edit_signature.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── file.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── gallery.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_add_password.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_add_text.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_create_pdf.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_excel_to_pdf.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_file_source_dropbox.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_file_source_files.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_file_source_google.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_file_source_icloud.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_fill_form.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_image_to_pdf.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_import_pdf.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_merge.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_power_to_pdf.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_read.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_remove_password.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_scan.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_sign.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_split.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── home_word_to_pdf.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── import_tutorial_1.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── import_tutorial_2.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── import_tutorial_3.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── info.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── logo_large.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── manage_annotations.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── manage_widget.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── onboarding_chat_pdf.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── onboarding_convert.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── onboarding_password.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── onboarding_signature.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── page_selection.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── password_entered.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── password_missing.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── review_low_rate.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── scan.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── settings.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── sign_drawing.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── signature.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── Subscription/
    │   │   │   │   ├── Contents.json
    │   │   │   │   ├── subscription_feature_chat_pdf.imageset/
    │   │   │   │   │   └── Contents.json
    │   │   │   │   ├── subscription_feature_convert.imageset/
    │   │   │   │   │   └── Contents.json
    │   │   │   │   ├── subscription_feature_edit.imageset/
    │   │   │   │   │   └── Contents.json
    │   │   │   │   ├── subscription_feature_password.imageset/
    │   │   │   │   │   └── Contents.json
    │   │   │   │   └── subscription_feature_signature.imageset/
    │   │   │   │       └── Contents.json
    │   │   │   ├── subscription_error.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── suggested_fields.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── tab_archive.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── tab_chat_pdf.imageset/
    │   │   │   │   └── Contents.json
    │   │   │   └── tab_home.imageset/
    │   │   │       └── Contents.json
    │   │   ├── Colors.xcassets/
    │   │   │   ├── Contents.json
    │   │   │   ├── AppPrimary.colorset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── Extra.colorset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── FourthText.colorset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── PrimaryBG.colorset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── PrimaryText.colorset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── SecondaryBG.colorset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── SecondaryText.colorset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── Specific/
    │   │   │   │   ├── Contents.json
    │   │   │   │   ├── ButtonGradientEnd.colorset/
    │   │   │   │   │   └── Contents.json
    │   │   │   │   └── ButtonGradientStart.colorset/
    │   │   │   │       └── Contents.json
    │   │   │   └── ThirdText.colorset/
    │   │   │       └── Contents.json
    │   │   ├── Fonts/
    │   │   │   ├── Poppins-Black.ttf
    │   │   │   ├── Poppins-BlackItalic.ttf
    │   │   │   ├── Poppins-Bold.ttf
    │   │   │   ├── Poppins-BoldItalic.ttf
    │   │   │   ├── Poppins-ExtraBold.ttf
    │   │   │   ├── Poppins-ExtraBoldItalic.ttf
    │   │   │   ├── Poppins-ExtraLight.ttf
    │   │   │   ├── Poppins-ExtraLightItalic.ttf
    │   │   │   ├── Poppins-Italic.ttf
    │   │   │   ├── Poppins-Light.ttf
    │   │   │   ├── Poppins-LightItalic.ttf
    │   │   │   ├── Poppins-Medium.ttf
    │   │   │   ├── Poppins-MediumItalic.ttf
    │   │   │   ├── Poppins-Regular.ttf
    │   │   │   ├── Poppins-SemiBold.ttf
    │   │   │   ├── Poppins-SemiBoldItalic.ttf
    │   │   │   ├── Poppins-Thin.ttf
    │   │   │   └── Poppins-ThinItalic.ttf
    │   │   ├── IAP/
    │   │   │   ├── EmptyProducts.storekit
    │   │   │   ├── LocalProductionProducts.storekit
    │   │   │   ├── LocalStagingProducts.storekit
    │   │   │   ├── ProductionProducts.storekit
    │   │   │   ├── Products.plist
    │   │   │   └── StagingProducts.storekit
    │   │   ├── Production/
    │   │   │   └── .DS_Store
    │   │   ├── Staging/
    │   │   │   └── .DS_Store
    │   │   └── Test/
    │   ├── Style/
    │   │   ├── AnimationPalette.swift
    │   │   ├── ColorPalette.swift
    │   │   └── FontPalette.swift
    │   ├── Utils/
    │   │   ├── Async.swift
    │   │   ├── CombineUtils.swift
    │   │   ├── DebugUtils.swift
    │   │   ├── MathUtils.swift
    │   │   ├── ParentalCheck.swift
    │   │   ├── PDFImageExtractor.swift
    │   │   ├── .DS_Store
    │   │   ├── Camera/
    │   │   │   ├── CameraPreviewView.swift
    │   │   │   ├── CameraService+Enums.swift
    │   │   │   ├── CameraService+Extensions.swift
    │   │   │   ├── CameraService.swift
    │   │   │   ├── ImageResizer.swift
    │   │   │   └── PhotoCaptureProcessor.swift
    │   │   ├── Extensions/
    │   │   │   ├── Color+Extensions.swift
    │   │   │   ├── CoreGraphics+Extensions.swift
    │   │   │   ├── Enum+Extensions.swift
    │   │   │   ├── Foundation+Extensions.swift
    │   │   │   ├── NSAttributedString+Extensions.swift
    │   │   │   ├── ObservableObject+Extensions.swift
    │   │   │   ├── PDFAnnotation+Extensions.swift
    │   │   │   ├── PdfDocument+Extensions.swift
    │   │   │   ├── PencilKit+Extensions.swift
    │   │   │   ├── StoreKit+Extensions.swift
    │   │   │   ├── String+Extensions.swift
    │   │   │   ├── UIApplication+Extensions.swift
    │   │   │   ├── UIFont+Extensions.swift
    │   │   │   ├── URL+Extensions.swift
    │   │   │   ├── View+Alert.swift
    │   │   │   └── View+Extensions.swift
    │   │   ├── Protocols/
    │   │   │   └── .DS_Store
    │   │   └── UI/
    │   │       ├── ActivityViewController.swift
    │   │       ├── AsyncView.swift
    │   │       ├── CircularProgressView.swift
    │   │       ├── FilePicker.swift
    │   │       ├── FormSheet.swift
    │   │       ├── FullScreenClearBackground.swift
    │   │       ├── ImageAnnotationStamp.swift
    │   │       ├── ImageResizableView.swift
    │   │       ├── LoadingView.swift
    │   │       ├── LottieView.swift
    │   │       ├── PageControl.swift
    │   │       ├── PdfKitView.swift
    │   │       ├── PdfKitViewBinder.swift
    │   │       ├── PencilKitView.swift
    │   │       ├── PopupView.swift
    │   │       ├── RoundedCorner.swift
    │   │       ├── SizePrinter.swift
    │   │       ├── TextResizableView.swift
    │   │       ├── UnderlyingError.swift
    │   │       └── ZoomImageModifier.swift
    │   ├── ViewModels/
    │   │   ├── ArchiveViewModel.swift
    │   │   ├── CameraImageProviderFlow.swift
    │   │   ├── CameraViewModel.swift
    │   │   ├── ChatPdfSelectionViewModel.swift
    │   │   ├── ChatPdfViewModel.swift
    │   │   ├── GalleryImageProviderFlow.swift
    │   │   ├── HomeViewModel.swift
    │   │   ├── ImageCropFlow.swift
    │   │   ├── OnboardingViewModel.swift
    │   │   ├── PdfEditViewModel.swift
    │   │   ├── PdfFillFormViewModel.swift
    │   │   ├── PdfFillWidgetViewModel.swift
    │   │   ├── PdfImportMultipleViewModel.swift
    │   │   ├── PdfImportViewModel.swift
    │   │   ├── PdfMergeViewModel.swift
    │   │   ├── PdfPageRangeEditorViewModel.swift
    │   │   ├── PdfReaderViewModel.swift
    │   │   ├── PdfReadViewModel.swift
    │   │   ├── PdfSignatureCanvasViewModel.swift
    │   │   ├── PdfSignaturePickerViewModel.swift
    │   │   ├── PdfSignaturePrioviderFlow.swift
    │   │   ├── PdfSignatureViewModel.swift
    │   │   ├── PdfSortViewModel.swift
    │   │   ├── PdfSplitViewModel.swift
    │   │   ├── PdfUnlockViewModel.swift
    │   │   ├── ReviewFlow.swift
    │   │   ├── SubscribeViewModel.swift
    │   │   ├── SubscriptionPairsViewModel.swift
    │   │   ├── SubscriptionPickerViewModel.swift
    │   │   ├── SubscriptionVerticalViewModel.swift
    │   │   └── SuggestedFieldsFormViewModel.swift
    │   └── Views/
    │       ├── ContentView.swift
    │       ├── .DS_Store
    │       ├── Archive/
    │       │   └── ArchiveView.swift
    │       ├── Camera/
    │       │   └── CameraView.swift
    │       ├── ChatPdf/
    │       │   ├── ChatPdfSelectionView.swift
    │       │   ├── ChatPdfView.swift
    │       │   ├── MessageIndicatorView.swift
    │       │   └── MessageView.swift
    │       ├── Common/
    │       │   ├── AddPasswordView.swift
    │       │   ├── CameraImageProviderFlowView.swift
    │       │   ├── GalleryImageProviderFlowView.swift
    │       │   ├── ImageCropFlowView.swift
    │       │   ├── ImportOption.swift
    │       │   ├── OptionItemView.swift
    │       │   ├── OptionListView.swift
    │       │   ├── PdfImageViewerView.swift
    │       │   ├── PdfImportMultipleView.swift
    │       │   ├── PdfImportView.swift
    │       │   ├── PdfMergeView.swift
    │       │   ├── PdfPageRangeEditorView.swift
    │       │   ├── PdfPageSelectionView.swift
    │       │   ├── PdfReaderView.swift
    │       │   ├── PdfReadView.swift
    │       │   ├── PdfShareView.swift
    │       │   ├── PdfSortView.swift
    │       │   ├── PdfSplitView.swift
    │       │   ├── PdfUnlockView.swift
    │       │   └── SuggestedFieldsFormView.swift
    │       ├── Home/
    │       │   ├── HomeItemView.swift
    │       │   └── HomeView.swift
    │       ├── ImportTutorial/
    │       │   ├── ImportTutorialPageView.swift
    │       │   └── ImportTutorialView.swift
    │       ├── Main/
    │       │   └── MainTabView.swift
    │       ├── Navigation/
    │       │   ├── Deeplink.swift
    │       │   ├── MainCoordinator.swift
    │       │   ├── PdfCoordinator.swift
    │       │   └── PdfShareCoordinator.swift
    │       ├── Onboarding/
    │       │   ├── OnboardingPageView.swift
    │       │   └── OnboardingView.swift
    │       ├── Pdf/
    │       │   ├── PdfCompressionPickerView.swift
    │       │   ├── PdfEditView.swift
    │       │   ├── PdfFillFormView.swift
    │       │   ├── PdfFillWidgetView.swift
    │       │   ├── PdfFlowView.swift
    │       │   ├── PdfSignatureCanvasView.swift
    │       │   ├── PdfSignaturePickerView.swift
    │       │   ├── PdfSignatureProviderFlowView.swift
    │       │   └── PdfSignatureView.swift
    │       ├── Review/
    │       │   ├── PreReviewPopupLowRateView.swift
    │       │   ├── PreReviewPopupView.swift
    │       │   └── ReviewFlowView.swift
    │       ├── Scan/
    │       │   └── ScannerView.swift
    │       ├── Settings/
    │       │   └── SettingsView.swift
    │       ├── Subscription/
    │       │   ├── SubscriptionErrorView.swift
    │       │   ├── SubscriptionFreeTrialToggleView.swift
    │       │   ├── SubscriptionPairsItemView.swift
    │       │   ├── SubscriptionPairsView.swift
    │       │   ├── SubscriptionPickerPlanListView.swift
    │       │   ├── SubscriptionPickerPlanView.swift
    │       │   ├── SubscriptionPickerView.swift
    │       │   ├── SubscriptionVerticalItemView.swift
    │       │   └── SubscriptionVerticalView.swift
    │       └── Welcome/
    │           └── WelcomeView.swift
    ├── pdfexpert.xcodeproj/
    │   ├── project.pbxproj
    │   ├── project.xcworkspace/
    │   │   ├── contents.xcworkspacedata
    │   │   └── xcshareddata/
    │   │       ├── IDEWorkspaceChecks.plist
    │   │       ├── WorkspaceSettings.xcsettings
    │   │       └── swiftpm/
    │   │           └── Package.resolved
    │   └── xcshareddata/
    │       └── xcschemes/
    │           ├── PdfExpert Staging.xcscheme
    │           ├── PdfExpert.xcscheme
    │           └── ShareFileExtension.xcscheme
    └── ShareFileExtension/
        ├── ShareFileExtension.entitlements
        ├── ShareViewController.swift
        ├── .DS_Store
        ├── Base.lproj/
        │   └── MainInterface.storyboard
        └── Resources/
            ├── .DS_Store
            ├── Production/
            │   └── Info.plist
            └── Staging/
                └── Info.plist

================================================
FILE: README.md
================================================

# AtlasPDF
AtlasPDF is an iOS app for iPhones that allow users to edit and manage their pdf files.

# Main features

## Conversion and Import
1. Conversion of Word, Pages, PowerPoint, Keynote, Excel and Numbers files to pdf.
2. Image acquistion from gallery, camera and File app, and conversion to pdf.
3. Import pdf (from within the app and through app extension).
4. Scan documents to pdf.

## Edit
1. Add margins.
2. Change compression quality.
3. Add pages.
4. Reorder pages.
5. Delete pages.
6. Add text annotations.
7. Fill editable fields.
8. Add signature.
9. Remove/add password.

## Other
1. Share of pdf files.
2. Subscription to unlock share feature.
3. Stored created pdf through iCloud.
4. Deletion of created pdfs.
5. Onboarding with tutorial.
6. Tutorial to open pdf from outside the app through app extension.

# Technologies Used
1. SwiftUI
2. StoreKit 2
3. Core Data
4. iCloud
5. PDFKit
6. Firebase Analytics
7. Firebase Remote Config (used to switch between two type of subscription screens)
8. VisionKit (used for the scanner feature)
9. PencilKit (used to take the user's signature)



================================================
FILE: ci_scripts/ci_post_clone.sh
================================================
#!/bin/sh

#  ci_post_clone.sh
#  PdfExpert
#
#  Created by Pcnaid Inc on 19/07/23.
#  

echo "POST CLONE-Xcode Build started"

BasePath=${CI_WORKSPACE}/PdfExpert

# GoogleService-Info.plist

CurrentFilePath=${BasePath}/Resources/Staging/GoogleService-Info.plist
touch "${CurrentFilePath}"
echo $CUSTOM_GOOGLE_SERVICE_INFO >"${CurrentFilePath}"

CurrentFilePath=${BasePath}/Resources/Production/GoogleService-Info.plist
touch "${CurrentFilePath}"
echo $CUSTOM_GOOGLE_SERVICE_INFO >"${CurrentFilePath}"

# Info.plist

CurrentFilePath=${BasePath}/Resources/Staging/Info.plist
touch "${CurrentFilePath}"
echo $CUSTOM_GOOGLE_SERVICE_INFO >"${CurrentFilePath}"

CurrentFilePath=${BasePath}/Resources/Production/Info.plist
touch "${CurrentFilePath}"
echo $CUSTOM_GOOGLE_SERVICE_INFO >"${CurrentFilePath}"

# ProjectInfo.plist

CurrentFilePath=${BasePath}/Resources/ProjectInfo.plist
touch "${CurrentFilePath}"
echo $CUSTOM_PROJECT_INFO >"${CurrentFilePath}"

echo "POST CLONE-Xcode Build finished"

exit 0



================================================
FILE: pdfexpert/Montserrat-Bold.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Montserrat-ExtraBold.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Montserrat-Medium.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Montserrat-Regular.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/PdfExpert.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>aps-environment</key>
	<string>development</string>
	<key>com.apple.developer.associated-domains</key>
	<array>
		<string>webcredentials:pcnaid.com</string>
		<string>applinks:cmrd2.app.link</string>
		<string>applinks:cmrd2-alternate.app.link</string>
		<string>applinks:cmrd2.test.app.link</string>
	</array>
	<key>com.apple.developer.icloud-container-identifiers</key>
	<array>
		<string>iCloud.pdfexpert</string>
	</array>
	<key>com.apple.developer.icloud-services</key>
	<array>
		<string>CloudKit</string>
		<string>CloudDocuments</string>
	</array>
	<key>com.apple.developer.ubiquity-container-identifiers</key>
	<array>
		<string>iCloud.pdfexpert</string>
	</array>
	<key>com.apple.security.application-groups</key>
	<array>
		<string>group.pcnaid.pdfexpert</string>
	</array>
</dict>
</plist>



================================================
FILE: pdfexpert/.DS_Store
================================================
[Non-text file]


================================================
FILE: pdfexpert/Applicaction/AppDelegate.swift
================================================
//
//  AppDelegate.swift
//  pdfexpert
//
//  Created by Pcnaid Inc on 28/03/23.
//

import UIKit
import FirebaseCore
import FacebookCore
import Factory

class AppDelegate: UIResponder, UIApplicationDelegate {

    @Injected(\.attibutionManager) var attibutionManager

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // App-level initializations belong here
        FirebaseApp.configure()
        ApplicationDelegate.shared.application(application, didFinishLaunchingWithOptions: launchOptions)
        self.attibutionManager.onAppDidFinishLaunching(withLaunchOptions: launchOptions)
        ProjectInfo.validate()

        // Appearance setup is moved to SceneDelegate

        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }

    // setupAppearance() method is removed from here
}



================================================
FILE: pdfexpert/Applicaction/Constants.swift
================================================
//
//  Constants.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 23/02/23.
//

import Foundation
import CoreData
import UniformTypeIdentifiers
import PDFKit
import Factory

enum SubscriptionViewType: CaseIterable {
    case pairs
    case verticalHighlightLongPeriod
    case verticalHighlightShortPeriod
    case picker
}

struct K {
    struct Test {
        static let UseMockDB = false
        static let NumberOfPdfs = 5
        
        static var DebugPdfDocumentUrl: URL? {
            return Bundle.main.url(forResource: "test", withExtension: "pdf")
        }
        
        static var DebugPdfDocumentData: Data? {
            guard let testFileUrl = DebugPdfDocumentUrl, (try? testFileUrl.checkResourceIsReachable()) ?? false else { return nil }
            return try? Data(contentsOf: testFileUrl)
        }
        
        static var DebugPdfDocument: PDFDocument? {
            guard let testFileDataUrl = DebugPdfDocumentData else { return nil }
            return PDFDocument(data: testFileDataUrl)
        }
        
        static func GetDebugCoreDataPdf(context: NSManagedObjectContext) -> CDPdf? {
            guard let testPdf = DebugPdf, let pdfData = testPdf.rawData else { return nil }
            let coreDataPdf = CDPdf(context: context)
            coreDataPdf.update(withPdf: testPdf, pdfData: pdfData)
            return coreDataPdf
        }
        
        static var DebugPdf: Pdf? {
            guard let testPdfDocument = DebugPdfDocument else { return nil }
            return Pdf(pdfDocument: testPdfDocument)
        }
        
        struct ChatPdf {
            static let UseMock = false
            static let NetworkStubsDelay = 1.0
            static let NetworkLogVerbose = false
        }
        
        struct Review {
            // If set to true, the review flow starts every time the current logic would trigger it,
            // even if it has already been shown in the past.
            static let ShowAlways = false
        }
    }
    
    struct MonetizationK {
        static let defaultSubscriptionViewType: SubscriptionViewType = .verticalHighlightLongPeriod
    }
    
    struct RemoteConfigK {
        static let DebugRemoteConfigExpirationDuration: TimeInterval = 30.0
        static let DefaultRemoteConfigExpirationDuration: TimeInterval = 60.0 * 60.0
    }
    
    struct ChatPdf {
        static let MaxBytes: UInt64 = 32 * 1_048_576 // 32 MB
        static let MaxPages: Int = 2000
        static let SetupMessageFallbackResponse: String = "Ask me something about your pdf!"
        static let SetupMessageRequest: String = """
Make a summary and suggest three questions. Format your response as a json with the following structure:
{
    "\(ChatPdfSetupData.CodingKeys.summary.rawValue)": "content of the summary",
    "\(ChatPdfSetupData.CodingKeys.suggestedQuestions.rawValue)": [
        "suggested question number 1",
        "suggested question number 2",
        "suggested question number 3"
    ]
}
"""
    }
    
    struct Review {
        static let MinimumRateForNativePopup: Int = 5
        static let FeedbackMaxCharacters: Int = 100
    }
    
    struct Misc {
        static let AppTitle = "AtlasPDF"
        
        static let PrivacyPolicyUrlString = "https://pcnaid.com/policy-viewer/privacy"
        static let TermsAndConditionsUrlString = "https://pcnaid.com/policy-viewer/terms"
        
        static let ImportFileTypesForAddPage: [UTType] = {
            [
                UTType.image,
                UTType.pdf,
                .presentation,
                .spreadsheet,
                UTType("com.microsoft.word.doc"),
                UTType("com.apple.iwork.pages.sffpages")
            ].compactMap { $0 }
        }()
        static let ImportFileTypesForMerge: [UTType] = { [UTType.pdf].compactMap { $0 } }()
        static let ImportFileTypesForSplit: [UTType] = { [UTType.pdf].compactMap { $0 } }()
        static let ImportFileTypesForRead: [UTType] = { [UTType.pdf].compactMap { $0 } }()
        
        static let ThumbnailSize: CGSize = CGSize(width: 256, height: 256)
        static let ThumbnailEditSize: CGSize = CGSize(width: 80, height: 80)
        static let PdfPageSize: CGSize = CGSize(width: 595, height: 842)
        static let PdfPageDefaultMargin: CGFloat = 0
        static let DefaultAnnotationTextFontSize: CGFloat = 10.0
        static let DefaultAnnotationTextFontName: String = "Arial"
        static let PdfMarginsColor: UIColor = .white
        static let PdfDefaultMarginsOption: MarginsOption = .noMargins
        static let PdfDefaultCompression: CompressionOption = .noCompression
        static let PdfReaderDefaultFontScale: CGFloat = 1.5
        static let SignatureDrawScaleFactor: CGFloat = 3.0
    }
}

extension MarginsOption {
    var horizontalMargin: CGFloat {
        switch self {
        case .noMargins: return 0.0
        case .mediumMargins: return 20.0
        case .heavyMargins: return 40.0
        }
    }
}

extension CompressionOption {
    var quality: CGFloat {
        switch self {
        case .noCompression: return 1.0
        case .low: return 0.66
        case .medium: return 0.33
        case .high: return 0
        }
    }
}

extension ImportFileOption: FilePickerTypeProvider {
     
    var fileTypes: [UTType] {
        switch self {
        case .image: return [UTType.image]
        case .word: return [UTType("com.microsoft.word.doc")].compactMap { $0 }
        case .excel: return [.spreadsheet]
        case .powerpoint: return [.presentation]
        case .pdf: return [UTType.pdf]
        case .allDocs: return [
            UTType.pdf,
            .presentation,
            .spreadsheet,
            UTType("com.microsoft.word.doc"),
            UTType("com.apple.iwork.pages.sffpages")
        ].compactMap { $0 }
        }
    }
 }



================================================
FILE: pdfexpert/Applicaction/PdfExpertApp.swift
================================================
//
//  PdfExpertApp.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/03/23.
//

import SwiftUI

@main
struct PdfExpertApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}



================================================
FILE: pdfexpert/Applicaction/SceneDelegate.swift
================================================
//
//  SceneDelegate.swift
//  pdfexpert
//
//  Created by AbdulBadran on 4/16/25.
//

import UIKit
import SwiftUI // Import SwiftUI if ColorPalette/FontPalette are defined there or rely on it

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.

        // Setup global appearance just before the scene's window appears
        self.setupAppearance()

        // If using SwiftUI App lifecycle (@main struct ... : App),
        // the system handles window creation and root view controller setup.
        // No manual window setup needed here if PdfExpertApp.swift has WindowGroup.

        guard let _ = (scene as? UIWindowScene) else { return }

        // Example if you needed to inject environment objects into ContentView
        // (assuming ContentView is your root view from PdfExpertApp)
        // if let windowScene = scene as? UIWindowScene {
        //     let window = UIWindow(windowScene: windowScene)
        //     let contentView = ContentView().environmentObject(YourObservableObject()) // Example
        //     window.rootViewController = UIHostingController(rootView: contentView)
        //     self.window = window
        //     window.makeKeyAndVisible()
        // }

        // If your PdfExpertApp.swift correctly defines the WindowGroup with ContentView,
        // the standard template code above is often sufficient, and SwiftUI handles the rest.
    }

    private func setupAppearance() {
        // Copied from AppDelegate
        UINavigationBar.appearance().isTranslucent = false
        // Make sure ColorPalette and FontPalette are accessible here
        // You might need to ensure they are defined globally or imported correctly
        // If they are SwiftUI types (e.g., Color, Font), use them directly.
        // If they return UIColors/UIFonts, the existing code is fine.

        // Assuming ColorPalette.primaryText returns a type initializable by UIColor
        // and FontPalette.uiFontMedium returns a UIFont
        // If not, adjust the initializers accordingly.
        UINavigationBar.appearance().tintColor = UIColor(ColorPalette.primaryText) // Example if using Asset Catalog Color
        // Or if ColorPalette.primaryText IS a UIColor:
        // UINavigationBar.appearance().tintColor = ColorPalette.primaryText

        UINavigationBar.appearance().largeTitleTextAttributes = [.font : UIFont.systemFont(ofSize: 24, weight: .medium)] // Example using system font
        // Or if FontPalette.uiFontMedium returns a UIFont:
        // UINavigationBar.appearance().largeTitleTextAttributes = [.font : FontPalette.uiFontMedium(withSize: 24)]

        let tabBarAppearance = UITabBarAppearance()
        tabBarAppearance.configureWithOpaqueBackground()
        // Similar adjustments might be needed for ColorPalette usage:
        tabBarAppearance.backgroundColor = UIColor(ColorPalette.secondaryBG) // Example
        tabBarAppearance.selectionIndicatorTintColor = UIColor(ColorPalette.buttonGradientStart) // Example

        UITabBar.appearance().scrollEdgeAppearance = tabBarAppearance
        UITabBar.appearance().standardAppearance = tabBarAppearance
    }


    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.
    }
}



================================================
FILE: pdfexpert/InternalUtils/ImageCropper.swift
================================================
//
//  ImageCropper.swift
//  MantisSwiftUIExample
//
//  Created by Yingtao Guo on 2/16/23.
//

import Mantis
import SwiftUI

enum ImageCropperType {
    case normal
    case noRotaionDial
}

struct ImageCropper: UIViewControllerRepresentable {
    @Binding var image: UIImage?
    @Binding var cropShapeType: Mantis.CropShapeType
    @Binding var presetFixedRatioType: Mantis.PresetFixedRatioType
    @Binding var type: ImageCropperType
    
    @Environment(\.presentationMode) var presentationMode
    
    class Coordinator: CropViewControllerDelegate {
        var parent: ImageCropper
        
        init(_ parent: ImageCropper) {
            self.parent = parent
        }
        
        func cropViewControllerDidCrop(_ cropViewController: Mantis.CropViewController, cropped: UIImage, transformation: Transformation, cropInfo: CropInfo) {
            parent.image = cropped
            print("transformation is \(transformation)")
            parent.presentationMode.wrappedValue.dismiss()
        }
        
        func cropViewControllerDidCancel(_ cropViewController: Mantis.CropViewController, original: UIImage) {
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    func makeUIViewController(context: Context) -> UIViewController {
        switch type {
        case .normal:
            return makeNormalImageCropper(context: context)
        case .noRotaionDial:
            return makeImageCropperHiddingRotationDial(context: context)
        }
    }
    
    func updateUIViewController(_ uiViewController: UIViewController, context: Context) {
        
    }
}

extension ImageCropper {
    func makeNormalImageCropper(context: Context) -> UIViewController {
        var config = Mantis.Config()
        config.cropViewConfig.cropShapeType = cropShapeType
        config.presetFixedRatioType = presetFixedRatioType
        let cropViewController = Mantis.cropViewController(image: image!,
                                                           config: config)
        cropViewController.delegate = context.coordinator
        return cropViewController
    }
    
    func makeImageCropperHiddingRotationDial(context: Context) -> UIViewController {
        var config = Mantis.Config()
        config.cropViewConfig.showAttachedRotationControlView = false
        let cropViewController = Mantis.cropViewController(image: image!, config: config)
        cropViewController.delegate = context.coordinator

        return cropViewController
    }
}



================================================
FILE: pdfexpert/InternalUtils/PdfScanUtility.swift
================================================
//
//  PdfScanUtility.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/05/23.
//

import Foundation
import SwiftUI
import PDFKit

class PdfScanUtility {
    
    static func convertScan(scannerResult: ScannerResult, asyncOperation: Binding<AsyncOperation<Pdf, PdfError>>) {
        
        let progress = Progress(totalUnitCount: Int64(scannerResult.scan.pageCount))
        asyncOperation.wrappedValue = AsyncOperation(status: .loading(progress))
        
        DispatchQueue.global(qos: .userInitiated).async {

            let pdfDocument = PDFDocument()
            for pageIndex in 0..<scannerResult.scan.pageCount {
                let pageImage = scannerResult.scan.imageOfPage(at: pageIndex)
                if let page = pageImage.pdfPage() {
                    pdfDocument.insert(page, at: pdfDocument.pageCount)
                }
                
                DispatchQueue.main.async {
                    progress.completedUnitCount = Int64(pageIndex)
                    asyncOperation.wrappedValue = AsyncOperation(status: .loading(progress))
                }
            }
            
            DispatchQueue.main.async {
                asyncOperation.wrappedValue = AsyncOperation(status: .data(Pdf(pdfDocument: pdfDocument)))
            }
        }
    }
}



================================================
FILE: pdfexpert/InternalUtils/PdfUtility.swift
================================================
//
//  PdfUtility.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/04/23.
//

import Foundation
import PDFKit
import CoreData

class PDFUtility {
    
    static func convertUiImageToPdf(uiImage: UIImage) -> PDFDocument {
        let pdfDocument = PDFDocument()
        appendImageToPdfDocument(pdfDocument: pdfDocument, uiImage: uiImage)
        return pdfDocument
    }
    
    static func appendImageToPdfDocument(pdfDocument: PDFDocument, uiImage: UIImage) {
        
        if let pdfPage = uiImage.pdfPage() {
            pdfDocument.insert(pdfPage, at: pdfDocument.pageCount)
        } else {
            assertionFailure("Couldn't create pdf page from given UIImage")
        }
    }
    
    static func appendPdfDocument(_ pdfDocument: PDFDocument, toPdfDocument: PDFDocument) {
        for pageIndex in 0..<pdfDocument.pageCount {
            if let page = pdfDocument.page(at: pageIndex) {
                toPdfDocument.insert(page, at: toPdfDocument.pageCount)
            } else {
                assertionFailure("Missing expected page at index: \(pageIndex)")
            }
        }
    }
    
    static func generatePdfThumbnails(pdfDocument: PDFDocument, size: CGSize?) -> [UIImage?] {
        var thumbnails: [UIImage?] = []
        for index in 0..<pdfDocument.pageCount {
            let image = Self.generatePdfThumbnail(pdfDocument: pdfDocument,
                                                  size: size,
                                                  forPageIndex: index)
            thumbnails.append(image)
        }
        return thumbnails
    }
    
    static func generatePdfThumbnail(documentData: Data,
                                     size: CGSize?,
                                     forPageIndex pageIndex: Int = 0) -> UIImage? {
        guard let pdfDocument = PDFDocument(data: documentData) else { return nil }
        return self.generatePdfThumbnail(pdfDocument: pdfDocument,
                                         size: size,
                                         forPageIndex: pageIndex)
    }
    
    static func generatePdfThumbnail(pdfDocument: PDFDocument,
                                     size: CGSize?,
                                     forPageIndex pageIndex: Int = 0) -> UIImage? {
        guard pageIndex >= 0, pageIndex < pdfDocument.pageCount else { return nil }
        guard let pdfDocumentPage = pdfDocument.page(at: pageIndex) else { return nil }
        if let size = size {
            let nativeScale = UIScreen.main.nativeScale
            let nativeSize = CGSize(width: size.width * nativeScale, height: size.height * nativeScale)
            return pdfDocumentPage.thumbnail(of: nativeSize, for: PDFDisplayBox.trimBox)
        } else {
            return pdfDocumentPage.thumbnail(of: pdfDocumentPage.bounds(for: .mediaBox).size, for: .mediaBox)
        }
    }
    
    static func applyPostProcess(toPdfDocument pdfDocument: PDFDocument, margins: MarginsOption, compression: CompressionOption) -> PDFDocument {
        
        guard pdfDocument.pageCount > 0 else { return PDFDocument(data: pdfDocument.dataRepresentation()!)! }
        guard margins != .noMargins, compression != .noCompression else { return PDFDocument(data: pdfDocument.dataRepresentation()!)! }
        
        let newPdfDocument = PDFDocument()
        for pageIndex in 0..<pdfDocument.pageCount {
            guard let page = pdfDocument.page(at: pageIndex) else {
                continue
            }
            
            // Fetch the page rect for the page we want to render.
            let pageRect = page.bounds(for: .mediaBox)
            
            let originalSize = pageRect.size
            
            let newWidth = originalSize.width - margins.horizontalMargin * 2
            let newHeight = (originalSize.height / originalSize.width) * newWidth
            
            let renderer = UIGraphicsImageRenderer(size: originalSize)
            var newImage = renderer.image { ctx in
                
                // Set and fill the background color.
                K.Misc.PdfMarginsColor.set()
                ctx.fill(pageRect)
                
                // Translate the context so that we only draw the `cropRect`.
                ctx.cgContext.translateBy(x: -pageRect.origin.x + margins.horizontalMargin,
                                          y: originalSize.height - pageRect.origin.y - (originalSize.height - newHeight)/2)

                // Flip the context vertically because the Core Graphics coordinate system starts from the bottom.
                ctx.cgContext.scaleBy(x: newWidth / originalSize.width, y: -newHeight / originalSize.height)
                
                // Draw the PDF page.
                page.draw(with: .mediaBox, to: ctx.cgContext)
            }
            
            if compression.quality < 1.0, let jpegData = newImage.jpegData(compressionQuality: compression.quality) {
                let nsJpegData = NSData(data: jpegData)
                let unsafePointer = UnsafePointer<UInt8>(nsJpegData.bytes.bindMemory(to: UInt8.self, capacity: nsJpegData.length))
                if let dataPtr = CFDataCreate(kCFAllocatorDefault, unsafePointer, nsJpegData.length),
                   let dataProvider = CGDataProvider(data: dataPtr),
                   let cgImage = CGImage(jpegDataProviderSource: dataProvider, decode: nil, shouldInterpolate: true, intent: .defaultIntent) {
                    newImage = UIImage(cgImage: cgImage)
                }
            }
            
            if let pdfPage = PDFPage(image: newImage) {
                newPdfDocument.insert(pdfPage, at: newPdfDocument.pageCount)
            }
        }
        return newPdfDocument
    }
    
    static func getSharePdfUrl(pdf: Pdf) -> URL {
        let documentDirectory = FileManager.default.temporaryDirectory
        return documentDirectory.appendingPathComponent(pdf.filename).appendingPathExtension(for: .pdf)
    }
    
    static func processToShare(pdf: Pdf, applyPostProcess: Bool) -> URL {
        
        var pdfDocument = pdf.pdfDocument
        if applyPostProcess {
            pdfDocument = Self.applyPostProcess(toPdfDocument: pdfDocument,
                                                margins: pdf.margins,
                                                compression: pdf.compression)
        }
        
        let fileURL = Self.getSharePdfUrl(pdf: pdf)
        
        let options: [PDFDocumentWriteOption: Any] = {
            if let password = pdf.password {
                return [
                    PDFDocumentWriteOption.userPasswordOption : password,
                    PDFDocumentWriteOption.ownerPasswordOption : password
                ]
            } else {
                return [:]
            }
        }()
        
        // Write with password protection
        pdfDocument.write(to: fileURL, withOptions: options)
        
        return fileURL
    }
    
    static func cleanSharedPdf(pdf: Pdf) {
        let fileUrl = Self.getSharePdfUrl(pdf: pdf)
        do {
            try FileManager.default.removeItem(at: fileUrl)
        } catch {
            print("PdfUtility - Failed to delete temporary file at '\(fileUrl)'. Error: \(error)")
        }
    }
    
    static func unlock(data: Data, password: String) -> CGPDFDocument? {
        if let pdf = CGPDFDocument(CGDataProvider(data: data as CFData)!) {
            guard pdf.isEncrypted == true else { return pdf }
            guard pdf.unlockWithPassword("") == false else { return pdf }
            
            if let cPasswordString = password.cString(using: String.Encoding.utf8) {
                if pdf.unlockWithPassword(cPasswordString) {
                    return pdf
                }
            }
        }
        return nil
    }
    
    static func removePassword(data: Data, existingPDFPassword: String) throws -> Data? {
        
        if let pdf = unlock(data: data, password: existingPDFPassword) {
            let data = NSMutableData()
            
            autoreleasepool {
                let pageCount = pdf.numberOfPages
                UIGraphicsBeginPDFContextToData(data, .zero, nil)
                
                for index in 1...pageCount {
                    
                    let page = pdf.page(at: index)
                    let pageRect = page?.getBoxRect(CGPDFBox.mediaBox)
                    
                    
                    UIGraphicsBeginPDFPageWithInfo(pageRect!, nil)
                    let ctx = UIGraphicsGetCurrentContext()
                    ctx?.interpolationQuality = .high
                    // Draw existing page
                    ctx!.saveGState()
                    ctx!.scaleBy(x: 1, y: -1)
                    ctx!.translateBy(x: 0, y: -(pageRect?.size.height)!)
                    ctx!.drawPDFPage(page!)
                    ctx!.restoreGState()
                    
                }
                
                UIGraphicsEndPDFContext()
            }
            return data as Data
        }
        return nil
    }
    
    static func decryptFile(pdf: Pdf, password: String = "") -> AsyncOperation<Pdf, PdfError> {
        guard pdf.pdfDocument.isEncrypted else {
            return AsyncOperation(status: .data(pdf))
        }
        
        guard pdf.pdfDocument.unlock(withPassword: password) else {
            return AsyncOperation(status: .error(.wrongPassword))
        }
        
        guard let pdfEncryptedData = pdf.pdfDocument.dataRepresentation() else {
            assertionFailure("Missing expected encrypted data")
            return AsyncOperation(status: .error(.unknownError))
        }
        
        guard let pdfDecryptedData = try? PDFUtility.removePassword(data: pdfEncryptedData, existingPDFPassword: password) else {
            assertionFailure("Missing expected decrypted data")
            return AsyncOperation(status: .error(.unknownError))
        }
        
        guard let pdfDecryptedDocument = PDFDocument(data: pdfDecryptedData) else {
            assertionFailure("Cannot decode pdf from decrypted data")
            return AsyncOperation(status: .error(.unknownError))
        }
        var pdf = pdf
        pdf.updateDocument(pdfDecryptedDocument)
        pdf.updatePassword(password)
        return AsyncOperation(status: .data(pdf))
    }
    
    static func hasPdfWidget(pdf: Pdf) -> Bool {
        for pageIndex in 0..<pdf.pdfDocument.pageCount {
            if let page = pdf.pdfDocument.page(at: pageIndex) {
                if page.annotations.contains(where: { $0.isWidgetAnnotation }) {
                    return true
                }
            }
        }
        return false
    }
}

extension UIImage {
    
    func pdfPage() -> PDFPage? {
        guard let fixedOrientationImage = self.fixedOrientation() else {
            return nil
        }
        // Typical Letter PDF page size and margins
        let pageBounds = CGRect(origin: .zero, size: K.Misc.PdfPageSize)
        let margin: CGFloat = K.Misc.PdfPageDefaultMargin

        let imageMaxWidth = pageBounds.width - (margin * 2)
        let imageMaxHeight = pageBounds.height - (margin * 2)

        let image = fixedOrientationImage.scaledImage(scaleFactor: size.scaleFactor(forMaxWidth: imageMaxWidth,
                                                                                    maxHeight: imageMaxHeight)) ?? fixedOrientationImage
        let renderer = UIGraphicsPDFRenderer(bounds: pageBounds)
        
        // This procedure for rendering pdf pages (copied from WeScan) is the only one that seems
        // to make the applyPostProcess method to work. Creating PDFPage instances with PDFPage.init(_ image: UIImage)
        // causes the PDFPage.draw method to draw a black page.
        let data = renderer.pdfData { ctx in
            ctx.beginPage()
            
            ctx.cgContext.interpolationQuality = .high
            
            image.draw(at: CGPoint(x: (pageBounds.width - image.size.width) / 2,
                                   y: (pageBounds.height - image.size.height) / 2))
        }
        return PDFDocument(data: data)?.page(at: 0)
    }
    
    /// Scales the image to the specified size in the RGB color space.
    ///
    /// - Parameters:
    ///   - scaleFactor: Factor by which the image should be scaled.
    /// - Returns: The scaled image.
    func scaledImage(scaleFactor: CGFloat) -> UIImage? {
        guard let cgImage = self.cgImage else { return nil }

        let customColorSpace = CGColorSpaceCreateDeviceRGB()

        let width = CGFloat(cgImage.width) * scaleFactor
        let height = CGFloat(cgImage.height) * scaleFactor
        let bitsPerComponent = cgImage.bitsPerComponent
        let bytesPerRow = cgImage.bytesPerRow
        let bitmapInfo = cgImage.bitmapInfo.rawValue

        guard let context = CGContext(
            data: nil,
            width: Int(width),
            height: Int(height),
            bitsPerComponent: bitsPerComponent,
            bytesPerRow: bytesPerRow,
            space: customColorSpace,
            bitmapInfo: bitmapInfo
        ) else { return nil }

        context.interpolationQuality = .high
        context.draw(cgImage, in: CGRect(origin: .zero, size: CGSize(width: width, height: height)))

        return context.makeImage().flatMap { UIImage(cgImage: $0) }
    }
    
    /// Fix image orientaton to protrait up
    func fixedOrientation() -> UIImage? {
        guard imageOrientation != UIImage.Orientation.up else {
            // This is default orientation, don't need to do anything
            return self.copy() as? UIImage
        }
        
        guard let cgImage = self.cgImage else {
            // CGImage is not available
            return nil
        }
        
        guard let colorSpace = cgImage.colorSpace, let ctx = CGContext(data: nil, width: Int(size.width), height: Int(size.height), bitsPerComponent: cgImage.bitsPerComponent, bytesPerRow: 0, space: colorSpace, bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue) else {
            return nil // Not able to create CGContext
        }
        
        var transform: CGAffineTransform = CGAffineTransform.identity
        
        switch imageOrientation {
        case .down, .downMirrored:
            transform = transform.translatedBy(x: size.width, y: size.height)
            transform = transform.rotated(by: CGFloat.pi)
        case .left, .leftMirrored:
            transform = transform.translatedBy(x: size.width, y: 0)
            transform = transform.rotated(by: CGFloat.pi / 2.0)
        case .right, .rightMirrored:
            transform = transform.translatedBy(x: 0, y: size.height)
            transform = transform.rotated(by: CGFloat.pi / -2.0)
        case .up, .upMirrored:
            break
        @unknown default:
            fatalError("Missing...")
            break
        }
        
        // Flip image one more time if needed to, this is to prevent flipped image
        switch imageOrientation {
        case .upMirrored, .downMirrored:
            transform = transform.translatedBy(x: size.width, y: 0)
            transform = transform.scaledBy(x: -1, y: 1)
        case .leftMirrored, .rightMirrored:
            transform = transform.translatedBy(x: size.height, y: 0)
            transform = transform.scaledBy(x: -1, y: 1)
        case .up, .down, .left, .right:
            break
        @unknown default:
            fatalError("Missing...")
            break
        }
        
        ctx.concatenate(transform)
        
        switch imageOrientation {
        case .left, .leftMirrored, .right, .rightMirrored:
            ctx.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.height, height: size.width))
        default:
            ctx.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.width, height: size.height))
            break
        }
        
        guard let newCGImage = ctx.makeImage() else { return nil }
        return UIImage.init(cgImage: newCGImage, scale: 1, orientation: .up)
    }
}

extension CGSize {
    /// Calculates an appropriate scale factor which makes the size fit inside both the `maxWidth` and `maxHeight`.
    /// - Parameters:
    ///   - maxWidth: The maximum width that the size should have after applying the scale factor.
    ///   - maxHeight: The maximum height that the size should have after applying the scale factor.
    /// - Returns: A scale factor that makes the size fit within the `maxWidth` and `maxHeight`.
    func scaleFactor(forMaxWidth maxWidth: CGFloat, maxHeight: CGFloat) -> CGFloat {
        if width < maxWidth && height < maxHeight { return 1 }

        let widthScaleFactor = 1 / (width / maxWidth)
        let heightScaleFactor = 1 / (height / maxHeight)

        // Use the smaller scale factor to ensure both the width and height are below the max
        return min(widthScaleFactor, heightScaleFactor)
    }
}

extension PDFView {
    var currentPageIndex: Int? {
        guard let document = self.document, let currentPage = self.currentPage else {
            return nil
        }
        for pageIndex in 0..<document.pageCount {
            if document.page(at: pageIndex) == currentPage {
                return pageIndex
            }
        }
        return nil
    }
}



================================================
FILE: pdfexpert/InternalUtils/SharedErrors.swift
================================================
//
//  SharedLocalizedError.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 07/03/23.
//

import Foundation

enum SharedLocalizedError: LocalizedError {
    case unknownError
    
    var errorDescription: String? {
        switch self {
        case .unknownError: return "Internal Error. Please try again later"
        }
    }
}

enum SharedUnderlyingError: LocalizedError, UnderlyingError {
    case unknownError
    case underlyingError(errorDescription: String)
    
    static func getUnknownError() -> Self { Self.unknownError }
    
    static func getUnderlyingError(errorDescription: String) -> Self {
        return .underlyingError(errorDescription: errorDescription)
    }
    
    var errorDescription: String? {
        switch self {
        case .unknownError: return "Internal Error. Please try again later"
        case .underlyingError(let errorMessage): return errorMessage
        }
    }
}

enum PdfError: LocalizedError, UnderlyingError {
    case unknownError
    case urlToPdfConversionError
    case underlyingError(errorDescription: String)
    case wrongPassword
    
    static func getUnknownError() -> Self { Self.unknownError }
    
    static func getUnderlyingError(errorDescription: String) -> Self {
        return .underlyingError(errorDescription: errorDescription)
    }
    
    var errorDescription: String? {
        switch self {
        case .unknownError, .urlToPdfConversionError:
            return "Internal Error. Please try again later"
        case .underlyingError(let errorMessage): return errorMessage
        case .wrongPassword: return "Wrong Password"
        }
    }
}

enum AddPasswordError: LocalizedError {
    case unknownError
    case pdfHasPassword
    
    var errorDescription: String? {
        switch self {
        case .unknownError: return "Internal Error. Please try again later"
        case .pdfHasPassword: return "Your pdf is already protected"
        }
    }
}

enum RemovePasswordError: LocalizedError {
    case unknownError
    case pdfNoPassword
    
    var errorDescription: String? {
        switch self {
        case .unknownError: return "Internal Error. Please try again later"
        case .pdfNoPassword: return "Your pdf is already unlocked"
        }
    }
}

enum PdfSplitError: LocalizedError, UnderlyingError {
    case unknownError
    case pdfNoPage
    case pdfSinglePage
    case incompatibleRange
    case underlyingError(errorDescription: String)
    
    static func getUnknownError() -> Self { Self.unknownError }
    
    static func getUnderlyingError(errorDescription: String) -> Self {
        return .underlyingError(errorDescription: errorDescription)
    }
    
    var errorDescription: String? {
        switch self {
        case .unknownError, .incompatibleRange: return "Internal Error. Please try again later"
        case .pdfNoPage: return "Your pdf has no pages."
        case .pdfSinglePage: return "Your pdf has only one page, so you cannot split it into multiple pdfs."
        case .underlyingError(let errorMessage): return errorMessage
        }
    }
}



================================================
FILE: pdfexpert/InternalUtils/SharedStorage.swift
================================================
//
//  SharedStorage.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 05/05/23.
//

import Foundation

class SharedStorage {
    
    enum UserDefaultsKey: String {
        case pdfDataShareExtensionExistanceFlag
        case pdfDataShareExtensionPassword
    }
    
    enum FileName: String {
        case pdfDataShareExtension
    }
    
    #if STAGING
    static let schema = "pdfprostaging://"
    #else
    static let schema = "pdfpro://"
    #endif
    
    private static let appGroup = "group.pcnaid.pdfexpert"
    private static let userDefaults = UserDefaults(suiteName: appGroup)
    
    static var cacheDirectory: URL? {
        FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: Self.appGroup)?.appending(path: "Library/Caches",
                                                                                                          directoryHint: .isDirectory)
    }
    
    static var pdfDataShareExtensionExistanceFlag: Bool {
        get { Self.userDefaults?.bool(forKey: UserDefaultsKey.pdfDataShareExtensionExistanceFlag.rawValue) ?? false }
        set {
            Self.userDefaults?.set(newValue, forKey: UserDefaultsKey.pdfDataShareExtensionExistanceFlag.rawValue)
            Self.userDefaults?.synchronize()
        }
    }
    
    static var pdfDataShareExtensionPassword: String? {
        get { Self.userDefaults?.string(forKey: UserDefaultsKey.pdfDataShareExtensionPassword.rawValue) }
        set {
            Self.userDefaults?.set(newValue, forKey: UserDefaultsKey.pdfDataShareExtensionPassword.rawValue)
            Self.userDefaults?.synchronize()
        }
    }
    
    private static var pdfDataShareExtensionFilePath: URL? {
        Self.cacheDirectory?.appending(component: FileName.pdfDataShareExtension.rawValue).appendingPathExtension(for: .pdf)
    }
    
    static var pdfDataShareExtension: Data? {
        get {
            guard let url = Self.pdfDataShareExtensionFilePath else { return nil }
            return try? Data(contentsOf: url)
        }
        set {
            guard let url = Self.pdfDataShareExtensionFilePath else { return }
            if let newValue = newValue {
                try? newValue.write(to: url)
            } else {
                try? FileManager.default.removeItem(at: url)
            }
        }
    }
}



================================================
FILE: pdfexpert/InternalUtils/SubscriptionViewUtility.swift
================================================
//
//  SubscriptionViewUtility.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 24/02/23.
//

import Foundation
import StoreKit
import Collections

fileprivate struct InternalSubscriptionPeriod {
    let unit: Product.SubscriptionPeriod.Unit
    let value: Int
}

extension Product.SubscriptionPeriod.Unit {
    var displayUnitSingle: String {
        switch self {
        case .day: return "day"
        case .week: return "week"
        case .month: return "month"
        case .year: return "year"
        default: return ""
        }
    }
    
    var displayUnitPeriod: String {
        switch self {
        case .day: return "daily"
        case .week: return "weekly"
        case .month: return "monthly"
        case .year: return "yearly"
        default: return ""
        }
    }
    
    var displayUnitMultiple: String {
        switch self {
        case .day: return "days"
        case .week: return "weeks"
        case .month: return "months"
        case .year: return "years"
        default: return ""
        }
    }
    
    var displayUnitSingleWithArticle: String {
        switch self {
        case .day: return "a day"
        case .week: return "a week"
        case .month: return "a month"
        case .year: return "an year"
        default: return ""
        }
    }
    
    var days: Int {
        switch self {
        case .day: return 1
        case .week: return 7
        case .month: return 30
        case .year: return 365
        default: return 0
        }
    }
    
    var previousUnit: Self? {
        switch self {
        case .day: return nil
        case .week: return .day
        case .month: return .week
        case .year: return .month
        default: return nil
        }
    }
}

fileprivate extension InternalSubscriptionPeriod {
    
    var days: Int {
        return self.unit.days * self.value
    }
    
    // period == 1 ? "a day" : "5 days"
    var displayPeriodStartStatement: String {
        if self.value > 1 {
            return "\(self.value) \(self.unit.displayUnitMultiple)"
        } else {
            return self.unit.displayUnitSingleWithArticle
        }
    }
    
    // period == 1 ? "day" : "5 days"
    var displayPeriod: String {
        if self.value > 1 {
            return "\(self.value) \(self.unit.displayUnitMultiple)"
        } else {
            return self.unit.displayUnitSingle
        }
    }
    
    // period == 1 ? "daily" : "5 days"
    var displayFrequency: String {
        if self.value > 1 {
            return "\(self.value) \(self.unit.displayUnitMultiple)"
        } else {
            return self.unit.displayUnitPeriod
        }
    }
    
    // period == 1 ? "1 day" : "5 days"
    var displayPeriodWithNumber: String {
        "\(self.value) \(self.value > 1 ? self.unit.displayUnitMultiple : self.unit.displayUnitSingle)"
    }
    
    func convert(toUnit unit: Product.SubscriptionPeriod.Unit) -> Self {
        return InternalSubscriptionPeriod(unit: unit, value: self.days/unit.days)
    }
}

extension Product.SubscriptionPeriod {
    
    // 3 days => 3, 3 weeks => 21, 2 months => 60, ...
    // Not reliable for legal information or date calculations,
    // since months and years are fixed on 30 and 365 respectively
    var days: Int {
        return InternalSubscriptionPeriod(unit: self.unit, value: self.value).days
    }
    
    fileprivate func getInternalPeriod(weekFrom7days: Bool) -> InternalSubscriptionPeriod {
        if weekFrom7days, self.value == 7, self.unit == .day {
            return InternalSubscriptionPeriod(unit: .week, value: 1)
        } else {
            return InternalSubscriptionPeriod(unit: self.unit, value: self.value)
        }
    }
}

extension Product {
    
    var title: String {
        var text = "Premium"
        if let subscription = self.subscription {
            text += " \(subscription.subscriptionPeriod.getInternalPeriod(weekFrom7days: true).displayPeriodWithNumber)"
        }
        return text
    }
    
    var titleShort: String {
        var text = ""
        if let subscription = self.subscription {
            text += "\(subscription.subscriptionPeriod.getInternalPeriod(weekFrom7days: true).displayFrequency)"
        }
        text += " \(self.displayPrice)"
        text = text.capitalizingFirstLetter()
        return text
    }
    
    var period: String {
        var text = ""
        if let subscription = self.subscription {
            text += "\(subscription.subscriptionPeriod.getInternalPeriod(weekFrom7days: true).displayFrequency)"
        }
        text = text.capitalizingFirstLetter()
        return text
    }
    
    var priceText: String {
        return self.displayPrice
    }
    
    var weeklyPriceAndPeriod: String {
        var text = self.getPriceText(weekFrom7days: false, customUnitPeriod: .week)
        text = text.capitalizingFirstLetter()
        return text
    }
    
    var fullDescriptionText: String {
        var text = ""
        if let introductortOffer = self.subscription?.introductoryOffer {
            text += "\(introductortOffer.period.getInternalPeriod(weekFrom7days: false).displayPeriodStartStatement) free, then "
        }
        text += self.getPriceText(weekFrom7days: true)
        text = text.capitalizingFirstLetter()
        return text
    }
    
    var freeTrialText: String? {
        if let introductoryOffer = self.subscription?.introductoryOffer, introductoryOffer.paymentMode == .freeTrial {
            let freeTrialDuration = introductoryOffer.period.getInternalPeriod(weekFrom7days: false).displayPeriodWithNumber
            return "FREE TRIAL for \(freeTrialDuration)"
        } else {
            return nil
        }
    }
    
    // Returned only if:
    // - The current product is a subscription
    // - The current product is the most convenient one
    // - There is another product which is a subscription and is less convenient
    func getBestDiscount(forProducts products: [Product]) -> String? {
        // Compare subscription periods instead of the products themselves to handle cases of identical
        // subscriptions that varies only for introductory offers (e.g.: yearly with free trial, yearly without free trial)
        let mostConvenientSubscriptionPeriod = Self.getMostConvenientSubscription(fromProducts: products)?.subscription?.subscriptionPeriod
        guard let mostConvenientSubscriptionPeriod, self.subscription?.subscriptionPeriod == mostConvenientSubscriptionPeriod else {
            return nil
        }
        guard let discountPercentage = self.getDiscountPercentage(forProducts: products) else {
            return nil
        }
        return "\(discountPercentage) OFF"
    }
    
    // Returned only if:
    // - The current product is a subscription
    // - There is another product which is a subscription and is less convenient
    func getDiscount(forProducts products: [Product]) -> String? {
        guard let subscription = self.subscription else {
            return nil
        }
        guard let discountPercentage = self.getDiscountPercentage(forProducts: products) else {
            return nil
        }
        guard let previousUnit = subscription.subscriptionPeriod.unit.previousUnit else {
            return nil
        }
        let periodInPreviousUnit = subscription.subscriptionPeriod.getInternalPeriod(weekFrom7days: false).convert(toUnit: previousUnit)
        var text = periodInPreviousUnit.displayPeriodWithNumber
        text += " at "
        text += self.getPriceText(weekFrom7days: false, customUnitPeriod: previousUnit, showTrailing: false)
        text = text.capitalizingFirstLetter()
        text += ", save \(discountPercentage)"
        return text
    }
    
    private func getDiscountPercentage(forProducts products: [Product]) -> String? {
        let nextMostConvenientProduct = Self.getMostConvenientSubscription(fromProducts: products, worseThan: self)
        
        guard let nextMostConvenientProduct = nextMostConvenientProduct else {
            return nil
        }
        guard let priceYearly = self.priceYearly,
              let nextMostConvenientProductPriceYearly = nextMostConvenientProduct.priceYearly else {
            return nil
        }
        
        let discount = Decimal(1) - priceYearly / nextMostConvenientProductPriceYearly
        let discountPercentage = discount.formatted(.percent
            .precision(.integerAndFractionLength(integerLimits: ..<3, fractionLimits: 0...0)))
        return discountPercentage
    }
    
    private static func sortedSubscriptionsBasedOnConvenience(fromProducts products: [Product]) -> [Product] {
        return products.filter { $0.priceYearly != nil }.sorted { $0.priceYearly ?? 0 < $1.priceYearly ?? 0 }
    }
    
    private static func getMostConvenientSubscription(fromProducts products: [Product], worseThan referenceProduct: Product? = nil) -> Product? {
        let sortedProducts = Self.sortedSubscriptionsBasedOnConvenience(fromProducts: products)
        if let referenceProduct = referenceProduct, let index = sortedProducts.firstIndex(of: referenceProduct) {
            let nextProductIndex = index + 1
            if nextProductIndex < sortedProducts.count {
                return sortedProducts[nextProductIndex]
            } else {
                return nil
            }
        } else {
            return sortedProducts.first
        }
    }
    
    private var priceYearly: Decimal? {
        if let subscription = self.subscription {
            return (self.price / Decimal(subscription.subscriptionPeriod.days)) * Decimal(SubscriptionPeriod.Unit.year.days)
        } else {
            return nil
        }
    }
    
    // if customUnitPeriod == nil
    // <price>/<displayPeriod>. E.g.: 99.99€/year, 19.99/2 months
    // otherwise
    // <price in custom unit period>(= (price / period days) * custom unit period days)/<display period of custom unit period>
    // E.g.: custom unit period == week => 89.99€/year => 1.73€/week
    private func getPriceText(weekFrom7days: Bool, customUnitPeriod: SubscriptionPeriod.Unit? = nil, showTrailing: Bool = true) -> String {
        if let subscription = self.subscription {
            var text = ""
            if let customUnitPeriod = customUnitPeriod {
                let pricePerUnit = (self.price / Decimal(subscription.subscriptionPeriod.days)) * Decimal(customUnitPeriod.days)
                text += self.priceFormatStyle
                    .precision(.integerAndFractionLength(integerLimits: 1..<3, fractionLimits: 2...2))
                    .format(pricePerUnit)
                if showTrailing {
                    text += "/\(customUnitPeriod.displayUnitSingle)"
                }
            } else {
                text += self.displayPrice
                if showTrailing {
                    text += "/\(subscription.subscriptionPeriod.getInternalPeriod(weekFrom7days: weekFrom7days).displayPeriod)"
                }
            }
            return text
        } else {
            return self.displayPrice
        }
    }
}

let productMetaViewsKey: String = "views"

func getSubscriptionsForView(products: [Product], store: Store, viewKey: String) -> [Product] {
    return products.filter {
        if $0.subscription != nil,
           let metaDictionary = store.getProductData(forProductId: $0.id) as? [String: Any],
           let views = metaDictionary[productMetaViewsKey] as? [String],
           views.contains(viewKey) {
            return true
        } else {
            return false
        }
    }
}

extension Array where Element == Product {
    func subscriptionPairs<T: SubscriptionPlan>(periodOrderDesc: Bool, conversion: ((Product?) -> T?)) async throws -> [SubscriptionPlanCombo<T>] {
        var groupedSubscriptions: OrderedDictionary<Int, [Product]> = self.reduce([:]) { partialResult, subscription in
            var partialResult = partialResult
            if let subscriptionInfo = subscription.subscription {
                let key = subscriptionInfo.subscriptionPeriod.days
                var subscriptions = partialResult[key] ?? []
                subscriptions.append(subscription)
                partialResult[key] = subscriptions
            }
            return partialResult
        }
        
        groupedSubscriptions.sort { pair1, pair2 in
            periodOrderDesc ? pair1.key > pair2.key : pair1.key < pair2.key
        }
        
        let subscriptionPlanPairs: [SubscriptionPlanCombo<T>] = groupedSubscriptions.reduce([]) { partialResult, rawPair in
            var partialResult = partialResult
            let freeTrialSubscriptionPlan = conversion(rawPair.value.first (where: { $0.subscription?.introductoryOffer?.paymentMode == .freeTrial }))
            let standardSubscriptionPlan = conversion(rawPair.value.first (where: { $0.subscription?.introductoryOffer == nil }))
            if standardSubscriptionPlan != nil || freeTrialSubscriptionPlan != nil {
                partialResult.append(SubscriptionPlanCombo<T>(standardSubscriptionPlan: standardSubscriptionPlan,
                                                              freeTrialSubscriptionPlan: freeTrialSubscriptionPlan))
            }
            return partialResult
        }
        return subscriptionPlanPairs
    }
}



================================================
FILE: pdfexpert/InternalUtils/View+Internal.swift
================================================
//
//  View+Internal.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 13/03/23.
//

import Foundation
import SwiftUI
import Factory

enum DisclamerType: Hashable, Identifiable {
    case privacyPolicy, termsAndConditions
    
    var id: Self { self }
}

extension View {
    
    var defaultGradientBackground: some View {
        LinearGradient(colors: [ColorPalette.buttonGradientStart, ColorPalette.buttonGradientEnd],
                       startPoint: UnitPoint(x: 0.25, y: 0.5), endPoint: UnitPoint(x: 0.75, y: 0.5))
    }
    
    @ViewBuilder func getDefaultButton(text: String, enabled: Bool = true, onButtonPressed: @escaping () -> ()) -> some View {
        Button(action: onButtonPressed) {
            Text(text)
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .font(forCategory: .button)
                .foregroundColor(ColorPalette.primaryText)
                .contentShape(Capsule())
        }
        .frame(maxWidth: .infinity)
        .frame(height: 48)
        .background(self.getDefaultButtonBackground(enabled: enabled))
        .cornerRadius(10)
        .disabled(!enabled)
    }
    
    @ViewBuilder private func getDefaultButtonBackground(enabled: Bool) -> some View {
        if enabled {
            self.defaultGradientBackground
        } else {
            ColorPalette.thirdText
        }
    }
    
    func getDisclamer(color: Color, onSelection: @escaping (DisclamerType) -> ()) -> some View {
        var attributedString = AttributedString("By continuing you accept our ")
        attributedString += Self.getAttributedText(forUrlString: K.Misc.TermsAndConditionsUrlString, text: "Terms and Conditions")
        attributedString += AttributedString(" and confirm that you have received our ")
        attributedString += Self.getAttributedText(forUrlString: K.Misc.PrivacyPolicyUrlString, text: "Privacy Policy")
        attributedString += AttributedString(".")
        return Text(attributedString)
            .multilineTextAlignment(.center)
            .font(forCategory: .caption1)
            .foregroundColor(color)
            .tint(color)
    }
    
    func alertCameraPermission(isPresented: Binding<Bool>) -> some View {
        self.alert("Unable to access camera",
                   isPresented: isPresented) {
            Button("Settings", role: .none) {
                if let appSettingsUrl = URL(string: UIApplication.openSettingsURLString) {
                UIApplication.shared.open(appSettingsUrl,
                                              options: [:],
                                              completionHandler: nil)
                                          }
            }
            Button("Cancel", role: .cancel) {}
        } message: {
            Text("You have denied permission to access the camera of your device. Please go to your phone Settings to change your camera permission to be able to scan and convert your documents.")
        }
    }
    
    @ViewBuilder func getSubscriptionView(onComplete: @escaping () -> ()) -> some View {
        switch Container.shared.configService().remoteConfigData.value.subcriptionViewType {
        case .pairs: SubscriptionPairsView(onComplete: onComplete)
        case .verticalHighlightLongPeriod:
            let viewModel = Container.shared.subscriptionVerticalViewModel(.highlightLongPeriod)
            SubscriptionVerticalView(viewModel: viewModel, onComplete: onComplete)
        case .verticalHighlightShortPeriod:
            let viewModel = Container.shared.subscriptionVerticalViewModel(.highlightShortPeriod)
            SubscriptionVerticalView(viewModel: viewModel, onComplete: onComplete)
        case .picker: SubscriptionPickerView(onComplete: onComplete)
        }
    }
    
    func showSubscriptionView(_ show: Binding<Bool>, onComplete: @escaping () -> ()) -> some View {
        self.fullScreenCover(isPresented: show) {
            getSubscriptionView(onComplete: {
                show.wrappedValue = false
                onComplete()
            })
        }
    }
    
    func sharePdf(_ pdf: Binding<Pdf?>, applyPostProcess: Bool, onDismiss: @escaping () -> ()) -> some View {
        self.sheet(item: pdf, onDismiss: {
            if let pdf = pdf.wrappedValue {
                PDFUtility.cleanSharedPdf(pdf: pdf)
            }
            onDismiss()
        }) { pdf in
            ActivityViewController(activityItems: [PDFUtility.processToShare(pdf: pdf, applyPostProcess: applyPostProcess)],
                                   thumbnail: pdf.thumbnail,
                                   title: pdf.filename)
        }
    }
    
    func pageCounter(currentPageIndex: Int, totalPages: Int) -> some View {
        Text("\(currentPageIndex + 1) of \(totalPages)")
            .font(forCategory: .body1)
            .foregroundColor(ColorPalette.primaryText)
    }
    
    func removePasswordView(show: Binding<Bool>,
                            removePasswordCallback: @escaping () -> ()) -> some View {
        self.alert("Would you like to remove your password?", isPresented: show, actions: {
            Button("Delete", role: .destructive, action: removePasswordCallback)
            Button("Cancel", role: .cancel, action: {})
        }, message: {
            Text("If you decide to remove the password, your PDF will no longer be protected.")
        })
    }
    
    func showError<T: LocalizedError>(_ errorBinding: Binding<T?>) -> some View {
        self.alert("Error",
                   isPresented: .constant(errorBinding.wrappedValue != nil),
                   presenting: errorBinding.wrappedValue,
                   actions: { pdfSaveError in
            Button("Ok") { errorBinding.wrappedValue = nil }
        }, message: { error in
            Text(error.errorDescription ?? "")
        })
    }
}



================================================
FILE: pdfexpert/InternalUtils/View+Preview.swift
================================================
//
//  View+Preview.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 07/03/23.
//

import Foundation
import SwiftUI

extension View {
    func previewOrientation() -> some View {
        self.previewInterfaceOrientation(.landscapeLeft)
    }
}



================================================
FILE: pdfexpert/Models/AppTrackingTransparency.swift
================================================
//
//  AppTrackingTransparency.swift
//  FourBooks
//
//  Created by Pcnaid Inc on 03/05/21.
//  Copyright © 2021 4Books. All rights reserved.
//

import Foundation
import Factory
import AppTrackingTransparency

protocol AppTrackingTransparency : AnyObject {
    var serviceSupported: Bool { get }
    var permissionGranted: Bool? { get }
    func requestPermissionIfNeeded() async
}

extension Container {
    var appTrackingTransparancy: Factory<AppTrackingTransparency> {
        self { AppTrackingTransparencyImpl() }.singleton
    }
}



================================================
FILE: pdfexpert/Models/AppTrackingTransparencyImpl.swift
================================================
//
//  AppTrackingTransparencyImpl.swift
//  FourBooks
//
//  Created by Pcnaid Inc on 03/05/21.
//  Copyright © 2021 4Books. All rights reserved.
//

import Foundation
import AppTrackingTransparency
#if FACEBOOK
import FacebookCore
#endif
import Factory

class AppTrackingTransparencyImpl: AppTrackingTransparency {
    
    var serviceSupported: Bool {
        if #available(iOS 14, *) {
            return true
        } else {
            return false
        }
    }
    
    var permissionGranted: Bool? {
        if #available(iOS 14, *) {
            return ATTrackingManager.trackingAuthorizationStatus.granted
        } else {
            return true
        }
    }
    
    @Injected(\.analyticsManager) var analyticsManager
    @Injected(\.attibutionManager) var attibutionManager
    
    init() {
        self.updateFacebookAdvertiseTrackingSettings()
    }
    
    func requestPermissionIfNeeded() async {
        if #available(iOS 14, *) {
            debugPrint(for: self, message: "Current Auth Status: \(ATTrackingManager.trackingAuthorizationStatus.rawValue)")
        }
        guard self.permissionGranted == nil else {
            return
        }
        if #available(iOS 14, *) {
            return await withCheckedContinuation({ continuation in
                ATTrackingManager.requestTrackingAuthorization(completionHandler: { authorizationStatus in
                    self.updateFacebookAdvertiseTrackingSettings()
                    self.trackAuthorizationEvent(authorizationStatus: authorizationStatus)
                    continuation.resume()
                })
            })
        } else {
            return
        }
    }
    
    private func updateFacebookAdvertiseTrackingSettings() {
                let enableAdvertiserTracking = self.permissionGranted ?? false
                #if FACEBOOK
       // Settings.shared.setAdvertiserTrackingEnabled(enableAdvertiserTracking)
                debugPrint(for: self, message: "Facebook Advertiser Tracking Enabled set to: \(enableAdvertiserTracking)")
                #endif
            }
    
    private func trackAuthorizationEvent(authorizationStatus: ATTrackingManager.AuthorizationStatus) {
        self.attibutionManager.onHandleATTAuthorizationStatus(authorizationStatus: authorizationStatus)
        switch authorizationStatus {
          case .authorized:
            debugPrint(for: self, message: "Authorization Granted")
            self.analyticsManager.track(event: .appTrackingTransparancyAuthorized)
          default:
            debugPrint(for: self, message: "Authorization not granted")
            break
          }
    }
}

@available(iOS 14.0, *)
extension ATTrackingManager.AuthorizationStatus {
    var granted: Bool? {
        switch self {
        case .authorized: return true
        case .notDetermined: return nil
        case .denied, .restricted: return false
        @unknown default: return false
        }
    }
}



================================================
FILE: pdfexpert/Models/AttibutionManagerImpl.swift
================================================
//
//  AttibutionManagerImpl.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/09/23.
//

import Foundation
import Factory
import BranchSDK
import UIKit
import AppTrackingTransparency

extension Container {
    var attibutionManager: Factory<AttributionManager> {
        self { AttributionManagerImpl() }.singleton
    }
}

class AttributionManagerImpl: AttributionManager {
    
    func onAppDidFinishLaunching(withLaunchOptions launchOptions:  [UIApplication.LaunchOptionsKey: Any]?) {
        #if STAGING
        Branch.setUseTestBranchKey(true)
        #endif
//        Branch.getInstance().enableLogging()
//        Branch.getInstance().validateSDKIntegration()
        Branch.getInstance().initSession(launchOptions: launchOptions) { (params, error) in
            print("AttributionManagerImpl - Deeplink detected. Parameters: \((params as? [String: AnyObject]) ?? [:])")
            // TODO: Implement Deeplink from here
        }
    }
    
    func onOpenUrl(url: URL) {
        Branch.getInstance().handleDeepLink(url)
    }
    
    func onHandleATTAuthorizationStatus(authorizationStatus: ATTrackingManager.AuthorizationStatus) {
        Branch.getInstance().handleATTAuthorizationStatus(authorizationStatus.rawValue)
    }
}



================================================
FILE: pdfexpert/Models/AttributionManager.swift
================================================
//
//  AttributionManager.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/09/23.
//

import Foundation
import UIKit
import AppTrackingTransparency

protocol AttributionManager : AnyObject {
    func onAppDidFinishLaunching(withLaunchOptions launchOptions:  [UIApplication.LaunchOptionsKey: Any]?)
    func onOpenUrl(url: URL)
    func onHandleATTAuthorizationStatus(authorizationStatus: ATTrackingManager.AuthorizationStatus)
}



================================================
FILE: pdfexpert/Models/ConfigService.swift
================================================
//
//  ConfigService.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 13/04/23.
//

import Foundation
import Combine

protocol ConfigService {
    func onApplicationDidBecomeActive()
    var remoteConfigData: CurrentValueSubject<RemoteConfigData, Never> { get }
}



================================================
FILE: pdfexpert/Models/RemoteConfigManager.swift
================================================
//
//  RemoteConfigImpl.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 13/04/23.
//

import Foundation
import Factory
import FirebaseRemoteConfig
import Combine
import CombineExt

struct RemoteConfigData {
    let subcriptionViewType: SubscriptionViewType
    
    init(remoteConfig: RemoteConfig) {
        let subscriptionViewTypeValue = remoteConfig.configValue(forKey: RemoteConfigKey.subcriptionViewType.rawValue).stringValue
        self.subcriptionViewType = SubscriptionViewType.getSubscriptionViewType(forRemoteConfigValue: subscriptionViewTypeValue)
    }
}

extension Container {
    var configService: Factory<ConfigService> {
        self { RemoteConfigManager() }.singleton
    }
}

class RemoteConfigManager : ConfigService {
    
    lazy var remoteConfigData: CurrentValueSubject<RemoteConfigData, Never> = CurrentValueSubject<RemoteConfigData, Never>(RemoteConfigData(remoteConfig: self.remoteConfig))
    
    private var remoteConfigExpirationDuration: TimeInterval {
        return self.isTestUser
            ? K.RemoteConfigK.DebugRemoteConfigExpirationDuration
            : K.RemoteConfigK.DefaultRemoteConfigExpirationDuration
    }
    
    private var sharedFetchConfigRequest: AnyPublisher<RemoteConfigData, Never>?
    private let remoteConfig: RemoteConfig
    private var cancelBag = Set<AnyCancellable>()
    private var isTestUser: Bool {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }
    
    init() {
        self.remoteConfig = RemoteConfig.remoteConfig()
        self.remoteConfig.configSettings = RemoteConfigSettings()
        self.remoteConfig.setDefaults(RemoteConfig.defaults)
    }
    
    // MARK: - ConfigService
    
    func onApplicationDidBecomeActive() {
        self.fetchConfig().sink(receiveValue: { _ in }).store(in: &self.cancelBag)
    }
    
    // MARK: Private methods
    
    private func fetchConfig() -> AnyPublisher<RemoteConfigData, Never> {
        print("RemoteConfigManager - fetchConfig started")
        let sharedFetchConfigRequest: AnyPublisher<RemoteConfigData, Never> = {
            if let sharedFetchConfigRequest = self.sharedFetchConfigRequest {
                print("RemoteConfigManager - returned cached instance")
                return sharedFetchConfigRequest
            } else {
                print("RemoteConfigManager - returned new instance")
                return self.createFetchConfigRequest()
            }
        }()
        self.sharedFetchConfigRequest = sharedFetchConfigRequest
        return sharedFetchConfigRequest
    }
    
    private func createFetchConfigRequest() -> AnyPublisher<RemoteConfigData, Never> {
        return AnyPublisher<RemoteConfigData, Never>.create { subscriber in
            let notifyRemoteConfig = {
                self.sharedFetchConfigRequest = nil
                let remoteConfigData = RemoteConfigData(remoteConfig: self.remoteConfig)
                self.remoteConfigData.send(remoteConfigData)
                subscriber.send(remoteConfigData)
            }
            self.remoteConfig
                .fetch(withExpirationDuration: self.remoteConfigExpirationDuration,
                       completionHandler: { (status, error) in
                        if status == .success {
                            print("RemoteConfigManager - Config fetched!")
                            self.remoteConfig.activate(completion: { (changed, error) in
                                if let error = error {
                                    print("RemoteConfigManager - Config not activated. Error: '\(error.localizedDescription)'")
                                } else if changed {
                                    print("RemoteConfigManager - Config activated with changes")
                                } else {
                                    print("RemoteConfigManager - Config activated without changes")
                                }
                                // Must run this on main thread (this completion block runs on a different thread... how cute...)
                                DispatchQueue.main.async {
                                    notifyRemoteConfig()
                                }
                            })
                        } else {
                            print("RemoteConfigManager - Config not fetched. Error: '\(error?.localizedDescription ?? "")'")
                            DispatchQueue.main.async {
                                notifyRemoteConfig()
                            }
                        }
                })
            return AnyCancellable {}
        }.share().eraseToAnyPublisher()
    }
}

fileprivate enum RemoteConfigKey : String, CaseIterable {
    case subcriptionViewType = "subscription_view_type"
}

fileprivate extension RemoteConfig {
    
    static var defaults: [String: NSObject] {
        var result: [String: NSObject] = [:]
        RemoteConfigKey.allCases.forEach { (key) in
            switch key {
            case .subcriptionViewType:
                result[key.rawValue] = NSString(string: K.MonetizationK.defaultSubscriptionViewType.remoteConfigValue)
            }
        }
        return result
    }
}

fileprivate extension SubscriptionViewType {
    var remoteConfigValue: String {
        switch self {
        case .pairs: return "pairs"
        case .verticalHighlightLongPeriod: return "vertical"
        case .verticalHighlightShortPeriod: return "vertical_highlight_short_period"
        case .picker: return "picker"
        }
    }
    
    static func getSubscriptionViewType(forRemoteConfigValue remoteConfigValue: String?) -> Self {
        for type in Self.allCases {
            if type.remoteConfigValue == remoteConfigValue {
                return type
            }
        }
        return K.MonetizationK.defaultSubscriptionViewType
    }
}



================================================
FILE: pdfexpert/Models/Store.swift
================================================
//
//  Store.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 03/03/23.
//

import Foundation
import StoreKit
import Combine

protocol Store {
    var subscriptions: [Product] { get }
    var consumables: [Product] { get }
    var purchasedSubscriptions: [Product] { get }
    var subscriptionGroupStatus: RenewalState? { get }
    var isPremium: CurrentValueSubject<Bool, Never> { get }
    
    func refreshAll() async throws
    func requestProducts() async throws
    func purchase(_ product: Product) async throws -> Transaction?
    func isPurchased(_ product: Product) async throws -> Bool
    func checkVerified<T>(_ result: VerificationResult<T>) throws -> T
    func updateCustomerProductStatus() async
    func getProductData(forProductId productId: String) -> Any?
    func sortByPrice(_ products: [Product]) -> [Product]
}



================================================
FILE: pdfexpert/Models/StoreImpl.swift
================================================
/*
See LICENSE folder for this sample’s licensing information.

Abstract:
The store class is responsible for requesting products from the App Store and starting purchases.
*/

import Foundation
import StoreKit
import Combine
import Factory

typealias Transaction = StoreKit.Transaction
typealias RenewalInfo = StoreKit.Product.SubscriptionInfo.RenewalInfo
typealias RenewalState = StoreKit.Product.SubscriptionInfo.RenewalState

public enum StoreError: Error {
    case failedVerification
}

//Define our app's subscription tiers by level of service, in ascending order.
public enum SubscriptionTier: Int, Comparable {
    case none = 0
    case standard = 1

    public static func < (lhs: Self, rhs: Self) -> Bool {
        return lhs.rawValue < rhs.rawValue
    }
}

extension Container {
    var store: Factory<Store> {
        self { StoreImpl() }.singleton
    }
}

class StoreImpl: Store {

    private(set) var subscriptions: [Product]
    private(set) var consumables: [Product]
    
    private(set) var purchasedSubscriptions: [Product] = []
    private(set) var subscriptionGroupStatus: RenewalState?
    
    var isPremium: CurrentValueSubject<Bool, Never> = CurrentValueSubject(false)
    
    var updateListenerTask: Task<Void, Error>? = nil

    private let productIdToProduct: [String: Any]
    
    @Injected(\.analyticsManager) var analyticsManager

    init() {
        self.productIdToProduct = Self.loadProductIdToProductData().reduce([:], {
            var result = $0
            result[(Bundle.main.bundleIdentifier ?? "") + "." + $1.key] = $1.value
            return result
        })

        //Initialize empty products, and then do a product request asynchronously to fill them in.
        self.subscriptions = []
        self.consumables = []

        //Start a transaction listener as close to app launch as possible so you don't miss any transactions.
        self.updateListenerTask = self.listenForTransactions()

        Task {
            try await self.refreshAll()
//            //During store initialization, request products from the App Store.
//            try await requestProducts()
//
//            //Deliver products that the customer purchases.
//            await updateCustomerProductStatus()
        }
    }

    deinit {
        self.updateListenerTask?.cancel()
    }
    
    static func loadProductIdToProductData() -> [String: Any] {
        guard let path = Bundle.main.path(forResource: "Products", ofType: "plist"),
              let plist = FileManager.default.contents(atPath: path),
              let data = try? PropertyListSerialization.propertyList(from: plist, format: nil) as? [String: Any] else {
            return [:]
        }
        return data
    }

    func listenForTransactions() -> Task<Void, Error> {
        return Task.detached {
            //Iterate through any transactions that don't come from a direct call to `purchase()`.
            for await result in Transaction.updates {
                do {
                    let transaction = try self.checkVerified(result)

                    //Deliver products to the user.
                    await self.updateCustomerProductStatus()

                    //Always finish a transaction.
                    await transaction.finish()
                } catch {
                    //StoreKit has a transaction that fails verification. Don't deliver content to the user.
                    print("Transaction failed verification")
                }
            }
        }
    }
    
    func refreshAll() async throws {
        
        //During store initialization, request products from the App Store.
        try await self.requestProducts()

        //Deliver products that the customer purchases.
        await self.updateCustomerProductStatus()
    }

    @MainActor
    func requestProducts() async throws {
        do {
            //Request products from the App Store using the identifiers that the Products.plist file defines.
            let storeProducts = try await Product.products(for: self.productIdToProduct.keys)
            
            var newSubscriptions: [Product] = []
            var newConsumables: [Product] = []

            //Filter the products into categories based on their type.
            for product in storeProducts {
                switch product.type {
                case .consumable:
                    newConsumables.append(product)
                case .nonConsumable:
                    debugPrint("Unexpected non consumable found")
                case .autoRenewable:
                    newSubscriptions.append(product)
                case .nonRenewable:
                    debugPrint("Unexpected non renewable found")
                default:
                    //Ignore this product.
                    print("Unknown product")
                }
            }

            //Sort each product category by price, lowest to highest, to update the store.
            self.consumables = self.sortByPrice(newConsumables)
            self.subscriptions = self.sortByPrice(newSubscriptions)
        } catch {
            print("Failed product request from the App Store server: \(error)")
            throw error
        }
    }

    @MainActor
    func purchase(_ product: Product) async throws -> Transaction? {
        //Begin purchasing the `Product` the user selects.
        let result = try await product.purchase()

        switch result {
        case .success(let verification):
            //Check whether the transaction is verified. If it isn't,
            //this function rethrows the verification error.
            let transaction = try self.checkVerified(verification)

            //The transaction is verified. Deliver content to the user.
            await self.updateCustomerProductStatus()

            //Always finish a transaction.
            await transaction.finish()
            
            // Sent custom method to analytics because free trials are not always automatically tracked
            // (e.g.: Firebase)
            self.analyticsManager.track(event: .checkoutCompleted(subscriptionPlanProduct: product))

            return transaction
        case .userCancelled, .pending:
            return nil
        default:
            return nil
        }
    }

    func isPurchased(_ product: Product) async throws -> Bool {
        //Determine whether the user purchases a given product.
        switch product.type {
        case .nonRenewable:
            debugPrint("Unexpected non renewable found")
            return false
        case .nonConsumable:
            debugPrint("Unexpected non consumable found")
            return false
        case .autoRenewable:
            return self.purchasedSubscriptions.contains(product)
        default:
            return false
        }
    }

    func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        //Check whether the JWS passes StoreKit verification.
        switch result {
        case .unverified:
            //StoreKit parses the JWS, but it fails verification.
            throw StoreError.failedVerification
        case .verified(let safe):
            //The result is verified. Return the unwrapped value.
            return safe
        }
    }

    @MainActor
    func updateCustomerProductStatus() async {
        var purchasedSubscriptions: [Product] = []

        //Iterate through all of the user's purchased products.
        for await result in Transaction.currentEntitlements {
            do {
                //Check whether the transaction is verified. If it isn’t, catch `failedVerification` error.
                let transaction = try self.checkVerified(result)

                //Check the `productType` of the transaction and get the corresponding product from the store.
                switch transaction.productType {
                case .nonConsumable:
                    debugPrint("Unexpected non consumable found")
                case .nonRenewable:
                    debugPrint("Unexpected non renewable found")
                case .autoRenewable:
                    if let subscription = self.subscriptions.first(where: { $0.id == transaction.productID }) {
                        purchasedSubscriptions.append(subscription)
                    }
                default:
                    break
                }
            } catch {
                print()
            }
        }

        //Update the store information with auto-renewable subscription products.
        self.purchasedSubscriptions = purchasedSubscriptions

        //Check the `subscriptionGroupStatus` to learn the auto-renewable subscription state to determine whether the customer
        //is new (never subscribed), active, or inactive (expired subscription). This app has only one subscription
        //group, so products in the subscriptions array all belong to the same group. The statuses that
        //`product.subscription.status` returns apply to the entire subscription group.
        self.subscriptionGroupStatus = try? await self.subscriptions.first?.subscription?.status.first?.state
        
        self.isPremium.send(Self.subscriptionStatusToIsPremium(subscriptionStatus: self.subscriptionGroupStatus))
    }

    func getProductData(forProductId productId: String) -> Any? {
        return self.productIdToProduct[productId]
    }

    func sortByPrice(_ products: [Product]) -> [Product] {
        products.sorted(by: { return $0.price < $1.price })
    }
    
    private static func subscriptionStatusToIsPremium(subscriptionStatus: RenewalState?) -> Bool {
        guard let state = subscriptionStatus else {
            return false
        }
        
        switch state {
        case .subscribed: return true
        case .expired: return false
        case .inBillingRetryPeriod: return true
        case .inGracePeriod: return true
        case .revoked: return false
        default:
            debugPrint("Unhandled RenewalState")
            return false
        }
    }
}

//fileprivate extension String {
//    func removeEnvironmentSuffix() -> String {
//        #if STAGING
//        self.replacingOccurrences(of: ".staging", with: "")
//        #else
//        self
//        #endif
//    }
//}



================================================
FILE: pdfexpert/Models/.DS_Store
================================================
[Non-text file]


================================================
FILE: pdfexpert/Models/Analytics/AnalyticsDefaultParameters.swift
================================================
//
//  AnalyticsDefaultParameters.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 05/09/23.
//

import Foundation

enum AnalyticsEventCustomParameters: String {
    case compressionOption = "compression_option"
    case marginOption = "margin_option"
    case homeActionType = "home_action_type"
    case importOption = "import_option"
    case pdfInputType = "pdf_input_type"
    case pdfInputTypeExtension = "pdf_input_type_extension"
    case productId = "product_identifier"
    case productPrice = "product_price"
    case subscriptionPlanIsFreeTrial = "subscription_is_free_trial"
    case reviewLowRateFeedbackContent = "review_low_rate_feedback_content"
    case screenName = "screen_name"
}

extension MarginsOption {
    var trackingParameterValue: String {
        switch self {
        case .noMargins: return "no_margins"
        case .mediumMargins: return "medium_margins"
        case .heavyMargins: return "heavy_margins"
        }
    }
}

extension FileSource {
    var trackingParameterValue: String {
        switch self {
        case .google: return "google_drive"
        case .dropbox: return "dropbox"
        case .icloud: return "iCloud"
        case .files: return "files"
        }
    }
}

extension AnalyticsScreen {
    var name: String {
        switch self {
        case .onboarding: return "Onboarding"
        case .home: return "Home"
        case .files: return "File"
        case .chatPdfSelection: return "ChatPdfSelection"
        case .settings: return "Settings"
        case .subscription: return "Subscription"
        case .importTutorial: return "ImportTutorial"
        case .signature: return "Signature"
        case .signaturePicker: return "SignaturePicker"
        case .fillForm: return "FillForm"
        case .fillWidget: return "FillWidget"
        case .chatPdf: return "ChatPdf"
        case .compressionPicker: return "CompressionPicker"
        case .sortPdf: return "SortPdf"
        case .pageRangeEditor: return "PageRangeEditor"
        case .reader: return "Reader"
        case .pageSelection: return "PageSelection"
        case .suggestedFields: return "SuggestedFields"
        }
    }
}

extension AnalyticsEvent {
    var customEventName: String {
        switch self {
        case .appTrackingTransparancyAuthorized: return "tracking_authorized"
        case .checkoutCompleted: return "checkout_completed"
        case .onboardingCompleted: return "onboarding_completed"
        case .onboardingSkipped: return "onboarding_skipped"
        case .homeActionChosen: return "home_action_chosen"
        case .homeFullActionChosen: return "home_full_action_chosen"
        case .homeFullActionCompleted: return "home_full_action_completed"
        case .pageAdded: return "page_added"
        case .pageRemoved: return "page_remove"
        case .pdfRenamed: return "pdf_renamed"
        case .passwordAdded: return "password_added"
        case .passwordRemoved: return "password_remove"
        case .compressionOptionChanged: return "compression_option_changed"
        case .pdfMerge: return "pdf_merge"
        case .pdfSplit: return "pdf_split"
        case .existingPdfOpened: return "existing_pdf_opened"
        case .existingPdfRemoved: return "existing_pdf_removed"
        case .importTutorialCompleted: return "import_tutorial_completed"
        case .pdfSaved: return "pdf_saved"
        case .pdfShared: return "pdf_shared"
        case .signatureCreated: return "signature_created"
        case .signatureAdded: return "signature_added"
        case .signatureRemoved: return "signature_removed"
        case .signaturesConfirmed: return "signatures_confirmed"
        case .signatureFileSaved: return "signatures_file_saved"
        case .signatureFileDeleted: return "signatures_file_deleted"
        case .textAnnotationAdded: return "text_annotation_added"
        case .textAnnotationRemoved: return "text_annotation_removed"
        case .annotationsConfirmed: return "annotations_confirmed"
        case .fillWidgetCancelled: return "fill_widget_cancelled"
        case .fillWidgetConfirmed: return "fill_widget_confirmed"
        case .chatPdfSelectionActionChosen: return "chat_pdf_selection_action_chosen"
        case .chatPdfSelectionFullActionChosen: return "chat_pdf_selection_full_action_chosen"
        case .chatPdfSelectionFullActionCompleted: return "chat_pdf_selection_full_action_completed"
        case .chatPdfMessageSent: return "chat_pdf_message_sent"
        case .subscriptionShown: return "subscription_shown"
        case .reviewLowRateFeedback: return "review_low_rate_feedback"
        case .suggestedFieldsSaved: return "suggested_fields_saved"
        case .reportScreen: return "report_screen"
        case .reportNonFatalError: return ""
        }
    }
    
    var parameters: [String: Any]? {
        switch self {
        case .appTrackingTransparancyAuthorized: return nil
        case .checkoutCompleted(let subscriptionPlanProduct):
            return [
                AnalyticsEventCustomParameters.productId.rawValue: subscriptionPlanProduct.id,
                AnalyticsEventCustomParameters.productPrice.rawValue: subscriptionPlanProduct.displayPrice,
                AnalyticsEventCustomParameters.subscriptionPlanIsFreeTrial.rawValue: subscriptionPlanProduct.subscription?.introductoryOffer?.paymentMode == .freeTrial
            ]
        case .homeActionChosen(let homeAction):
            return [AnalyticsEventCustomParameters.homeActionType.rawValue: homeAction.trackingParameterValue]
        case .homeFullActionChosen(let homeAction, let importOption):
            var parameters = [AnalyticsEventCustomParameters.homeActionType.rawValue: homeAction.trackingParameterValue]
            if let importOption = importOption {
                parameters[AnalyticsEventCustomParameters.importOption.rawValue] = importOption.trackingParameterValue
            }
            return parameters
        case .homeFullActionCompleted(let homeAction, let importOption, let fileExtension):
            var parameters = [AnalyticsEventCustomParameters.homeActionType.rawValue: homeAction.trackingParameterValue]
            if let fileExtension = fileExtension {
                parameters[AnalyticsEventCustomParameters.pdfInputTypeExtension.rawValue] = fileExtension
            }
            if let importOption = importOption {
                parameters[AnalyticsEventCustomParameters.importOption.rawValue] = importOption.trackingParameterValue
            }
            return parameters
        case .pageAdded(let pdfInputType, let fileExtension):
            var parameters = [AnalyticsEventCustomParameters.pdfInputType.rawValue: pdfInputType.trackingParameterValue]
            if let fileExtension = fileExtension {
                parameters[AnalyticsEventCustomParameters.pdfInputTypeExtension.rawValue] = fileExtension
            }
            return parameters
        case .onboardingCompleted: return nil
        case .onboardingSkipped: return nil
        case .pageRemoved: return nil
        case .pdfRenamed: return nil
        case .passwordAdded: return nil
        case .passwordRemoved: return nil
        case .compressionOptionChanged(let compressionOption):
            return [AnalyticsEventCustomParameters.compressionOption.rawValue: compressionOption.trackingParameterValue]
        case .pdfMerge: return nil
        case .pdfSplit: return nil
        case .existingPdfOpened: return nil
        case .existingPdfRemoved: return nil
        case .importTutorialCompleted: return nil
        case .textAnnotationAdded: return nil
        case .textAnnotationRemoved: return nil
        case .annotationsConfirmed: return nil
        case .signatureCreated: return nil
        case .signatureAdded: return nil
        case .signatureRemoved: return nil
        case .signaturesConfirmed: return nil
        case .signatureFileSaved: return nil
        case .signatureFileDeleted: return nil
        case .fillWidgetCancelled: return nil
        case .fillWidgetConfirmed: return nil
        case .pdfSaved: return nil
        case .pdfShared: return nil
        case .chatPdfSelectionActionChosen: return nil
        case .chatPdfSelectionFullActionChosen(let importOption):
            var parameters: [String: Any] = [:]
            if let importOption = importOption {
                parameters[AnalyticsEventCustomParameters.importOption.rawValue] = importOption.trackingParameterValue
            }
            return parameters
        case .chatPdfSelectionFullActionCompleted(let importOption, let fileExtension):
            var parameters: [String: Any] = [:]
            if let fileExtension = fileExtension {
                parameters[AnalyticsEventCustomParameters.pdfInputTypeExtension.rawValue] = fileExtension
            }
            if let importOption = importOption {
                parameters[AnalyticsEventCustomParameters.importOption.rawValue] = importOption.trackingParameterValue
            }
            return parameters
        case .chatPdfMessageSent: return nil
        case .subscriptionShown: return nil
        case .reviewLowRateFeedback(let feedback):
            return [AnalyticsEventCustomParameters.reviewLowRateFeedbackContent.rawValue: feedback]
        case .suggestedFieldsSaved: return nil
        case .reportScreen(let screen):
            return [AnalyticsEventCustomParameters.screenName.rawValue: screen.name]
        case .reportNonFatalError: return nil
        }
    }
}

extension AnalyticsError {
    
    var errorDescription: String {
        switch self {
        case .shareExtensionPdfMissingRawData: return "Share Extension Pdf raw data missing while existance flag was true"
        case .shareExtensionPdfExistingUnexpectedRawData: return "Share Extension Pdf raw data but the existance flag was false"
        case .shareExtensionPdfCannotDecode: return "Share Extension Pdf raw data existed but could not be converted to PdfDocument"
        case .shareExtensionPdfInvalidPasswordForLockedFile: return "Share Extension Pdf cannot be unlocked with the stored password"
        case .shareExtensionPdfMissingDataForUnlockedFile: return "Share Extension Pdf was unlocked but failed to provide data"
        case .shareExtensionPdfDecryptionFailed: return "Share Extension Pdf was unlocked but could not be decrypted"
        case .shareExtensionPdfCannotDecodeDecryptedData: return "Share Extension Pdf was decrypted but could not be converted to PdfDocument"
        case .chatPdfDeletionFailed: return "Pdf uploaded to Chat Pdf has not be deleted"
        }
    }
    
    var nsError: NSError {
        let userInfo: [String: Any] = [
            "error_description": self.errorDescription
        ]
        return NSError(domain: "AnalyticsError", code: 0, userInfo: userInfo)
    }
}

fileprivate extension AnalyticsPdfInputType {
    
    var trackingParameterValue: String {
        switch self {
        case .camera: return "camera"
        case .gallery: return "gallery"
        case .fileImage: return "file_image"
        case .file: return "file"
        case .scan: return "scan"
        case .appExtension: return "app_extension"
        case .scanPdf: return "scan_pdf"
        case .filePdf: return "file_pdf"
        case .scanFillForm: return "scan_fill_form"
        case .fileFillForm: return "file_fill_form"
        case .scanSign: return "scan_sign"
        case .fileSign: return "file_sign"
        case .fileFillWidget: return "file_fill_widget"
        }
    }
}

fileprivate extension HomeAction {
    
    var trackingParameterValue: String {
        switch self {
        case .appExtension: return "app_extension"
        case .imageToPdf: return "image_to_pdf"
        case .wordToPdf: return "word_to_pdf"
        case .excelToPdf: return "excel_to_pdf"
        case .powerpointToPdf: return "powerpoint_to_pdf"
        case .scan: return "scan"
        case .merge: return "merge"
        case .split: return "split"
        case .sign: return "sign"
        case .formFill: return "form_fill"
        case .addText: return "add_text"
        case .createPdf: return "create_pdf"
        case .importPdf: return "import_pdf"
        case .readPdf: return "read_pdf"
        case .removePassword: return "remove_password"
        case .addPassword: return "add_password"
        }
    }
}

fileprivate extension ImportOption {
    
    var trackingParameterValue: String {
        switch self {
        case .camera: return "camera"
        case .gallery: return "gallery"
        case .scan: return "scan"
        case .file(let fileSource):
            switch fileSource {
            case .google: return "google_drive"
            case .dropbox: return "dropbox"
            case .icloud: return "icloud"
            case .files: return "files"
            }
        }
    }
}

fileprivate extension CompressionOption {
    
    var trackingParameterValue: String {
        switch self {
        case .noCompression: return "no_compression"
        case .low: return "low"
        case .medium: return "medium"
        case .high: return "high"
        }
    }
}



================================================
FILE: pdfexpert/Models/Analytics/AnalyticsManager.swift
================================================
//
//  AnalyticsManager.swift
//  ForYouAndMe
//
//  Created by Pcnaid Inc on 10/07/2020.
//

import Foundation
import StoreKit

enum AnalyticsError {
    case shareExtensionPdfMissingRawData
    case shareExtensionPdfExistingUnexpectedRawData
    case shareExtensionPdfCannotDecode
    case shareExtensionPdfInvalidPasswordForLockedFile
    case shareExtensionPdfMissingDataForUnlockedFile
    case shareExtensionPdfDecryptionFailed
    case shareExtensionPdfCannotDecodeDecryptedData
    case chatPdfDeletionFailed
}

enum AnalyticsPdfInputType {
    case camera, gallery, fileImage, file, scan, appExtension, scanPdf, filePdf, scanFillForm, fileFillForm, scanSign, fileSign, fileFillWidget
}

enum AnalyticsScreen {
    case onboarding
    case home
    case files
    case chatPdfSelection
    case settings
    case subscription
    case importTutorial
    case signature
    case signaturePicker
    case fillForm
    case fillWidget
    case chatPdf
    case compressionPicker
    case sortPdf
    case pageRangeEditor
    case reader
    case pageSelection
    case suggestedFields
}

enum AnalyticsEvent {
    case appTrackingTransparancyAuthorized
    case checkoutCompleted(subscriptionPlanProduct: Product)
    case onboardingCompleted
    case onboardingSkipped
    case homeActionChosen(homeAction: HomeAction)
    case homeFullActionChosen(homeAction: HomeAction, importOption: ImportOption?)
    case homeFullActionCompleted(homeAction: HomeAction, importOption: ImportOption?, fileExtension: String?)
    case pageAdded(pdfInputType: AnalyticsPdfInputType, fileExtension: String?)
    case pageRemoved
    case pdfRenamed
    case passwordAdded
    case passwordRemoved
    case pdfMerge
    case pdfSplit
    case compressionOptionChanged(compressionOption: CompressionOption)
    case existingPdfOpened
    case existingPdfRemoved
    case importTutorialCompleted
    case signatureCreated
    case signatureAdded
    case signatureRemoved
    case signaturesConfirmed
    case signatureFileSaved
    case signatureFileDeleted
    case textAnnotationAdded
    case textAnnotationRemoved
    case annotationsConfirmed
    case fillWidgetCancelled
    case fillWidgetConfirmed
    case pdfSaved
    case pdfShared
    case chatPdfSelectionActionChosen
    case chatPdfSelectionFullActionChosen(importOption: ImportOption?)
    case chatPdfSelectionFullActionCompleted(importOption: ImportOption?, fileExtension: String?)
    case chatPdfMessageSent
    case subscriptionShown
    case reviewLowRateFeedback(feedback: String)
    case suggestedFieldsSaved
    case reportScreen(_ screen: AnalyticsScreen)
    case reportNonFatalError(_ error: AnalyticsError)
}

protocol AnalyticsManager {
    func track(event: AnalyticsEvent)
}



================================================
FILE: pdfexpert/Models/Analytics/AnalyticsManagerImpl.swift
================================================
//
//  AnalyticsManagerImpl.swift
//  ForYouAndMe
//
//  Created by Pcnaid Inc on 10/07/2020.
//

import Foundation
import Factory

extension Container {
    var analyticsManager: Factory<AnalyticsManager> {
        self { AnalyticsManagerImpl() }.singleton
    }
}

class AnalyticsManagerImpl: AnalyticsManager {
    
    private let platforms: [AnalyticsPlatform]
    
    init() {
        self.platforms = [FirebaseAnalyticsPlatform(), BranchAnalyticsPlatform()]
    }
    
    func track(event: AnalyticsEvent) {
        print("Analytics - Tracked event: \(event)")
        #if PRODUCTION && DEBUG
        #else
        self.platforms.forEach({ $0.track(event: event) })
        #endif
    }
}



================================================
FILE: pdfexpert/Models/Analytics/AnalyticsPlatform.swift
================================================
//
//  AnalyticsPlatform.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/04/23.
//

import Foundation

protocol AnalyticsPlatform {
    func track(event: AnalyticsEvent)
}



================================================
FILE: pdfexpert/Models/Analytics/BranchAnalyticsPlatform.swift
================================================
//
//  BranchAnalyticsPlatform.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 05/09/23.
//

import Foundation
import BranchSDK

class BranchAnalyticsPlatform: AnalyticsPlatform {
    
    func track(event: AnalyticsEvent) {
        switch event {
        case .checkoutCompleted(let subscriptionPlanProduct):
            let branchUniversalObject = BranchUniversalObject()
            branchUniversalObject.canonicalIdentifier = subscriptionPlanProduct.id
            branchUniversalObject.contentMetadata.price = NSDecimalNumber(decimal: subscriptionPlanProduct.price)
            branchUniversalObject.title = subscriptionPlanProduct.displayName
            branchUniversalObject.contentMetadata.quantity = 1
            branchUniversalObject.contentMetadata.productName = subscriptionPlanProduct.displayName
            branchUniversalObject.contentMetadata.currency = BNCCurrency(rawValue: subscriptionPlanProduct.priceFormatStyle.currencyCode)
            if subscriptionPlanProduct.isFreeTrial {
                BranchEvent.standardEvent(.startTrial, withContentItem: branchUniversalObject).logEvent()
            } else {
                BranchEvent.standardEvent(.subscribe, withContentItem: branchUniversalObject).logEvent()
            }
        case .reportNonFatalError:
            break
        default:
            self.sendEvent(withEventName: event.customEventName, parameters: event.parameters)
        }
    }
    
    // MARK: - Private Methods
    
    private func sendEvent(withEventName eventName: String, parameters: [String: Any]? = nil) {
        if let parameters {
            let branchUniversalObject = BranchUniversalObject(dictionary: parameters)
            BranchEvent.customEvent(withName: eventName, contentItem: branchUniversalObject).logEvent()
        } else {
            BranchEvent.customEvent(withName: eventName).logEvent()
        }
    }
}



================================================
FILE: pdfexpert/Models/Analytics/FirebaseAnalyticsPlatform.swift
================================================
//
//  FirebaseAnalyticsPlatform.swift
//  ForYouAndMe
//
//  Created by Pcnaid Inc on 23/09/2020.
//

import Foundation
import FirebaseAnalytics
import FirebaseCrashlytics

class FirebaseAnalyticsPlatform: AnalyticsPlatform {
    
    func track(event: AnalyticsEvent) {
        switch event {
        case .reportScreen(let screen):
            self.sendEvent(withEventName: AnalyticsEventScreenView, parameters: [AnalyticsParameterScreenName: screen.name])
        case .reportNonFatalError(let error):
            Crashlytics.crashlytics().record(error: error.nsError)
        default:
            self.sendEvent(withEventName: event.customEventName, parameters: event.parameters)
        }
    }
    
    // MARK: - Private Methods
    
    private func sendEvent(withEventName eventName: String, parameters: [String: Any]? = nil) {
        Analytics.logEvent(eventName, parameters: parameters)
    }
}



================================================
FILE: pdfexpert/Models/Entities/ChatPdfInitParams.swift
================================================
//
//  ChatPdfInitParams.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/07/23.
//

import Foundation

struct ChatPdfInitParams: Hashable, Identifiable {
    
    var id: Self { return self }
    
    let chatPdfRef: ChatPdfRef
    let setupData: ChatPdfSetupData
}



================================================
FILE: pdfexpert/Models/Entities/ChatPdfMessage.swift
================================================
//
//  ChatPdfMessage.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 20/07/23.
//

import Foundation

enum ChatPdfMessageRole {
    case user
    case assistant
}

enum ChatPdfMessageType {
    case text
    case indicator
}

struct ChatPdfMessage: Hashable {
    let role: ChatPdfMessageRole
    let type: ChatPdfMessageType
    let content: String
    let suggestedQuestions: [String]
}

extension ChatPdfMessage {
    init(role: ChatPdfMessageRole, type: ChatPdfMessageType, content: String) {
        self.role = role
        self.type = type
        self.content = content
        self.suggestedQuestions = []
    }
}



================================================
FILE: pdfexpert/Models/Entities/ChatPdfRef.swift
================================================
//
//  ChatPdfRef.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 20/07/23.
//

import Foundation

struct ChatPdfRef: Hashable, Identifiable {
    
    var id: Self { return self }
    
    let sourceId: String
}



================================================
FILE: pdfexpert/Models/Entities/ChatPdfSetupData.swift
================================================
//
//  ChatPdfSetupData.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 10/08/23.
//

import Foundation

struct ChatPdfSetupData: Hashable {
    let summary: String
    let suggestedQuestions: [String]
}



================================================
FILE: pdfexpert/Models/Entities/Pdf.swift
================================================
//
//  Pdf.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 11/04/23.
//

import Foundation
import PDFKit
import CoreData

enum MarginsOption: Int32, CaseIterable {
    case noMargins, mediumMargins, heavyMargins
}

enum CompressionOption: Int32, CaseIterable {
    case noCompression, low, medium, high
}

struct Pdf {
    private(set) var storeId: NSManagedObjectID? = nil
    private(set) var pdfDocument: PDFDocument
    private(set) var password: String? = nil
    private(set) var creationDate: Date = Date()
    private(set) var filename: String
    private(set) var compression: CompressionOption = K.Misc.PdfDefaultCompression
    private(set) var margins: MarginsOption = K.Misc.PdfDefaultMarginsOption
    
    var rawData: Data? {
        return self.pdfDocument.dataRepresentation()
    }
    
    init(storeId: NSManagedObjectID,
         pdfDocument: PDFDocument,
         password: String?,
         creationDate: Date?,
         fileName: String?,
         compression: CompressionOption,
         margins: MarginsOption) {
        self.storeId = storeId
        self.pdfDocument = pdfDocument
        self.password = password
        self.creationDate = creationDate ?? Date()
        self.filename = fileName ?? self.creationDate.creationDateText
        self.compression = compression
        self.margins = margins
    }
    
    init?(data: Data) {
        guard let pdfDocument = PDFDocument(data: data) else { return nil }
        self.pdfDocument = pdfDocument
        self.filename = self.creationDate.creationDateText
    }
    
    init?(pdfUrl: URL) {
        guard let pdfDocument = PDFDocument(url: pdfUrl) else { return nil }
        self.pdfDocument = pdfDocument
        self.filename = pdfUrl.filename
    }
    
    init(pdfDocument: PDFDocument) {
        self.pdfDocument = pdfDocument
        self.filename = self.creationDate.creationDateText
    }
    
    init() {
        self.pdfDocument = PDFDocument()
        self.filename = self.creationDate.creationDateText
    }
    
    mutating func updateStoreId(_ storeId: NSManagedObjectID?) {
        self.storeId = storeId
    }
    
    mutating func updateDocument(_ pdfDocument: PDFDocument) {
        self.pdfDocument = pdfDocument
    }
    
    mutating func updatePassword(_ newPassword: String?) {
        self.password = newPassword
    }
    
    mutating func updateCompression(_ newCompression: CompressionOption) {
        self.compression = newCompression
    }
    
    mutating func updateMargins(_ newMargins: MarginsOption) {
        self.margins = newMargins
    }
    
    mutating func updateFilename(_ filename: String) {
        self.filename = filename
    }
    
    var thumbnail: UIImage? {
        PDFUtility.generatePdfThumbnail(pdfDocument: self.pdfDocument, size: K.Misc.ThumbnailSize)
    }
    
    var pageCount: Int {
        return self.pdfDocument.pageCount
    }
}

fileprivate extension Date {
    
    var creationDateText: String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MM-dd-YYYY"
        return "File-\(dateFormatter.string(from: self))"
    }
}

extension Pdf: Hashable, Identifiable {
    var id: Self { return self }
}

extension Pdf: Collection {
    
    typealias Index = Int
    typealias Element = PDFPage
    
    var startIndex: Index { return 0 }
    var endIndex: Index { return self.pageCount }
    
    subscript(index: Index) -> Element {
        get { return self.pdfDocument.page(at: index)! }
    }
    
    func index(after i: Index) -> Index {
        return i + 1
    }
}



================================================
FILE: pdfexpert/Models/Entities/PickedImage.swift
================================================
//
//  PickedImage.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 07/06/23.
//

import Foundation
import PhotosUI
import SwiftUI

struct PickedImage: Transferable {
    let uiImage: UIImage
    
    static var transferRepresentation: some TransferRepresentation {
        DataRepresentation(importedContentType: .image) { data in
        #if canImport(UIKit)
            guard let uiImage = UIImage(data: data) else {
                throw ImageTransferError.importFailed
            }
            return PickedImage(uiImage: uiImage)
        #else
            throw ImageTransferError.importFailed
        #endif
        }
    }
}

enum ImageTransferError: LocalizedError {
    case importFailed
    
    var errorDescription: String? {
        switch self {
        case .importFailed: return "Couldn't import the selected photo."
        }
    }
}



================================================
FILE: pdfexpert/Models/Entities/ProjectInfo.swift
================================================
//
//  ProjectInfo.swift
//  FastCheckIn
//
//  Created by Pcnaid Inc on 03/07/23.
//

import Foundation

class ProjectInfo {
    
    private enum ProjectInfoKey: String, CaseIterable {
        
        case chatPdfApiKey = "CHAT_PDF_API_KEY"
    }
    
    static var chatPdfApiKey: String { Self.getValue(forKey: .chatPdfApiKey, defaultValue: "") }
    
    static func validate() {
        ProjectInfoKey.allCases.forEach { key in
            switch key {
            case .chatPdfApiKey: _ = Self.getValue(forKey: key, defaultValue: "")
            }
        }
    }
    
    static private var projectInfoDictionary: [String: Any] = {
        guard let url = Bundle.main.url(forResource: "ProjectInfo", withExtension: "plist") else {
            assertionFailure("Couldn't find ProjectInfo.plist")
            return [:]
        }
        guard let data = try? Data(contentsOf: url) else {
            assertionFailure("Couldn't open ProjectInfo.plist")
            return [:]
        }
        guard let studyConfig = try? PropertyListSerialization.propertyList(from: data, format: nil) as? [String: Any] else {
            assertionFailure("ProjectInfo.plist is not a dictionary of [String: Any]")
            return [:]
        }
        return studyConfig
    }()
    
    static private func getValue<T>(forKey key: ProjectInfoKey, defaultValue: T) -> T {
        guard let object = Self.projectInfoDictionary[key.rawValue], let value = object as? T  else {
            assertionFailure("Couldn't find \(key.rawValue) in ProjectInfo")
            return defaultValue
        }
        return value
    }
    
    static private func getOptionalValue<T>(forKey key: ProjectInfoKey) -> T? {
        guard let object = Self.projectInfoDictionary[key.rawValue], let value = object as? T  else {
            return nil
        }
        return value
    }
}



================================================
FILE: pdfexpert/Models/Entities/Signature.swift
================================================
//
//  Signature.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/08/23.
//

import Foundation
import CoreData
import PencilKit

struct Signature {
    let id: UUID = UUID()
    private(set) var storeId: NSManagedObjectID? = nil
    let image: UIImage
    let creationDate: Date
    
    var rawData: Data? {
        return self.image.pngData()
    }
    
    init?(storeId: NSManagedObjectID,
         creationDate: Date?,
         data: Data) {
        guard let image = UIImage(data: data) else {
            return nil
        }
        print("Signature - On Load Image Size: \(image.size). Scale: \(image.scale)")
        self.storeId = storeId
        self.image = image
        self.creationDate = creationDate ?? Date()
    }
    
    init(image: UIImage) {
        print("Signature - On Save Image Size: \(image.size). Scale: \(image.scale)")
        self.image = image
        self.creationDate = Date()
    }
    
    mutating func updateStoreId(_ storeId: NSManagedObjectID?) {
        self.storeId = storeId
    }
}

extension Signature: Identifiable {}

extension PKDrawing {
    var signatureImage: UIImage {
        self.image(from: self.bounds, scale: K.Misc.SignatureDrawScaleFactor, userInterfaceStyle: .light)
    }
}



================================================
FILE: pdfexpert/Models/Entities/SuggestedFields.swift
================================================
//
//  SuggestedFields.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 07/09/23.
//

import Foundation
import CoreData

struct SuggestedFields {
    private(set) var storeId: NSManagedObjectID? = nil
    var firstName: String?
    var lastName: String?
    var address: String?
    var city: String?
    var country: String?
    var email: String?
    var phone: String?
    
    var fields: [String] {
        let fields: [String?] = [
            self.firstName,
            self.lastName,
            self.address,
            self.city,
            self.country,
            self.email,
            self.phone
        ]
        return fields.compactMap { $0 }
    }

    mutating func updateStoreId(_ storeId: NSManagedObjectID?) {
        self.storeId = storeId
    }
}



================================================
FILE: pdfexpert/Models/Network/NetworkUtility.swift
================================================
//
//  NetworkUtility.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/07/23.
//

import Foundation

internal extension String {
    var urlEscaped: String {
        return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
    }
    
    var utf8Encoded: Data {
        return self.data(using: .utf8)!
    }
}

internal extension Optional where Wrapped == Int {
    var toString:String {
        return self != nil ? String(describing: self) : ""
    }
}

internal extension Int {
    var toString:String {
        return String(describing: self)
    }
}

internal extension Date {
    var toString:String {
        let dateFormatter = ISO8601DateFormatter()
        return dateFormatter.string(from: self)
    }
    
    var toDateString: String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        return dateFormatter.string(from: self)
    }
}

internal extension Bundle {
    static func getTestData(from fileName:String) -> Data {
        guard let url = Bundle.main.url(forResource: fileName, withExtension: "json"),
            let data = try? Data(contentsOf: url) else {
                return Data()
        }
        return data
    }
}

internal extension Data {
    static func JSONResponseDataFormatter(_ data: Data) -> String {
        return JSONPrettyDataFormatter(data)
    }
    
    static func JSONRequestDataFormatter(_ data: Data) -> String {
        return JSONPrettyDataFormatter(data)
    }
    
    private static func JSONPrettyDataFormatter(_ data: Data) -> String {
        do {
            let dataAsJSON = try JSONSerialization.jsonObject(with: data)
            let prettyData =  try JSONSerialization.data(withJSONObject: dataAsJSON, options: .prettyPrinted)
            return String(data: prettyData, encoding: .utf8) ?? ""
        } catch {
            return String(data: data, encoding: .utf8) ?? ""
        }
    }
}



================================================
FILE: pdfexpert/Models/Network/ChatPdf/ChatPdfManager.swift
================================================
//
//  ChatPdfManager.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 02/03/23.
//

import Foundation
import Factory
import Combine

enum ChatPdfError: LocalizedError, UnderlyingError {
    case unknownError
    case parse
    case pdfTooLarge
    case pdfTooManyPages
    case underlyingError(errorDescription: String)
    
    static func getUnknownError() -> Self { Self.unknownError }
    
    static func getUnderlyingError(errorDescription: String) -> Self {
        return .underlyingError(errorDescription: errorDescription)
    }
    
    var errorDescription: String? {
        switch self {
        case .unknownError, .parse: return "Internal Error. Please try again later"
        case .underlyingError(let errorMessage): return errorMessage
        case .pdfTooLarge: return "Your pdf is too large"
        case .pdfTooManyPages: return "Your pdf has too many pages"
        }
    }
}


protocol ChatPdfManager {
    func sendPdf(pdf: Data) -> AnyPublisher<ChatPdfRef, ChatPdfError>
    func generateText(ref: ChatPdfRef, prompt: String) -> AnyPublisher<ChatPdfMessage, ChatPdfError>
    func getSetupData(ref: ChatPdfRef) -> AnyPublisher<ChatPdfSetupData, ChatPdfError>
    func deletePdf(ref: ChatPdfRef)
}

extension Container {
    var chatPdfManager: Factory<ChatPdfManager> {
        self {
            #if DEBUG
            K.Test.ChatPdf.UseMock ? (ChatPdfManagerMock() as ChatPdfManager) : (ChatPdfManagerImpl() as ChatPdfManager)
            #else
            ChatPdfManagerImpl()
            #endif
        }.singleton
    }
}



================================================
FILE: pdfexpert/Models/Network/ChatPdf/ChatPdfManagerImpl.swift
================================================
//
//  ChatPdfManagerImpl.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/07/23.
//

import Foundation
import Moya
import CombineMoya
import Combine
import Factory

fileprivate struct ChatPdfApiError: Decodable, CustomStringConvertible {
    let code: String
    let message: String
    
    var description: String { self.message }
}

class ChatPdfManagerImpl: ChatPdfManager {
    
    fileprivate static let baseUrl: String = "https://api.chatpdf.com"
    
    fileprivate static let apiKey: String = { ProjectInfo.chatPdfApiKey }()
    
    lazy var provider: MoyaProvider<ChatPdfService> = { self.createProvider() }()
    
    lazy var loggerPlugin: PluginType = {
        let formatter = NetworkLoggerPlugin.Configuration.Formatter(requestData: Data.JSONRequestDataFormatter,
                                                                    responseData: Data.JSONRequestDataFormatter)
        let logOptions: NetworkLoggerPlugin.Configuration.LogOptions = K.Test.ChatPdf.NetworkLogVerbose
            ? .verbose
            : .default
        let config = NetworkLoggerPlugin.Configuration(formatter: formatter, logOptions: logOptions)
        return NetworkLoggerPlugin(configuration: config)
    }()
    
    @Injected(\.analyticsManager) private var analyticsManager
    
    private var cancelBag = Set<AnyCancellable>()
    
    func createProvider() -> MoyaProvider<ChatPdfService> {
        MoyaProvider<ChatPdfService>(plugins: [self.loggerPlugin])
    }
    
    func sendPdf(pdf: Data) -> AnyPublisher<ChatPdfRef, ChatPdfError> {
        self.send(request: .sendPdf(pdf: pdf))
    }
    
    func generateText(ref: ChatPdfRef, prompt: String) -> AnyPublisher<ChatPdfMessage, ChatPdfError> {
        self.send(request: .generateText(ref: ref, prompt: prompt))
    }
    
    func getSetupData(ref: ChatPdfRef) -> AnyPublisher<ChatPdfSetupData, ChatPdfError> {
        self.generateText(ref: ref, prompt: K.ChatPdf.SetupMessageRequest)
            .map { (message: ChatPdfMessage) in
                let decoder = JSONDecoder()
                if let setupData = try? decoder.decode(ChatPdfSetupData.self, from: Data(message.content.utf8)) {
                    return setupData
                } else {
                    return ChatPdfSetupData(summary: K.ChatPdf.SetupMessageFallbackResponse, suggestedQuestions: [])
                }
            }.eraseToAnyPublisher()
    }
    
    func deletePdf(ref: ChatPdfRef) {
        // Must be fire and forget by design, to avoid blocking the user and show unfriendly errors
        // TODO: Improve with a queue of to-be-deleted pdfs that periodically get flushed
        self.send(request: .deletePdf(ref: ref))
            .sink(receiveCompletion: { subscriptionCompletion in
                if let error = subscriptionCompletion.error {
                    print("ChatPdfManagerImpl - deleting Pdf from Chat PDF. Error: \(error.localizedDescription)")
                    self.analyticsManager.track(event: .reportNonFatalError(.chatPdfDeletionFailed))
                }
            }, receiveValue: {
                print("ChatPdfManagerImpl - successfully deleted from Chat PDF")
            }).store(in: &self.cancelBag)
    }
    
    private func send<T: Decodable>(request: ChatPdfService) -> AnyPublisher<T, ChatPdfError> {
        self.provider.requestPublisher(request)
            .tryMap() { response -> Data in
                guard 200 ... 299 ~= response.statusCode else {
                    let decoder = JSONDecoder()
                    if let apiError =  try? decoder.decode(ChatPdfApiError.self, from: response.data) {
                        throw ChatPdfError.underlyingError(errorDescription: apiError.description)
                    } else {
                        throw ChatPdfError.underlyingError(errorDescription: String(data: response.data, encoding: .utf8) ?? "")
                    }
                }
                return response.data
            }
            .decode(type: T.self, decoder: JSONDecoder())
            .mapError { error in
                if let error = error as? ChatPdfError {
                    return error
                } else if error is DecodingError {
                    return ChatPdfError.parse
                } else {
                    return ChatPdfError.underlyingError(errorDescription: error.localizedDescription)
                }
            }
            .eraseToAnyPublisher()
    }
    
    private func send(request: ChatPdfService) -> AnyPublisher<(), ChatPdfError> {
        self.provider.requestPublisher(request)
            .tryMap() { response -> () in
                guard 200 ... 299 ~= response.statusCode else {
                    let decoder = JSONDecoder()
                    if let apiError =  try? decoder.decode(ChatPdfApiError.self, from: response.data) {
                        throw ChatPdfError.underlyingError(errorDescription: apiError.description)
                    } else {
                        throw ChatPdfError.underlyingError(errorDescription: String(data: response.data, encoding: .utf8) ?? "")
                    }
                }
                return ()
            }
            .mapError { error in
                if let error = error as? ChatPdfError {
                    return error
                } else {
                    return ChatPdfError.underlyingError(errorDescription: error.localizedDescription)
                }
            }
            .eraseToAnyPublisher()
    }
}

enum ChatPdfService {
    case sendPdf(pdf: Data)
    case generateText(ref: ChatPdfRef, prompt: String)
    case deletePdf(ref: ChatPdfRef)
}

extension ChatPdfService: TargetType {
    
    var baseURL: URL { return URL(string: ChatPdfManagerImpl.baseUrl)! }
    
    var path: String {
        switch self {
        case .sendPdf: return "/v1/sources/add-file"
        case .generateText: return "/v1/chats/message"
        case .deletePdf: return "/v1/sources/delete"
        }
    }
    
    var method: Moya.Method {
        switch self {
        case .sendPdf, .generateText, .deletePdf:
            return .post
        }
    }
    
    var sampleData: Data {
        switch self {
        // Misc
        case .sendPdf: return "{\"sourceId\": \"TestSourceId\"}".utf8Encoded
        case .generateText:
            return "{\"content\": \"Test Message\"}".utf8Encoded
//            return "{\"content\": \"{\\\"summary\\\": \\\"content of the summary\\\",\\\"suggested_questions\\\": [\\\"suggested question number 1\\\",\\\"suggested question number 2\\\",\\\"suggested question number 3\\\"]}\"}".utf8Encoded
//            return "{\"content\": \"{\\\"summary\\\": \\\"content of the summary\\\",\\\"suggested_questions\\\": \\\"suggested question number 1\\\"}\"}".utf8Encoded
//            return "{\"content\": \"invalid text\"}".utf8Encoded
        case .deletePdf: return "".utf8Encoded
        }
    }
    
    var task: Task {
        switch self {
        case .sendPdf:
            return .uploadMultipart(self.multipartBody)
        case .generateText(let ref, let prompt):
            let message: [String: Any] = [
                "role": "user",
                "content": prompt
            ]
            let parameters: [String: Any] = [
                "sourceId": ref.sourceId,
                "messages": [message]
            ]
            return .requestParameters(parameters: parameters, encoding: JSONEncoding.default)
        case .deletePdf(let ref):
            return .requestParameters(parameters: ["sources": [ref.sourceId]], encoding: JSONEncoding.default)
        }
    }
    
    var multipartBody: [MultipartFormData] {
        switch self {
        case .sendPdf(let pdfFile):
            let imageDataProvider = MultipartFormData(provider: MultipartFormData.FormDataProvider.data(pdfFile),
                                                      name: "pdf_expert_file",
                                                      fileName: "pdf_expert_file.pdf",
                                                      mimeType: "application/pdf")
            return [imageDataProvider]
        default:
            return []
        }
    }
    
    var headers: [String: String]? {
        return [
            "Content-type": "application/json",
            "x-api-key": ChatPdfManagerImpl.apiKey
        ]
    }
}



================================================
FILE: pdfexpert/Models/Network/ChatPdf/ChatPdfManagerMock.swift
================================================
//
//  ChatPdfManagerMock.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 02/03/23.
//

import Foundation
import Combine
import Moya

class ChatPdfManagerMock: ChatPdfManagerImpl {
    
    override func createProvider() -> MoyaProvider<ChatPdfService> {
        if K.Test.ChatPdf.NetworkStubsDelay > 0.0 {
            // Delayed responses (to test progress HUD, for example, or other UI tests)
            return MoyaProvider<ChatPdfService>(stubClosure: MoyaProvider.delayedStub(K.Test.ChatPdf.NetworkStubsDelay),
                                                plugins: [self.loggerPlugin])
        } else {
            // Immediate stubs for unit tests
            return MoyaProvider<ChatPdfService>(stubClosure: MoyaProvider.immediatelyStub,
                                                plugins: [self.loggerPlugin])
        }
    }
}



================================================
FILE: pdfexpert/Models/Network/ChatPdf/Mapping/ChatPdfMessage+Decodable.swift
================================================
//
//  ChatPdfMessage+Decodable.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/07/23.
//

import Foundation

extension ChatPdfMessage: Decodable {
    private enum CodingKeys: CodingKey {
        case content
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.content = try container.decode(String.self, forKey: .content)
        self.type = .text
        self.role = .assistant
        self.suggestedQuestions = []
    }
}



================================================
FILE: pdfexpert/Models/Network/ChatPdf/Mapping/ChatPdfRef+Decodable.swift
================================================
//
//  ChatPdfRef+Decodable.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/07/23.
//

import Foundation

extension ChatPdfRef: Decodable {
    private enum CodingKeys: CodingKey {
        case sourceId
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.sourceId = try container.decode(String.self, forKey: .sourceId)
    }
}



================================================
FILE: pdfexpert/Models/Network/ChatPdf/Mapping/ChatPdfSetupData+Decodable.swift
================================================
//
//  ChatPdfSetupData+Decodable.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 10/08/23.
//

import Foundation

extension ChatPdfSetupData: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary
        case suggestedQuestions = "suggested_questions"
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.summary = try container.decode(String.self, forKey: .summary)
        self.suggestedQuestions = (try? container.decode([String].self, forKey: .suggestedQuestions)) ?? []
        if self.summary.isEmpty {
            throw DecodingError.dataCorruptedError(forKey: .summary, in: container, debugDescription: "Summary cannot be empty")
        }
    }
}



================================================
FILE: pdfexpert/Models/Persistence/CacheManager.swift
================================================
//
//  CacheManager.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 22/03/23.
//

import Foundation

protocol CacheManager {
    var onboardingShown: Bool { get set }
    var preReviewShown: Bool { get set }
}



================================================
FILE: pdfexpert/Models/Persistence/CacheManagerImpl.swift
================================================
//
//  CacheManagerImpl.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 22/03/23.
//

import Foundation
import Factory

extension Container {
    var cacheManager: Factory<CacheManager> {
        self { CacheManagerImpl() }.singleton
    }
}

class CacheManagerImpl: CacheManager {
    
    enum CacheManagerKey: String {
        case onboardingShown
        case preReviewShown
    }
    
    private let mainUserDefaults = UserDefaults.standard
    
    var onboardingShown: Bool {
        get { self.getBool(forKey: CacheManagerKey.onboardingShown.rawValue) ?? false }
        set { self.saveBool(newValue, forKey: CacheManagerKey.onboardingShown.rawValue) }
    }
    
    var preReviewShown: Bool {
        get { self.getBool(forKey: CacheManagerKey.preReviewShown.rawValue) ?? false }
        set { self.saveBool(newValue, forKey: CacheManagerKey.preReviewShown.rawValue) }
    }
        
    // MARK: - Private methods
    
    private func save<T>(encodable: T?, forKey key: String) where T: Encodable {
        if let encodable = encodable {
            let encoder = JSONEncoder()
            if let encoded = try? encoder.encode(encodable) {
                self.mainUserDefaults.set(encoded, forKey: key)
            }
        } else {
            self.reset(forKey: key)
        }
    }
    
    private func load<T>(forKey key: String) -> T? where T: Decodable {
        if let encodedData = self.mainUserDefaults.object(forKey: key) as? Data {
            let decoder = JSONDecoder()
            if let object = try? decoder.decode(T.self, from: encodedData) {
                return object
            }
        }
        return nil
    }
    
    private func saveNSSecureCoding<T>(object: T?, forKey key: String) where T: NSSecureCoding {
        if let object = object {
            if let encoded = try? NSKeyedArchiver.archivedData(withRootObject: object, requiringSecureCoding: true) {
                self.mainUserDefaults.set(encoded, forKey: key)
            }
        } else {
            self.reset(forKey: key)
        }
    }
    
    private func loadNSSecureCoding<T>(forKey key: String) -> T? where T: NSSecureCoding & NSObject {
        if let encodedData = self.mainUserDefaults.object(forKey: key) as? Data {
            return try? NSKeyedUnarchiver.unarchivedObject(ofClass: T.self, from: encodedData)
        }
        return nil
    }
    
    private func saveData(_ value: Data?, forKey key: String) {
        if let value = value {
            self.mainUserDefaults.set(value, forKey: key)
        } else {
            self.reset(forKey: key)
        }
    }
    
    private func getData(forKey key: String) -> Data? {
        return self.mainUserDefaults.data(forKey: key)
    }
    
    private func saveString(_ value: String?, forKey key: String) {
        if let value = value {
            self.mainUserDefaults.set(value, forKey: key)
        } else {
            self.reset(forKey: key)
        }
    }
    
    private func getString(forKey key: String) -> String? {
        return self.mainUserDefaults.string(forKey: key)
    }
    
    private func saveInteger(_ value: Int?, forKey key: String) {
        if let value = value {
            self.mainUserDefaults.set(value, forKey: key)
        } else {
            self.reset(forKey: key)
        }
    }
    
    private func getInteger(forKey key: String) -> Int? {
        if self.mainUserDefaults.object(forKey: key) != nil {
            return self.mainUserDefaults.integer(forKey: key)
        } else {
            return nil
        }
    }
    
    private func saveBool(_ value: Bool?, forKey key: String) {
        if let value = value {
            self.mainUserDefaults.set(value, forKey: key)
        } else {
            self.reset(forKey: key)
        }
    }
    
    private func getBool(forKey key: String) -> Bool? {
        if self.mainUserDefaults.object(forKey: key) != nil {
            return self.mainUserDefaults.bool(forKey: key)
        } else {
            return nil
        }
    }
    
    private func reset(forKey key: String) {
        self.mainUserDefaults.removeObject(forKey: key)
    }
}



================================================
FILE: pdfexpert/Models/Persistence/Repository.swift
================================================
//
//  Repository.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 27/03/23.
//

import Foundation

protocol Repository {
    func savePdf(pdf: Pdf) throws -> Pdf
    func getDoPdfExist() throws -> Bool
    func loadPdfs() throws -> [Pdf]
    func delete(pdf: Pdf) throws
    
    func saveSignature(signature: Signature) throws -> Signature
    func getDoSignatureExist() throws -> Bool
    func loadSignatures() throws -> [Signature]
    func delete(signature: Signature) throws
    func delete(signatures: [Signature]) throws
    
    func saveSuggestedFields(suggestedFields: SuggestedFields) throws -> SuggestedFields
    func loadSuggestedFields() throws -> SuggestedFields?
}



================================================
FILE: pdfexpert/Models/Persistence/RepositoryImpl.swift
================================================
//
//  RepositoryImpl.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 27/03/23.
//

import Foundation
import CoreData
import Factory
import CloudKit

private let DiskFullErrorDomain: String = NSSQLiteErrorDomain
private let DiskFullErrorCode: Int = 13

extension Container {
    var repository: Factory<Repository> {
        self { RepositoryImpl() }.singleton
    }
}

class RepositoryImpl: Repository {
    
    @Injected(\.persistence) var persistence
    @Injected(\.analyticsManager) var analyticsMananger
    
    private var sharedManagedContext: NSManagedObjectContext {
        return self.persistence.container.viewContext
    }
    
    // MARK: - PDF
    
    func savePdf(pdf: Pdf) throws -> Pdf {
        let pdf = try self.save(pdf)
        self.analyticsMananger.track(event: .pdfSaved)
        return pdf
    }
    
    func getDoPdfExist() throws -> Bool {
        return try self.getDoExist(forPersistableType: Pdf.self)
    }
    
    func loadPdfs() throws -> [Pdf] {
        return try self.loadItems()
    }
    
    func delete(pdf: Pdf) throws {
        try self.delete(pdf)
        self.analyticsMananger.track(event: .existingPdfRemoved)
    }
    
    // MARK: - Signature
    
    func saveSignature(signature: Signature) throws -> Signature {
        let signature = try self.save(signature)
        self.analyticsMananger.track(event: .signatureFileSaved)
        return signature
    }
    
    func getDoSignatureExist() throws -> Bool {
        return try self.getDoExist(forPersistableType: Signature.self)
    }
    
    func loadSignatures() throws -> [Signature] {
        return try self.loadItems()
    }
    
    func delete(signature: Signature) throws {
        try self.delete(signature)
        self.analyticsMananger.track(event: .signatureFileDeleted)
    }
    
    func delete(signatures: [Signature]) throws {
        for signature in signatures {
            try self.delete(signature: signature)
        }
    }
    
    // MARK: - SuggestedFields
    
    func saveSuggestedFields(suggestedFields: SuggestedFields) throws -> SuggestedFields {
        let suggestedFields = try self.save(suggestedFields)
        self.analyticsMananger.track(event: .suggestedFieldsSaved)
        return suggestedFields
    }
    
    func loadSuggestedFields() throws -> SuggestedFields? {
        return try self.loadItems(sortByCreationDate: false).first
    }
    
    // MARK: - Private Methods
    
    private func save<T: Persistable>(_ persistable: T) throws -> T {
        
        guard let savedOrNewCoreDataEntity = persistable.getSavedOrNewCoreDataEntity(context: self.sharedManagedContext) else {
            throw SaveError.unknownError
        }
        
        try self.saveChanges()
        
        guard let updatedPersistable = T.create(withCoreDataEntity: savedOrNewCoreDataEntity) else {
            throw SaveError.unknownError
        }
        
        return updatedPersistable
    }
    
    private func getDoExist<T: Persistable>(forPersistableType type: T.Type) throws -> Bool {
        return try (self.loadItems() as [T]).count > 0
    }
    
    private func loadItems<T: Persistable>(sortByCreationDate: Bool = true) throws -> [T] {
        let fetchRequest = T.fetchRequest()
        if sortByCreationDate {
            fetchRequest.sortDescriptors = [NSSortDescriptor(key:"creationDate", ascending: false)]
        }
        do {
            return try self.persistence.container.viewContext
                .fetch(fetchRequest)
                .compactMap { coreDataEntity in
                    guard let item = T.create(withCoreDataEntity: coreDataEntity) else {
                        return nil
                    }
                    return item
                }
        } catch {
            debugPrint(for: self, message: "Error while fetching items")
            throw SharedUnderlyingError.convertError(fromError: error)
        }
    }
    
    private func delete<T: Persistable>(_ persistable: T) throws {
        
        guard let storedSignature = persistable.getSavedCoreDataEntity(context: self.sharedManagedContext) else {
            debugPrint(for: self, message: "Current peristable instance doesn't exist in the persistent storage")
            return
        }
        self.persistence.container.viewContext.delete(storedSignature)
        try self.saveChanges()
    }
    
    private func saveChanges() throws {
        guard self.persistence.container.viewContext.hasChanges else {
            return
        }
        
        do {
            try self.persistence.container.viewContext.save()
        } catch let error as NSError {
            debugPrint(for: self, message: "Error while saving the story. Error: \(error.localizedDescription)")
            if error.domain == DiskFullErrorDomain, error.code == DiskFullErrorCode {
                debugPrint(for: self, message: "Memory full error")
                throw SaveError.diskFullError
            } else {
                debugPrint(for: self, message: "Unhandled save error")
                throw SaveError.convertError(fromError: error)
            }
        }
    }
}

enum SaveError: UnderlyingError {
    case unknownError
    case diskFullError
    case underlyingError(errorDescription: String)
    
    static func getUnknownError() -> Self { Self.unknownError }
    
    static func getUnderlyingError(errorDescription: String) -> Self {
        return .underlyingError(errorDescription: errorDescription)
    }
}



================================================
FILE: pdfexpert/Models/Persistence/CoreData/CDPdf.swift
================================================
//
//  CDPdf.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/04/23.
//
//

import Foundation
import CoreData

@objc(CDPdf)
public class CDPdf: NSManagedObject {
    
    func update(withPdf pdf: Pdf, pdfData: Data) {
        self.data = pdfData
        self.creationDate = pdf.creationDate
        self.password = pdf.password
        self.filename = pdf.filename
        self.compression = pdf.compression.rawValue
        self.margins = pdf.margins.rawValue
    }
}

extension CDPdf {
    @NSManaged public var data: Data?
    @NSManaged public var creationDate: Date?
    @NSManaged public var password: String?
    @NSManaged public var filename: String?
    @NSManaged public var compression: Int32
    @NSManaged public var margins: Int32
}



================================================
FILE: pdfexpert/Models/Persistence/CoreData/CDSignature.swift
================================================
//
//  CDSignature.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/08/23.
//

import Foundation
import CoreData

@objc(CDSignature)
public class CDSignature: NSManagedObject {
    
    func update(withSignature signature: Signature, imageData: Data) {
        self.data = imageData
        self.creationDate = signature.creationDate
    }
}

extension CDSignature {
    @NSManaged public var data: Data?
    @NSManaged public var creationDate: Date?
}



================================================
FILE: pdfexpert/Models/Persistence/CoreData/CDSuggestedFields.swift
================================================
//
//  CDSuggestedFields.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 07/09/23.
//

import Foundation
import CoreData

@objc(CDSuggestedFields)
public class CDSuggestedFields: NSManagedObject {
    
    func update(withSuggestedFields suggestedFields: SuggestedFields) {
        self.firstName = suggestedFields.firstName
        self.lastName = suggestedFields.lastName
        self.address = suggestedFields.address
        self.city = suggestedFields.city
        self.country = suggestedFields.country
        self.email = suggestedFields.email
        self.phone = suggestedFields.phone
    }
}

extension CDSuggestedFields {
    @NSManaged public var firstName: String?
    @NSManaged public var lastName: String?
    @NSManaged public var address: String?
    @NSManaged public var city: String?
    @NSManaged public var country: String?
    @NSManaged public var email: String?
    @NSManaged public var phone: String?
}



================================================
FILE: pdfexpert/Models/Persistence/CoreData/Persistence.swift
================================================
//
//  Persistence.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/04/23.
//

import CoreData
import Factory
import CloudKit

private var CloudKitContainerIdentifier: String = "iCloud.pdfexpert"
private var InitializeCloudKitSchema: Bool = false

extension Container {
    var persistence: Factory<PersistenceController> {
        self {
            #if DEBUG
            if K.Test.UseMockDB || isPreview() {
                return PersistenceController.preview
            } else {
                return PersistenceController()
            }
            #else
            PersistenceController()
            #endif
        }.singleton
    }
}

struct TransactionAuthor {
    static let app = "app"
}

class PersistenceController {

    static var preview: PersistenceController = {
        let result = PersistenceController(inMemory: true)
        let viewContext = result.container.viewContext
        for index in 0..<K.Test.NumberOfPdfs {
            _ = K.Test.GetDebugCoreDataPdf(context: viewContext)
        }
        do {
            try viewContext.save()
        } catch {
            // Replace this implementation with code to handle the error appropriately.
            // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
            let nsError = error as NSError
            fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
        }
        return result
    }()

    let container: NSPersistentContainer

    init(inMemory: Bool = false) {
        if inMemory {
            self.container = NSPersistentContainer(name: "AppCoreData")
            self.container.persistentStoreDescriptions.first!.url = URL(fileURLWithPath: "/dev/null")
            self.container.loadPersistentStores(completionHandler: { (storeDescription, error) in
                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            })
            self.container.viewContext.automaticallyMergesChangesFromParent = true
        } else {
            /**
             Prepare the containing folder for the Core Data stores.
             A Core Data store has companion files, so it's a good practice to put a store under a folder.
             */
            let baseURL = NSPersistentContainer.defaultDirectoryURL()
            let storeFolderURL = baseURL.appendingPathComponent("CoreDataStores")
            let privateStoreFolderURL = storeFolderURL.appendingPathComponent("Private")
            
            let fileManager = FileManager.default
            for folderURL in [privateStoreFolderURL] where !fileManager.fileExists(atPath: folderURL.path) {
                do {
                    try fileManager.createDirectory(at: folderURL, withIntermediateDirectories: true, attributes: nil)
                } catch {
                    fatalError("#\(#function): Failed to create the store folder: \(error)")
                }
            }
            
            let cloudKitContainer = NSPersistentCloudKitContainer(name: "AppCoreData")
            self.container = cloudKitContainer
            
            /**
             Grab the default (first) store and associate it with the CloudKit private database.
             Set up the store description by:
             - Specifying a filename for the store.
             - Enabling history tracking and remote notifications.
             - Specifying the iCloud container and database scope.
             */
            guard let privateStoreDescription = self.container.persistentStoreDescriptions.first else {
                fatalError("#\(#function): Failed to retrieve a persistent store description.")
            }
            privateStoreDescription.url = privateStoreFolderURL.appendingPathComponent("private.sqlite")
            
            privateStoreDescription.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
            privateStoreDescription.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
            privateStoreDescription.setOption(true as NSNumber, forKey: NSMigratePersistentStoresAutomaticallyOption)
            privateStoreDescription.setOption(true as NSNumber, forKey: NSInferMappingModelAutomaticallyOption)
            
            let cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: CloudKitContainerIdentifier)
            
            cloudKitContainerOptions.databaseScope = .private
            privateStoreDescription.cloudKitContainerOptions = cloudKitContainerOptions
            
            /**
             Load the persistent stores.
             */
            self.container.loadPersistentStores(completionHandler: { (loadedStoreDescription, error) in
                guard error == nil else {
                    fatalError("#\(#function): Failed to load persistent stores:\(error!)")
                }
                guard let cloudKitContainerOptions = loadedStoreDescription.cloudKitContainerOptions else {
                    return
                }
                if cloudKitContainerOptions.databaseScope == .private {
                    self._privatePersistentStore = self.container.persistentStoreCoordinator.persistentStore(for: loadedStoreDescription.url!)
                }
            })
            
            /**
             Run initializeCloudKitSchema() once to update the CloudKit schema every time you change the Core Data model.
             Don't call this code in the production environment.
             */
            if InitializeCloudKitSchema {
                do {
                    try cloudKitContainer.initializeCloudKitSchema()
                } catch {
                    print("\(#function): initializeCloudKitSchema: \(error)")
                }
            } else {
                self.container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
                self.container.viewContext.transactionAuthor = TransactionAuthor.app
                
                /**
                 Automatically merge the changes from other contexts.
                 */
                self.container.viewContext.automaticallyMergesChangesFromParent = true
                
                /**
                 Pin the viewContext to the current generation token and set it to keep itself up-to-date with local changes.
                 */
                do {
                    try self.container.viewContext.setQueryGenerationFrom(.current)
                } catch {
                    fatalError("#\(#function): Failed to pin viewContext to the current generation:\(error)")
                }
                
                /**
                 Observe the following notifications:
                 - The remote change notifications from container.persistentStoreCoordinator.
                 - The .NSManagedObjectContextDidSave notifications from any context.
                 - The event change notifications from the container.
                 */
                NotificationCenter.default.addObserver(self, selector: #selector(self.storeRemoteChange(_:)),
                                                       name: .NSPersistentStoreRemoteChange,
                                                       object: self.container.persistentStoreCoordinator)
                NotificationCenter.default.addObserver(self, selector: #selector(self.containerEventChanged(_:)),
                                                       name: NSPersistentCloudKitContainer.eventChangedNotification,
                                                       object: self.container)
            }
        }
    }
    
    private var _privatePersistentStore: NSPersistentStore?
    var privatePersistentStore: NSPersistentStore {
        return _privatePersistentStore!
    }
    
    lazy var cloudKitContainer: CKContainer = {
        return CKContainer(identifier: CloudKitContainerIdentifier)
    }()
        
    /**
     An operation queue for handling history-processing tasks: watching changes, deduplicating tags, and triggering UI updates, if needed.
     */
    lazy var historyQueue: OperationQueue = {
        let queue = OperationQueue()
        queue.maxConcurrentOperationCount = 1
        return queue
    }()
}

extension PersistenceController {
    /**
     Handle .NSPersistentStoreRemoteChange notifications.
     Process persistent history to merge relevant changes to the context, and deduplicate the tags, if necessary.
     */
    @objc
    func storeRemoteChange(_ notification: Notification) {
        guard let storeUUID = notification.userInfo?[NSStoreUUIDKey] as? String,
              [privatePersistentStore.identifier].contains(storeUUID) else {
            print("\(#function): Ignore a store remote Change notification because of no valid storeUUID.")
            return
        }
//        processHistoryAsynchronously(storeUUID: storeUUID)
    }

    /**
     Handle the container's event change notifications (NSPersistentCloudKitContainer.eventChangedNotification).
     */
    @objc
    func containerEventChanged(_ notification: Notification) {
         guard let value = notification.userInfo?[NSPersistentCloudKitContainer.eventNotificationUserInfoKey],
              let event = value as? NSPersistentCloudKitContainer.Event else {
            print("\(#function): Failed to retrieve the container event from notification.userInfo.")
            return
        }
        if event.error != nil {
            print("\(#function): Received a persistent CloudKit container event changed notification.\n\(event)")
        }
    }
}



================================================
FILE: pdfexpert/Models/Persistence/CoreData/Persistable/Pdf+Persistable.swift
================================================
//
//  Pdf+Persistable.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/08/23.
//

import Foundation
import CoreData
import PDFKit

extension Pdf: Persistable {
    
    typealias CDEntity = CDPdf
    
    func getSavedOrNewCoreDataEntity(context: NSManagedObjectContext) -> CDEntity? {
        
        guard let pdfData = self.rawData else {
            debugPrint(for: self, message: "Cannot get pdf raw data for given Pdf instance")
            return nil
        }
        
        let result: CDPdf = self.getSavedCoreDataEntity(context: context) ?? CDPdf(context: context)
        result.update(withPdf: self, pdfData: pdfData)
        return result
    }
    
    static func create(withCoreDataEntity coreDataEntity: some CDEntity) -> Self? {
        
        guard let pdfData = coreDataEntity.data, let pdfDocument = PDFDocument(data: pdfData) else {
            debugPrint(for: self, message: "Cannot get pdf document for given CDPdf instance")
            return nil
        }
        return Pdf(storeId: coreDataEntity.objectID,
                   pdfDocument: pdfDocument,
                   password: coreDataEntity.password,
                   creationDate: coreDataEntity.creationDate,
                   fileName: coreDataEntity.filename,
                   compression: CompressionOption(rawValue: coreDataEntity.compression) ?? K.Misc.PdfDefaultCompression,
                   margins: MarginsOption(rawValue: coreDataEntity.margins) ?? K.Misc.PdfDefaultMarginsOption)
    }
    
    static func fetchRequest() -> NSFetchRequest<CDPdf> {
        return NSFetchRequest<CDPdf>(entityName: "Pdf")
    }
}



================================================
FILE: pdfexpert/Models/Persistence/CoreData/Persistable/Persistable.swift
================================================
//
//  Persistable.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/08/23.
//

import Foundation
import CoreData

protocol Persistable {
    
    associatedtype CDEntity: NSManagedObject
    
    var storeId: NSManagedObjectID? { get }
    
    static func create(withCoreDataEntity coreDataEntity: CDEntity) -> Self?
    static func fetchRequest() -> NSFetchRequest<CDEntity>
    
    func getSavedOrNewCoreDataEntity(context: NSManagedObjectContext) -> CDEntity?
}

extension Persistable {
    func getSavedCoreDataEntity(context: NSManagedObjectContext) -> CDEntity? {
        if let objectId = self.storeId {
            return (try? context.existingObject(with: objectId)) as? CDEntity
        } else {
            return nil
        }
    }
}



================================================
FILE: pdfexpert/Models/Persistence/CoreData/Persistable/Signature+Persistable.swift
================================================
//
//  Signature+Persistable.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/08/23.
//

import Foundation
import CoreData

extension Signature: Persistable {
    
    typealias CDEntity = CDSignature
    
    func getSavedOrNewCoreDataEntity(context: NSManagedObjectContext) -> CDEntity? {
        
        guard let signatureData = self.rawData else {
            debugPrint(for: self, message: "Cannot get signature raw data for given Signature instance")
            return nil
        }
        
        let result: CDSignature = self.getSavedCoreDataEntity(context: context) ?? CDSignature(context: context)
        result.update(withSignature: self, imageData: signatureData)
        return result
    }
    
    static func create(withCoreDataEntity coreDataEntity: some CDEntity) -> Self? {
        
        guard let signatureData = coreDataEntity.data else {
            debugPrint(for: self, message: "Cannot get signature data for given CDSignature instance")
            return nil
        }
        let signature = Signature(storeId: coreDataEntity.objectID,
                                  creationDate: coreDataEntity.creationDate,
                                  data: signatureData
        )
        guard let signature else {
            debugPrint(for: self, message: "Cannot get signature drawing for given signature data")
            return nil
        }
        return signature
    }
    
    static func fetchRequest() -> NSFetchRequest<CDSignature> {
        return NSFetchRequest<CDSignature>(entityName: "Signature")
    }
}



================================================
FILE: pdfexpert/Models/Persistence/CoreData/Persistable/SuggestedFields+Persistable.swift
================================================
//
//  SuggestedFields+Persistable.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 07/09/23.
//

import Foundation
import CoreData

extension SuggestedFields: Persistable {
    
    typealias CDEntity = CDSuggestedFields
    
    func getSavedOrNewCoreDataEntity(context: NSManagedObjectContext) -> CDEntity? {
        let result: CDEntity = self.getSavedCoreDataEntity(context: context) ?? CDEntity(context: context)
        result.update(withSuggestedFields: self)
        return result
    }
    
    static func create(withCoreDataEntity coreDataEntity: some CDEntity) -> Self? {
        
        return SuggestedFields(
            storeId: coreDataEntity.objectID,
            firstName: coreDataEntity.firstName,
            lastName: coreDataEntity.lastName,
            address: coreDataEntity.address,
            city: coreDataEntity.city,
            country: coreDataEntity.country,
            email: coreDataEntity.email,
            phone: coreDataEntity.phone
        )
    }
    
    static func fetchRequest() -> NSFetchRequest<CDEntity> {
        return NSFetchRequest<CDEntity>(entityName: "SuggestedFields")
    }
}



================================================
FILE: pdfexpert/Preview Content/Preview Assets.xcassets/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/InfoTemplate.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleURLTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>None</string>
			<key>CFBundleURLSchemes</key>
			<array>
				<string>fb1171568467580217</string>
			</array>
		</dict>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLName</key>
			<string>com.pcnaid.pdfexpert</string>
			<key>CFBundleURLSchemes</key>
			<array>
				<string>pdfpro</string>
			</array>
		</dict>
	</array>
	<key>FacebookAdvertiserIDCollectionEnabled</key>
	<true/>
	<key>FacebookAppID</key>
	<string>1171568467580217</string>
	<key>FacebookAutoLogAppEventsEnabled</key>
	<true/>
	<key>FacebookClientToken</key>
	<string>5cd9d790a2afc06ff086a69e67823a55</string>
	<key>FacebookDisplayName</key>
	<string>AtlasPDF</string>
	<key>ITSAppUsesNonExemptEncryption</key>
	<false/>
	<key>UIAppFonts</key>
	<array>
		<string>Montserrat-ExtraBold.ttf</string>
		<string>Montserrat-Medium.ttf</string>
		<string>Montserrat-Regular.ttf</string>
		<string>Montserrat-Bold.ttf</string>
	</array>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
	</dict>
	<key>UIBackgroundModes</key>
	<array>
		<string>remote-notification</string>
	</array>
	<key>UIViewControllerBasedStatusBarAppearance</key>
	<false/>
</dict>
</plist>



================================================
FILE: pdfexpert/Resources/.DS_Store
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Animations/loading.json
================================================
{"v":"5.7.8","fr":29.9700012207031,"ip":0,"op":30.0000012219251,"w":500,"h":500,"nm":"Loading","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Shape Layer 4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":13,"s":[546,266,0],"to":[0,-11,0],"ti":[0,0,0]},{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":17,"s":[546,200,0],"to":[0,0,0],"ti":[0,-11,0]},{"t":21.0000008553475,"s":[546,266,0]}],"ix":2,"l":2,"x":"var $bm_rt;\nvar $bm_rt;\nvar n, n, t, t, v, amp, freq, decay;\n$bm_rt = $bm_rt = n = 0;\nif (numKeys > 0) {\n    $bm_rt = $bm_rt = n = nearestKey(time).index;\n    if (key(n).time > time) {\n        n--;\n    }\n}\nif (n == 0) {\n    $bm_rt = $bm_rt = t = 0;\n} else {\n    $bm_rt = $bm_rt = t = sub(time, key(n).time);\n}\nif (n > 0 && t < 1) {\n    v = velocityAtTime(sub(key(n).time, div(thisComp.frameDuration, 10)));\n    amp = 0.05;\n    freq = 4;\n    decay = 8;\n    $bm_rt = $bm_rt = add(value, div(mul(mul(v, amp), Math.sin(mul(mul(mul(freq, t), 2), Math.PI))), Math.exp(mul(decay, t))));\n} else {\n    $bm_rt = $bm_rt = value;\n}"},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[45.137,45.137],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[1,0.7490196078431373,0.24705882352941178,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":8,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.7490196078431373,0.24705882352941178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-167.432,-17.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":30.0000012219251,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"Shape Layer 3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":9,"s":[454,266,0],"to":[0,-11,0],"ti":[0,0,0]},{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":13,"s":[454,200,0],"to":[0,0,0],"ti":[0,-11,0]},{"t":17.0000006924242,"s":[454,266,0]}],"ix":2,"l":2,"x":"var $bm_rt;\nvar $bm_rt;\nvar n, n, t, t, v, amp, freq, decay;\n$bm_rt = $bm_rt = n = 0;\nif (numKeys > 0) {\n    $bm_rt = $bm_rt = n = nearestKey(time).index;\n    if (key(n).time > time) {\n        n--;\n    }\n}\nif (n == 0) {\n    $bm_rt = $bm_rt = t = 0;\n} else {\n    $bm_rt = $bm_rt = t = sub(time, key(n).time);\n}\nif (n > 0 && t < 1) {\n    v = velocityAtTime(sub(key(n).time, div(thisComp.frameDuration, 10)));\n    amp = 0.05;\n    freq = 4;\n    decay = 8;\n    $bm_rt = $bm_rt = add(value, div(mul(mul(v, amp), Math.sin(mul(mul(mul(freq, t), 2), Math.PI))), Math.exp(mul(decay, t))));\n} else {\n    $bm_rt = $bm_rt = value;\n}"},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[45.137,45.137],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[0.3568627450980392,0.7607843137254902,0.9058823529411765,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":8,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.3568627450980392,0.7607843137254902,0.9058823529411765,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-167.432,-17.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":30.0000012219251,"st":-359.00001462237,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"Shape Layer 2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":4,"s":[365,266,0],"to":[0,-11,0],"ti":[0,0,0]},{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":9,"s":[365,200,0],"to":[0,0,0],"ti":[0,-11,0]},{"t":13.0000005295009,"s":[365,266,0]}],"ix":2,"l":2,"x":"var $bm_rt;\nvar $bm_rt;\nvar n, n, t, t, v, amp, freq, decay;\n$bm_rt = $bm_rt = n = 0;\nif (numKeys > 0) {\n    $bm_rt = $bm_rt = n = nearestKey(time).index;\n    if (key(n).time > time) {\n        n--;\n    }\n}\nif (n == 0) {\n    $bm_rt = $bm_rt = t = 0;\n} else {\n    $bm_rt = $bm_rt = t = sub(time, key(n).time);\n}\nif (n > 0 && t < 1) {\n    v = velocityAtTime(sub(key(n).time, div(thisComp.frameDuration, 10)));\n    amp = 0.05;\n    freq = 4;\n    decay = 8;\n    $bm_rt = $bm_rt = add(value, div(mul(mul(v, amp), Math.sin(mul(mul(mul(freq, t), 2), Math.PI))), Math.exp(mul(decay, t))));\n} else {\n    $bm_rt = $bm_rt = value;\n}"},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[45.137,45.137],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[0,0.7019607843137254,0.5333333333333333,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":8,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.7019607843137254,0.5333333333333333,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-167.432,-17.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":30.0000012219251,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":4,"nm":"Shape Layer 1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":0,"s":[277,266,0],"to":[0,-11,0],"ti":[0,0,0]},{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":4,"s":[277,200,0],"to":[0,0,0],"ti":[0,-11,0]},{"t":9.00000036657752,"s":[277,266,0]}],"ix":2,"l":2,"x":"var $bm_rt;\nvar $bm_rt;\nvar n, n, t, t, v, amp, freq, decay;\n$bm_rt = $bm_rt = n = 0;\nif (numKeys > 0) {\n    $bm_rt = $bm_rt = n = nearestKey(time).index;\n    if (key(n).time > time) {\n        n--;\n    }\n}\nif (n == 0) {\n    $bm_rt = $bm_rt = t = 0;\n} else {\n    $bm_rt = $bm_rt = t = sub(time, key(n).time);\n}\nif (n > 0 && t < 1) {\n    v = velocityAtTime(sub(key(n).time, div(thisComp.frameDuration, 10)));\n    amp = 0.05;\n    freq = 4;\n    decay = 8;\n    $bm_rt = $bm_rt = add(value, div(mul(mul(v, amp), Math.sin(mul(mul(mul(freq, t), 2), Math.PI))), Math.exp(mul(decay, t))));\n} else {\n    $bm_rt = $bm_rt = value;\n}"},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[45.137,45.137],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[0.06274509803921569,0.023529411764705882,0.6235294117647059,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":8,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.06274509803921569,0.023529411764705882,0.6235294117647059,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-167.432,-17.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":30.0000012219251,"st":0,"bm":0}],"markers":[]}


================================================
FILE: pdfexpert/Resources/Animations/pdf-scanning.json
================================================
{"nm":"pdf_scanning","mn":"","layers":[{"ty":4,"nm":"scanning","mn":"","sr":1,"st":-793.000032299552,"op":107.000004358199,"ip":-793.000032299552,"hd":false,"cl":"","ln":"","ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[93,93,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":1,"k":[{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[180.282,513.787,0],"t":0},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[180.282,93.787,0],"t":46},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[180.282,513.787,0],"t":99.0000040323527}],"ix":2},"sa":{"a":0,"k":0},"o":{"a":0,"k":38,"ix":11},"r":{"a":0,"k":0,"ix":10}},"ef":[],"shapes":[{"ty":"gr","bm":0,"cl":"","ln":"","hd":false,"mn":"ADBE Vector Group","nm":"Rectangle 1","ix":1,"cix":2,"np":3,"it":[{"ty":"rc","bm":0,"cl":"","ln":"","hd":false,"mn":"ADBE Vector Shape - Rect","nm":"Rectangle Path 1","d":1,"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"s":{"a":0,"k":[292,60],"ix":2}},{"ty":"st","bm":0,"cl":"","ln":"","hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":1,"lj":1,"ml":4,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"d":[],"c":{"a":0,"k":[0.2157,0.2627,0.6078],"ix":3}},{"ty":"fl","bm":0,"cl":"","ln":"","hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[1,0.7647,0.7647],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[122.837,53.333],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,-143],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]}],"ind":1},{"ty":2,"nm":"pdf_corner","mn":"","sr":1,"st":-781.000031810782,"op":106.000004317469,"ip":-781.000031810782,"hd":false,"cl":"","ln":"","ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[51.25,51.25,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":0,"k":[269.731,73.454,0],"ix":2},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10}},"ef":[],"refId":"image_0","ind":2},{"ty":2,"nm":"pdf_text","mn":"","sr":1,"st":-781.000031810782,"op":106.000004317469,"ip":-781.000031810782,"hd":false,"cl":"","ln":"","ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[80.824,28.018,0],"ix":1},"s":{"a":1,"k":[{"o":{"x":0.167,"y":0.167},"i":{"x":0.667,"y":1},"s":[25,25,100],"t":-20},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[117,117,100],"t":34.0000013848484}],"ix":6},"sk":{"a":0,"k":0},"p":{"a":0,"k":[187.968,212.08,0],"ix":2},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10}},"ef":[],"refId":"image_1","ind":3},{"ty":2,"nm":"pdf_line","mn":"","sr":1,"st":-781.000031810782,"op":106.000004317469,"ip":-781.000031810782,"hd":false,"cl":"","ln":"","ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[63,66,0],"ix":1},"s":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[25,25,100],"t":0},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[117,117,100],"t":54.0000021994651}],"ix":6},"sk":{"a":0,"k":0},"p":{"a":0,"k":[184.731,215.454,0],"ix":2},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10}},"ef":[],"refId":"image_2","ind":4},{"ty":2,"nm":"pdf_bg","mn":"","sr":1,"st":-781.000031810782,"op":106.000004317469,"ip":-781.000031810782,"hd":false,"cl":"","ln":"","ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[136.25,154.25,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":0,"k":[184.73,176.454,0],"ix":2},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10}},"ef":[],"refId":"image_3","ind":5}],"ddd":0,"h":360,"w":360,"meta":{"a":"akhtarzaman","k":"pdf scan scannning docs documents","d":"pdf_scanning_lottie_animation_create_by_akhtarzaman","g":"LottieFiles AE 3.1.1","tc":"#000000"},"v":"4.8.0","fr":29.9700012207031,"op":102.000004154545,"ip":0,"assets":[{"id":"image_0","u":"","e":1,"w":103,"h":103,"p":"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGcAAABnCAYAAAAdQVz5AAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAAEdUlEQVR4nO2bW2rkRhSG\/1Mkb4HMDjKPA77EZvBgP8QtEyZMCAkOSZ6rF5A9xEsYyAbUO0hW0Hbb2IwxHpswzOtkB5NnY5082Jq+6dKSSqpS1fnMb9xNI5f0ceocCRo3e7\/9DsFJFMB\/3u79GtteiLCMAgAGtAhyDwUwAAaD9e3eL7HtBQlTFDOQJmHot7siyBVUxnsiyBGy5AAiyAk+9ZyM6Le7P8cW1xY8eZXzCIkgi5TIAUSQPVTupjYX0tciqHMUZmfpwkAEdcwK29oMIqhTqskBRFCHVJcDiKCOqCcHEEEdUHQTWh5mfb17GFtYdxCsOEoXhCGCWkI1M\/MQTqCvX4gg09TvOQswRJBpmvWchTBYBBnEWOWkiCBzGJcDiCBTNJ\/WcpKA9ZUIaoTRnpOhSF+9+Cnu7nT8wsgoXRJ9tSOC6tBKz8lABNWgKzmACKpMl3IAEVQJxej8R1\/u\/BjbPvE+0HXlAAAIEEEr0MW0lhliEVSGlcpJEUHFtHwTWh5i6UF5WK2cFBGUjRNyABGURWsPPusEImgO6z1nKZzoy50f4nZPux9YG6ULk0BfPhdBzvScDIIX5LIcIHBB7vWc5ejL59\/HrV0Bh3FqWssP6TcBCnJ9W5shPEE9kgOEJqjCN9tcCfSb7TAE9axyHqEwBPVTDhCEoP7KAbwX1JNRuiAEfeGpoD7chJaGiPXF9qvY+NWxTL+3tRmI4J0gN59K1wzBL0HeVE6KT4K86DlLPQh+9KD+T2s5gQeCvNvW5um3IM\/lAH0W5GXPWU6iL7a\/i01dtK7wapQuib7Y6pegALa1OXolyNtprSD6vCeCQquclF4ICmQgyIw+33oZN7+E7RFq5aQ4LSikaS0v+nzzZdz0QrZB6JXzALkpKOSeMx9i5wSFOErnxzFBsq0t4JIgkZOBK4Kk5+SEKdHnm9\/GTS5uU2SULggDVgXJtlaCTUEyra2QBNBnFgRJz1k9+mzzIK55nWsh21olqFNBIqcy3QkSObXoRlAPv9nmSqDPNtoVpED4t81\/4DmtClLM+GB9Dup39KQlQdJzDEAtCVIEfDR90BBpQ5Bi4hvrG4MnIbCebERxVQl5KCQ4NnUwIa0gM4IIAE7XIzZxMGEKE0b7\/xwPmxxDAQAz\/ra\/KfgVcPMKUo+\/\/7J\/Oh6Gm\/UgSv+YrA8+APiq7oGEAohqbXHT+xyiI4PLEWapWUE0+0Kqp2UqVtDcEwICDa3v0z6HEz3Z2I\/LpEx9LHCyvn8Exh+rHkCoxWjwbjIs+9CSHAA4Wds\/BjAwvCBhnlJBmQ8+k8\/VIYNuW1mSkKJP1oq3uMzKAYDxVvSE7viYwF8bX5YwS24F5coBHgSpu\/vXAHQbqxI+MRq8Ox0uvlkoJ2Wy9s2QgdcAvjS8KGHKkqCV5ADA+Fn0VNH9EUiqqDUYo8H702H6cmU5KeNn0VPQ\/REpHIKlkkzDjNHBo6DKclLGW9ET3N0fIkFExBHkyYIxmGl08P50WFvOIuMo+gwf8YWp44VOdHP83\/8408U0NPbpmQAAAABJRU5ErkJggg=="},{"id":"image_1","u":"","e":1,"w":162,"h":57,"p":"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKIAAAA5CAYAAAC1U\/CbAAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAAFJ0lEQVR4nO2d7XHjNhCGn\/Xkv92BdRXYHRxdgZUKzFRwTgWn60DpQKogUgd0BSdXELmCSBVsfgCylRsJoG3hQwSeGc1YQ4hYmi+BxWIBCoCqjoApcEU41vbTASsR2QSs6yiqOgYeA5x6A6ww17gSkVWAOk6Cvd8TYJTQjA0wFZEOMEap6kbjs1LVif2nRMHWF4uNqs5UtY11fX2wNuXEDEDsHw9J\/zuwBCYhWxFVvQL+DXV+D1tghmkB1olsQFVvgZ+p6nfw5QK4TW0FcA\/8VNWpFUwIUl7nJfAN+EdNqxzSBXLRJKrXx\/gCuEltxR7fgJV9cofKd8w1jhPUneoB8NFdpLbgANdAN3AxXgN\/B+4BzoUnEVnlKEQwXdnQxQimB+gKFeMW+AtoAX7zFJ5jnOzPcIXxz0YYH+W65+92YhxFCvXcvYYSemDFs3tQ9q\/vva7ODbarTh3yERFJVrlnaD0JUN\/IOux9Q0azE9XbeOppTlTPlaq2qtr1vL4dGw0cylJP+Cpk3T6id80ishaRCaYFmff4yUPoG3RKRGQjIjMRaYAvmNBUHy6BhZbZTccX4g57w1rgjx7FJ2GtCYN96MbAHfDc4yc3fN4VOkuSD1ZEZIZxWl2Mz7mlsL5nQ78e4F5VQ0xBZk1yIQKIyCPw4ihySb7B2F68twc4J3fkFGQhRMvEc7yJYENwbA\/gE+MlZ+qOfJRshGhv0NZRZDAxxZ7uyFkN0j5LNkK0dI5jgxEivLojT55ikwimZEFuQnQFdC+jWRGP1nO8mFYxNyEWhU0J++EpliI5IjpViOmZ4vaN20h2JKUKMTF2Hn3hKHJTQvecmxAbxzFXnPHcmXqOD757zkaI9qn\/6iiyjmNJfGzWjetBG1TE4BDZCBG\/L9RFsCElneNYFWIM1CTAfvcUc\/lRQ2DtOJbTco4g+BJjg2OTGWaeYi+pk0Yj0OF4GNUkCK9DGqCqXcjzYx626aF7mVSIVoQd\/ife58yXwIjwfrLLRz\/V+R9UdWnT415J1jWrWXi+xi\/C3ZrgQfOeZQoD4P7XjPhoLaK+rfEYYwYmfafs2lTbk1SC0rI3QPMJsdGPr1sZ8ba3yoj+i6b2mYvI0AcppbLe\/+IT4lfC+w3HeCbMZklZcs4Z6B9ktv8li\/DNAZZAU1iXPPhYoeUZ+P3XCEDy8M0BfthVfqXhaxFjhK\/uAp9\/cywMl5MQn4DHAuKFx3C2iDF6h5Qj9xyEuGR\/w8ZyaRzHfJncZ08KIb5ghu0dsCjMD3ThGhQOvpfwCfGJzycbrO2ntKBtb9S\/RV0Xw46U+ITYFTpwiI0vTNXFMCIluYZviqFHHuayBPelCjE9voSOImaWqhATYn3De0eRrV2MP3iqEBPRMw+zmPS3KsR0dLgzkLZUIVZComYXXG8ycAmDlB05zKwUg+2OF\/gzmp5LC5vVFjESdoHYin5pdW1Ya\/KjCjEwdnP3CebVY32Sg\/8sMfGjds2BsN3wo\/30XRYxF5FiBij7VCGeEDtL0mDW5bjig4eY262Ni6QK8Y32g+9aGdnPLR\/fw7FoEUIV4j6pXhVcakb6\/6hCTMcWs1S2iLlkH3XUnIYlMKoifOOCfm9EqpyGJ8zLJ8clzZr04QL3fiquY2eFzQ53bREckjlGgE3iLHVXC5x2I1RVvdXDbwodXFDVca2nZqXmpeDZvbpNVRdHbE66K61Y424x7\/RogN2ezpMhdh9qYn1j\/OuI38MGM313dN1uTqgJU7WYSEFdRVmp7PgPOGNrjeW0wuYAAAAASUVORK5CYII="},{"id":"image_2","u":"","e":1,"w":126,"h":132,"p":"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH4AAACECAYAAABWKp\/3AAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAAA3klEQVR4nO3bsQ2AQAwEQZ6ILui\/SlPDRy+0MxVY2vS8Zua9yLlPH8AZwkcJHyV8lPBRwkcJHyV8lPBRwkcJDwAAAAAAAAAAsG35lm2yuYsSPkr4KOGjhI8SPkr4KOGjhI8SPkp4AAAAAAAAAACAbb5lo2zuooSPEj5K+Cjho4SPEj5K+Cjho4SPEh4AAAAAAAAAAGCbb9kom7so4aOEjxI+Svgo4aOEjxI+Svgo4aOEj1oz85w+AgAAAAAAAAAAfsu3bJTNXZTwUcJHCR8lfJTwUcJHCR8lfJTwUcJHfTZ1Ewb25QZeAAAAAElFTkSuQmCC"},{"id":"image_3","u":"","e":1,"w":273,"h":309,"p":"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAREAAAE1CAYAAADAqdSuAAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAAJN0lEQVR4nO3dPY9c5RXA8fNc32ArQsJpLKhwQeqhTBfnG2yTKB1LRxc3SBbVTZq0rhBSClwiuXG+wfobsHWKhAo6jORi1569T4pdv6zZ13tm5s6d+f2kI7BlL4+E9NeZt2dKJNUvuw\/jRnwa0XwSpf999ufBOZ7Hzfhn6brnYx+E08qQv1QfdHcjyv0osRMRHy\/2SHCu\/bhZ75Wuezb2QXjjWhGpD7q7UUoXEZ8t5zhwKSFZM1eKSO2623FQuijxt2UfCK5ASNbIpRGpX3WfRi2PImK2\/OPAlQnJmrgwIvXBP3Yj6sOI+GA1x4Fr2Y9bQjK2cyNSH3S7EfHt6o4Cg+zHrRCSEZ0Zkfqg260CwnTsFyEZza8iUr\/qPq197IWHMEyLkIzkVERq192uB\/F9eO8H0yQkI2je\/kV\/EF0ICNM1qwexV7vu9tgH2SavN5H6oLtbI\/475mFgQWwkK\/R6E+kjuhHPAYtkI1mhEnGyhVRbCBtnvxzGvfLQRrJMTUREH7E78jlgGWb1ZuzV+zaSZWoiIoqIsLmEZMlK\/bL7sDbx49gHgSXz0GZJmuMLhWDj2UiWpIk+PomoYcwWjJAsQdM31ZWGbBEhWbTm8j8Cm0ZIFqmJWIMl05iVT531QrIQTfQx9v9NY0aaOuvfE5IsD2fYckKSJSIgJCkiAhEhJMOJCLwmJEOICJwiJNclIvArQnIdIgJnEpKraiMiotaRjwHrqM76Nvbq\/c6nfy9gE4GLlJj1bW8juYCIwGWE5EIiAlchJOdqfHTGmCuOkJzJJgLXICS\/JiJwTUJymojAAELyhojAQEJyzKVExiSmhpDYRCBp20MiIrAA2xySJjyeMWYhU6PO+vZo60JiE4EFqhFbFxIRgQXbtpCICCzBNoVERGBJtiUkbfQRtYx9DNhMNWLW3zja6IuNbCKwfLP5jc3dSEQEVmNjQyIisDobGRIRgdXauJCICKzeRoVERGAcGxOSk4iM\/7kDY7ZwZvMb88mHxCYC45p8SEQExjfpkBxHZPStzpitn9m8mWZIbCKwPiYZEhGB9TK5kIgIrJ9JhaQZ\/6GgMeaMmb2cSEhsIrC+JhESEYH1tvYhERFYf2sdkjZqP\/YZgMvNXpaXa3lDmk0EpuNVSNZqIxERmJa1C4mIwPSsVUhEBKZpbUIiIjBdaxESEYFpGz0kIgLTN2pIRAQ2w2ghaSMial31fxZYgtmLWP0b0mwisFlehWRlG4mIwOZZaUiaiD5GvznBGLPoWVlIbCKwsVYTEhGBjbb8kIgIbLzlhkREYCssLySN51WN2ZZZTkhsIrBNlhASEYFts+CQiAhsowWGRERgWy0oJCIC22wBIWm8OGPMlk+ts8NESGwiQEQiJCcRGb2Fxpixp\/azwzi8dkiOI7IG5zfGrMH0MTvsrxcSD2eAd10rJCICnOXKIRER4DxXComIABe5NCQiAlzmwpCICHAV54ZERICrOjMkLiUyxlxnZodHp0NiEwGu61RIRAQY4jgku92tto8aZezjAFM0O3j\/4A82ESBFRIAUEQFSRARIEREgpY0+wsszwFA2ESBFRIAUEQFSRARIEREgpT3+Rx33FMBEleOISAgwRIlXm4iKAEMUz4kASSICpIgIkCIiQIqIACkiAqSICJAiIkBKG7Uf+wzAVJViEwFyRARIaV2xCgx1FDYRIElEgBQRAVJEBEhxKREw3NwmAiSJCJAiIkCKr4wAEuY2ESBHRIAUEQFS2ug9IwIMZxMBUkQESBERIEVEgBQRAVJEBEgRESCljfC9M8BwLiUChisezgBJIgKkiAiQIiJASus5VSDDJgKkiAiQIiJAiogAKa13vQODldefnSljHwWYpOLhDJAjIkCKiAApIgKkiAiQIiJAyvHXaHqFFxigzG0iQJKIACkiAqSICJBy\/JURvjMCGMRnZ4AkEQFSfAMekGITAVJEBEgRESBFRICU1j3NwFBHYRMBkkQESBERIKWNvvraGWCYMreJADkiAqSICJAiIkCKiAApIgKkiAiQ4lIiYLhiEwGS2j68YRUYzldGACkezgApIgKkiAiQIiJAiogAKa0XZoDB5jYRIElEgBQRAVJEBEgRESCljei9QAMMVGwiQI5LiYAUmwiQIiJAiogAKSICpIgIkCIiQIqIACkiAqS00Y99BGCyiu+dAVKKb8ADhivhOREgSUSAFBEBUkQESBERIOX4fSJengGGKDYRIElEgBQRAVJEBEhpwyfwgMHmNhEgR0SAFBEBUtqIiOo6EWCAo7lNBEgSESBFRIAUEQFSRARIEREgRUSAlDb6PqK4lQgYxiYCpIgIkCIiQIqIACmtz94BGTYRIEVEgBQRAVLaiIjwxAgwhG\/AA7KONxGrCDBIsYkAOSICpIgIkCIiQIqIACkiAqS0Ub3ACwzkzWZAlogAKSICpIgIkNJ6WhUYzmdngCQRAVJEBEhxsxkw3NwmAiSJCJAiIkCKiAApbT\/2CYDJKmETAZJEBEhpo4\/wRhFgmLlNBMgRESBFRIAUEQFSRARIEREgRUSAwWrTPBMRYLCjvn92\/GazMvZRgEkqx7e9P\/d+VWCIG0fNQRNN+c\/YBwGm6c7jr39q4yi+j8YuAlxPLfE0IqK58\/jr78c+DDA9JWIv4s1LvP8e7yjAFJWj5knESURKiSfjHgeYmP1Xj2KaiIg7333zKCJ+GPNEwHSUEg9f\/Xv7+jf76GqJb8c5EjAZJX44WTwi4q23vd95\/M2jKLYR4GKlj+7tX59623tfYneVhwGmpUY8vfP4zRYS8U5EPvrum72I+PsKzwRMxy83X9zaefc3z\/zUzE9\/+WKvRPxx+WcCpqJv4k8ni8YpZ36K96Q2+8s+FDANpcbnZwUk4oLP7\/68c\/\/24XsHexExW9K5gAmoNT7\/6J3nQd524SUAP+\/s3n7x3q2HNepnCz8ZsO5+qU3ZOW8DeeVKN4n8+OcvdkupDyPig0WcDFh35enNFwc7v3vy6Nmlf\/KqP\/LHv35xt5lHV4utBDZX\/aFG01308OVd177T7K2Y7ITNBDbFfo3y8DrxeGXwxYg\/7+zePvjNrZ2mxr1a+nsR5eOhPwsYQ3laS+zdqEdP7jz+1+ArQRZ2u2q917XPbv\/v\/UX9PGA5Xv7mt\/M7j79+vqif93\/qH3DNcSPSsgAAAABJRU5ErkJggg=="}]}


================================================
FILE: pdfexpert/Resources/AppCoreData.xcdatamodeld/.xccurrentversion
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>_XCCurrentVersionName</key>
	<string>PdfExpert.xcdatamodel</string>
</dict>
</plist>



================================================
FILE: pdfexpert/Resources/AppCoreData.xcdatamodeld/PdfExpert.xcdatamodel/contents
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<model type="com.apple.IDECoreDataModeler.DataModel" documentVersion="1.0" lastSavedToolsVersion="21754" systemVersion="22A380" minimumToolsVersion="Automatic" sourceLanguage="Swift" usedWithCloudKit="YES" userDefinedModelVersionIdentifier="">
    <entity name="Pdf" representedClassName="CDPdf" syncable="YES">
        <attribute name="compression" optional="YES" attributeType="Integer 32" defaultValueString="0" usesScalarValueType="YES"/>
        <attribute name="creationDate" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="data" optional="YES" attributeType="Binary"/>
        <attribute name="filename" optional="YES" attributeType="String"/>
        <attribute name="margins" optional="YES" attributeType="Integer 32" defaultValueString="0" usesScalarValueType="YES"/>
        <attribute name="password" optional="YES" attributeType="String"/>
    </entity>
    <entity name="Signature" representedClassName="CDSignature" syncable="YES">
        <attribute name="creationDate" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="data" optional="YES" attributeType="Binary"/>
    </entity>
    <entity name="SuggestedFields" representedClassName="CDSuggestedFields" syncable="YES">
        <attribute name="address" optional="YES" attributeType="String"/>
        <attribute name="city" optional="YES" attributeType="String"/>
        <attribute name="country" optional="YES" attributeType="String"/>
        <attribute name="email" optional="YES" attributeType="String"/>
        <attribute name="firstName" optional="YES" attributeType="String"/>
        <attribute name="lastName" optional="YES" attributeType="String"/>
        <attribute name="phone" optional="YES" attributeType="String"/>
    </entity>
</model>


================================================
FILE: pdfexpert/Resources/Assets.xcassets/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/.DS_Store
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Assets.xcassets/AccentColor.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0xF8",
          "green" : "0x91",
          "red" : "0x3F"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "AtlasWorks - PDF App icon.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/AppIconStaging.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "AtlasWorks - PDF App icon.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/archive_empty.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "empty_archive.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "empty_archive@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "empty_archive@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/camera.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "camera.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "camera@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "camera@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/edit_add_file.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "edit_add_file.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "edit_add_file@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "edit_add_file@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/edit_add_text.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "edit_add_text.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "edit_add_text@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "edit_add_text@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/edit_compression.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "edit_compression.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "edit_compression@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "edit_compression@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/edit_fill_form.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "edit_fill_form.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "edit_fill_form@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "edit_fill_form@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/edit_margins.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "margins.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "margins@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "margins@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/edit_option_compress.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "edit_option_compress.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "edit_option_compress@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "edit_option_compress@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/edit_option_password_lock.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "edit_option_password_lock.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "edit_option_password_lock@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "edit_option_password_lock@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/edit_option_password_unlock.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "edit_option_password_unlock.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "edit_option_password_unlock@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "edit_option_password_unlock@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/edit_option_split.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "edit_option_split.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "edit_option_split@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "edit_option_split@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/edit_signature.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "edit_signature.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "edit_signature@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "edit_signature@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/file.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "file.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "file@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "file@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/gallery.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "gallery 1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "gallery 1@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "gallery 1@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_add_password.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_add_password.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_add_password@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_add_password@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_add_text.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_add_text.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_add_text@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_add_text@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_create_pdf.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_create_pdf.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_create_pdf@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_create_pdf@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_excel_to_pdf.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_excel_to_pdf.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_excel_to_pdf@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_excel_to_pdf@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_file_source_dropbox.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_file_source_dropbox.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_file_source_dropbox@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_file_source_dropbox@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_file_source_files.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "file.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "file@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "file@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_file_source_google.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_file_source_google.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_file_source_google@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_file_source_google@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_file_source_icloud.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_file_source_icloud.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_file_source_icloud@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_file_source_icloud@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_fill_form.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_fill_form.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_fill_form@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_fill_form@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_image_to_pdf.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_image_to_pdf.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_image_to_pdf@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_image_to_pdf@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_import_pdf.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_import_pdf.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_import_pdf@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_import_pdf@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_merge.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_merge.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_merge@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_merge@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_power_to_pdf.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_power_to_pdf.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_power_to_pdf@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_power_to_pdf@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_read.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_read.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_read@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_read@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_remove_password.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_remove_password.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_remove_password@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_remove_password@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_scan.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_scan.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_scan@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_scan@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_sign.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_signature.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_signature@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_signature@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_split.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_split.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_split@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_split@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/home_word_to_pdf.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "home_word_to_pdf.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "home_word_to_pdf@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "home_word_to_pdf@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/import_tutorial_1.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "import_tutorial_1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "import_tutorial_1@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "import_tutorial_1@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/import_tutorial_2.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "import_tutorial_2.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "import_tutorial_2@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "import_tutorial_2@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/import_tutorial_3.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "import_tutorial_3.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "import_tutorial_3@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "import_tutorial_3@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/info.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "info.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "info@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "info@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/logo_large.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "logo_large.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "logo_large@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "logo_large@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/manage_annotations.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "manage_annotations.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "manage_annotations@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "manage_annotations@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/manage_widget.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "manage_annotations.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "manage_annotations@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "manage_annotations@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/onboarding_chat_pdf.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "onboarding_chat_pdf.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "onboarding_chat_pdf@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "onboarding_chat_pdf@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/onboarding_convert.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "onboarding_tutorial_1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "onboarding_tutorial_1@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "onboarding_tutorial_1@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/onboarding_password.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "onboarding_tutorial_4.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "onboarding_tutorial_4@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "onboarding_tutorial_4@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/onboarding_signature.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "onboarding_tutorial_2.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "onboarding_tutorial_2@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "onboarding_tutorial_2@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/page_selection.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "page_selection.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "page_selection@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "page_selection@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/password_entered.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "password_entered.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "password_entered@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "password_entered@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/password_missing.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "password_missing.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "password_missing@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "password_missing@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/review_low_rate.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "review_low_rate.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "review_low_rate@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "review_low_rate@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/scan.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "scan.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "scan@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "scan@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/settings.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "tab_settings.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "tab_settings@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "tab_settings@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/sign_drawing.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "sign_drawing.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "sign_drawing@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "sign_drawing@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/signature.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "signature.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "signature@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "signature@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/Subscription/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/Subscription/subscription_feature_chat_pdf.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "subscription_feature_chat_pdf.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "subscription_feature_chat_pdf@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "subscription_feature_chat_pdf@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/Subscription/subscription_feature_convert.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "subscription_feature_convert.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "subscription_feature_convert@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "subscription_feature_convert@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/Subscription/subscription_feature_edit.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "subscription_feature_edit.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "subscription_feature_edit@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "subscription_feature_edit@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/Subscription/subscription_feature_password.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "subscription_feature_password.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "subscription_feature_password@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "subscription_feature_password@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/Subscription/subscription_feature_signature.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "subscription_feature_signature.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "subscription_feature_signature@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "subscription_feature_signature@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/subscription_error.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "attention_icon.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "attention_icon@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "attention_icon@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/suggested_fields.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "suggested_fields.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "suggested_fields@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "suggested_fields@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/tab_archive.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "tab_archive.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "tab_archive@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "tab_archive@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/tab_chat_pdf.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "tab_chat_pdf.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "tab_chat_pdf@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "tab_chat_pdf@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Assets.xcassets/tab_home.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "tab_home.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "tab_home@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "tab_home@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "properties" : {
    "template-rendering-intent" : "template"
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/AppPrimary.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0xA3",
          "green" : "0x50",
          "red" : "0x67"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/Extra.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0x00",
          "green" : "0xC7",
          "red" : "0xFF"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/FourthText.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0x5A",
          "green" : "0x5A",
          "red" : "0x5A"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/PrimaryBG.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0x15",
          "green" : "0x13",
          "red" : "0x12"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/PrimaryText.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0xFF",
          "green" : "0xFF",
          "red" : "0xFF"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/SecondaryBG.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0x26",
          "green" : "0x24",
          "red" : "0x23"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/SecondaryText.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0xF8",
          "green" : "0x91",
          "red" : "0x3F"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/Specific/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/Specific/ButtonGradientEnd.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0xF8",
          "green" : "0x91",
          "red" : "0x3F"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/Specific/ButtonGradientStart.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0xE8",
          "green" : "0xAB",
          "red" : "0x00"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Colors.xcassets/ThirdText.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0xB9",
          "green" : "0xB9",
          "red" : "0xB9"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: pdfexpert/Resources/Fonts/Poppins-Black.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-BlackItalic.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-Bold.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-ExtraBold.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-ExtraBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-ExtraLight.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-ExtraLightItalic.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-Italic.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-Light.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-LightItalic.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-Medium.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-MediumItalic.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-Regular.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-SemiBold.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-SemiBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-Thin.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Fonts/Poppins-ThinItalic.ttf
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/IAP/EmptyProducts.storekit
================================================
{
  "identifier" : "AF06D1DE",
  "nonRenewingSubscriptions" : [

  ],
  "products" : [

  ],
  "settings" : {

  },
  "subscriptionGroups" : [

  ],
  "version" : {
    "major" : 2,
    "minor" : 0
  }
}



================================================
FILE: pdfexpert/Resources/IAP/LocalProductionProducts.storekit
================================================
{
  "appPolicies" : {
    "eula" : "",
    "policies" : [
      {
        "locale" : "en_US",
        "policyText" : "",
        "policyURL" : ""
      }
    ]
  },
  "identifier" : "610606E8",
  "nonRenewingSubscriptions" : [

  ],
  "products" : [

  ],
  "settings" : {
    "_failTransactionsEnabled" : false,
    "_locale" : "en_US",
    "_storefront" : "USA",
    "_storeKitErrors" : [
      {
        "current" : null,
        "enabled" : false,
        "name" : "Load Products"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Purchase"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Verification"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "App Store Sync"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Subscription Status"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "App Transaction"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Manage Subscriptions Sheet"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Refund Request Sheet"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Offer Code Redeem Sheet"
      }
    ]
  },
  "subscriptionGroups" : [
    {
      "id" : "21297792",
      "localizations" : [

      ],
      "name" : "Main",
      "subscriptions" : [
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "4.99",
          "familyShareable" : false,
          "groupNumber" : 3,
          "internalID" : "6447059846",
          "introductoryOffer" : null,
          "localizations" : [
            {
              "description" : "Unlimited access to all app features.",
              "displayName" : "Unlimited access",
              "locale" : "en_US"
            }
          ],
          "productID" : "eu.balzo.pdfexpert.monthly",
          "recurringSubscriptionPeriod" : "P1M",
          "referenceName" : "Monthly",
          "subscriptionGroupID" : "21297792",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "4.99",
          "familyShareable" : false,
          "groupNumber" : 4,
          "internalID" : "6447059881",
          "introductoryOffer" : {
            "internalID" : "5AC93103",
            "numberOfPeriods" : 1,
            "paymentMode" : "free",
            "subscriptionPeriod" : "P1W"
          },
          "localizations" : [
            {
              "description" : "Unlimited access to all app features.",
              "displayName" : "Unlimited access",
              "locale" : "en_US"
            }
          ],
          "productID" : "eu.balzo.pdfexpert.monthly.freetrial",
          "recurringSubscriptionPeriod" : "P1M",
          "referenceName" : "Monthly Free Trial",
          "subscriptionGroupID" : "21297792",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "1.99",
          "familyShareable" : false,
          "groupNumber" : 5,
          "internalID" : "6447692196",
          "introductoryOffer" : null,
          "localizations" : [
            {
              "description" : "Unlimited access to all app features.",
              "displayName" : "Unlimited access",
              "locale" : "en_US"
            }
          ],
          "productID" : "eu.balzo.pdfexpert.weekly",
          "recurringSubscriptionPeriod" : "P1W",
          "referenceName" : "Weekly",
          "subscriptionGroupID" : "21297792",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "19.99",
          "familyShareable" : false,
          "groupNumber" : 1,
          "internalID" : "6447059590",
          "introductoryOffer" : null,
          "localizations" : [
            {
              "description" : "Unlimited access to all app features.",
              "displayName" : "Unlimited access",
              "locale" : "en_US"
            }
          ],
          "productID" : "eu.balzo.pdfexpert.yearly",
          "recurringSubscriptionPeriod" : "P1Y",
          "referenceName" : "Yearly",
          "subscriptionGroupID" : "21297792",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "19.99",
          "familyShareable" : false,
          "groupNumber" : 2,
          "internalID" : "6447059831",
          "introductoryOffer" : {
            "internalID" : "D369907B",
            "numberOfPeriods" : 1,
            "paymentMode" : "free",
            "subscriptionPeriod" : "P1W"
          },
          "localizations" : [
            {
              "description" : "Unlimited access to all app features.",
              "displayName" : "Unlimited Access",
              "locale" : "en_US"
            }
          ],
          "productID" : "eu.balzo.pdfexpert.yearly.freetrial",
          "recurringSubscriptionPeriod" : "P1Y",
          "referenceName" : "Yearly Free Trial",
          "subscriptionGroupID" : "21297792",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        }
      ]
    }
  ],
  "version" : {
    "major" : 4,
    "minor" : 0
  }
}



================================================
FILE: pdfexpert/Resources/IAP/LocalStagingProducts.storekit
================================================
{
  "appPolicies" : {
    "eula" : "",
    "policies" : [
      {
        "locale" : "en_US",
        "policyText" : "",
        "policyURL" : ""
      }
    ]
  },
  "identifier" : "4F24126A",
  "nonRenewingSubscriptions" : [

  ],
  "products" : [

  ],
  "settings" : {
    "_failTransactionsEnabled" : false,
    "_locale" : "en_US",
    "_storefront" : "USA",
    "_storeKitErrors" : [
      {
        "current" : {
          "index" : 2,
          "type" : "generic"
        },
        "enabled" : false,
        "name" : "Load Products"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Purchase"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Verification"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "App Store Sync"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Subscription Status"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "App Transaction"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Manage Subscriptions Sheet"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Refund Request Sheet"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Offer Code Redeem Sheet"
      }
    ]
  },
  "subscriptionGroups" : [
    {
      "id" : "21342828",
      "localizations" : [

      ],
      "name" : "Main",
      "subscriptions" : [
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "4.99",
          "familyShareable" : false,
          "groupNumber" : 1,
          "internalID" : "6449435879",
          "introductoryOffer" : null,
          "localizations" : [

          ],
          "productID" : "eu.balzo.pdfexpert.staging.monthly",
          "recurringSubscriptionPeriod" : "P1M",
          "referenceName" : "Monthly",
          "subscriptionGroupID" : "21342828",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "4.99",
          "familyShareable" : false,
          "groupNumber" : 5,
          "internalID" : "6449436432",
          "introductoryOffer" : {
            "internalID" : "D91BFEE9",
            "numberOfPeriods" : 1,
            "paymentMode" : "free",
            "subscriptionPeriod" : "P1W"
          },
          "localizations" : [

          ],
          "productID" : "eu.balzo.pdfexpert.staging.monthly.freetrial",
          "recurringSubscriptionPeriod" : "P1M",
          "referenceName" : "Monthly Free Trial",
          "subscriptionGroupID" : "21342828",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "1.99",
          "familyShareable" : false,
          "groupNumber" : 2,
          "internalID" : "6449436136",
          "introductoryOffer" : null,
          "localizations" : [

          ],
          "productID" : "eu.balzo.pdfexpert.staging.weekly",
          "recurringSubscriptionPeriod" : "P1W",
          "referenceName" : "Weekly",
          "subscriptionGroupID" : "21342828",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "19.99",
          "familyShareable" : false,
          "groupNumber" : 3,
          "internalID" : "6449436141",
          "introductoryOffer" : null,
          "localizations" : [

          ],
          "productID" : "eu.balzo.pdfexpert.staging.yearly",
          "recurringSubscriptionPeriod" : "P1Y",
          "referenceName" : "Yearly",
          "subscriptionGroupID" : "21342828",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "19.99",
          "familyShareable" : false,
          "groupNumber" : 4,
          "internalID" : "6449436302",
          "introductoryOffer" : {
            "internalID" : "6D245617",
            "numberOfPeriods" : 1,
            "paymentMode" : "free",
            "subscriptionPeriod" : "P1W"
          },
          "localizations" : [

          ],
          "productID" : "eu.balzo.pdfexpert.staging.yearly.freetrial",
          "recurringSubscriptionPeriod" : "P1Y",
          "referenceName" : "Yearly Free Trial",
          "subscriptionGroupID" : "21342828",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        }
      ]
    }
  ],
  "version" : {
    "major" : 4,
    "minor" : 0
  }
}



================================================
FILE: pdfexpert/Resources/IAP/ProductionProducts.storekit
================================================
{
  "appPolicies" : {
    "eula" : "",
    "policies" : [
      {
        "locale" : "en_US",
        "policyText" : "",
        "policyURL" : ""
      }
    ]
  },
  "identifier" : "4215B0B5",
  "nonRenewingSubscriptions" : [

  ],
  "products" : [

  ],
  "settings" : {
    "_applicationInternalID" : "6744288931",
    "_developerTeamID" : "KQM6GWHKY3",
    "_failTransactionsEnabled" : false,
    "_lastSynchronizedDate" : 706463782.07062304,
    "_locale" : "en_US",
    "_storefront" : "USA",
    "_storeKitErrors" : [
      {
        "current" : null,
        "enabled" : false,
        "name" : "Load Products"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Purchase"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Verification"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "App Store Sync"
      },
      {
        "current" : {
          "index" : 2,
          "type" : "generic"
        },
        "enabled" : false,
        "name" : "Subscription Status"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "App Transaction"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Manage Subscriptions Sheet"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Refund Request Sheet"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Offer Code Redeem Sheet"
      }
    ]
  },
  "subscriptionGroups" : [
    {
      "id" : "21667229",
      "localizations" : [

      ],
      "name" : "Main",
      "subscriptions" : [
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "12.99",
          "familyShareable" : false,
          "groupNumber" : 2,
          "internalID" : "6744569812",
          "introductoryOffer" : null,
          "localizations" : [
            {
              "description" : "Unlimited access to all app features.",
              "displayName" : "Unlimited access",
              "locale" : "en_US"
            }
          ],
          "productID" : "com.pcnaid.pdfexpert.monthly",
          "recurringSubscriptionPeriod" : "P1M",
          "referenceName" : "Monthly",
          "subscriptionGroupID" : "21667229",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "12.99",
          "familyShareable" : false,
          "groupNumber" : 3,
          "internalID" : "6744569730",
          "introductoryOffer" : {
            "internalID" : "6744569730",
            "numberOfPeriods" : 1,
            "paymentMode" : "free",
            "subscriptionPeriod" : "P1W"
          },
          "localizations" : [
            {
              "description" : "Unlimited access to all app features.",
              "displayName" : "Unlimited access",
              "locale" : "en_US"
            }
          ],
          "productID" : "com.pcnaid.pdfexpert.monthly.freetrial",
          "recurringSubscriptionPeriod" : "P1M",
          "referenceName" : "Monthly Free Trial",
          "subscriptionGroupID" : "21667229",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "3.99",
          "familyShareable" : false,
          "groupNumber" : 1,
          "internalID" : "6744569786",
          "introductoryOffer" : null,
          "localizations" : [
            {
              "description" : "Unlimited access to all app features.",
              "displayName" : "Unlimited access",
              "locale" : "en_US"
            }
          ],
          "productID" : "com.pcnaid.pdfexpert.weekly",
          "recurringSubscriptionPeriod" : "P1W",
          "referenceName" : "Weekly",
          "subscriptionGroupID" : "21667229",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "89.99",
          "familyShareable" : false,
          "groupNumber" : 4,
          "internalID" : "6744569681",
          "introductoryOffer" : null,
          "localizations" : [
            {
              "description" : "Unlimited access to all app features.",
              "displayName" : "Unlimited access",
              "locale" : "en_US"
            }
          ],
          "productID" : "com.pcnaid.pdfexpert.yearly",
          "recurringSubscriptionPeriod" : "P1Y",
          "referenceName" : "Yearly",
          "subscriptionGroupID" : "21667229",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "89.99",
          "familyShareable" : false,
          "groupNumber" : 5,
          "internalID" : "6744569907",
          "introductoryOffer" : {
            "internalID" : "6744569907",
            "numberOfPeriods" : 1,
            "paymentMode" : "free",
            "subscriptionPeriod" : "P1W"
          },
          "localizations" : [
            {
              "description" : "Unlimited access to all app features.",
              "displayName" : "Unlimited Access",
              "locale" : "en_US"
            }
          ],
          "productID" : "com.pcnaid.pdfexpert.yearly.freetrial",
          "recurringSubscriptionPeriod" : "P1Y",
          "referenceName" : "Yearly Free Trial",
          "subscriptionGroupID" : "21667229",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        }
      ]
    }
  ],
  "version" : {
    "major" : 4,
    "minor" : 0
  }
}



================================================
FILE: pdfexpert/Resources/IAP/Products.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>yearly</key>
	<dict>
		<key>name</key>
		<string>standard_subscription</string>
		<key>views</key>
		<array>
			<string>pairs</string>
			<string>picker</string>
		</array>
	</dict>
	<key>yearly.freetrial</key>
	<dict>
		<key>name</key>
		<string>standard_subscription</string>
		<key>views</key>
		<array>
			<string>pairs</string>
			<string>vertical</string>
			<string>picker</string>
		</array>
	</dict>
	<key>monthly</key>
	<dict>
		<key>name</key>
		<string>standard_subscription</string>
		<key>views</key>
		<array>
			<string>pairs</string>
			<string>vertical</string>
		</array>
	</dict>
	<key>monthly.freetrial</key>
	<dict>
		<key>name</key>
		<string>standard_subscription</string>
		<key>views</key>
		<array>
			<string>pairs</string>
		</array>
	</dict>
	<key>weekly</key>
	<dict>
		<key>name</key>
		<string>standard_subscription</string>
		<key>views</key>
		<array>
			<string>vertical</string>
			<string>picker</string>
		</array>
	</dict>
</dict>
</plist>



================================================
FILE: pdfexpert/Resources/IAP/StagingProducts.storekit
================================================
{
  "appPolicies" : {
    "eula" : "",
    "policies" : [
      {
        "locale" : "en_US",
        "policyText" : "",
        "policyURL" : ""
      }
    ]
  },
  "identifier" : "01B5CCE1",
  "nonRenewingSubscriptions" : [

  ],
  "products" : [

  ],
  "settings" : {
    "_applicationInternalID" : "6744288931",
    "_developerTeamID" : "KQM6GWHKY3",
    "_failTransactionsEnabled" : false,
    "_lastSynchronizedDate" : 706614288.93695605,
    "_locale" : "en_US",
    "_storefront" : "USA",
    "_storeKitErrors" : [
      {
        "current" : null,
        "enabled" : false,
        "name" : "Load Products"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Purchase"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Verification"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "App Store Sync"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Subscription Status"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "App Transaction"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Manage Subscriptions Sheet"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Refund Request Sheet"
      },
      {
        "current" : null,
        "enabled" : false,
        "name" : "Offer Code Redeem Sheet"
      }
    ]
  },
  "subscriptionGroups" : [
    {
      "id" : "21342828",
      "localizations" : [

      ],
      "name" : "Main",
      "subscriptions" : [
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "3.99",
          "familyShareable" : false,
          "groupNumber" : 1,
          "internalID" : "6449435879",
          "introductoryOffer" : null,
          "localizations" : [

          ],
          "productID" : "eu.balzo.pdfexpert.staging.monthly",
          "recurringSubscriptionPeriod" : "P1M",
          "referenceName" : "Monthly",
          "subscriptionGroupID" : "21342828",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "3.99",
          "familyShareable" : false,
          "groupNumber" : 6,
          "internalID" : "6449436432",
          "introductoryOffer" : {
            "internalID" : "1F91B9DD",
            "numberOfPeriods" : 1,
            "paymentMode" : "free",
            "subscriptionPeriod" : "P1W"
          },
          "localizations" : [

          ],
          "productID" : "eu.balzo.pdfexpert.staging.monthly.freetrial",
          "recurringSubscriptionPeriod" : "P1M",
          "referenceName" : "Monthly Free Trial",
          "subscriptionGroupID" : "21342828",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "1.99",
          "familyShareable" : false,
          "groupNumber" : 3,
          "internalID" : "6449436136",
          "introductoryOffer" : null,
          "localizations" : [

          ],
          "productID" : "eu.balzo.pdfexpert.staging.weekly",
          "recurringSubscriptionPeriod" : "P1W",
          "referenceName" : "Weekly",
          "subscriptionGroupID" : "21342828",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "17.99",
          "familyShareable" : false,
          "groupNumber" : 4,
          "internalID" : "6449436141",
          "introductoryOffer" : null,
          "localizations" : [

          ],
          "productID" : "eu.balzo.pdfexpert.staging.yearly",
          "recurringSubscriptionPeriod" : "P1Y",
          "referenceName" : "Yearly",
          "subscriptionGroupID" : "21342828",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        },
        {
          "adHocOffers" : [

          ],
          "codeOffers" : [

          ],
          "displayPrice" : "17.99",
          "familyShareable" : false,
          "groupNumber" : 5,
          "internalID" : "6449436302",
          "introductoryOffer" : {
            "internalID" : "178FF839",
            "numberOfPeriods" : 1,
            "paymentMode" : "free",
            "subscriptionPeriod" : "P1W"
          },
          "localizations" : [

          ],
          "productID" : "eu.balzo.pdfexpert.staging.yearly.freetrial",
          "recurringSubscriptionPeriod" : "P1Y",
          "referenceName" : "Yearly Free Trial",
          "subscriptionGroupID" : "21342828",
          "type" : "RecurringSubscription",
          "winbackOffers" : [

          ]
        }
      ]
    }
  ],
  "version" : {
    "major" : 4,
    "minor" : 0
  }
}



================================================
FILE: pdfexpert/Resources/Production/.DS_Store
================================================
[Non-text file]


================================================
FILE: pdfexpert/Resources/Staging/.DS_Store
================================================
[Non-text file]



================================================
FILE: pdfexpert/Style/AnimationPalette.swift
================================================
//
//  AnimationPalette.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/03/23.
//

import Foundation
import SwiftUI

enum AnimationType: String {
    case dots = "loading"
    case pdf = "pdf-scanning"
}

extension AnimationType {
    var view: some View {
        var view = LottieView(filename: self.rawValue)
        switch self {
        case .dots: view = view.loop()
        case .pdf: view = view.loop(autoReverse: true)
        }
        return GeometryReader { geometryReader in
            view.frame(width: geometryReader.size.width / 2.0)
                .frame(maxHeight: .infinity)
                .position(x: geometryReader.size.width / 2.0, y: geometryReader.size.height / 2.0)
        }
    }
}



================================================
FILE: pdfexpert/Style/ColorPalette.swift
================================================
//
//  ColorPalette.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 23/02/23.
//

import Foundation
import SwiftUI

class ColorPalette {
    static let primary = Color("Primary")
    static let primaryBG = Color("PrimaryBG")
    static let secondaryBG = Color("SecondaryBG")
    static let primaryText = Color("PrimaryText")
    static let secondaryText = Color("SecondaryText")
    static let thirdText = Color("ThirdText")
    static let fourthText = Color("FourthText")
    static let extra = Color("Extra")
    static let buttonGradientStart = Color("ButtonGradientStart")
    static let buttonGradientEnd = Color("ButtonGradientEnd")
}



================================================
FILE: pdfexpert/Style/FontPalette.swift
================================================
//
//  FontPalette.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 23/02/23.
//

import Foundation
import SwiftUI

class FontPalette {
    
    private static let fontFamily: String = "Poppins"
    
    static func fontBlack(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-Black", size: size)
    }
    static func fontBlackItalic(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-BlackItalic", size: size)
    }
    static func fontBold(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-Bold", size: size)
    }
    static func fontBoldItalic(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-BoldItalic", size: size)
    }
    static func fontExtraBold(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-ExtraBold", size: size)
    }
    static func fontExtraBoldItalic(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-ExtraBoldItalic", size: size)
    }
    static func fontExtraLight(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-ExtraLight", size: size)
    }
    static func fontExtraLightItalic(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-ExtraLightItalic", size: size)
    }
    static func fontItalic(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-Italic", size: size)
    }
    static func fontLight(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-Light", size: size)
    }
    static func fontLightItalic(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-LightItalic", size: size)
    }
    static func fontMedium(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-Medium", size: size)
    }
    static func fontMediumItalic(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-MediumItalic", size: size)
    }
    static func fontRegular(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-Regular", size: size)
    }
    static func fontSemiBold(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-SemiBold", size: size)
    }
    static func fontSemiBoldItalic(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-SemiBoldItalic", size: size)
    }
    static func fontThin(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-Thin", size: size)
    }
    static func fontThinItalic(withSize size: CGFloat) -> Font {
        return Font.custom("\(Self.fontFamily)-ThinItalic", size: size)
    }
    
    static func uiFontBlack(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-Black", size: size) ?? UIFont.boldSystemFont(ofSize: size)
    }
    static func uiFontBlackItalic(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-BlackItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
    }
    static func uiFontBold(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-Bold", size: size) ?? UIFont.boldSystemFont(ofSize: size)
    }
    static func uiFontBoldItalic(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-BoldItalic", size: size) ?? UIFont.boldSystemFont(ofSize: size)
    }
    static func uiFontExtraBold(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-ExtraBold", size: size) ?? UIFont.boldSystemFont(ofSize: size)
    }
    static func uiFontExtraBoldItalic(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-ExtraBoldItalic", size: size) ?? UIFont.boldSystemFont(ofSize: size)
    }
    static func uiFontExtraLight(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-ExtraLight", size: size) ?? UIFont.systemFont(ofSize: size)
    }
    static func uiFontExtraLightItalic(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-ExtraLightItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
    }
    static func uiFontItalic(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-Italic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
    }
    static func uiFontLight(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-Light", size: size) ?? UIFont.systemFont(ofSize: size)
    }
    static func uiFontLightItalic(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-LightItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
    }
    static func uiFontMedium(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-Medium", size: size) ?? UIFont.systemFont(ofSize: size)
    }
    static func uiFontMediumItalic(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-MediumItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
    }
    static func uiFontRegular(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-Regular", size: size) ?? UIFont.systemFont(ofSize: size)
    }
    static func uiFontSemiBold(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-SemiBold", size: size) ?? UIFont.boldSystemFont(ofSize: size)
    }
    static func uiFontSemiBoldItalic(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-SemiBoldItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
    }
    static func uiFontThin(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-Thin", size: size) ?? UIFont.systemFont(ofSize: size)
    }
    static func uiFontThinItalic(withSize size: CGFloat) -> UIFont {
        return UIFont(name: "\(Self.fontFamily)-ThinItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
    }
}

enum FontCategory {
    case largeTitle
    case title1
    case title2
    case button
    case headline
    case body1
    case body2
    case body3
    case linkText
    case callout
    case caption1
    case caption2
    
    var font: Font {
        switch self {
        case .largeTitle: return FontPalette.fontMedium(withSize: 32)
        case .title1: return FontPalette.fontMedium(withSize: 24)
        case .title2: return FontPalette.fontMedium(withSize: 22)
        case .button: return FontPalette.fontMedium(withSize: 18)
        case .headline: return FontPalette.fontMedium(withSize: 18)
        case .body1: return FontPalette.fontRegular(withSize: 16)
        case .body2: return FontPalette.fontRegular(withSize: 14)
        case .body3: return FontPalette.fontMedium(withSize: 16)
        case .linkText: return FontPalette.fontRegular(withSize: 14)
        case .callout: return FontPalette.fontMedium(withSize: 12)
        case .caption1: return FontPalette.fontRegular(withSize: 12)
        case .caption2: return FontPalette.fontRegular(withSize: 10)
        }
    }
}

extension View {
    func font(forCategory category: FontCategory) -> some View {
        self.font(category.font)
    }
}



================================================
FILE: pdfexpert/Utils/Async.swift
================================================
//
//  Async.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 23/02/23.
//

import Foundation
import SwiftUI

protocol AsyncLoadable {
    var isLoading: Bool { get }
    func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool) -> Self
}

protocol AsyncFailable {
    
    associatedtype E: LocalizedError
    
    var error: E? { get }
    static var resetState: Self { get }
}

enum AsyncOperationStatus<T, E: LocalizedError> {
    case empty
    case data(T)
    case error(E)
    case loading(Progress)
}

struct AsyncOperation<T, E: LocalizedError> {
    let status: AsyncOperationStatus<T, E>
}

extension AsyncOperation: AsyncLoadable, AsyncFailable where E: LocalizedError {
    
    var success: Bool {
        switch self.status {
        case .empty: return false
        case .data: return true
        case .error: return false
        case .loading: return false
        }
    }
    
    var isLoading: Bool {
        switch self.status {
        case .empty: return false
        case .data: return false
        case .error: return false
        case .loading: return true
        }
    }
    
    var data: T? {
        switch self.status {
        case .empty: return nil
        case .data(let data): return data
        case .error: return nil
        case .loading: return nil
        }
    }
    
    var error: E? {
        switch self.status {
        case .empty: return nil
        case .data: return nil
        case .error(let error): return error
        case .loading: return nil
        }
    }
    
    func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool = true) -> Self {
        switch self.status {
        case .loading(let progress):
            return AsyncOperation(status: .loading(progress.update(newProgress: loadingProgress, onlyIfLess: onlyIfLess)))
        default:
            return self
        }
    }
    
    static var resetState: Self { .init(status: .empty) }
}

enum AsyncEmptyFailable<E: LocalizedError>: AsyncLoadable, AsyncFailable {
    case idle
    case loading(Progress)
    case error(E)
    
    var isLoading: Bool {
        switch self {
        case .idle: return false
        case .error: return false
        case .loading: return true
        }
    }
    
    var error: E? {
        switch self {
        case .idle: return nil
        case .error(let error): return error
        case .loading: return nil
        }
    }
    
    func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool = true) -> Self {
        switch self {
        case .loading(let progress):
            return .loading(progress.update(newProgress: loadingProgress, onlyIfLess: onlyIfLess))
        default:
            return self
        }
    }
    
    static var resetState: Self { .idle }
}

enum AsyncEmpty: AsyncLoadable {
    case idle
    case loading(Progress)
    
    var isLoading: Bool {
        switch self {
        case .idle: return false
        case .loading: return true
        }
    }
    
    func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool = true) -> Self {
        switch self {
        case .loading(let progress):
            return .loading(progress.update(newProgress: loadingProgress, onlyIfLess: onlyIfLess))
        default:
            return self
        }
    }
}

enum AsyncItem<T>: AsyncLoadable {
    
    case empty
    case loading(Progress)
    case data(T)
    
    var hasData: Bool {
        switch self {
        case .empty: return false
        case .loading: return false
        case .data: return true
        }
    }
    
    var isLoading: Bool {
        switch self {
        case .empty: return false
        case .loading: return true
        case .data: return false
        }
    }
    
    var data: T? {
        switch self {
        case .empty: return nil
        case .loading: return nil
        case .data(let data): return data
        }
    }
    
    func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool = true) -> Self {
        switch self {
        case .loading(let progress):
            return .loading(progress.update(newProgress: loadingProgress, onlyIfLess: onlyIfLess))
        default:
            return self
        }
    }
}

enum AsyncItemFailable<T, E: LocalizedError>: AsyncLoadable, AsyncFailable {
    
    case empty
    case loading(Progress)
    case data(T)
    case error(E)
    
    var success: Bool {
        switch self {
        case .empty: return false
        case .data: return true
        case .error: return false
        case .loading: return false
        }
    }
    
    var isLoading: Bool {
        switch self {
        case .empty: return false
        case .loading: return true
        case .data: return false
        case .error: return false
        }
    }
    
    var data: T? {
        switch self {
        case .empty: return nil
        case .loading: return nil
        case .data(let data): return data
        case .error: return nil
        }
    }
    
    var error: E? {
        switch self {
        case .empty: return nil
        case .data: return nil
        case .error(let error): return error
        case .loading: return nil
        }
    }
    
    func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool = true) -> Self {
        switch self {
        case .loading(let progress):
            return .loading(progress.update(newProgress: loadingProgress, onlyIfLess: onlyIfLess))
        default:
            return self
        }
    }
    
    static var resetState: Self { .empty }
}

extension Progress {
    static var undeterminedProgress: Self {
        .init(totalUnitCount: 1)
    }
    
    func update(newProgress: Progress, onlyIfLess: Bool = true) -> Progress {
        if !onlyIfLess || self.completedUnitCount < newProgress.completedUnitCount {
            return newProgress
        } else {
            return self
        }
    }
}



================================================
FILE: pdfexpert/Utils/CombineUtils.swift
================================================
//
//  CombineUtils.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 20/07/23.
//

import Foundation
import Combine

extension Just {
    static func withErrorType<E>(_ value: Output, _ errorType: E.Type
    ) -> AnyPublisher<Output, E> {
        return Just(value)
            .setFailureType(to: E.self)
            .eraseToAnyPublisher()
    }
}

extension Publisher where Failure: LocalizedError {
    func sinkToAsyncStatus(_ completion: @escaping (AsyncOperationStatus<Output, Failure>) -> Void) -> AnyCancellable {
        return sink(receiveCompletion: { subscriptionCompletion in
            if let error = subscriptionCompletion.error {
                completion(AsyncOperationStatus<Output, Failure>.error(error))
            }
        }, receiveValue: { value in
            completion(AsyncOperationStatus<Output, Failure>.data(value))
        })
    }
}

extension Subscribers.Completion {
    var error: Failure? {
        switch self {
        case let .failure(error): return error
        default: return nil
        }
    }
}

extension Publisher {
    
    /// Includes the current element as well as the previous element from the upstream publisher in a tuple where the previous element is optional.
    /// The first time the upstream publisher emits an element, the previous element will be `nil`.
    ///
    ///     let range = (1...5)
    ///     cancellable = range.publisher
    ///         .withPrevious()
    ///         .sink { print ("(\($0.previous), \($0.current))", terminator: " ") }
    ///      // Prints: "(nil, 1) (Optional(1), 2) (Optional(2), 3) (Optional(3), 4) (Optional(4), 5) ".
    ///
    /// - Returns: A publisher of a tuple of the previous and current elements from the upstream publisher.
    func withPrevious() -> AnyPublisher<(previous: Output?, current: Output), Failure> {
        scan(Optional<(Output?, Output)>.none) { ($0?.1, $1) }
            .compactMap { $0 }
            .eraseToAnyPublisher()
    }
    
    /// Includes the current element as well as the previous element from the upstream publisher in a tuple where the previous element is not optional.
    /// The first time the upstream publisher emits an element, the previous element will be the `initialPreviousValue`.
    ///
    ///     let range = (1...5)
    ///     cancellable = range.publisher
    ///         .withPrevious(0)
    ///         .sink { print ("(\($0.previous), \($0.current))", terminator: " ") }
    ///      // Prints: "(0, 1) (1, 2) (2, 3) (3, 4) (4, 5) ".
    ///
    /// - Parameter initialPreviousValue: The initial value to use as the "previous" value when the upstream publisher emits for the first time.
    /// - Returns: A publisher of a tuple of the previous and current elements from the upstream publisher.
    func withPrevious(_ initialPreviousValue: Output) -> AnyPublisher<(previous: Output, current: Output), Failure> {
        scan((initialPreviousValue, initialPreviousValue)) { ($0.1, $1) }.eraseToAnyPublisher()
    }
}



================================================
FILE: pdfexpert/Utils/DebugUtils.swift
================================================
//
//  DebugUtils.swift
//  FourBooks
//
//  Created by Pcnaid Inc on 15/06/2020.
//  Copyright © 2020 4Books. All rights reserved.
//

import Foundation

@discardableResult
public func debugPrintElapsedTimeSince(operationName: String, startTime: CFAbsoluteTime) -> CFAbsoluteTime {
    let currentTime = CFAbsoluteTimeGetCurrent()
    print("Debug - Time elapsed for \(operationName): \(currentTime - startTime) s.")
    return currentTime
}

public func debugPrint(for type: Any.Type, message: String, function: String = #function) {
    print("\(String(describing: type)) - \(function) - \(message)")
}

public func debugPrint(for instance: Any, message: String, function: String = #function) {
    debugPrint(for: type(of: instance), message: message)
}

public func isPreview() -> Bool {
    return ProcessInfo.processInfo.environment["XCODE_RUNNING_FOR_PREVIEWS"] == "1"
}



================================================
FILE: pdfexpert/Utils/MathUtils.swift
================================================
//
//  MathUtils.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 25/08/23.
//

import Foundation

struct Line {
    let slope: CGFloat
    let intercept: CGFloat
}

class MathUtils {
    
    static func getSlope(ofLinePassingThrough pointA: CGPoint, and pointB: CGPoint) -> CGFloat {
        let x1 = pointA.x
        let x2 = pointB.x
        let y1 = pointA.y
        let y2 = pointB.y
        
        return (y2 - y1) / (x2 - x1)
    }
    
    static func getIntercept(ofLinePassingThrough pointA: CGPoint, and pointB: CGPoint) -> CGFloat {
        let x1 = pointA.x
        let x2 = pointB.x
        let y1 = pointA.y
        let y2 = pointB.y
        
        return (x2*y1 - x1*y2) / (x2 - x1)
    }
    
    static func getLine(ofLinePassingThrough pointA: CGPoint, and pointB: CGPoint) -> Line {
        let slope = self.getSlope(ofLinePassingThrough: pointA, and: pointB)
        let intercept = self.getIntercept(ofLinePassingThrough: pointA, and: pointB)
        
        return Line(slope: slope,
                    intercept: intercept)
    }
}

extension Line {
    
    var direction: CGPoint {
        CGPoint(x: 1, y: self.slope).normalized
    }
    
    func getY(forX x: CGFloat) -> CGFloat {
        return x * self.slope + self.intercept
    }
    
    func closestPoint(toPoint point: CGPoint) -> CGPoint {
        let direction = self.direction
        let translatedPoint = CGPoint(x: point.x, y: point.y - self.intercept)
        let pointProjectionLength = CGPoint.dot(direction, translatedPoint)
        let translatedClosestPoint = direction.scale(by: pointProjectionLength)
        return CGPoint(x: translatedClosestPoint.x, y: translatedClosestPoint.y + self.intercept)
    }
}

extension CGPoint {
    
    var length: CGFloat {
        CGFloat(sqrtf(powf(Float(self.x), 2.0) + powf(Float(self.y), 2.0)))
    }
    
    var normalized: CGPoint {
        let length = self.length
        if length > 0.0 {
            return self.scale(by: 1.0 / length)
        } else {
            return .zero
        }
    }
    
    func scale(by scaleFactor: CGFloat) -> CGPoint {
        CGPoint(x: self.x * scaleFactor, y: self.y * scaleFactor)
    }
    
    static func dot(_ pointA: CGPoint, _ pointB: CGPoint) -> CGFloat {
        pointA.x * pointB.x + pointA.y * pointB.y
    }
}



================================================
FILE: pdfexpert/Utils/ParentalCheck.swift
================================================
//
//  ParentalCheck.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 14/03/23.
//

import Foundation

enum ParentalCheck<T: Hashable>: Hashable, Identifiable {
    case checking(T)
    case success(T)
    
    var id: Self { self }
}



================================================
FILE: pdfexpert/Utils/PDFImageExtractor.swift
================================================
//
//  main.swift
//  ImageExtractor
//
//  Created by Damiaan on 13/08/2019.
//  Copyright © 2019 dPro. All rights reserved.
//

import Foundation
import PDFKit

enum PDFReadError: Error {
	case couldNotOpenPage(Int)
	case couldNotGetPageReference
	case couldNotOpenPageDictionary
	case couldNotReadResources
	case cannotCopyData
}

enum EmbeddedImage {
	case jpg(Data)
	case raw(CGImage)
}

func extractImages(from pdf: PDFDocument, extractor: @escaping (EmbeddedImage, Int, String)->Void) throws {
	for pageNumber in 0..<pdf.pageCount {
		guard let page = pdf.page(at: pageNumber) else {
			throw PDFReadError.couldNotOpenPage(pageNumber)
		}
		try extractImages(from: page) { extractor($0, pageNumber, $1) }
	}
}

func extractImages(from page: PDFPage, extractor: @escaping (EmbeddedImage, String)->Void) throws {
	guard let page = page.pageRef else {
		throw PDFReadError.couldNotGetPageReference
	}

	guard let dictionary = page.dictionary else {
		throw PDFReadError.couldNotOpenPageDictionary
	}

	guard let resources = dictionary[CGPDFDictionaryGetDictionary, "Resources"] else {
		throw PDFReadError.couldNotReadResources
	}

	if let xObject = resources[CGPDFDictionaryGetDictionary, "XObject"] {
		func iterator(key: UnsafePointer<Int8>, object: CGPDFObjectRef, info: UnsafeMutableRawPointer?) -> Bool {
			do {
				if let data = try extractImage(key: key, object: object) {
					extractor(data, String(cString: key))
				}
			} catch {
				print(error)
				return true
			}
			return true
		}
		CGPDFDictionaryApplyBlock(xObject, iterator, nil)
	}
}

enum RawDecodingError: Error {
	case cannotConstructImage
	case cannotReadSize
	case cannotReadBitsPerComponent
	case noColorSpace([String]?)
	case unkownColorSpace(String)
	case corruptColorSpace
	case noLookupTable
}

func extractImage(key: UnsafePointer<Int8>, object: CGPDFObjectRef) throws -> EmbeddedImage? {
	guard let stream: CGPDFStreamRef = object[CGPDFObjectGetValue, .stream] else { return nil }
	guard let dictionary = CGPDFStreamGetDictionary(stream) else {return nil}

	guard dictionary.getName("Subtype", CGPDFDictionaryGetName) == "Image" else {return nil}
	print(String(cString: key))

	var format = CGPDFDataFormat.raw
	guard let data = CGPDFStreamCopyData(stream, &format) else { throw PDFReadError.cannotCopyData }

	if format == .JPEG2000 || format == .jpegEncoded {
		if
			let colorSpace = try? dictionary[CGPDFDictionaryGetObject, "ColorSpace"]?.getColorSpace(),
			let provider = CGDataProvider(data: data),
			let embeddedImage = CGImage(
				jpegDataProviderSource: provider,
				decode: nil,
				shouldInterpolate: false,
				intent: .defaultIntent
			),
			let correctedImage = embeddedImage.copy(colorSpace: colorSpace)
		{
            return .raw(correctedImage)
		}
		return .jpg(data as Data)
	} else {
		return .raw( try getCGImage(data: data, info: dictionary) )
	}
}

func getCGImage(data: CFData, info: CGPDFDictionaryRef) throws -> CGImage {
	guard let colorSpace = try info[CGPDFDictionaryGetObject, "ColorSpace"]?.getColorSpace() else {
		throw RawDecodingError.noColorSpace(info.getNameArray(for: "Filter"))
	}

	guard
		let width = info[CGPDFDictionaryGetInteger, "Width"],
		let height = info[CGPDFDictionaryGetInteger, "Height"]
		else {
			throw RawDecodingError.cannotReadSize
	}
	guard let bitsPerComponent = info[CGPDFDictionaryGetInteger, "BitsPerComponent"] else {
		throw RawDecodingError.cannotReadBitsPerComponent
	}

	let decode: [CGFloat]?
	if let decodeRef = info[CGPDFDictionaryGetArray, "Decode"] {
		let count = CGPDFArrayGetCount(decodeRef)
		decode = (0..<count).map {
			decodeRef[CGPDFArrayGetNumber, $0]!
		}
	} else {
		decode = nil
	}

	guard let databuffer = CGDataProvider(data: data) else {throw RawDecodingError.cannotConstructImage}
	guard let image = CGImage(
		width: width,
		height: height,
		bitsPerComponent: bitsPerComponent,
		bitsPerPixel: bitsPerComponent * colorSpace.numberOfComponents,
		bytesPerRow: Int((Double(width * bitsPerComponent * colorSpace.numberOfComponents) / 8.0).rounded(.up)),
		space: colorSpace,
		bitmapInfo: CGBitmapInfo(),
		provider: databuffer,
		decode: decode,
		shouldInterpolate: false,
		intent: .defaultIntent
	) else {throw RawDecodingError.cannotConstructImage}

	return image
}

protocol DefaultInitializer {
	init()
}

extension Int: DefaultInitializer {}
extension CGFloat: DefaultInitializer {}

extension CGPDFObjectRef {
	func getName<K>(_ key: K, _ getter: (OpaquePointer, K, UnsafeMutablePointer<UnsafePointer<Int8>?>)->Bool) -> String? {
		guard let pointer = self[getter, key] else { return nil }
		return String(cString: pointer)
	}

	func getName<K>(_ key: K, _ getter: (OpaquePointer, K, UnsafeMutableRawPointer?)->Bool) -> String? {
		guard let pointer: UnsafePointer<UInt8> = self[getter, key] else { return nil }
		return String(cString: pointer)
	}

	subscript<R, K>(_ getter: (OpaquePointer, K, UnsafeMutablePointer<R?>)->Bool, _ key: K) -> R? {
		var result: R!
		guard getter(self, key, &result) else { return nil }
		return result
	}

	subscript<R: DefaultInitializer, K>(_ getter: (OpaquePointer, K, UnsafeMutablePointer<R>)->Bool, _ key: K) -> R? {
		var result = R()
		guard getter(self, key, &result) else { return nil }
		return result
	}

    subscript<R, K>(_ getter: (OpaquePointer, K, UnsafeMutableRawPointer?)->Bool, _ key: K) -> R? {
            var result: R!
            guard getter(self, key, &result) else { return nil }
            return result
        }

	func getNameArray(for key: String) -> [String]? {
		var object: CGPDFObjectRef!
		guard CGPDFDictionaryGetObject(self, key, &object) else { return nil }

		if let name = object.getName(.name, CGPDFObjectGetValue) {
			return [name]
		} else {
			guard let array: CGPDFArrayRef = object[CGPDFObjectGetValue, .array] else {return nil}
			var names = [String]()
			for index in 0..<CGPDFArrayGetCount(array) {
				guard let name = array.getName(index, CGPDFArrayGetName) else { continue }
				names.append(name)
			}
			assert(names.count == CGPDFArrayGetCount(array))
			return names
		}
	}

	func getColorSpace() throws -> CGColorSpace {
		if let name = getName(.name, CGPDFObjectGetValue) {
			switch name {
			case "DeviceGray":
				return CGColorSpaceCreateDeviceGray()
			case "DeviceRGB":
				return CGColorSpaceCreateDeviceRGB()
			case "DeviceCMYK":
				return CGColorSpaceCreateDeviceCMYK()
			default:
				throw RawDecodingError.unkownColorSpace(name)
			}
		} else {
			guard
				let array: CGPDFArrayRef = self[CGPDFObjectGetValue, .array],
				let name = array.getName(0, CGPDFArrayGetName)
				else {
					throw RawDecodingError.corruptColorSpace
			}

			switch name {
			case "Indexed":
				guard
					let base = try array[CGPDFArrayGetObject, 1]?.getColorSpace(),
					let hival = array[CGPDFArrayGetInteger, 2],
					hival < 256
					else {
						throw RawDecodingError.corruptColorSpace
				}
				let colorSpace: CGColorSpace?
				if let lookupTable = array[CGPDFArrayGetString, 3] {
					guard let pointer = CGPDFStringGetBytePtr(lookupTable) else { throw RawDecodingError.corruptColorSpace }
					colorSpace = CGColorSpace(indexedBaseSpace: base, last: hival, colorTable: pointer)
				} else if let lookupTable = array[CGPDFArrayGetStream, 3] {
					var format = CGPDFDataFormat.raw
					guard let data = CGPDFStreamCopyData(lookupTable, &format) else {
						throw RawDecodingError.corruptColorSpace
					}
					colorSpace = CGColorSpace(
						indexedBaseSpace: base,
						last: hival,
						colorTable: CFDataGetBytePtr(data)
					)
				} else {
					throw RawDecodingError.noLookupTable
				}
				guard let result = colorSpace else { throw RawDecodingError.corruptColorSpace }
				return result
			case "ICCBased":
				var format = CGPDFDataFormat.raw
				guard
					let stream = array[CGPDFArrayGetStream, 1],
					let info = CGPDFStreamGetDictionary(stream),
					let componentCount = info[CGPDFDictionaryGetInteger, "N"],
					let profileData = CGPDFStreamCopyData(stream, &format),
					let profile = CGDataProvider(data: profileData)
					else {
						throw RawDecodingError.corruptColorSpace
				}
				let alternate = try info[CGPDFDictionaryGetObject, "Alternate"]?.getColorSpace()
				guard let colorSpace = CGColorSpace(
					iccBasedNComponents: componentCount,
					range: nil,
					profile: profile,
					alternate: alternate
					) else {
						throw RawDecodingError.corruptColorSpace
				}
				return colorSpace
			case "Lab":
				guard
					let info = array[CGPDFArrayGetDictionary, 1],
					let whitePointRef = info[CGPDFDictionaryGetArray, "WhitePoint"]?.asFloatArray()
					else { throw RawDecodingError.corruptColorSpace }
				guard let colorSpace = CGColorSpace(
					labWhitePoint: whitePointRef,
					blackPoint: info[CGPDFDictionaryGetArray, "BlackPoint"]?.asFloatArray(),
					range: info[CGPDFDictionaryGetArray, "Range"]?.asFloatArray()
					) else {
						throw RawDecodingError.corruptColorSpace
				}
				return colorSpace
			default:
				throw RawDecodingError.unkownColorSpace(name)
			}
		}
	}

	func asFloatArray() -> [CGFloat] {
		return (0..<CGPDFArrayGetCount(self)).map {
			self[CGPDFArrayGetNumber, $0]!
		}
	}
}



================================================
FILE: pdfexpert/Utils/.DS_Store
================================================
[Non-text file]


================================================
FILE: pdfexpert/Utils/Camera/CameraPreviewView.swift
================================================
//
//  CameraPreviewView.swift
//  SwiftCamera
//
//  Created by Rolando Rodriguez on 10/17/20.
//

import SwiftUI
import AVFoundation

struct CameraPreviewView: UIViewRepresentable {
    class VideoPreviewView: UIView {
        override class var layerClass: AnyClass {
             AVCaptureVideoPreviewLayer.self
        }
        
        var videoPreviewLayer: AVCaptureVideoPreviewLayer {
            return layer as! AVCaptureVideoPreviewLayer
        }
    }
    
    let session: AVCaptureSession
    
    func makeUIView(context: Context) -> VideoPreviewView {
        let view = VideoPreviewView()
        view.backgroundColor = .black
        view.videoPreviewLayer.cornerRadius = 0
        view.videoPreviewLayer.session = session
        view.videoPreviewLayer.connection?.videoOrientation = .portrait

        return view
    }
    
    func updateUIView(_ uiView: VideoPreviewView, context: Context) {
        
    }
}

struct CameraPreviewView_Previews: PreviewProvider {
    static var previews: some View {
        CameraPreviewView(session: AVCaptureSession())
            .frame(height: 300)
    }
}



================================================
FILE: pdfexpert/Utils/Camera/CameraService+Enums.swift
================================================
//
//  CameraService+Enums.swift
//  SwiftCamera
//
//  Created by Rolando Rodriguez on 10/15/20.
//

import Foundation

//  MARK: CameraService Enums
extension CameraService {
    enum LivePhotoMode {
        case on
        case off
    }
    
    enum DepthDataDeliveryMode {
        case on
        case off
    }
    
    enum PortraitEffectsMatteDeliveryMode {
        case on
        case off
    }
    
    enum SessionSetupResult {
        case success
        case notAuthorized
        case configurationFailed
    }
    
    enum CaptureMode: Int {
        case photo = 0
        case movie = 1
    }
}



================================================
FILE: pdfexpert/Utils/Camera/CameraService+Extensions.swift
================================================
//
//  CameraService+Extensions.swift
//  SwiftCamera
//
//  Created by Rolando Rodriguez on 10/15/20.
//

import Foundation
import UIKit
import AVFoundation

extension AVCaptureVideoOrientation {
    init?(deviceOrientation: UIDeviceOrientation) {
        switch deviceOrientation {
        case .portrait: self = .portrait
        case .portraitUpsideDown: self = .portraitUpsideDown
        case .landscapeLeft: self = .landscapeRight
        case .landscapeRight: self = .landscapeLeft
        default: return nil
        }
    }
    
    init?(interfaceOrientation: UIInterfaceOrientation) {
        switch interfaceOrientation {
        case .portrait: self = .portrait
        case .portraitUpsideDown: self = .portraitUpsideDown
        case .landscapeLeft: self = .landscapeLeft
        case .landscapeRight: self = .landscapeRight
        default: return nil
        }
    }
}

extension AVCaptureDevice.DiscoverySession {
    var uniqueDevicePositionsCount: Int {
        
        var uniqueDevicePositions = [AVCaptureDevice.Position]()
        
        for device in devices where !uniqueDevicePositions.contains(device.position) {
            uniqueDevicePositions.append(device.position)
        }
        
        return uniqueDevicePositions.count
    }
}



================================================
FILE: pdfexpert/Utils/Camera/CameraService.swift
================================================
//
//  CameraService.swift
//  SwiftCamera
//
//  Created by Rolando Rodriguez on 10/15/20.
//

import Foundation
import Combine
import AVFoundation
import UIKit

//  MARK: Class Camera Service, handles setup of AVFoundation needed for a basic camera app.
public struct Photo: Identifiable, Equatable {
//    The ID of the captured photo
    public var id: String
//    Data representation of the captured photo
    public var originalData: Data
    
    public init(id: String = UUID().uuidString, originalData: Data) {
        self.id = id
        self.originalData = originalData
    }
}

public enum CameraError {
    case permissionDenied
    case cameraUnavailable
}

extension Photo {
    public var compressedData: Data? {
        ImageResizer(targetWidth: 800).resize(data: originalData)?.jpegData(compressionQuality: 0.5)
    }
    public var thumbnailData: Data? {
        ImageResizer(targetWidth: 100).resize(data: originalData)?.jpegData(compressionQuality: 0.5)
    }
    public var thumbnailImage: UIImage? {
        guard let data = thumbnailData else { return nil }
        return UIImage(data: data)
    }
    public var image: UIImage? {
        guard let data = compressedData else { return nil }
        return UIImage(data: data)
    }
}

public class CameraService {
    typealias PhotoCaptureSessionID = String
    
//    MARK: Observed Properties UI must react to
    
//    1.
    @Published public var flashMode: AVCaptureDevice.FlashMode = .off
//    2.
    @Published public var error: CameraError? = nil
//    3.
    @Published public var shouldShowSpinner = false
//    4.
    @Published public var willCapturePhoto = false
//    5.
    @Published public var isCameraButtonDisabled = true
//    6.
    @Published public var isCameraUnavailable = true
//    8.
    @Published public var photo: Photo?
    
// MARK: Session Management Properties
    
//    9
    public let session = AVCaptureSession()
//    10
    var isSessionRunning = false
//    12
    var isConfigured = false
//    13
    var setupResult: SessionSetupResult = .success
//    14
    // Communicate with the session and other session objects on this queue.
    private let sessionQueue = DispatchQueue(label: "session queue")
    
    @objc dynamic var videoDeviceInput: AVCaptureDeviceInput!
    
    // MARK: Device Configuration Properties
    private let videoDeviceDiscoverySession = AVCaptureDevice.DiscoverySession(deviceTypes: [.builtInWideAngleCamera, .builtInDualCamera, .builtInTrueDepthCamera], mediaType: .video, position: .unspecified)
    
    // MARK: Capturing Photos
    
    private let photoOutput = AVCapturePhotoOutput()
    
    private var inProgressPhotoCaptureDelegates = [Int64: PhotoCaptureProcessor]()
    
    // MARK: KVO and Notifications Properties
    
    private var keyValueObservations = [NSKeyValueObservation]()
    
    
    public func configure() {
        /*
         Setup the capture session.
         In general, it's not safe to mutate an AVCaptureSession or any of its
         inputs, outputs, or connections from multiple threads at the same time.
         
         Don't perform these tasks on the main queue because
         AVCaptureSession.startRunning() is a blocking call, which can
         take a long time. Dispatch session setup to the sessionQueue, so
         that the main queue isn't blocked, which keeps the UI responsive.
         */
        sessionQueue.async {
            self.configureSession()
        }
    }
    
    //        MARK: Checks for user's permisions
    public func checkForPermissions() {
      
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .authorized:
            // The user has previously granted access to the camera.
            break
        case .notDetermined:
            /*
             The user has not yet been presented with the option to grant
             video access. Suspend the session queue to delay session
             setup until the access request has completed.
             */
            sessionQueue.suspend()
            AVCaptureDevice.requestAccess(for: .video, completionHandler: { granted in
                if !granted {
                    self.setupResult = .notAuthorized
                }
                self.sessionQueue.resume()
            })
            
        default:
            // The user has previously denied access.
            setupResult = .notAuthorized
            
            DispatchQueue.main.async {
                self.error = .permissionDenied
                self.isCameraUnavailable = true
                self.isCameraButtonDisabled = true
            }
        }
    }
    
    //  MARK: Session Management
    
    // Call this on the session queue.
    /// - Tag: ConfigureSession
    private func configureSession() {
        if setupResult != .success {
            return
        }
        
        session.beginConfiguration()
        
        session.sessionPreset = .photo
        
        // Add video input.
        do {
            var defaultVideoDevice: AVCaptureDevice?
            
            if let backCameraDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) {
                // If a rear dual camera is not available, default to the rear wide angle camera.
                defaultVideoDevice = backCameraDevice
            } else if let frontCameraDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .front) {
                // If the rear wide angle camera isn't available, default to the front wide angle camera.
                defaultVideoDevice = frontCameraDevice
            }
            
            guard let videoDevice = defaultVideoDevice else {
                print("Default video device is unavailable.")
                setupResult = .configurationFailed
                session.commitConfiguration()
                return
            }
            
            let videoDeviceInput = try AVCaptureDeviceInput(device: videoDevice)
            
            if session.canAddInput(videoDeviceInput) {
                session.addInput(videoDeviceInput)
                self.videoDeviceInput = videoDeviceInput
                
            } else {
                print("Couldn't add video device input to the session.")
                setupResult = .configurationFailed
                session.commitConfiguration()
                return
            }
        } catch {
            print("Couldn't create video device input: \(error)")
            setupResult = .configurationFailed
            session.commitConfiguration()
            return
        }
        
        // Add the photo output.
        if session.canAddOutput(photoOutput) {
            session.addOutput(photoOutput)
            
            photoOutput.maxPhotoQualityPrioritization = .quality
            
        } else {
            print("Could not add photo output to the session")
            setupResult = .configurationFailed
            session.commitConfiguration()
            return
        }
        
        session.commitConfiguration()
        
        self.isConfigured = true
        
        self.start()
    }
 
    //  MARK: Device Configuration
    
    /// - Tag: ChangeCamera
    public func changeCamera() {
        guard self.setupResult == .success else {
            return
        }
        //        MARK: Here disable all camera operation related buttons due to configuration is due upon and must not be interrupted
        DispatchQueue.main.async {
            self.isCameraButtonDisabled = true
        }
        //
        
        sessionQueue.async {
            let currentVideoDevice = self.videoDeviceInput.device
            let currentPosition = currentVideoDevice.position
            
            let preferredPosition: AVCaptureDevice.Position
            let preferredDeviceType: AVCaptureDevice.DeviceType
            
            switch currentPosition {
            case .unspecified, .front:
                preferredPosition = .back
                preferredDeviceType = .builtInWideAngleCamera
                
            case .back:
                preferredPosition = .front
                preferredDeviceType = .builtInWideAngleCamera
                
            @unknown default:
                print("Unknown capture position. Defaulting to back, dual-camera.")
                preferredPosition = .back
                preferredDeviceType = .builtInWideAngleCamera
            }
            let devices = self.videoDeviceDiscoverySession.devices
            var newVideoDevice: AVCaptureDevice? = nil
            
            // First, seek a device with both the preferred position and device type. Otherwise, seek a device with only the preferred position.
            if let device = devices.first(where: { $0.position == preferredPosition && $0.deviceType == preferredDeviceType }) {
                newVideoDevice = device
            } else if let device = devices.first(where: { $0.position == preferredPosition }) {
                newVideoDevice = device
            }
            
            if let videoDevice = newVideoDevice {
                do {
                    let videoDeviceInput = try AVCaptureDeviceInput(device: videoDevice)
                    
                    self.session.beginConfiguration()
                    
                    // Remove the existing device input first, because AVCaptureSession doesn't support
                    // simultaneous use of the rear and front cameras.
                    self.session.removeInput(self.videoDeviceInput)
                    
                    if self.session.canAddInput(videoDeviceInput) {
                        self.session.addInput(videoDeviceInput)
                        self.videoDeviceInput = videoDeviceInput
                    } else {
                        self.session.addInput(self.videoDeviceInput)
                    }
                    
                    if let connection = self.photoOutput.connection(with: .video) {
                        if connection.isVideoStabilizationSupported {
                            connection.preferredVideoStabilizationMode = .auto
                        }
                    }
                    
                    self.photoOutput.maxPhotoQualityPrioritization = .quality
                    
                    self.session.commitConfiguration()
                } catch {
                    print("Error occurred while creating video device input: \(error)")
                }
            }
            
            DispatchQueue.main.async {
//                MARK: Here enable capture button due to successfull setup
                self.isCameraButtonDisabled = false
            }
        }
    }
    
    public func focus(at focusPoint: CGPoint){
//        let focusPoint = self.videoPreviewLayer.captureDevicePointConverted(fromLayerPoint: point)

        let device = self.videoDeviceInput.device
        do {
            try device.lockForConfiguration()
            if device.isFocusPointOfInterestSupported {
                device.focusPointOfInterest = focusPoint
                device.exposurePointOfInterest = focusPoint
                device.exposureMode = .continuousAutoExposure
                device.focusMode = .continuousAutoFocus
                device.unlockForConfiguration()
            }
        }
        catch {
            print(error.localizedDescription)
        }
    }
    
    /// - Tag: Stop capture session
    
    public func stop(completion: (() -> ())? = nil) {
        sessionQueue.async {
            if self.isSessionRunning {
                if self.setupResult == .success {
                    self.session.stopRunning()
                    self.isSessionRunning = self.session.isRunning
                    
                    if !self.session.isRunning {
                        DispatchQueue.main.async {
                            self.isCameraButtonDisabled = true
                            self.isCameraUnavailable = true
                            completion?()
                        }
                    }
                }
            }
        }
    }
    
    /// - Tag: Start capture session
    
    public func start() {
//        We use our capture session queue to ensure our UI runs smoothly on the main thread.
        sessionQueue.async {
            if !self.isSessionRunning && self.isConfigured {
                switch self.setupResult {
                case .success:
                    self.session.startRunning()
                    self.isSessionRunning = self.session.isRunning
                    
                    if self.session.isRunning {
                        DispatchQueue.main.async {
                            self.isCameraButtonDisabled = false
                            self.isCameraUnavailable = false
                        }
                    }
                    
                case .configurationFailed:
                    
                    print("Camera unavailable on this device")

                    DispatchQueue.main.async {
                        self.error = .cameraUnavailable
                        self.isCameraButtonDisabled = true
                        self.isCameraUnavailable = true
                    }
            case .notAuthorized:
                print("Application not authorized to use camera")

                DispatchQueue.main.async {
                    self.error = .permissionDenied
                    self.isCameraButtonDisabled = true
                    self.isCameraUnavailable = true
                }
            }
            }
        }
    }
    
    public func set(zoom: CGFloat){
        let factor = zoom < 1 ? 1 : zoom
        let device = self.videoDeviceInput.device
        
        do {
            try device.lockForConfiguration()
            device.videoZoomFactor = factor
            device.unlockForConfiguration()
        }
        catch {
            print(error.localizedDescription)
        }
    }
    
    //    MARK: Capture Photo
    
    /// - Tag: CapturePhoto
    public func capturePhoto(saveToLibrary: Bool) {
        if self.setupResult == .success {
            self.isCameraButtonDisabled = true
            
            sessionQueue.async {
                if let photoOutputConnection = self.photoOutput.connection(with: .video) {
                    photoOutputConnection.videoOrientation = .portrait
                }
                var photoSettings = AVCapturePhotoSettings()
                
                // Capture HEIF photos when supported. Enable according to user settings and high-resolution photos.
                if  self.photoOutput.availablePhotoCodecTypes.contains(.hevc) {
                    photoSettings = AVCapturePhotoSettings(format: [AVVideoCodecKey: AVVideoCodecType.hevc])
                }
                
                // Sets the flash option for this capture.
                if self.videoDeviceInput.device.isFlashAvailable {
                    photoSettings.flashMode = self.flashMode
                }
                
                // ────────────────────────────────────────────────────────────────
                // iOS 16+ High‑Resolution Photos
                // ────────────────────────────────────────────────────────────────
                if #available(iOS 16.0, *) {
                    // 1) Opt in to the system’s high‑res pipeline:
                    photoSettings.isHighResolutionPhotoEnabled = true

                    // 2) (Optional) If you want to explicitly pin to the device's largest supported
                    //    resolution, read it from your AVCaptureDevice:
                    if let deviceInput = self.videoDeviceInput {
                        let dims = deviceInput.device.activeFormat.supportedMaxPhotoDimensions
                        if let maxDim = dims.last {
                            photoSettings.maxPhotoDimensions = maxDim
                            print("iOS 16+: maxPhotoDimensions set to \(maxDim.width)x\(maxDim.height)")
                        } else {
                            print("Warning: supportedMaxPhotoDimensions was empty.")
                        }
                    } else {
                        print("Warning: videoDeviceInput unavailable, skipping custom maxPhotoDimensions.")
                    }
                }
                // ────────────────────────────────────────────────────────────────
                    
                    // --- Using the exact 'if let' structure you provided ---
                    /* Alternative implementation using your exact snippet:
                    if let maxDimensions = self.photoOutput?.supportedMaxPhotoDimensions.last { // Use optional chaining for photoOutput
                         photoSettings.maxPhotoDimensions = maxDimensions
                         print("iOS 16+: Setting max photo dimensions to \(maxDimensions.width)x\(maxDimensions.height)") // Optional logging
                    } else {
                        print("Warning: Could not determine maximum supported photo dimensions for iOS 16+. Using default behavior.")
                        // Optional fallback here too
                    }
                    */
                     
                } else {
                    // Fallback for earlier iOS versions
                    photoSettings.isHighResolutionPhotoEnabled = true
                }
                
                
                
                // Sets the preview thumbnail pixel format
                if !photoSettings.__availablePreviewPhotoPixelFormatTypes.isEmpty {
                    photoSettings.previewPhotoFormat = [kCVPixelBufferPixelFormatTypeKey as String: photoSettings.__availablePreviewPhotoPixelFormatTypes.first!]
                }
                
                photoSettings.photoQualityPrioritization = .quality
                
                let photoCaptureProcessor = PhotoCaptureProcessor(withSaveToLibrary: saveToLibrary,
                                                                  requestedPhotoSettings: photoSettings,
                                                                  willCapturePhotoAnimation: { [weak self] in
                    // Tells the UI to flash the screen to signal that SwiftCamera took a photo.
                    DispatchQueue.main.async {
                        self?.willCapturePhoto = true
                    }
                    
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.25) {
                        self?.willCapturePhoto = false
                    }
                    
                }, completionHandler: { [weak self] (photoCaptureProcessor) in
                    // When the capture is complete, remove a reference to the photo capture delegate so it can be deallocated.
                    if let data = photoCaptureProcessor.photoData {
                        self?.photo = Photo(originalData: data)
                        print("passing photo")
                    } else {
                        print("No photo data")
                    }
                    
                    self?.isCameraButtonDisabled = false
                    
                    self?.sessionQueue.async {
                        self?.inProgressPhotoCaptureDelegates[photoCaptureProcessor.requestedPhotoSettings.uniqueID] = nil
                    }
                }, photoProcessingHandler: { [weak self] animate in
                    // Animates a spinner while photo is processing
                    if animate {
                        self?.shouldShowSpinner = true
                    } else {
                        self?.shouldShowSpinner = false
                    }
                })
                
                // The photo output holds a weak reference to the photo capture delegate and stores it in an array to maintain a strong reference.
                self.inProgressPhotoCaptureDelegates[photoCaptureProcessor.requestedPhotoSettings.uniqueID] = photoCaptureProcessor
                self.photoOutput.capturePhoto(with: photoSettings, delegate: photoCaptureProcessor)
            }
        }
    }



================================================
FILE: pdfexpert/Utils/Camera/ImageResizer.swift
================================================
//
//  ImageResizer.swift
//  SwiftCamera
//
//  Created by Rolando Rodriguez on 10/15/20.
//

import Foundation
import UIKit

enum ImageResizingError: Error {
    case cannotRetrieveFromURL
    case cannotRetrieveFromData
}

public struct ImageResizer {
    var targetWidth: CGFloat
    
    public func resize(at url: URL) -> UIImage? {
        guard let image = UIImage(contentsOfFile: url.path) else {
            return nil
        }
        
        return self.resize(image: image)
    }
    
    public func resize(image: UIImage) -> UIImage {
        let originalSize = image.size
        let targetSize = CGSize(width: targetWidth, height: targetWidth*originalSize.height/originalSize.width)
        let renderer = UIGraphicsImageRenderer(size: targetSize)
        return renderer.image { (context) in
            image.draw(in: CGRect(origin: .zero, size: targetSize))
        }
    }
    
    public func resize(data: Data) -> UIImage? {
        guard let image = UIImage(data: data) else {return nil}
        return resize(image: image )
    }
}

struct MemorySizer {
    static func size(of data: Data) -> String {
        let bcf = ByteCountFormatter()
        bcf.allowedUnits = [.useMB] // optional: restricts the units to MB only
        bcf.countStyle = .file
        let string = bcf.string(fromByteCount: Int64(data.count))
        return string
    }
}



================================================
FILE: pdfexpert/Utils/Camera/PhotoCaptureProcessor.swift
================================================
//
//  PhotoCaptureProcessor.swift
//  abseil
//
//  Created by Rolando Rodriguez on 10/15/20.
//

import Foundation
import Photos

class PhotoCaptureProcessor: NSObject {
    
    lazy var context = CIContext()

    private(set) var requestedPhotoSettings: AVCapturePhotoSettings
    
    private let saveToLibrary: Bool
    
    private let willCapturePhotoAnimation: () -> Void
    
    private let completionHandler: (PhotoCaptureProcessor) -> Void
    
    private let photoProcessingHandler: (Bool) -> Void
    
//    The actual captured photo's data
    var photoData: Data?
    
//    The maximum time lapse before telling UI to show a spinner
    private var maxPhotoProcessingTime: CMTime?
        
//    Init takes multiple closures to be called in each step of the photco capture process
    init(withSaveToLibrary saveToLibrary: Bool,
         requestedPhotoSettings: AVCapturePhotoSettings,
         willCapturePhotoAnimation: @escaping () -> Void,
         completionHandler: @escaping (PhotoCaptureProcessor) -> Void,
         photoProcessingHandler: @escaping (Bool) -> Void) {
        
        self.saveToLibrary = saveToLibrary
        self.requestedPhotoSettings = requestedPhotoSettings
        self.willCapturePhotoAnimation = willCapturePhotoAnimation
        self.completionHandler = completionHandler
        self.photoProcessingHandler = photoProcessingHandler
    }
}

extension PhotoCaptureProcessor: AVCapturePhotoCaptureDelegate {
    
    // This extension adopts AVCapturePhotoCaptureDelegate protocol methods.
    
    /// - Tag: WillBeginCapture
    func photoOutput(_ output: AVCapturePhotoOutput, willBeginCaptureFor resolvedSettings: AVCaptureResolvedPhotoSettings) {
        maxPhotoProcessingTime = resolvedSettings.photoProcessingTimeRange.start + resolvedSettings.photoProcessingTimeRange.duration
    }
    
    /// - Tag: WillCapturePhoto
    func photoOutput(_ output: AVCapturePhotoOutput, willCapturePhotoFor resolvedSettings: AVCaptureResolvedPhotoSettings) {
        DispatchQueue.main.async {
            self.willCapturePhotoAnimation()
        }
        
        guard let maxPhotoProcessingTime = maxPhotoProcessingTime else {
            return
        }
        
        // Show a spinner if processing time exceeds one second.
        let oneSecond = CMTime(seconds: 2, preferredTimescale: 1)
        if maxPhotoProcessingTime > oneSecond {
            DispatchQueue.main.async {
                self.photoProcessingHandler(true)
            }
        }
    }
    
    /// - Tag: DidFinishProcessingPhoto
    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
        
        DispatchQueue.main.async {
            self.photoProcessingHandler(false)
        }
        
        if let error = error {
            print("Error capturing photo: \(error)")
        } else {
            photoData = photo.fileDataRepresentation()
        }
    }
    
    //        MARK: Saves capture to photo library
    func saveToPhotoLibrary(_ photoData: Data) {
        
        PHPhotoLibrary.requestAuthorization { status in
            if status == .authorized {
                PHPhotoLibrary.shared().performChanges({
                    let options = PHAssetResourceCreationOptions()
                    let creationRequest = PHAssetCreationRequest.forAsset()
                    options.uniformTypeIdentifier = self.requestedPhotoSettings.processedFileType.map { $0.rawValue }
                    creationRequest.addResource(with: .photo, data: photoData, options: options)
                    
                    
                }, completionHandler: { _, error in
                    if let error = error {
                        print("Error occurred while saving photo to photo library: \(error)")
                    }
                    
                    DispatchQueue.main.async {
                        self.completionHandler(self)
                    }
                }
                )
            } else {
                DispatchQueue.main.async {
                    self.completionHandler(self)
                }
            }
        }
    }
    
    /// - Tag: DidFinishCapture
    func photoOutput(_ output: AVCapturePhotoOutput, didFinishCaptureFor resolvedSettings: AVCaptureResolvedPhotoSettings, error: Error?) {
        if let error = error {
            print("Error capturing photo: \(error)")
            DispatchQueue.main.async {
                self.completionHandler(self)
            }
            return
        } else {
            guard let data = photoData else {
                DispatchQueue.main.async {
                    self.completionHandler(self)
                }
                return
            }
            
            if self.saveToLibrary {
                self.saveToPhotoLibrary(data)
            } else {
                DispatchQueue.main.async {
                    self.completionHandler(self)
                }
            }
        }
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/Color+Extensions.swift
================================================
//
//  Color+Extensions.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 23/02/23.
//

import Foundation
import SwiftUI

extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // RGBA (32-bit)
            (r, g, b, a) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }

        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue:  Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/CoreGraphics+Extensions.swift
================================================
//
//  CoreGraphics+Extensions.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 07/09/23.
//

import Foundation

extension CGSize {
    var aspectRatio: CGFloat {
        return self.width / self.height
    }
    
    func clipToSize(
        _ clippingSize: CGSize,
        horizontalMargin: CGFloat = 0,
        verticalMargin: CGFloat = 0,
        keepAspectRatio: Bool = true
    ) -> CGSize {
        var clippedWidth: CGFloat = self.width
        var clippedHeight: CGFloat = self.height
        
        let maxHeight: CGFloat = clippingSize.height - horizontalMargin
        if clippedHeight > maxHeight {
            clippedHeight = maxHeight
            clippedWidth = clippedHeight * self.aspectRatio
        }
        
        let maxWidth: CGFloat = clippingSize.height - verticalMargin
        if clippedWidth > maxWidth {
            clippedWidth = maxWidth
            clippedHeight = clippedWidth / self.aspectRatio
        }
        
        return CGSize(width: clippedWidth, height: clippedHeight)
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/Enum+Extensions.swift
================================================
//
//  Enum+Extensions.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 09/03/23.
//

import Foundation

extension CaseIterable where Self: Equatable {
    
    static var totalCases: Int {
        return Self.allCases.count
    }
    
    var index: Int {
        return Array(Self.allCases).firstIndex(of: self)!
    }
    
    var next: Self? {
        let all = Self.allCases
        let idx = all.firstIndex(of: self)!
        let next = all.index(after: idx)
        return next != all.endIndex ? all[next] : nil
    }
    
    var previous: Self? {
        let all = Array(Self.allCases)
        let idx = all.firstIndex(of: self)!
        let previous = all.index(before: idx)
        return previous >= 0 ? all[previous] : nil
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/Foundation+Extensions.swift
================================================
//
//  Foundation+Extensions.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 03/05/23.
//

import Foundation

extension URL {
    static func getDocumentsDirectory() -> URL {
        let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
        return paths[0]
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/NSAttributedString+Extensions.swift
================================================
//
//  NSAttributedString+Extensions.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/08/23.
//

import Foundation

extension NSAttributedString {
     public func attributedStringByTrimmingCharacterSet(charSet: CharacterSet) -> NSAttributedString {
         let modifiedString = NSMutableAttributedString(attributedString: self)
        modifiedString.trimCharactersInSet(charSet: charSet)
         return NSAttributedString(attributedString: modifiedString)
     }
}

extension NSMutableAttributedString {
     public func trimCharactersInSet(charSet: CharacterSet) {
        var range = (string as NSString).rangeOfCharacter(from: charSet as CharacterSet)

         // Trim leading characters from character set.
         while range.length != 0 && range.location == 0 {
            replaceCharacters(in: range, with: "")
            range = (string as NSString).rangeOfCharacter(from: charSet)
         }

         // Trim trailing characters from character set.
        range = (string as NSString).rangeOfCharacter(from: charSet, options: .backwards)
         while range.length != 0 && NSMaxRange(range) == length {
            replaceCharacters(in: range, with: "")
            range = (string as NSString).rangeOfCharacter(from: charSet, options: .backwards)
         }
     }
}



================================================
FILE: pdfexpert/Utils/Extensions/ObservableObject+Extensions.swift
================================================
//
//  ObservableObject+Extensions.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/05/23.
//

import Foundation
import SwiftUI

@MainActor // <<< ADD THIS ANNOTATION
extension ObservableObject {
    func asyncSubject<T, E>(_ keyPath: WritableKeyPath<Self, AsyncOperation<T, E>>) -> Binding<AsyncOperation<T, E>> {
        let defaultValue = self[keyPath: keyPath]
        return .init(get: { [weak self] in
                self?[keyPath: keyPath] ?? defaultValue
            }, set: { [weak self] in
                self?[keyPath: keyPath] = $0
            })
        }
    }


























================================================
FILE: pdfexpert/Utils/Extensions/PDFAnnotation+Extensions.swift
================================================
//
//  PDFAnnotation+Extensions.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 30/05/23.
//

import Foundation
import PDFKit

private enum PDFCustomKey: String {
    case annotationType = "type"
}

private enum PDFAnnotationTypeValue: String {
    case signature = "signature"
}

extension PDFAnnotation {
    
    var text: String { self.contents ?? "" }
    
    var isTextAnnotation: Bool {
        guard let subType = self.annotationKeyValues[PDFAnnotationKey.subtype] as? PDFAnnotationSubtype, subType == PDFAnnotationSubtype.freeText else {
            return false
        }
        return true
    }
    
    var isWidgetAnnotation: Bool {
        guard let subType = self.annotationKeyValues[PDFAnnotationKey.subtype] as? PDFAnnotationSubtype, subType == PDFAnnotationSubtype.widget else {
            return false
        }
        return true
    }
    
    var isSignatureAnnotation: Bool {
        guard let subType = self.annotationKeyValues[PDFAnnotationKey.subtype] as? PDFAnnotationSubtype,
              subType == PDFAnnotationSubtype.stamp,
              self.annotationKeyValues.getCustomPdfValue(forKey: PDFCustomKey.annotationType.rawValue) == PDFAnnotationTypeValue.signature.rawValue else {
            return false
        }
        return true
    }
    
    var image: UIImage {
        let renderer = UIGraphicsImageRenderer(size: self.bounds.size)
        return renderer.image { ctx in
            
            ctx.cgContext.translateBy(x: -self.bounds.origin.x, y: self.bounds.origin.y)
            // Flip the context vertically because the Core Graphics coordinate system starts from the bottom.
            ctx.cgContext.translateBy(x: 0, y: self.bounds.size.height)
            ctx.cgContext.scaleBy(x: 1, y: -1)
            
            self.draw(with: .mediaBox, in: ctx.cgContext)
        }
    }
    
    var verticalCenteredTextBounds: CGRect {
        self.bounds.decode(forText: self.contents ?? "", withFont: self.font)
    }
    
    static func create(with text: String,
         forBounds bounds: CGRect,
         textColor: UIColor,
         fontName: String,
         withProperties properties: [AnyHashable : Any]?) -> PDFAnnotation {
        let font = UIFont.font(named: fontName, fitting: text, into: bounds.size, with: [:], options: [])
        let encodedBounds = bounds.encode(forText: text, withFont: font)
        let annotation = PDFAnnotation(bounds: encodedBounds, forType: PDFAnnotationSubtype.freeText,  withProperties: properties)
        annotation.fontColor = textColor
        annotation.color = .clear
        annotation.font = font
        annotation.alignment = .center
        annotation.contents = text
        return annotation
    }
    
    static func createSignature(with image: UIImage,
         forBounds bounds: CGRect) -> PDFAnnotation {
        var properties: [AnyHashable: Any] = [:]
        properties.addCustomPdfValue(PDFAnnotationTypeValue.signature.rawValue, forKey: PDFCustomKey.annotationType.rawValue)
        let annotation = ImageStampAnnotation(with: image, forBounds: bounds, withProperties: properties)
        return annotation
    }
}

fileprivate extension CGRect {
    
    static var safetyMargin: CGFloat { 10.0 }
    
    func encode(forText text: String, withFont font: UIFont?) -> CGRect {
        let size = text.boundingRect(font: font, with: [:], options: []).size
        let center = CGPoint(x: self.origin.x + self.size.width / 2, y: self.origin.y + self.size.height / 2)
        let origin = CGPoint(x: center.x - size.width / 2, y: center.y - size.height / 2)
        return CGRect(origin: origin, size: size)
            .inset(by: UIEdgeInsets(top: -Self.safetyMargin,
                                    left: -Self.safetyMargin,
                                    bottom: -Self.safetyMargin,
                                    right: -Self.safetyMargin))
    }
    
    func decode(forText text: String, withFont font: UIFont?) -> CGRect {
        return self
            .inset(by: UIEdgeInsets(top: Self.safetyMargin,
                                    left: Self.safetyMargin,
                                    bottom: Self.safetyMargin,
                                    right: Self.safetyMargin))
    }
}

fileprivate extension Dictionary where Key == AnyHashable, Value == Any {
    
    private static var keyPrefix: String { "PdfExpert" }
    
    mutating func addCustomPdfValue(_ value: Any, forKey key: AnyHashable) {
        self["\(Self.keyPrefix)_\(key)"] = value
    }
    
    func getCustomPdfValue<T>(forKey key: AnyHashable) -> T? {
        return self["/\(Self.keyPrefix)_\(key)"] as? T
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/PdfDocument+Extensions.swift
================================================
//
//  PdfDocument+Extensions.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 24/08/23.
//

import Foundation
import PDFKit

// 1. Wrapper Struct: *This struct* behaves like a Collection of PDFPages
public struct PDFPagesView: Collection {
    private let document: PDFDocument // Holds the document

    init(document: PDFDocument) { // Needs the document to work
        self.document = document
    }

    // Type Aliases: Matches original
    public typealias Index = Int
    public typealias Element = PDFPage

    // Required Properties: Matches original logic
    public var startIndex: Index { return 0 }
    public var endIndex: Index { return self.document.pageCount } // Accesses page count via stored document

    // Required Subscript: Matches original logic (safer unwrap)
    public subscript(index: Index) -> Element {
        // Calls page(at:) on the stored document. Uses guard for safety.
        guard let page = self.document.page(at: index) else {
            fatalError("Index \(index) out of bounds...") // Or handle error differently
        }
        return page
    }

    // Required Method: Matches original
    public func index(after i: Index) -> Index {
        return i + 1
    }

    // Optional but good additions (often get default implementations from Collection anyway)
    public var count: Int { return self.document.pageCount }
    public var isEmpty: Bool { return self.document.pageCount == 0 }

    // Implicitly Gains: All other Collection/Sequence methods
    // (e.g., for-in loops, .count, .isEmpty, .map, .filter, .first, .last, etc.)
    // These methods operate *on the PDFPagesView instance*.
}

// 2. Accessor Extension: How to *get* the wrapper from a PDFDocument
extension PDFDocument {
    public var pages: PDFPagesView {
        return PDFPagesView(document: self)
    }
}





================================================
FILE: pdfexpert/Utils/Extensions/PencilKit+Extensions.swift
================================================
//
//  PencilKit+Extensions.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 19/05/23.
//

import Foundation
import PencilKit

extension PKDrawing {
    
    /**
     Same behaviour as PKDrawing.image(from:scale:), with the only difference that the provided
     UIUserInterfaceStyle will be the one used as reference for color conversion upon image creation.
     
     This is useful to prevent unwanted automatic color conversion of dark colors to bright colors (and vice versa)
     in case of dark mode.
     */
    func image(from rect: CGRect, scale: CGFloat, userInterfaceStyle: UIUserInterfaceStyle) -> UIImage {
        let currentTraits = UITraitCollection.current
        UITraitCollection.current = UITraitCollection(userInterfaceStyle: userInterfaceStyle)
        let image = self.image(from: rect, scale: scale)
        UITraitCollection.current = currentTraits
        return image
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/StoreKit+Extensions.swift
================================================
//
//  StoreKit+Extensions.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 05/09/23.
//

import Foundation
import StoreKit

public extension Product {
    var isFreeTrial: Bool {
        self.subscription?.introductoryOffer?.paymentMode == .freeTrial
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/String+Extensions.swift
================================================
//
//  String+Extensions.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 06/03/23.
//

import Foundation
import UIKit

extension String {
    
    public var nilIfEmpty: String? {
        return self.isEmpty ? nil : self
    }
    
    public func capitalizingFirstLetter() -> String {
        return prefix(1).capitalized + dropFirst()
    }

    public mutating func capitalizeFirstLetter() {
        self = self.capitalizingFirstLetter()
    }
    
    public func boundingRect(font: UIFont?,
                             with attributes: [NSAttributedString.Key: Any],
                             options: NSStringDrawingOptions) -> CGRect {
        var attributes = attributes
        attributes[.font] = font
        return self.boundingRect(with: CGSize(width: CGFloat.greatestFiniteMagnitude,
                                              height: CGFloat.greatestFiniteMagnitude),
                                 options: options,
                                 attributes: attributes,
                                 context: nil)
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/UIApplication+Extensions.swift
================================================
//
//  UIApplication+Extensions.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 02/03/23.
//

import Foundation
import SwiftUI

extension UIApplication {
    static func dismissKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/UIFont+Extensions.swift
================================================
//
//  UIFont+Extensions.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 01/06/23.
//

import Foundation
import UIKit

extension UIFont {
    static func font(named fontName: String,
                     fitting text: String,
                     into targetSize: CGSize,
                     with attributes: [NSAttributedString.Key: Any],
                     options: NSStringDrawingOptions) -> UIFont {
        var attributes = attributes
        let fontSize = targetSize.height

        attributes[.font] = UIFont(name: fontName, size: fontSize)
        let size = text.boundingRect(with: CGSize(width: .greatestFiniteMagnitude, height: fontSize),
                                     options: options,
                                     attributes: attributes,
                                     context: nil).size

        let heightSize = targetSize.height / (size.height / fontSize)
        let widthSize = targetSize.width / (size.width / fontSize)
        let minSize = min(heightSize, widthSize)
        
        return UIFont(name: fontName, size: minSize) ?? .systemFont(ofSize: minSize)
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/URL+Extensions.swift
================================================
//
//  URL+Extensions.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/07/23.
//

import Foundation

extension URL {
    var filename: String {
        self.deletingPathExtension().lastPathComponent
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/View+Alert.swift
================================================
//
//  View+Alert.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 24/02/23.
//

import Foundation
import SwiftUI


extension View {
    func errorAlert<T, E>(asyncOperation: Binding<AsyncOperation<T, E>>, buttonTitle: String = "OK") -> some View {
        var localizedError: E? = nil
        switch asyncOperation.wrappedValue.status {
        case .error(let error): localizedError = error
        default: break
        }
        return alert("Error", isPresented: .constant(localizedError != nil), presenting: localizedError) { _ in
            Button(buttonTitle) {
                asyncOperation.wrappedValue = AsyncOperation(status: .empty)
            }
        } message: { localizedError in
            Text(localizedError.errorDescription ?? "")
        }
    }
    
    func errorAlert<T: AsyncFailable>(asyncFailable: Binding<T>, buttonTitle: String = "OK") -> some View {
        let localizedError: T.E? = asyncFailable.wrappedValue.error
        return alert("Error", isPresented: .constant(localizedError != nil), presenting: localizedError) { _ in
            Button(buttonTitle) {
                asyncFailable.wrappedValue = T.resetState
            }
        } message: { localizedError in
            Text(localizedError.errorDescription ?? "")
        }
    }
}



================================================
FILE: pdfexpert/Utils/Extensions/View+Extensions.swift
================================================
//
//  View+Extensions.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 10/03/23.
//

import Foundation
import SwiftUI

#if canImport(UIKit)
extension View {
    func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
}
#endif

extension View {
    
    func getCloseButton(color: Color, leftSide: Bool = true, padding: CGFloat? = nil, onClose: @escaping () -> ()) -> some View {
        VStack {
            HStack {
                if !leftSide {
                    Spacer()
                }
                Button(action: { onClose() }) {
                    Self.getSystemClose(color: color)
                }
                if leftSide {
                    Spacer()
                }
            }
            Spacer()
        }
        .padding(.all, padding)
    }
    
    func getEditButton(color: Color, font: Font, editMode: Binding<EditMode>) -> some View {
        VStack {
            HStack {
                Spacer()
                Button(action: {
                    withAnimation {
                        if editMode.wrappedValue == .active {
                            editMode.wrappedValue = .inactive
                        } else {
                            editMode.wrappedValue = .active
                        }
                    }
                }) {
                    Text(editMode.wrappedValue.text)
                        .font(font)
                        .foregroundColor(color)
                }
            }
            .padding(.trailing)
            Spacer()
        }
        .padding(.top)
    }
    
    @ViewBuilder func addCustomBackButton(color: Color, onPress: @escaping () -> ()) -> some View {
        self.navigationBarBackButtonHidden()
            .toolbar {
            ToolbarItem(placement: .navigationBarLeading) {
                Button(action: { onPress() }) {
                    Self.getSystemChevron(color: color, directionRight: false)
                }
            }
        }
    }
    
    static func getAttributedText(forUrlString urlString: String,
                                  text: String) -> AttributedString {
        var attributedString = try! AttributedString(markdown: "[\(text)](\(urlString))")
        attributedString.underlineStyle = .single
        return attributedString
    }
    
    static func getSystemChevron(color: Color, directionRight: Bool = true) -> some View {
        Image(systemName: directionRight ? "chevron.right" : "chevron.left")
            .font(.system(size: 20, weight: .medium, design: .default))
            .foregroundColor(color)
    }
    
    static func getSystemClose(color: Color) -> some View {
        Image(systemName: "xmark")
            .font(.system(size: 16).bold())
            .foregroundColor(color)
    }
    
    func addSystemCloseButton(color: Color, onPress: @escaping () -> ()) -> some View {
        self.navigationBarBackButtonHidden()
            .toolbar {
            ToolbarItem(placement: .navigationBarLeading) {
                Button(action: { onPress() }) {
                    Self.getSystemClose(color: color)
                }
            }
        }
    }
    
    /// Applies the given transform if the given condition evaluates to `true`.
    /// - Parameters:
    ///   - condition: The condition to evaluate.
    ///   - transform: The transform to apply to the source `View`.
    /// - Returns: Either the original `View` or the modified `View` if the condition is `true`.
    @ViewBuilder func `if`<Content: View>(_ condition: Bool, transform: (Self) -> Content) -> some View {
        if condition {
            transform(self)
        } else {
            self
        }
    }
    
    @ViewBuilder func actionDialog<A>(_ title: Text,
                                      isPresented: Binding<Bool>,
                                      titleVisibility: Visibility = .automatic,
                                      @ViewBuilder actions: () -> A) -> some View where A : View {
        // This platform branching is needed because, on iPad, confirmationDialog brokes interaction subsequent modals
        // See: http://openradar.appspot.com/radar?id=5597349300666368
        if UIDevice.current.userInterfaceIdiom == .pad {
            self.alert(title, isPresented: isPresented, actions: actions)
        } else {
            self.confirmationDialog(title, isPresented: isPresented, titleVisibility: titleVisibility, actions: actions)
        }
    }
    
    var isScrollToAvailable: Bool {
        if UIDevice.current.userInterfaceIdiom == .pad {
            // ScrollViewProxy.scrollTo() method crashes on certain conditions on iPadOS < 16.4.1
            // https://developer.apple.com/forums/thread/712510
            if #available(iOS 16.4.1, *) {
                return true
            } else {
                return false
            }
        } else {
            return true
        }
    }
}

extension Binding where Value == String {
    func max(_ limit: Int) -> Self {
        if self.wrappedValue.count > limit {
            DispatchQueue.main.async {
                self.wrappedValue = String(self.wrappedValue.dropLast())
            }
        }
        return self
    }
}

fileprivate extension EditMode {
    var text: String {
        switch self {
        case .active: return "Done"
        case .inactive: return "Edit"
        case .transient: return ""
        @unknown default: return ""
        }
    }
}



================================================
FILE: pdfexpert/Utils/Protocols/.DS_Store
================================================
[Non-text file]


================================================
FILE: pdfexpert/Utils/UI/ActivityViewController.swift
================================================
//
//  ActivityViewController.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 30/03/23.
//

import SwiftUI
import UIKit
import LinkPresentation


struct ActivityViewController: UIViewControllerRepresentable {

    var activityItems: [Any]
    var applicationActivities: [UIActivity]? = nil
    var thumbnail: UIImage? = nil
    var title: String
    
    @Environment(\.presentationMode) var presentationMode

    func makeUIViewController(context: UIViewControllerRepresentableContext<ActivityViewController>) -> UIActivityViewController {
        var activityItems: [Any] = self.activityItems
        activityItems.append(self.makeCoordinator())
        let controller = UIActivityViewController(activityItems: activityItems,
                                                  applicationActivities: self.applicationActivities)
        controller.completionWithItemsHandler = { (activityType, completed, returnedItems, error) in
            self.presentationMode.wrappedValue.dismiss()
        }
        return controller
    }

    func updateUIViewController(_ uiViewController: UIActivityViewController, context: UIViewControllerRepresentableContext<ActivityViewController>) {}
    
    func makeCoordinator() -> ActivityCoordinator {
        ActivityCoordinator(thumbnail: self.thumbnail, title: self.title)
    }
}

class ActivityCoordinator: NSObject, UIActivityItemSource {
    
    private let thumbnail: UIImage?
    private let title: String

    init(thumbnail: UIImage?, title: String) {
        self.thumbnail = thumbnail
        self.title = title
    }
    
    func activityViewControllerPlaceholderItem(_ activityViewController: UIActivityViewController) -> Any {
        return ""
    }

    func activityViewController(_ activityViewController: UIActivityViewController, itemForActivityType activityType: UIActivity.ActivityType?) -> Any? {
        return nil
    }

    func activityViewControllerLinkMetadata(_ activityViewController: UIActivityViewController) -> LPLinkMetadata? {
        let metadata = LPLinkMetadata()
        if let thumbnail {
            metadata.imageProvider = NSItemProvider(object: thumbnail)
        }
        metadata.title = self.title
        return metadata
    }
}

struct ActivityViewController_Previews: PreviewProvider {
    static var previews: some View {
        ActivityViewController(activityItems: [URL(string: "https://www.apple.com")!], title: "Test File")
    }
}



================================================
FILE: pdfexpert/Utils/UI/AsyncView.swift
================================================
//
//  AsyncView.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 02/03/23.
//

import Foundation
import SwiftUI

extension View {
    
    func asyncView<DataType, ErrorType: LocalizedError>(
        asyncOperation: Binding<AsyncOperation<DataType, ErrorType>>) -> some View {
        return self.modifier(
            AsyncView(asyncOperation: asyncOperation, loadingView: { ProgressView() })
        )
    }
    
    func asyncView<LoadingView: View, DataType, ErrorType: LocalizedError>(
        asyncOperation: Binding<AsyncOperation<DataType, ErrorType>>,
        @ViewBuilder loadingView: @escaping () -> LoadingView) -> some View {
        return self.modifier(
            AsyncView(asyncOperation: asyncOperation, loadingView: loadingView)
        )
    }
}

struct AsyncView<LoadingView: View, DataType, ErrorType: LocalizedError>: ViewModifier {
    
    @Binding var asyncOperation: AsyncOperation<DataType, ErrorType>
    
    var loadingView: (() -> LoadingView)
    
    init(asyncOperation: Binding<AsyncOperation<DataType, ErrorType>>,
         loadingView: @escaping (() -> LoadingView)) {
        self._asyncOperation = asyncOperation
        self.loadingView = loadingView
    }
    
    func body(content: Content) -> some View {
        ZStack {
            content
                .allowsHitTesting(!self.asyncOperation.isLoading)
            self.additionalContent
        }.errorAlert(asyncOperation: self.$asyncOperation)
    }
    
    @ViewBuilder var additionalContent: some View {
        switch self.asyncOperation.status {
        case .empty: Spacer()
        case .loading:
            Color(.black).opacity(0.5)
                .edgesIgnoringSafeArea(.all)
            self.loadingView()
        case .error: Spacer()
        case .data:  Spacer()
        }
    }
}

fileprivate enum AsyncViewError: LocalizedError {}

struct AsyncView_Previews: PreviewProvider {
    
    @State fileprivate static var testAsyncOperation = AsyncOperation<Void, AsyncViewError>(status: .loading(Progress(totalUnitCount: 1)))
    
    static var previews: some View {
        Color(.white)
            .asyncView(asyncOperation: $testAsyncOperation)
    }
}





extension View {
    
    func asyncView<AsyncItem: AsyncFailable & AsyncLoadable>(
        asyncItem: Binding<AsyncItem>) -> some View {
            return self
                .asyncFailableView(asyncItem: asyncItem)
                .asyncLoadableView(asyncItem: asyncItem, loadingView: { ProgressView() })
    }
    
    func asyncView<LoadingView: View, AsyncItem: AsyncFailable & AsyncLoadable>(
        asyncItem: Binding<AsyncItem>,
        @ViewBuilder loadingView: @escaping () -> LoadingView) -> some View {
            return self
                .asyncFailableView(asyncItem: asyncItem)
                .asyncLoadableView(asyncItem: asyncItem, loadingView: loadingView)
    }
    
    func asyncView<AsyncItem: AsyncFailable>(
        asyncItem: Binding<AsyncItem>) -> some View {
            return self
                .asyncFailableView(asyncItem: asyncItem)
    }
    
    func asyncView<AsyncItem: AsyncLoadable>(
        asyncItem: Binding<AsyncItem>) -> some View {
            return self
                .asyncLoadableView(asyncItem: asyncItem, loadingView: { ProgressView() })
    }
    
    func asyncView<LoadingView: View, AsyncItem: AsyncLoadable>(
        asyncItem: Binding<AsyncItem>,
        @ViewBuilder loadingView: @escaping () -> LoadingView) -> some View {
            return self
                .asyncLoadableView(asyncItem: asyncItem, loadingView: loadingView)
    }
    
    func asyncFailableView<AsyncItem: AsyncFailable>(
        asyncItem: Binding<AsyncItem>) -> some View {
        return self.modifier(
            AsyncFailableView(asyncItem: asyncItem)
        )
    }
    
    func asyncLoadableView<LoadingView: View, AsyncItem: AsyncLoadable>(
        asyncItem: Binding<AsyncItem>,
        @ViewBuilder loadingView: @escaping () -> LoadingView) -> some View {
        return self.modifier(
            AsyncLoadableView(asyncItem: asyncItem, loadingView: loadingView)
        )
    }
}

struct AsyncFailableView<AsyncItem: AsyncFailable>: ViewModifier {
    
    @Binding var asyncItem: AsyncItem
    
    init(asyncItem: Binding<AsyncItem>) {
        self._asyncItem = asyncItem
    }
    
    func body(content: Content) -> some View {
        content.errorAlert(asyncFailable: self.$asyncItem)
    }
}

struct AsyncLoadableView<LoadingView: View, AsyncItem: AsyncLoadable>: ViewModifier {
    
    @Binding var asyncItem: AsyncItem
    
    var loadingView: (() -> LoadingView)
    
    init(asyncItem: Binding<AsyncItem>, loadingView: @escaping (() -> LoadingView)) {
        self._asyncItem = asyncItem
        self.loadingView = loadingView
    }
    
    func body(content: Content) -> some View {
        ZStack {
            content.allowsHitTesting(!self.asyncItem.isLoading)
            if self.asyncItem.isLoading {
                Color(.black).opacity(0.5)
                    .edgesIgnoringSafeArea(.all)
                self.loadingView()
            }
        }
    }
}



================================================
FILE: pdfexpert/Utils/UI/CircularProgressView.swift
================================================
//
//  CircularProgressView.swift
//  StoryKidsAI
//
//  Created by Pcnaid Inc on 08/03/23.
//

import SwiftUI

struct CircularProgressView: View {
    
    let foregroundColor: Color
    let backgroundColor: Color
    let width: CGFloat
    let progress: Double
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(
                    self.backgroundColor,
                    lineWidth: self.width
                )
            Circle()
                .trim(from: 0, to: self.progress)
                .stroke(
                    self.foregroundColor,
                    style: StrokeStyle(
                        lineWidth: self.width,
                        lineCap: .round
                    )
                )
                .rotationEffect(.degrees(-90))
                .animation(.easeOut, value: self.progress)

        }
    }
}

struct CircularProgressView_Previews: PreviewProvider {
    static var previews: some View {
        CircularProgressView(foregroundColor: .black,
                             backgroundColor: .gray,
                             width: 20,
                             progress: 0.4)
        .previewLayout(PreviewLayout.fixed(width: 200, height: 200))
        .padding()
    }
}



================================================
FILE: pdfexpert/Utils/UI/FilePicker.swift
================================================
//
//  FilePicker.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 29/03/23.
//

import Foundation
import SwiftUI
import UIKit
import UniformTypeIdentifiers.UTType

typealias FilePickerCallback = ([URL]) -> ()

struct FilePicker: UIViewControllerRepresentable {
    
    let fileTypes: [UTType]
    let multipleSelection: Bool
    let onPickedFiles: FilePickerCallback
    
    func makeUIViewController(context: Context) -> some UIViewController {
        let controller = UIDocumentPickerViewController(forOpeningContentTypes: self.fileTypes, asCopy: true)
        controller.allowsMultipleSelection = self.multipleSelection
        controller.shouldShowFileExtensions = true
        controller.view.backgroundColor = UIColor(ColorPalette.primaryBG)
        controller.delegate = context.coordinator
        return controller
    }
    
    func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) {
        
    }
    
    func makeCoordinator() -> FilePickerCoordinator {
        FilePickerCoordinator(onPickedFiles: self.onPickedFiles)
    }
}

class FilePickerCoordinator: NSObject, UIDocumentPickerDelegate {
    
    let onPickedFiles: FilePickerCallback

    init(onPickedFiles: @escaping FilePickerCallback) {
        self.onPickedFiles = onPickedFiles
    }
    
    func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
        self.onPickedFiles(urls)
    }
}

extension View {
    @ViewBuilder func filePicker(isPresented: Binding<Bool>,
                                 fileTypes: [UTType],
                                 multipleSelection: Bool = false,
                                 onPickedFiles: @escaping FilePickerCallback) -> some View {
        if UIDevice.current.userInterfaceIdiom == .pad {
            self.sheet(isPresented: isPresented) {
                FilePicker(fileTypes: fileTypes, multipleSelection: multipleSelection, onPickedFiles: onPickedFiles)
            }
        } else {
            self.fullScreenCover(isPresented: isPresented) {
                FilePicker(fileTypes: fileTypes, multipleSelection: multipleSelection, onPickedFiles: onPickedFiles)
            }
        }
    }
}

protocol FilePickerTypeProvider: Identifiable {
    var fileTypes: [UTType] { get }
}

extension View {
    @ViewBuilder func filePicker<Item: FilePickerTypeProvider>(item: Binding<Item?>,
                                                               multipleSelection: Bool = false,
                                                               onPickedFiles: @escaping FilePickerCallback) -> some View {
        if UIDevice.current.userInterfaceIdiom == .pad {
            self.sheet(item: item) {
                FilePicker(fileTypes: $0.fileTypes, multipleSelection: multipleSelection, onPickedFiles: onPickedFiles)
            }
        } else {
            self.fullScreenCover(item: item) {
                FilePicker(fileTypes: $0.fileTypes, multipleSelection: multipleSelection, onPickedFiles: onPickedFiles)
            }
        }
    }
}



================================================
FILE: pdfexpert/Utils/UI/FormSheet.swift
================================================
//
//  FormSheet.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 14/06/23.
//

import SwiftUI

// MARK: - FormSheet Boolean

class FormSheetWrapper<Content: View>: UIViewController, UIPopoverPresentationControllerDelegate {

    var size: CGSize
    var content: () -> Content
    var onDismiss: (() -> Void)?

    private var hostVC: UIHostingController<Content>?

    required init?(coder: NSCoder) { fatalError("") }

    init(size: CGSize, content: @escaping () -> Content) {
        self.size = size
        self.content = content
        super.init(nibName: nil, bundle: nil)
    }

    func show() {
        guard hostVC == nil else { return }
        let vc = UIHostingController(rootView: content())

        vc.preferredContentSize = self.size
        vc.modalPresentationStyle = .formSheet
        vc.presentationController?.delegate = self
        hostVC = vc
        self.present(vc, animated: true, completion: nil)
    }

    func hide() {
        guard let vc = self.hostVC, !vc.isBeingDismissed else { return }
        dismiss(animated: true, completion: nil)
        hostVC = nil
    }
    
    func presentationControllerDidDismiss(_ presentationController: UIPresentationController) {
        hostVC = nil
        self.onDismiss?()
    }
}

struct FormSheet<Content: View> : UIViewControllerRepresentable {

    @Binding var show: Bool
    let size: CGSize

    let content: () -> Content

    func makeUIViewController(context: UIViewControllerRepresentableContext<FormSheet<Content>>) -> FormSheetWrapper<Content> {

        let vc = FormSheetWrapper(size: self.size, content: content)
        vc.onDismiss = { self.show = false }
        return vc
    }

    func updateUIViewController(_ uiViewController: FormSheetWrapper<Content>,
                                context: UIViewControllerRepresentableContext<FormSheet<Content>>) {
        if self.show {
            uiViewController.show()
        }
        else {
            uiViewController.hide()
        }
    }
}

// MARK: - FormSheet Identifiable

public protocol FormSheetItem: Identifiable {
    var viewSize: CGSize { get }
}

class FormSheetWrapperIdentifiable<Content: View, Item: FormSheetItem>: UIViewController, UIPopoverPresentationControllerDelegate {
    
    var content: (Item) -> Content
    var onDismiss: (() -> Void)?

    private var hostVC: UIHostingController<Content>?

    required init?(coder: NSCoder) { fatalError("") }

    init(content: @escaping (Item) -> Content) {
        self.content = content
        super.init(nibName: nil, bundle: nil)
    }

    func show(item: Item) {
        guard hostVC == nil else { return }
        let vc = UIHostingController(rootView: content(item))

        vc.preferredContentSize = item.viewSize
        vc.modalPresentationStyle = .formSheet
        vc.presentationController?.delegate = self
        hostVC = vc
        self.present(vc, animated: true, completion: nil)
    }

    func hide() {
        guard let vc = self.hostVC, !vc.isBeingDismissed else { return }
        dismiss(animated: true, completion: nil)
        hostVC = nil
    }

    func presentationControllerDidDismiss(_ presentationController: UIPresentationController) {
        hostVC = nil
        self.onDismiss?()
    }
}

struct FormSheetIdentifiable<Content: View, Item: FormSheetItem> : UIViewControllerRepresentable {

    @Binding var item: Item?

    let content: (Item) -> Content

    func makeUIViewController(context: UIViewControllerRepresentableContext<FormSheetIdentifiable<Content, Item>>) -> FormSheetWrapperIdentifiable<Content, Item> {

        let vc = FormSheetWrapperIdentifiable(content: content)
        vc.onDismiss = { self.item = nil }
        return vc
    }

    func updateUIViewController(_ uiViewController: FormSheetWrapperIdentifiable<Content, Item>,
                                context: UIViewControllerRepresentableContext<FormSheetIdentifiable<Content, Item>>) {
        if let item = self.item {
            uiViewController.show(item: item)
        }
        else {
            uiViewController.hide()
        }
    }
}

// MARK: - View Extensions

extension View {
    @ViewBuilder public func formSheet<Content: View>(isPresented: Binding<Bool>,
                                                      size: CGSize,
                                                      @ViewBuilder content: @escaping () -> Content) -> some View {
        if UIDevice.current.userInterfaceIdiom == .pad {
            self.background(FormSheet(show: isPresented,
                                      size: size,
                                      content: content))
        } else {
            self.sheet(isPresented: isPresented) {
                content()
                    .presentationDetents([.height(size.height)])
            }
        }
    }
    
    @ViewBuilder public func formSheet<Content: View, Item: FormSheetItem>(item: Binding<Item?>,
                                                                          @ViewBuilder content: @escaping (Item) -> Content) -> some View {
        if UIDevice.current.userInterfaceIdiom == .pad {
            self.background(FormSheetIdentifiable(item: item,
                                                  content: content))
        } else {
            self.sheet(item: item) { item in
                content(item)
                    .presentationDetents([.height(item.viewSize.height)])
            }
        }
    }
}



================================================
FILE: pdfexpert/Utils/UI/FullScreenClearBackground.swift
================================================
//
//  FullScreenClearBackground.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 10/08/23.
//

import Foundation
import SwiftUI

struct FullScreenClearBackground: UIViewControllerRepresentable {
    
    public func makeUIViewController(context: UIViewControllerRepresentableContext<Self>) -> UIViewController {
        return Controller()
    }
    
    public func updateUIViewController(_ uiViewController: UIViewController, context: UIViewControllerRepresentableContext<Self>) {
    }
    
    class Controller: UIViewController {
        
        override func viewDidLoad() {
            super.viewDidLoad()
            self.view.backgroundColor = .clear
        }
        
        override func willMove(toParent parent: UIViewController?) {
            super.willMove(toParent: parent)
            parent?.view?.backgroundColor = .clear
            parent?.modalPresentationStyle = .overCurrentContext
        }
    }
}

extension View {
    @ViewBuilder public func sheetAutoHeight<Content: View>(isPresented: Binding<Bool>,
                                                            backgroundColor: Color,
                                                            topCornerRadius: CGFloat = 0,
                                                            @ViewBuilder content: @escaping () -> Content) -> some View {
        self.fullScreenCover(isPresented: isPresented) {
            Button(action: { isPresented.wrappedValue = false }) {
                self.getContentView(backgroundColor: backgroundColor,
                                    topCornerRadius: topCornerRadius,
                                    content: { content() })
            }
            .background(FullScreenClearBackground())
        }
    }
    
    @ViewBuilder public func sheetAutoHeight<Content: View, Item: Identifiable>(item: Binding<Item?>,
                                                            backgroundColor: Color,
                                                            topCornerRadius: CGFloat = 0,
                                                            @ViewBuilder content: @escaping (Item) -> Content) -> some View {
        self.fullScreenCover(item: item) { unwrappedItem in
            Button(action: { item.wrappedValue = nil }) {
                self.getContentView(backgroundColor: backgroundColor,
                                    topCornerRadius: topCornerRadius,
                                    content: { content(unwrappedItem) })
            }
            .background(FullScreenClearBackground())
        }
    }
    
    @ViewBuilder private func getContentView<Content: View>(backgroundColor: Color,
                                                            topCornerRadius: CGFloat,
                                                            @ViewBuilder content: @escaping () -> Content) -> some View {
        VStack(spacing: 0) {
            Spacer()
            if topCornerRadius > 0 {
                backgroundColor.frame(height: topCornerRadius * 2)
                    .cornerRadius(topCornerRadius, corners: [.topLeft, .topRight])
            }
            content()
                .background(backgroundColor)
        }
    }
}



================================================
FILE: pdfexpert/Utils/UI/ImageAnnotationStamp.swift
================================================
//
//  ImageAnnotationStamp.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 10/05/23.
//

import Foundation
import UIKit
import PDFKit

class ImageStampAnnotation: PDFAnnotation {
    
    private let stampImage: UIImage?
    
    init(with image: UIImage, forBounds bounds: CGRect, withProperties properties: [AnyHashable : Any]?) {
        self.stampImage = image
        super.init(bounds: bounds, forType: PDFAnnotationSubtype.stamp,  withProperties: properties)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func draw(with box: PDFDisplayBox, in context: CGContext)   {
        guard let cgImage = self.stampImage?.cgImage else { return }
        context.draw(cgImage, in: self.bounds)
    }
}



================================================
FILE: pdfexpert/Utils/UI/ImageResizableView.swift
================================================
//
//  ImageResizableView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 16/05/23.
//

import SwiftUI
import UIKit

struct ImageResizableView: View {
    
    enum HandlePosition { case bottomLeft, bottomRight, topLeft, topRight }
    
    let uiImage: UIImage
    @Binding var imageRect: CGRect
    let borderColor: Color
    let borderWidth: CGFloat
    let handleColor: Color
    let handleSize: CGFloat
    let handleTapSize: CGFloat
    let keepAspectRatio: Bool
    
    @State var tapImageOffset: CGPoint? = nil
    
    private var topLeft: CGPoint {
        self.imageRect.origin
    }
    
    private var topRight: CGPoint {
        CGPoint(x: self.imageRect.origin.x + self.imageRect.size.width,
                y: self.imageRect.origin.y)
    }
    
    private var bottomLeft: CGPoint {
        CGPoint(x: self.imageRect.origin.x,
                y: self.imageRect.origin.y + self.imageRect.size.height)
    }
    
    private var bottomRight: CGPoint {
        CGPoint(x: self.imageRect.origin.x + self.imageRect.size.width,
                y: self.imageRect.origin.y + self.imageRect.size.height)
    }
    
    private var computedCenter: CGPoint {
        CGPoint(x: self.topLeft.x + (self.bottomRight.x - self.topLeft.x) / 2,
                y: self.topLeft.y + (self.bottomRight.y - self.topLeft.y) / 2)
    }
    
    private var computedSize: CGSize {
        CGSize(width: self.bottomRight.x - self.topLeft.x,
               height: self.bottomRight.y - self.topLeft.y)
    }
    
    init(uiImage: UIImage,
         imageRect: Binding<CGRect>,
         borderColor: Color,
         borderWidth: CGFloat,
         handleColor: Color,
         handleSize: CGFloat,
         handleTapSize: CGFloat,
         keepAspectRatio: Bool) {
        self.uiImage = uiImage
        self._imageRect = imageRect
        self.borderColor = borderColor
        self.borderWidth = borderWidth
        self.handleColor = handleColor
        self.handleSize = handleSize
        self.handleTapSize = handleTapSize
        self.keepAspectRatio = keepAspectRatio
    }
    
    var body: some View {
        GeometryReader { parentGeometryReader in
            ZStack {
                GeometryReader { _ in
                    Image(uiImage: self.uiImage)
                        .resizable()
                        .background(Rectangle().stroke(self.borderColor, lineWidth: self.borderWidth))
                        .position(self.computedCenter)
                        .frame(width: self.computedSize.width, height: self.computedSize.height)
                        .gesture(
                            DragGesture()
                                .onChanged { gesture in
                                    self.OnDragImage(dragGestureValue: gesture,
                                                     parentViewSize: parentGeometryReader.size)
                                }
                                .onEnded { _ in self.tapImageOffset = nil }
                        )
                }
                self.getHandle(handlePosition: .bottomLeft,
                               parentViewSize: parentGeometryReader.size)
                self.getHandle(handlePosition: .bottomRight,
                               parentViewSize: parentGeometryReader.size)
                self.getHandle(handlePosition: .topLeft,
                               parentViewSize: parentGeometryReader.size)
                self.getHandle(handlePosition: .topRight,
                               parentViewSize: parentGeometryReader.size)
            }
        }
    }
    
    private func OnDragImage(dragGestureValue: DragGesture.Value, parentViewSize: CGSize) {
        
        let location = dragGestureValue.location
        let center = self.computedCenter
        let size = self.computedSize
        
        if self.tapImageOffset == nil {
            self.tapImageOffset = CGPoint(x: dragGestureValue.startLocation.x - center.x,
                                          y: dragGestureValue.startLocation.y - center.y)
        }
        
        guard let tapImageOffset = self.tapImageOffset else {
            return
        }
        
        var newCenterX = location.x - tapImageOffset.x
        newCenterX = max(min(newCenterX, parentViewSize.width - size.width / 2), size.width / 2)
        var newCenterY = location.y - tapImageOffset.y
        newCenterY = max(min(newCenterY, parentViewSize.height - size.height / 2), size.height / 2)
        
        let currentEventTranslation: CGPoint = CGPoint(x: newCenterX - center.x,
                                                       y: newCenterY - center.y)
        let bottomRight = CGPoint(x: self.bottomRight.x + currentEventTranslation.x,
                                  y: self.bottomRight.y + currentEventTranslation.y)
        let topLeft = CGPoint(x: self.topLeft.x + currentEventTranslation.x,
                              y: self.topLeft.y + currentEventTranslation.y)
        self.updateRect(topLeft: topLeft, bottomRight: bottomRight)
    }
    
    private func OnDrag(handlePosition: HandlePosition,
                        dragGestureValue: DragGesture.Value,
                        parentViewSize: CGSize) {
        
        let location = self.getDragLocation(originalDragLocation: dragGestureValue.location,
                                            handle: handlePosition)
        
        var bottomRight: CGPoint = .zero
        var topLeft: CGPoint = .zero
        
        switch handlePosition {
        case .bottomLeft:
            var bottomLeft = CGPoint(x: location.x,
                                     y: location.y)
                .getBoundedPoint(containerSize: parentViewSize,
                                 margin: self.handleSize / 2,
                                 keepAspectRatio: self.keepAspectRatio,
                                 originalPoint: self.bottomLeft)
            bottomLeft = CGPoint(
                x: min(bottomLeft.x, self.bottomRight.x - self.handleSize),
                y: max(bottomLeft.y, self.topLeft.y + self.handleSize)
            )
            bottomRight = CGPoint(x: self.bottomRight.x, y: bottomLeft.y)
            topLeft = CGPoint(x: bottomLeft.x, y: self.topLeft.y)
        case .bottomRight:
            bottomRight = CGPoint(x: location.x,
                                  y: location.y)
            .getBoundedPoint(containerSize: parentViewSize,
                             margin: self.handleSize / 2,
                             keepAspectRatio: self.keepAspectRatio,
                             originalPoint: self.bottomRight)
            bottomRight = CGPoint(
                x: max(bottomRight.x, self.topLeft.x + self.handleSize),
                y: max(bottomRight.y, self.topLeft.y + self.handleSize)
            )
            topLeft = self.topLeft
        case .topLeft:
            topLeft = CGPoint(x: location.x,
                              y: location.y)
            .getBoundedPoint(containerSize: parentViewSize,
                             margin: self.handleSize / 2,
                             keepAspectRatio: self.keepAspectRatio,
                             originalPoint: self.topLeft)
            topLeft = CGPoint(
                x: min(topLeft.x, self.bottomRight.x - self.handleSize),
                y: min(topLeft.y, self.bottomRight.y - self.handleSize)
            )
            bottomRight = self.bottomRight
        case .topRight:
            var topRight = CGPoint(x: location.x,
                                   y: location.y)
                .getBoundedPoint(containerSize: parentViewSize,
                                 margin: self.handleSize / 2,
                                 keepAspectRatio: self.keepAspectRatio,
                                 originalPoint: self.topRight)
            topRight = CGPoint(
                x: max(topRight.x, self.topLeft.x + self.handleSize),
                y: min(topRight.y, self.bottomRight.y - self.handleSize)
            )
            bottomRight = CGPoint(x: topRight.x, y: self.bottomRight.y)
            topLeft = CGPoint(x: self.topLeft.x, y: topRight.y)
        }
        self.updateRect(topLeft: topLeft, bottomRight: bottomRight)
    }
    
    private func getHandle(handlePosition: HandlePosition,
                           parentViewSize: CGSize) -> some View {
        Group {
            Circle()
                .frame(width: self.handleSize, height: self.handleSize)
                .foregroundColor(self.handleColor)
        }
        .frame(width: self.handleTapSize, height: self.handleTapSize)
        .contentShape(Circle())
        .position(handlePosition.getPosition(forParentViewSize: self.computedSize,
                                             parentCenter: self.computedCenter))
        .gesture(
            DragGesture()
                .onChanged { gesture in
                    self.OnDrag(handlePosition: handlePosition,
                                dragGestureValue: gesture,
                                parentViewSize: parentViewSize)
                }
        )
    }
    
    private func updateRect(topLeft: CGPoint, bottomRight: CGPoint) {
        self.imageRect = CGRect(x: topLeft.x,
                                y: topLeft.y,
                                width: bottomRight.x - topLeft.x,
                                height: bottomRight.y - topLeft.y)
    }
    
    private func getDragLocation(originalDragLocation: CGPoint, handle: HandlePosition) -> CGPoint {
        guard self.keepAspectRatio else {
            return originalDragLocation
        }
        
        let line = {
            switch handle {
            case .bottomLeft, .topRight:
                return MathUtils.getLine(ofLinePassingThrough: self.bottomLeft, and: self.topRight)
            case .bottomRight, .topLeft:
                return MathUtils.getLine(ofLinePassingThrough: self.bottomRight, and: self.topLeft)
            }
        }()
        return line.closestPoint(toPoint: originalDragLocation)
    }
}

fileprivate extension ImageResizableView.HandlePosition {
    func getPosition(forParentViewSize parentViewSize: CGSize, parentCenter: CGPoint) -> CGPoint {
        switch self {
        case .bottomLeft: return CGPoint(x: parentCenter.x - parentViewSize.width / 2,
                                         y: parentCenter.y + parentViewSize.height / 2)
        case .bottomRight: return CGPoint(x: parentCenter.x + parentViewSize.width / 2,
                                          y: parentCenter.y + parentViewSize.height / 2)
        case .topLeft: return CGPoint(x: parentCenter.x - parentViewSize.width / 2,
                                      y: parentCenter.y - parentViewSize.height / 2)
        case .topRight: return CGPoint(x: parentCenter.x + parentViewSize.width / 2,
                                       y: parentCenter.y - parentViewSize.height / 2)
        }
    }
}

fileprivate extension CGPoint {
    func getBoundedPoint(containerSize: CGSize,
                         margin: CGFloat,
                         keepAspectRatio: Bool,
                         originalPoint: CGPoint) -> CGPoint {
        if keepAspectRatio {
            // If aspect ratio must be kept, discard any change outside margins.
            if self.x < margin
                || self.x > containerSize.width - margin
                || self.y < margin
                || self.y > containerSize.height - margin {
                return originalPoint
            } else {
                return self
            }
        } else {
            return CGPoint(
                x: min(max(self.x, margin), containerSize.width - margin),
                y: min(max(self.y, margin), containerSize.height - margin)
            )
        }
    }
}

struct ImageResizableView_Previews: PreviewProvider {
    
    static let imageSize: CGSize = CGSize(width: 200, height: 200)
    
    static var previews: some View {
        if let image = UIImage(named: "gallery") {
            GeometryReader { geometryReader in
                ImageResizableView(
                    uiImage: image,
                    imageRect: .constant(CGRect(x: geometryReader.size.width * 0.5 - imageSize.width / 2,
                                                y: geometryReader.size.height * 0.5 - imageSize.height / 2,
                                                width: imageSize.width,
                                                height: imageSize.height)),
                    borderColor: .red,
                    borderWidth: 2,
                    handleColor: .white,
                    handleSize: 10,
                    handleTapSize: 50,
                    keepAspectRatio: true
                )
            }
        } else {
            Spacer()
        }
    }
}



================================================
FILE: pdfexpert/Utils/UI/LoadingView.swift
================================================
//
//  LoadingView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 03/08/23.
//

import SwiftUI

extension View {
    
    func loadingView(show: Binding<Bool>) -> some View {
        return self.modifier(
            LoadingView(show: show, loadingView: { ProgressView() })
        )
    }
    
    func loadingView<T: View>(
        show: Binding<Bool>,
        @ViewBuilder loadingView: @escaping () -> T) -> some View {
        return self.modifier(
            LoadingView(show: show, loadingView: loadingView)
        )
    }
}

struct LoadingView<T: View>: ViewModifier {
    
    @Binding var show: Bool
    
    var loadingView: (() -> T)
    
    init(show: Binding<Bool>,
         loadingView: @escaping (() -> T)) {
        self._show = show
        self.loadingView = loadingView
    }
    
    func body(content: Content) -> some View {
        ZStack {
            content
                .allowsHitTesting(!self.show)
            if self.show {
                self.loadingView()
            }
        }
    }
}



================================================
FILE: pdfexpert/Utils/UI/LottieView.swift
================================================
//
//  LottieView.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 23/02/23.
//

import SwiftUI
import Lottie

struct LottieView: UIViewRepresentable {
    let animationView = LottieAnimationView()
    var filename = "loading"
    
    func makeUIView(context: Context) -> some UIView {
        let view = UIView()
        
        let animation = LottieAnimation.named(filename)
        animationView.animation = animation
        animationView.contentMode = .scaleAspectFit
        animationView.play()
        
        animationView.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(animationView)
        
        NSLayoutConstraint.activate([
            animationView.heightAnchor.constraint(equalTo: view.heightAnchor),
            animationView.widthAnchor.constraint(equalTo: view.widthAnchor),
        ])
        
        return view
    }
    
    func updateUIView(_ uiView: UIViewType, context: Context) {}
    
    func loop(autoReverse: Bool = false) -> Self {
        let view = self
        view.animationView.loopMode = autoReverse ? .autoReverse : .loop
        return view
    }
}

struct LottieView_Previews: PreviewProvider {
    static var previews: some View {
        LottieView()
    }
}



================================================
FILE: pdfexpert/Utils/UI/PageControl.swift
================================================
//
//  PageControl.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/04/23.
//

import SwiftUI
import UIKit

struct PageControl: UIViewRepresentable {
    
    var currentPageIndex: Int
    var numberOfPages: Int
    var currentPageColor: Color
    var normalPageColor: Color
    var enableInteraction: Bool
    
    func makeUIView(context: Context) -> UIPageControl {
        let pageControl = UIPageControl()
        pageControl.pageIndicatorTintColor = UIColor(self.normalPageColor)
        pageControl.currentPageIndicatorTintColor = UIColor(self.currentPageColor)
        pageControl.numberOfPages = self.numberOfPages
        pageControl.isUserInteractionEnabled = self.enableInteraction
        return pageControl
    }
    
    func updateUIView(_ uiView: UIPageControl, context: Context) {
        uiView.currentPage = self.currentPageIndex
    }
}

struct PageControl_Previews: PreviewProvider {
    static var previews: some View {
        PageControl(currentPageIndex: 0,
                    numberOfPages: 3,
                    currentPageColor: .red,
                    normalPageColor: .blue,
                    enableInteraction: false)
    }
}



================================================
FILE: pdfexpert/Utils/UI/PdfKitView.swift
================================================
//
//  PdfKitView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 11/04/23.
//

import SwiftUI
import PDFKit

struct PdfKitView: UIViewRepresentable {
    typealias UIViewType = PDFView
    typealias OnTapPageCallback = ((PDFPage?) -> ())
    typealias ViewToPageRectConversionCallback = ((CGRect) -> ())

    let pdfDocument: PDFDocument?
    let singlePage: Bool
    let pageMargins: UIEdgeInsets?
    let currentPage: Int?
    let backgroundColor: UIColor?
    let usePaginator: Bool
    let onTapPage: OnTapPageCallback?
    var viewRect: Binding<CGRect>?
    var viewToPageRectConversionCallback: ViewToPageRectConversionCallback?

    init(
        pdfDocument: PDFDocument?,
        singlePage: Bool = false,
        pageMargins: UIEdgeInsets? = nil,
        currentPage: Int? = nil,
        backgroundColor: UIColor? = nil,
        usePaginator: Bool = false,
        onTapPage: OnTapPageCallback? = nil,
        viewRect: Binding<CGRect>? = nil,
        viewToPageRectConversionCallback: ViewToPageRectConversionCallback? = nil
    ) {
        self.pdfDocument = pdfDocument
        self.singlePage = singlePage
        self.pageMargins = pageMargins
        self.currentPage = currentPage
        self.backgroundColor = backgroundColor
        self.usePaginator = usePaginator
        self.onTapPage = onTapPage
        self.viewRect = viewRect
        self.viewToPageRectConversionCallback = viewToPageRectConversionCallback
    }

    func makeUIView(context: Context) -> UIViewType {
        let pdfView = PDFView()
        self.updatePdfView(pdfView)
        if nil != self.onTapPage {
            let tapGesture = UITapGestureRecognizer(target: context.coordinator,
                                                    action: #selector(context.coordinator.onTap))
            tapGesture.delegate = context.coordinator
            pdfView.addGestureRecognizer(tapGesture)
        }
        return pdfView
    }
    
    func makeCoordinator() -> PdfKitViewCoordinator {
        PdfKitViewCoordinator(onTapPage: { [self] tap in
            guard let onTapPage = self.onTapPage,
                  let pdfView = tap.view as? PDFView else { return }
            let position = tap.location(in: tap.view)
            onTapPage(pdfView.page(for: position, nearest: false))
        })
    }

    func updateUIView(_ pdfView: UIViewType, context: Context) {
        self.updatePdfView(pdfView)
        if let page = pdfView.currentPage, let viewRect = self.viewRect?.wrappedValue {
            self.viewToPageRectConversionCallback?(pdfView.convert(viewRect, to: page))
        }
    }
    
    private func updatePdfView(_ pdfView: UIViewType) {
        pdfView.document = self.pdfDocument
        pdfView.autoScales = true
        self.updateBackground(pdfView: pdfView)
        self.updateSinglePage(pdfView: pdfView)
        self.updatePageMargins(pdfView: pdfView)
        self.updateCurrentPage(pdfView: pdfView)
        self.updateUsePaginator(pdfView: pdfView)
    }
    
    private func updateBackground(pdfView: UIViewType) {
        if let backgroundColor = self.backgroundColor {
            pdfView.backgroundColor = backgroundColor
        }
    }
    
    private func updateSinglePage(pdfView: UIViewType) {
        if self.singlePage {
            pdfView.displayMode = .singlePage
        }
    }
    
    private func updatePageMargins(pdfView: UIViewType) {
        if let pageMargins = self.pageMargins {
            pdfView.pageBreakMargins = pageMargins
        }
    }
    
    private func updateCurrentPage(pdfView: UIViewType) {
        if let currentPage = self.currentPage,
           currentPage >= 0,
           currentPage < self.pdfDocument?.pageCount ?? 0,
           let page = self.pdfDocument?.page(at: currentPage) {
            pdfView.go(to: page)
        }
    }
    
    private func updateUsePaginator(pdfView: UIViewType) {
        pdfView.usePageViewController(self.usePaginator)
    }
}

class PdfKitViewCoordinator: NSObject, UIGestureRecognizerDelegate {
    
    typealias OnTapPageCallback = ((UITapGestureRecognizer) -> ())
    
    let onTapPage: OnTapPageCallback?

    init(onTapPage: OnTapPageCallback? = nil) {
        self.onTapPage = onTapPage
    }
    
    @objc func onTap(sender: UITapGestureRecognizer) {
        self.onTapPage?(sender)
    }
}

struct PdfKitView_Previews: PreviewProvider {
    static var previews: some View {
        PdfKitView(
            pdfDocument: K.Test.DebugPdfDocument,
            singlePage: false,
            pageMargins: nil,
            currentPage: nil,
            backgroundColor: nil,
            usePaginator: true,
            onTapPage: { page in print("Test Tap. Page hash: \(page.hashValue)") }
        )
    }
}



================================================
FILE: pdfexpert/Utils/UI/PdfKitViewBinder.swift
================================================
//
//  PdfKitViewBinder.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 29/05/23.
//

import SwiftUI
import PDFKit

struct PdfKitViewBinder: UIViewRepresentable {
    typealias UIViewType = PDFView

    @Binding var pdfView: PDFView
    let singlePage: Bool
    let pageMargins: UIEdgeInsets?
    let backgroundColor: UIColor?
    let usePaginator: Bool

    init(
        pdfView: Binding<PDFView>,
        singlePage: Bool = false,
        pageMargins: UIEdgeInsets? = nil,
        backgroundColor: UIColor? = nil,
        usePaginator: Bool = false
    ) {
        self._pdfView = pdfView
        self.singlePage = singlePage
        self.pageMargins = pageMargins
        self.backgroundColor = backgroundColor
        self.usePaginator = usePaginator
    }

    func makeUIView(context: Context) -> UIViewType {
        self.updatePdfView(self.pdfView)
        return pdfView
    }

    func updateUIView(_ pdfView: UIViewType, context: Context) {
        self.updatePdfView(pdfView)
    }
    
    private func updatePdfView(_ pdfView: UIViewType) {
        self.updateScale(pdfView: pdfView)
        self.updateBackground(pdfView: pdfView)
        self.updateSinglePage(pdfView: pdfView)
        self.updatePageMargins(pdfView: pdfView)
        self.updateUsePaginator(pdfView: pdfView)
    }
    
    private func updateScale(pdfView: UIViewType) {
        pdfView.autoScales = true
        let minScaleFactor = pdfView.scaleFactorForSizeToFit
        if minScaleFactor > 0 {
            pdfView.minScaleFactor = minScaleFactor
        }
    }
    
    private func updateBackground(pdfView: UIViewType) {
        if let backgroundColor = self.backgroundColor {
            pdfView.backgroundColor = backgroundColor
        }
    }
    
    private func updateSinglePage(pdfView: UIViewType) {
        if self.singlePage {
            pdfView.displayMode = .singlePage
        }
    }
    
    private func updatePageMargins(pdfView: UIViewType) {
        if let pageMargins = self.pageMargins {
            pdfView.pageBreakMargins = pageMargins
        }
    }
    
    private func updateUsePaginator(pdfView: UIViewType) {
        pdfView.usePageViewController(self.usePaginator)
    }
}

struct PdfKitViewBinder_Previews: PreviewProvider {
    
    static let pdfView = {
        let pdfView = PDFView()
        pdfView.document = K.Test.DebugPdfDocument
        return pdfView
    }()
    
    static var previews: some View {
        PdfKitViewBinder(
            pdfView: .constant(pdfView),
            singlePage: false,
            pageMargins: nil,
            backgroundColor: nil,
            usePaginator: true
        )
    }
}



================================================
FILE: pdfexpert/Utils/UI/PencilKitView.swift
================================================
//
//  PencilKitView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 19/05/23.
//

import SwiftUI
import PencilKit
import UIKit

struct PencilKitView: UIViewRepresentable {
    
    @Binding var canvasView: PKCanvasView
    
    let backgroundColor: Color
    let inkColor: Color
    let onSaved: () -> Void
    
    func makeUIView(context: Context) -> PKCanvasView {
        self.canvasView.drawingPolicy = .anyInput
        
        // Needed to prevent dark colors (e.g: black) to be converted to bright colors
        // (and vice versa) in case of dark mode.
        self.canvasView.overrideUserInterfaceStyle = .light
        
        self.canvasView.tool = PKInkingTool(.pen, color: UIColor(self.inkColor), width: 15)
        self.canvasView.backgroundColor = UIColor(self.backgroundColor)
        
        return self.canvasView
    }
    
    func updateUIView(_ canvasView: PKCanvasView, context: Context) {}
}

struct PencilKitView_Previews: PreviewProvider {
    
    static let canvasView = PKCanvasView()
    
    static var previews: some View {
        PencilKitView(canvasView: .constant(canvasView),
                      backgroundColor: .white,
                      inkColor: .black,
                      onSaved: { print("PencilKitView - On Saved") })
    }
}



================================================
FILE: pdfexpert/Utils/UI/PopupView.swift
================================================
//
//  PopupView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/08/23.
//

import SwiftUI

struct PopupView<PopupContent: View>: ViewModifier {

    @Binding var isPresenting: Bool
    let backgroundColor: Color
    let tapToDismiss: Bool
    var popupContent: () -> PopupContent
    
    private var screen: CGRect {
        return UIScreen.main.bounds
    }

    func body(content: Content) -> some View {
        content
            .overlay(
                ZStack{
                    if self.isPresenting {
                        self.backgroundView
                        HStack {
                            Spacer()
                            VStack {
                                Spacer()
                                self.popupContent()
                                    .transition(.move(edge: .bottom))
                                Spacer()
                            }
                            Spacer()
                        }
                        .transition(.move(edge: .bottom))
                    }
                }.frame(width: self.screen.width,
                        height: self.screen.height)
                .edgesIgnoringSafeArea(.all)
                .animation(.easeOut, value: self.isPresenting)
            )
    }
    
    @ViewBuilder var backgroundView: some View {
        let color = self.backgroundColor
        if self.tapToDismiss {
            color.onTapGesture {
                self.isPresenting = false
            }
        } else {
            color
        }
    }
}

extension View {
    func popup<PopupContent: View> (
        isPresenting: Binding<Bool>,
        backgroundColor: Color = Color.black.opacity(0.3),
        tapToDismiss: Bool = true,
        @ViewBuilder popupContent: @escaping () -> PopupContent
    ) -> some View {
        self.modifier(PopupView(isPresenting: isPresenting,
                                backgroundColor: backgroundColor,
                                tapToDismiss: tapToDismiss,
                                popupContent: popupContent))
    }
}

struct PopupView_Previews: PreviewProvider {
    
    static var previews: some View {
        Color.white
        .popup(
            isPresenting: .constant(true)
        ) {
            Color.red.frame(width: 200, height: 300)
        }
    }
}



================================================
FILE: pdfexpert/Utils/UI/RoundedCorner.swift
================================================
//
//  RoundedCorner.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 29/03/23.
//

import Foundation
import SwiftUI

struct RoundedCorner: Shape {

    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners

    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(roundedRect: rect,
                                byRoundingCorners: self.corners,
                                cornerRadii: CGSize(width: self.radius,
                                                    height: self.radius))
        return Path(path.cgPath)
    }
}

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        self.clipShape( RoundedCorner(radius: radius, corners: corners) )
    }
}



================================================
FILE: pdfexpert/Utils/UI/SizePrinter.swift
================================================
//
//  SizePrinter.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 01/06/23.
//

import Foundation
import SwiftUI

struct SizePrinter: ViewModifier {
    
    @State var size: CGSize = .zero { didSet { print("SizePrinter - size: \(self.size)") } }
    
    func body(content: Content) -> some View {
        content
            .background(
                GeometryReader { proxy in
                    Color.clear // we just want the reader to get triggered, so let's use an empty color
                        .onAppear {
                            self.size = proxy.size
                        }
                }
            )
    }
}

extension View {
    func printSize() -> some View {
        modifier(SizePrinter())
    }
}



================================================
FILE: pdfexpert/Utils/UI/TextResizableView.swift
================================================
//
//  TextResizableView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 26/05/23.
//

import SwiftUI
import UIKit

typealias TextResizableViewDeleteCallback = (() -> ())

struct TextResizableViewData {
    var text: String
    var rect: CGRect
}

struct TextResizableView: View {
    
    enum FocusField: Hashable {
        case field
    }
    
    @Binding var data: TextResizableViewData
    let fontName: String
    let fontColor: UIColor
    let color: Color
    let borderWidth: CGFloat
    let minSize: CGSize
    let handleSize: CGFloat
    let handleTapSize: CGFloat
    let deleteCallback: TextResizableViewDeleteCallback
    let suggestedWords: [String]
    
    @State private var tapOffset: CGPoint? = nil
    @FocusState private var focusedField: FocusField?
    @State private var filteredSuggestedWords: [String] = []
    
    private var topLeft: CGPoint {
        self.data.rect.origin
    }
    
    private var bottomRight: CGPoint {
        CGPoint(x: self.data.rect.origin.x + self.data.rect.size.width,
                y: self.data.rect.origin.y + self.data.rect.size.height)
    }
    
    private var computedCenter: CGPoint {
        CGPoint(x: self.topLeft.x + (self.bottomRight.x - self.topLeft.x) / 2,
                y: self.topLeft.y + (self.bottomRight.y - self.topLeft.y) / 2)
    }
    
    private var computedSize: CGSize {
        CGSize(width: self.bottomRight.x - self.topLeft.x,
               height: self.bottomRight.y - self.topLeft.y)
    }
    
    private var font: UIFont {
        UIFont.font(named: self.fontName,
                    fitting: self.data.text,
                    into: self.computedSize,
                    with: [:],
                    options: [])
    }
    
    init(data: Binding<TextResizableViewData>,
         fontName: String,
         fontColor: UIColor,
         color: Color,
         borderWidth: CGFloat,
         minSize: CGSize,
         handleSize: CGFloat,
         handleTapSize: CGFloat,
         suggestedWords: [String],
         deleteCallback: @escaping TextResizableViewDeleteCallback) {
        self._data = data
        self.fontName = fontName
        self.fontColor = fontColor
        self.color = color
        self.borderWidth = borderWidth
        self.minSize = minSize
        self.handleSize = handleSize
        self.handleTapSize = handleTapSize
        self.suggestedWords = suggestedWords
        self.deleteCallback = deleteCallback
    }
    
    var body: some View {
        ZStack {
            Rectangle()
                .foregroundColor(.clear)
                .contentShape(Rectangle())
                .allowsHitTesting(self.focusedField == .field)
                .onTapGesture {
                    self.focusedField = .none
                }
            GeometryReader { parentGeometryReader in
                ZStack {
                    GeometryReader { _ in
                        TextField("", text: self.$data.text)
                            .multilineTextAlignment(.center)
                            .lineLimit(1)
                            .font(Font(self.font))
                            .foregroundColor(Color(self.fontColor))
                            .focused(self.$focusedField, equals: .field)
                            .onAppear {
                                self.tapOffset = nil
                                // Dispatch on main thread is currently necessary
                                // to avoid memory leak on the view model of the parent view.
                                DispatchQueue.main.async {
                                    self.focusedField = .field
                                }
                            }
                            .contentShape(Rectangle())
                            .frame(width: self.computedSize.width, height: self.computedSize.height)
                            .background(Rectangle().stroke(self.color, lineWidth: self.borderWidth))
                            .position(self.computedCenter)
                            .gesture(
                                DragGesture()
                                    .onChanged { gesture in
                                        self.OnDrag(dragGestureValue: gesture,
                                                    parentViewSize: parentGeometryReader.size)
                                    }
                                    .onEnded { _ in self.tapOffset = nil }
                            )
                            .toolbar {
                                ToolbarItem(placement: .keyboard) {
                                    ScrollView(.horizontal, showsIndicators: false) {
                                        HStack(spacing: 8) {
                                            ForEach(self.filteredSuggestedWords, id: \.self) { suggestedWord in
                                                Button(action: {
                                                    self.data.text = suggestedWord
                                                }) {
                                                    Text(suggestedWord)
                                                        .foregroundColor(ColorPalette.primaryText)
                                                        .font(FontCategory.body2.font.bold())
                                                        .padding([.trailing, .leading], 8)
                                                }
                                                .background(ColorPalette.secondaryText)
                                                .clipShape(Capsule())
                                            }
                                        }
                                    }
                                }
                            }
                            .onChange(of: self.data.text) { _ in
                                self.updateFilteredSuggestedWords()
                            }
                    }
                    self.getResizeHandle(parentViewSize: parentGeometryReader.size)
                    self.getDeleteButton(parentViewSize: parentGeometryReader.size)
                }
            }
        }
    }
    
    private func OnDrag(dragGestureValue: DragGesture.Value, parentViewSize: CGSize) {
        
        let location = dragGestureValue.location
        let center = self.computedCenter
        let size = self.computedSize
        
        if self.tapOffset == nil {
            self.tapOffset = CGPoint(x: dragGestureValue.startLocation.x - center.x,
                                          y: dragGestureValue.startLocation.y - center.y)
        }
        
        guard let tapOffset = self.tapOffset else {
            return
        }
        
        var newCenterX = location.x - tapOffset.x
        newCenterX = max(min(newCenterX, parentViewSize.width - size.width / 2), size.width / 2)
        var newCenterY = location.y - tapOffset.y
        newCenterY = max(min(newCenterY, parentViewSize.height - size.height / 2), size.height / 2)
        
        let currentEventTranslation: CGPoint = CGPoint(x: newCenterX - center.x,
                                                       y: newCenterY - center.y)
        let bottomRight = CGPoint(x: self.bottomRight.x + currentEventTranslation.x,
                                  y: self.bottomRight.y + currentEventTranslation.y)
        let topLeft = CGPoint(x: self.topLeft.x + currentEventTranslation.x,
                              y: self.topLeft.y + currentEventTranslation.y)
        self.updateRect(topLeft: topLeft, bottomRight: bottomRight, text: self.data.text)
    }
    
    private func onResizeDrag(dragGestureValue: DragGesture.Value, parentViewSize: CGSize) {
        
        let location = dragGestureValue.location
        
        var bottomRight = CGPoint(x: location.x,y: location.y)
            .getBoundedPoint(containerSize: parentViewSize, margin: self.handleSize / 2)
        bottomRight = CGPoint(
            x: max(bottomRight.x, self.topLeft.x + self.minSize.width),
            y: max(bottomRight.y, self.topLeft.y + self.minSize.height)
        )
        
        self.updateRect(topLeft: self.topLeft, bottomRight: bottomRight, text: self.data.text)
    }

    private func getResizeHandle(parentViewSize: CGSize) -> some View {
        ZStack {
            Circle()
                .frame(width: self.handleSize, height: self.handleSize)
                .foregroundColor(.white)
            Image(systemName: "arrow.up.left.and.arrow.down.right.circle.fill")
                .resizable()
                .frame(width: self.handleSize, height: self.handleSize)
                .foregroundColor(self.color)
        }
        .frame(width: self.handleTapSize, height: self.handleTapSize)
        .contentShape(Circle())
        .position(CGPoint(x: self.computedCenter.x + self.computedSize.width / 2,
                          y: self.computedCenter.y + self.computedSize.height / 2))
        .gesture(
            DragGesture()
                .onChanged { gesture in
                    self.onResizeDrag(dragGestureValue: gesture, parentViewSize: parentViewSize)
                }
        )
    }
    
    private func getDeleteButton(parentViewSize: CGSize) -> some View {
        Button(action: { self.deleteCallback() }) {
            ZStack {
                Circle()
                    .frame(width: self.handleSize, height: self.handleSize)
                    .foregroundColor(.white)
                Image(systemName: "trash.circle.fill")
                    .resizable()
                    .frame(width: self.handleSize, height: self.handleSize)
                    .foregroundColor(self.color)
            }
        }
        .frame(width: self.handleTapSize, height: self.handleTapSize)
        .contentShape(Circle())
        .position(CGPoint(x: self.computedCenter.x - self.computedSize.width / 2,
                          y: self.computedCenter.y - self.computedSize.height / 2))
    }

    private func updateRect(topLeft: CGPoint, bottomRight: CGPoint, text: String) {
        let rect = CGRect(x: topLeft.x,
                          y: topLeft.y,
                          width: bottomRight.x - topLeft.x,
                          height: bottomRight.y - topLeft.y)
        self.data = TextResizableViewData(text: self.data.text, rect: rect)
    }
    
    private func updateFilteredSuggestedWords() {
        self.filteredSuggestedWords = self.suggestedWords
            .filter { $0.hasPrefix(self.data.text) && !self.data.text.isEmpty && $0 != self.data.text }
    }
}

fileprivate extension CGPoint {
    func getBoundedPoint(containerSize: CGSize, margin: CGFloat) -> CGPoint {
        return CGPoint(
            x: min(max(self.x, margin), containerSize.width - margin),
            y: min(max(self.y, margin), containerSize.height - margin)
        )
    }
}

struct TextResizableView_Previews: PreviewProvider {
    
    static let size: CGSize = CGSize(width: 100, height: 50)
    static let text: String = "Test String"
    
    static var previews: some View {
        GeometryReader { geometryReader in
            TextResizableView(data: .constant(getData(forParentSize: geometryReader.size)),
                              fontName: "Arial",
                              fontColor: .white,
                              color: .orange,
                              borderWidth: 4,
                              minSize: CGSize(width: 5, height: 5),
                              handleSize: 25,
                              handleTapSize: 50,
                              suggestedWords: ["Merlin", "Wizard", "North-West Tower"],
                              deleteCallback: { print("TextResizableView_Previews - Delete callback called!") })
            .position(x: geometryReader.size.width/2, y: geometryReader.size.height/2)
            .frame(width: geometryReader.size.width, height: geometryReader.size.height)
        }
    }
    
    private static func getData(forParentSize parentSize: CGSize) -> TextResizableViewData {
        TextResizableViewData(text: text, rect: getRect(forParentSize: parentSize))
    }
    
    private static func getRect(forParentSize parentSize: CGSize) -> CGRect {
        CGRect(x: parentSize.width * 0.5 - size.width / 2,
               y: parentSize.height * 0.5 - size.height / 2,
               width: size.width,
               height: size.height)
    }
}



================================================
FILE: pdfexpert/Utils/UI/UnderlyingError.swift
================================================
//
//  UnderlyingError.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 02/03/23.
//

import Foundation

protocol UnderlyingError: Error {
    static func getUnknownError() -> Self
    static func getUnderlyingError(errorDescription: String) -> Self
    static func convertUnderlyingError(fromError error: Error) -> Self?
}

extension Error {
    static func getSelfError(forError error: Error) -> Self? {
        return error as? Self
    }
}

extension UnderlyingError {
    static func convertError(fromError error: Error) -> Self {
        return Self.getSelfError(forError: error) ?? Self.convertUnderlyingError(fromError: error) ?? Self.getUnknownError()
    }
    
    static func convertUnderlyingError(fromError error: Error) -> Self? {
        return Self.getUnderlyingError(errorDescription: error.localizedDescription)
    }
}



================================================
FILE: pdfexpert/Utils/UI/ZoomImageModifier.swift
================================================
import SwiftUI
import UIKit

struct ZoomImageModifier: ViewModifier {
    private var contentSize: CGSize
    private var min: CGFloat = 1.0
    private var max: CGFloat = 3.0
    @State var currentScale: CGFloat = 1.0

    init(contentSize: CGSize) {
        self.contentSize = contentSize
    }
    
    var doubleTapGesture: some Gesture {
        TapGesture(count: 2).onEnded {
            if currentScale <= min { currentScale = max } else
            if currentScale >= max { currentScale = min } else {
                currentScale = ((max - min) * 0.5 + min) < currentScale ? max : min
            }
        }
    }
    
    func body(content: Content) -> some View {
        ScrollView([.horizontal, .vertical]) {
            content
                .frame(width: contentSize.width * currentScale, height: contentSize.height * currentScale, alignment: .center)
                .modifier(PinchToZoom(minScale: min, maxScale: max, scale: $currentScale))
        }
        .gesture(doubleTapGesture)
        .animation(.easeInOut, value: currentScale)
    }
}

class PinchZoomView: UIView {
    let minScale: CGFloat
    let maxScale: CGFloat
    var isPinching: Bool = false
    var scale: CGFloat = 1.0
    let scaleChange: (CGFloat) -> Void
    
    init(minScale: CGFloat,
           maxScale: CGFloat,
         currentScale: CGFloat,
         scaleChange: @escaping (CGFloat) -> Void) {
        self.minScale = minScale
        self.maxScale = maxScale
        self.scale = currentScale
        self.scaleChange = scaleChange
        super.init(frame: .zero)
        let pinchGesture = UIPinchGestureRecognizer(target: self, action: #selector(pinch(gesture:)))
        pinchGesture.cancelsTouchesInView = false
        addGestureRecognizer(pinchGesture)
    }
    
    required init?(coder: NSCoder) {
        fatalError()
    }
    
    @objc private func pinch(gesture: UIPinchGestureRecognizer) {
        switch gesture.state {
        case .began:
            isPinching = true
            
        case .changed, .ended:
            if gesture.scale <= minScale {
                scale = minScale
            } else if gesture.scale >= maxScale {
                scale = maxScale
            } else {
                scale = gesture.scale
            }
            scaleChange(scale)
        case .cancelled, .failed:
            isPinching = false
            scale = 1.0
        default:
            break
        }
    }
}

struct PinchZoom: UIViewRepresentable {
    let minScale: CGFloat
    let maxScale: CGFloat
    @Binding var scale: CGFloat
    @Binding var isPinching: Bool
    
    func makeUIView(context: Context) -> PinchZoomView {
        let pinchZoomView = PinchZoomView(minScale: minScale, maxScale: maxScale, currentScale: scale, scaleChange: { scale = $0 })
        return pinchZoomView
    }
    
    func updateUIView(_ pageControl: PinchZoomView, context: Context) { }
}

struct PinchToZoom: ViewModifier {
    let minScale: CGFloat
    let maxScale: CGFloat
    @Binding var scale: CGFloat
    @State var anchor: UnitPoint = .center
    @State var isPinching: Bool = false
    
    func body(content: Content) -> some View {
        content
            .scaleEffect(scale, anchor: anchor)
            .animation(.spring(), value: isPinching)
            .overlay(PinchZoom(minScale: minScale, maxScale: maxScale, scale: $scale, isPinching: $isPinching))
    }
}



================================================
FILE: pdfexpert/ViewModels/ArchiveViewModel.swift
================================================
//
//  ArchiveViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/04/23.
//

import Foundation
import Factory
import CoreData
import Combine
import CloudKitSyncMonitor

extension Container {
    var archiveViewModel: Factory<ArchiveViewModel> {
        self { ArchiveViewModel() }
    }
}

class ArchiveViewModel: ObservableObject {
    
    @Published var asyncItems: AsyncOperation<[Pdf], SharedLocalizedError> = AsyncOperation(status: .empty)
    @Published var asyncItemDelete: AsyncOperation<(), SharedLocalizedError> = AsyncOperation(status: .empty)
    @Published var isLoading: Bool = false
    
    @Injected(\.repository) private var repository
    @Injected(\.store) private var store
    @Injected(\.analyticsManager) private var analyticsManager
    @Injected(\.mainCoordinator) private var mainCoordinator
    @Injected(\.pdfShareCoordinator) var pdfShareCoordinator
    
    let syncMonitor = SyncMonitor.shared
    
    private var cancelBag = Set<AnyCancellable>()
    
    init() {
        SyncMonitor.shared.$importState.sink { [weak self] importState in
            switch importState {
            case .inProgress:
                self?.isLoading = true
            case .succeeded:
                self?.refresh()
                self?.isLoading = false
            case .failed:
                self?.refresh()
                self?.isLoading = false
            case .notStarted:
                self?.isLoading = false
            }
            self?.updateView()
        }.store(in: &self.cancelBag)
        
        // Refresh the pdf list every time the pdf edit flow is dismissed
        self.mainCoordinator.$pdfEditFlowData.filter { $0 == nil }.sink { data in
            self.refresh()
        }.store(in: &self.cancelBag)
    }
    
    func editItem(item: Pdf) {
        self.analyticsManager.track(event: .existingPdfOpened)
        self.mainCoordinator.showPdfEditFlow(pdf: item, isNewPdf: false)
    }
    
    func shareItem(item: Pdf) {
        self.pdfShareCoordinator.share(pdf: item, applyPostProcess: true, onComplete: { [weak self] in
            self?.mainCoordinator.startReview()
        })
    }
    
    func delete(item: Pdf) {
        self.asyncItemDelete = AsyncOperation(status: .empty)
        do {
            try self.repository.delete(pdf: item)
            self.asyncItemDelete = AsyncOperation(status: .empty)
        } catch {
            debugPrint(for: self, message: "Deletion failed. Error: \(error)")
            self.asyncItemDelete = AsyncOperation(status: .error(.unknownError))
        }
        self.refresh()
    }
    
    func onAppear() {
        self.analyticsManager.track(event: .reportScreen(.files))
        self.refresh()
    }
    
    func refresh() {
        do {
            let items = try self.repository.loadPdfs()
            self.asyncItems = AsyncOperation(status: .data(items))
        } catch {
            debugPrint(for: self, message: "Refresh failed. Error: \(error)")
            self.asyncItems = AsyncOperation(status: .error(SharedLocalizedError.unknownError))
        }
    }
    
    func updateView(){
        self.objectWillChange.send()
    }
}



================================================
FILE: pdfexpert/ViewModels/CameraImageProviderFlow.swift
================================================
//
//  CameraImageProviderFlow.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/09/23.
//

import Foundation
import Factory
import UIKit

extension Container {
    var cameraImageProviderFlow: Factory<CameraImageProviderFlow> {
        self { CameraImageProviderFlow() }
    }
}

class CameraImageProviderFlow: ObservableObject {
    
    typealias CameraImageTakenCallback = ((UIImage) -> ())
    
    @Published var cameraShow: Bool = false
    
    private var onImageTaken: CameraImageTakenCallback?
    
    func startFlow(onImageTaken: @escaping CameraImageTakenCallback) {
        self.onImageTaken = onImageTaken
        self.cameraShow = true
    }
    
    func onPhotoCaptured(image: UIImage) {
        self.cameraShow = false
        self.onImageTaken?(image)
    }
}



================================================
FILE: pdfexpert/ViewModels/CameraViewModel.swift
================================================
//
//  CameraViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 30/03/23.
//

import Foundation
import AVFoundation
import Combine
import Factory
import UIKit

typealias ImageCapturedCallback = (UIImage) -> ()

extension Container {
    var cameraService: Factory<CameraService> {
        self { CameraService() }
    }
}

extension Container {
    var cameraViewModel: ParameterFactory<ImageCapturedCallback, CameraViewModel> {
        self { CameraViewModel(onImageCaptured: $0) }.shared
    }
}

final class CameraViewModel: ObservableObject {
    
    @Injected(\.cameraService) var cameraService
    
    @Published var error: CameraError?
    
    @Published var showAlertError: Bool = false
    
    @Published var isFlashOn = false
    
    @Published var willCapturePhoto = false
    
    var session: AVCaptureSession { self.cameraService.session }
    
    private var onImageCaptured: ImageCapturedCallback
    
    private var subscriptions = Set<AnyCancellable>()
    
    init(onImageCaptured: @escaping ImageCapturedCallback) {
        
        self.onImageCaptured = onImageCaptured
        
        self.cameraService.$photo.sink { [weak self] (photo) in
            if let photo = photo {
                self?.onImageCaptured(photo.image!)
            }
        }
        .store(in: &self.subscriptions)
        
        self.cameraService.$error.sink { [weak self] (error) in
            self?.error = error
            if nil != error {
                self?.showAlertError = true
            }
        }
        .store(in: &self.subscriptions)
        
        self.cameraService.$flashMode.sink { [weak self] (mode) in
            self?.isFlashOn = mode == .on
        }
        .store(in: &self.subscriptions)
        
        self.cameraService.$willCapturePhoto.sink { [weak self] (val) in
            self?.willCapturePhoto = val
        }
        .store(in: &self.subscriptions)
    }
    
    func configure() {
        self.cameraService.checkForPermissions()
        self.cameraService.configure()
    }
    
    func capturePhoto() {
        self.cameraService.capturePhoto(saveToLibrary: false)
    }
    
    func flipCamera() {
        self.cameraService.changeCamera()
    }
    
    func zoom(with factor: CGFloat) {
        self.cameraService.set(zoom: factor)
    }
    
    func switchFlash() {
        self.cameraService.flashMode = self.cameraService.flashMode == .on ? .off : .on
    }
}



================================================
FILE: pdfexpert/ViewModels/ChatPdfSelectionViewModel.swift
================================================
//
//  ChatPdfSelectionViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 19/07/23.
//

import Foundation
import Factory
import PhotosUI
import PSPDFKit
import Combine

@MainActor
extension Container {
    var chatPdfSelectionViewModel: Factory<ChatPdfSelectionViewModel> {
        self { ChatPdfSelectionViewModel() }
    }
}

@MainActor
final class ChatPdfSelectionViewModel: ObservableObject {
    
    @Published var importOptionGroup: ImportOptionGroup? = nil
    @Published var importFileOption: ImportFileOption? = nil
    
    @Published var scannerShow: Bool = false
    @Published var cameraPermissionDeniedShow: Bool = false
    
    @MainActor @Published var asyncImportPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
        didSet {
            if let pdf = self.asyncImportPdf.data {
                self.trackFullActionCompleted()
                self.uploadPdf(pdf: pdf)
            }
        }
    }
    
    @Published var asyncChatPdfSetup: AsyncOperation<ChatPdfInitParams, ChatPdfError> = AsyncOperation(status: .empty) {
        didSet {
            if let chatPdfInitParams = self.asyncChatPdfSetup.data {
                self.chatPdfInitParams = chatPdfInitParams
            } else {
                self.chatPdfInitParams = nil
            }
        }
    }
    
    @Published var chatPdfInitParams: ChatPdfInitParams? = nil
    
    @Published var monetizationShow: Bool = false
    
    @Injected(\.store) private var store
    @Injected(\.chatPdfManager) private var chatPdfManager
    @Injected(\.analyticsManager) private var analyticsManager
    
    lazy var pdfUnlockViewModel: PdfUnlockViewModel = {
            Container.shared.pdfUnlockViewModel(PdfUnlockViewModel.Params(asyncUnlockedPdfSingleOutput: self.asyncSubject(\.asyncImportPdf)))
        }()
    


    
    
    
    
    private var currentAnalyticsImportOption: ImportOption? = nil
    private var currentAnalyticsFileExtension: String? = nil
    
    private var cancelBag = Set<AnyCancellable>()
    
    func onAppear() {
        self.analyticsManager.track(event: .reportScreen(.chatPdfSelection))
    }
    
    func getPdfButtonPressed() {
        self.trackPdfSelection()
        if self.store.isPremium.value {
            self.importOptionGroup = .fileAndScan
        } else {
            self.monetizationShow = true
        }
    }
    
    @MainActor
    func handleImportOption(importOption: ImportOption) {
        switch importOption {
        case .camera:
            // TODO: Improve this by defining context-specific ImportOption types
            assertionFailure("Unexpected import option")
            break
        case .gallery:
            // TODO: Improve this by defining context-specific ImportOption types
            assertionFailure("Unexpected import option")
            break
        case .scan: self.scanPdf()
        case .file(let fileSource):
            switch fileSource {
            case .google: self.openFilePicker(fileSource: .google)
            case .dropbox: self.openFilePicker(fileSource: .dropbox)
            case .icloud: self.openFilePicker(fileSource: .icloud)
            case .files: self.openFilePicker(fileSource: .files)
            }
        }
    }
    
    @MainActor
    func openFilePicker(fileSource: FileSource) {
        self.trackFullActionChosen(importOption: .file(fileSource: fileSource))
        self.importOptionGroup = nil
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            self.importFileOption = .allDocs
        }
    }
    
    @MainActor
    func scanPdf() {
        self.importOptionGroup = nil
        // In this case ImportOption.scan is not actually been selected by the user,
        // but is provided for coherence
        self.trackFullActionChosen(importOption: .scan)
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            self.showScanner()
        }
    }
    
    @MainActor
    func convertScan(scannerResult: ScannerResult) {
        self.scannerShow = false
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            PdfScanUtility.convertScan(scannerResult: scannerResult, asyncOperation: self.asyncSubject(\.asyncImportPdf))
        }
    }
    
    @MainActor
    func processPickedFileUrl(_ fileUrl: URL?) {
        guard let fileUrl else {
            assertionFailure("Missing expected url")
            self.asyncImportPdf = AsyncOperation(status: .error(.unknownError))
            return
        }
        
        self.importFileOption = nil
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            self.convertFileByUrl(fileUrl: fileUrl)
        }
    }
    
    @MainActor
    func importPdf(pdfUrl: URL) {
        guard let pdf = Pdf(pdfUrl: pdfUrl) else {
            assertionFailure("Missing expected file for give url")
            return
        }
        
        self.currentAnalyticsFileExtension = pdfUrl.pathExtension
        self.pdfUnlockViewModel.unlockPdf(pdf: pdf)
    }
    
    @MainActor
    private func convertFileByUrl(fileUrl: URL) {
        let fileUtType = UTType(filenameExtension: fileUrl.pathExtension)
        if fileUtType?.conforms(to: .pdf) ?? false {
            self.importPdf(pdfUrl: fileUrl)
        } else {
            self.asyncImportPdf = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
            Processor.generatePDF(from: fileUrl, options: [:]) { data, error in
                if let error = error {
                    debugPrint(for: self, message: "Error converting word file. Error: \(error)")
                    self.asyncImportPdf = AsyncOperation(status: .error(.unknownError))
                } else if let data = data, let pdf = Pdf(data: data) {
                    self.currentAnalyticsFileExtension = fileUrl.pathExtension
                    self.asyncImportPdf = AsyncOperation(status: .data(pdf))
                } else {
                    self.asyncImportPdf = AsyncOperation(status: .error(.unknownError))
                }
            }
        }
    }
    
    @MainActor
    private func showScanner() {
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .authorized, .notDetermined:
            self.scannerShow = true
        default:
            self.cameraPermissionDeniedShow = true
        }
    }
    
    @MainActor
    private func uploadPdf(pdf: Pdf) {
        guard let pdfData = pdf.rawData else {
            assertionFailure("Missing expected pdf data")
            self.asyncChatPdfSetup = AsyncOperation(status: .error(.unknownError))
            return
        }
        
        self.asyncChatPdfSetup = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
        
        guard pdfData.count <= K.ChatPdf.MaxBytes else {
            self.asyncChatPdfSetup = AsyncOperation(status: .error(.pdfTooLarge))
            return
        }
        
        guard pdf.pdfDocument.pageCount <= K.ChatPdf.MaxPages else {
            self.asyncChatPdfSetup = AsyncOperation(status: .error(.pdfTooManyPages))
            return
        }
        
        self.chatPdfManager.sendPdf(pdf: pdfData)
            .flatMap { chatPdfRef in
                self.chatPdfManager.getSetupData(ref: chatPdfRef)
                    .map { ChatPdfInitParams(chatPdfRef: chatPdfRef, setupData: $0) }
            }
            .sinkToAsyncStatus { [weak self] status in
                self?.asyncChatPdfSetup = AsyncOperation(status: status)
            }.store(in: &self.cancelBag)
    }
    
    private func trackPdfSelection() {
        self.analyticsManager.track(event: .chatPdfSelectionActionChosen)
    }
    
    private func trackFullActionChosen(importOption: ImportOption?) {
        self.currentAnalyticsImportOption = importOption
        self.analyticsManager.track(event: .chatPdfSelectionFullActionChosen(importOption: importOption))
    }
    
    private func trackFullActionCompleted() {
        self.analyticsManager.track(event: .chatPdfSelectionFullActionCompleted(importOption: currentAnalyticsImportOption,
                                                                                fileExtension: self.currentAnalyticsFileExtension))
        self.currentAnalyticsImportOption = nil
        self.currentAnalyticsFileExtension = nil
    }
}



================================================
FILE: pdfexpert/ViewModels/ChatPdfViewModel.swift
================================================
//
//  ChatPdfViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 19/07/23.
//

import Foundation
import Factory
import Combine

@MainActor
extension Container {
    var chatPdfViewModel: ParameterFactory<ChatPdfViewModel.Parameters, ChatPdfViewModel> {
        self { ChatPdfViewModel(parameters: $0) }
    }
}

class ChatPdfViewModel: ObservableObject {
    
    struct Parameters {
        let chatPdfInitParams: ChatPdfInitParams
    }
    
    @Injected(\.chatPdfManager) private var chatPdfManager
    @Injected(\.analyticsManager) private var analyticsManager
    
    @Published var messages = [ChatPdfMessage]()
    
    private let chatPdfRef: ChatPdfRef
    
    private var cancelBag = Set<AnyCancellable>()
    
    init(parameters: Parameters) {
        self.chatPdfRef = parameters.chatPdfInitParams.chatPdfRef
        self.messages.append(parameters.chatPdfInitParams.setupData.message)
    }
    
    func onAppear() {
        self.analyticsManager.track(event: .reportScreen(.chatPdf))
    }
    
    func onDisappear() {
        self.chatPdfManager.deletePdf(ref: self.chatPdfRef)
    }
    
    func getResponse(text: String) {
        
        self.analyticsManager.track(event: .chatPdfMessageSent)
        
        self.addMessage(ChatPdfMessage(role: .user, type: .text, content: text))
        self.addMessage(ChatPdfMessage(role: .assistant, type: .indicator, content: ""))
        
        self.chatPdfManager.generateText(ref: self.chatPdfRef, prompt: text)
            .sink(receiveCompletion: { [weak self] subscriptionCompletion in
                if let error = subscriptionCompletion.error {
                    self?.addMessage(ChatPdfMessage(role: .assistant, type: .text, content: error.localizedDescription))
                }
            }, receiveValue: { [weak self] message in
                self?.addMessage(message)
            }).store(in: &self.cancelBag)
    }
    
    private func addMessage(_ message: ChatPdfMessage) {
        // if messages list is empty just add new message
        guard let lastMessage = self.messages.last else {
            self.messages.append(message)
            return
        }
        // if last message is an indicator switch with new one
        if lastMessage.type == .indicator && lastMessage.role != .user {
            self.messages[self.messages.count - 1] = message
        } else {
            // otherwise, add new message to the end of the list
            self.messages.append(message)
        }
    }
}

fileprivate extension ChatPdfSetupData {
    var message: ChatPdfMessage {
        ChatPdfMessage(role: .assistant, type: .text, content: self.summary, suggestedQuestions: self.suggestedQuestions)
    }
}



================================================
FILE: pdfexpert/ViewModels/GalleryImageProviderFlow.swift
================================================
//
//  GalleryImageProviderFlow.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/09/23.
//

import Foundation
import Factory
import PhotosUI
import UIKit
import SwiftUI

extension Container {
    var galleryImageProviderFlow: Factory<GalleryImageProviderFlow> {
        self { GalleryImageProviderFlow() }
    }
}

class GalleryImageProviderFlow: ObservableObject {
    
    typealias GalleryImageSelectedCallback = ((UIImage) -> ())
    
    @Published var asyncImageLoading: AsyncEmptyFailable<SharedUnderlyingError> = .idle
    @Published var imagePickerShow: Bool = false
    @Published var imageSelection: PhotosPickerItem? = nil {
        didSet {
            if let imageSelection {
                let progress = self.loadTransferable(from: imageSelection)
                self.asyncImageLoading = .loading(progress)
            } else {
                self.asyncImageLoading = .idle
            }
        }
    }
    
    private var onImageSelected: GalleryImageSelectedCallback?
    
    func startFlow(onImageSelected: @escaping GalleryImageSelectedCallback) {
        self.onImageSelected = onImageSelected
        self.imagePickerShow = true
    }
    
    private func loadTransferable(from imageSelection: PhotosPickerItem) -> Progress {
        return imageSelection.loadTransferable(type: PickedImage.self) { result in
            DispatchQueue.main.async {
                switch result {
                case .success(let image?):
                    self.asyncImageLoading = .idle
                    self.onImageSelected?(image.uiImage)
                case .success(nil):
                    self.asyncImageLoading = .idle
                case .failure(let error):
                    self.asyncImageLoading = .error(SharedUnderlyingError.convertError(fromError: error))
                }
            }
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/HomeViewModel.swift
================================================
//
//  HomeViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/03/23.
//

import Foundation
import Factory
import SwiftUI
import PhotosUI
import PSPDFKit

@MainActor
extension Container {
    var homeViewModel: Factory<HomeViewModel> {
        self { HomeViewModel() }
    }
}

enum HomeAction: Hashable, Identifiable {
    
    var id: Self { return self }
    
    case appExtension
    
    case imageToPdf
    case wordToPdf
    case excelToPdf
    case powerpointToPdf
    case scan
    
    case merge
    case split
    
    case sign
    case formFill
    case addText
    case createPdf
    
    case importPdf
    
    case readPdf
    
    case removePassword
    case addPassword
    
    var importFileOption: ImportFileOption? {
        switch self {
        case .appExtension: return nil
        case .imageToPdf: return .image
        case .wordToPdf: return .word
        case .excelToPdf: return .excel
        case .powerpointToPdf: return .powerpoint
        case .scan: return nil
        case .merge: return .pdf
        case .split: return .pdf
        case .sign: return .allDocs
        case .formFill: return .pdf
        case .addText: return .allDocs
        case .createPdf: return nil
        case .importPdf: return .pdf
        case .readPdf: return .pdf
        case .removePassword: return .pdf
        case .addPassword: return .pdf
        }
    }
    
    var editStartAction: PdfEditStartAction? {
        switch self {
        case .appExtension: return nil
        case .imageToPdf: return nil
        case .wordToPdf: return nil
        case .excelToPdf: return nil
        case .powerpointToPdf: return nil
        case .scan: return nil
        case .merge: return nil
        case .split: return nil
        case .sign: return .openSignature
        case .formFill: return .openFillWidget
        case .addText: return .openFillForm
        case .createPdf: return nil
        case .importPdf: return nil
        case .readPdf: return nil
        case .removePassword: return nil
        case .addPassword: return nil
        }
    }
    
    var homePostImportAction: HomePostImportAction? {
        switch self {
        case .appExtension: return nil
        case .imageToPdf: return nil
        case .wordToPdf: return nil
        case .excelToPdf: return nil
        case .powerpointToPdf: return nil
        case .scan: return nil
        case .merge: return nil
        case .split: return nil
        case .sign: return nil
        case .formFill: return nil
        case .addText: return nil
        case .createPdf: return nil
        case .importPdf: return nil
        case .readPdf: return nil
        case .removePassword: return .removePassword
        case .addPassword: return .addPassword
        }
    }
}

enum ImportFileOption: Hashable, Identifiable {
    
    var id: Self { return self }
    
    case image
    case word
    case excel
    case powerpoint
    case pdf
    case allDocs
}

enum FileSource: Hashable, Identifiable {
    var id: Self { return self }
    case google, dropbox, icloud, files
}

enum HomePostImportAction: Hashable, Identifiable {
    var id: Self { return self }
    case addPassword, removePassword
}

@MainActor
public class HomeViewModel : ObservableObject {
    
    @Published var importOptionGroup: ImportOptionGroup? = nil
    @Published var importFileOption: ImportFileOption? = nil
    
    @Published var imagePickerShow: Bool = false
    @Published var imageSelection: PhotosPickerItem? = nil {
        didSet {
            if let imageSelection {
                let progress = self.loadTransferable(from: imageSelection)
                self.asyncImageLoading = AsyncOperation(status: .loading(progress))
            } else {
                self.asyncImageLoading = AsyncOperation(status: .empty)
            }
        }
    }
    
    @Published var asyncImageLoading: AsyncOperation<(), SharedUnderlyingError> = AsyncOperation(status: .empty)
    
    @Published var cameraShow: Bool = false
    @Published var scannerShow: Bool = false
    @Published var cameraPermissionDeniedShow: Bool = false
    @Published var addPasswordShow: Bool = false
    
    @Published var asyncPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
        didSet {
            if let pdf = self.asyncPdf.data {
                self.trackFullActionCompleted()
                if let homePostImportAction = self.action?.homePostImportAction {
                    self.performHomePostImportAction(homePostImportAction)
                } else {
                    self.mainCoordinator.showPdfEditFlow(pdf: pdf, startAction: self.editStartAction, isNewPdf: true)
                }
            }
        }
    }
    
    @Published var pdfSaved: Pdf? = nil
    @Published var addPasswordCompletedShow: Bool = false
    @Published var removePasswordCompletedShow: Bool = false
    @Published var addPasswordError: AddPasswordError? = nil
    @Published var removePasswordError: RemovePasswordError? = nil
    
    @Injected(\.store) private var store
    @Injected(\.analyticsManager) private var analyticsManager
    @Injected(\.repository) private var repository
    @Injected(\.mainCoordinator) private var mainCoordinator
    @Injected(\.pdfShareCoordinator) var pdfShareCoordinator
    @Injected(\.pdfSplitViewModel) var pdfSplitViewModel
    @Injected(\.pdfReadViewModel) var pdfReadViewModel
    
    lazy var pdfUnlockViewModel: PdfUnlockViewModel = {
        Container.shared.pdfUnlockViewModel(PdfUnlockViewModel.Params(asyncUnlockedPdfSingleOutput: self.asyncSubject(\.asyncPdf)))
    }()
    
    lazy var pdfMergeViewModel: PdfMergeViewModel = { Container.shared.pdfMergeViewModel(PdfMergeViewModel.Params(asyncPdf: self.asyncSubject(\.asyncPdf)))
    }()
    
    var editStartAction: PdfEditStartAction? { self.action?.editStartAction }
    
    private var action: HomeAction? = nil
    private var currentAnalyticsImportOption: ImportOption? = nil
    private var currentAnalyticsFileExtension: String? = nil
    
    @MainActor
    func onAppear() {
        self.action = nil
        Task {
            try await self.store.refreshAll()
        }
        self.analyticsManager.track(event: .reportScreen(.home))
    }
    
    @MainActor
    func onDidBecomeActive() {
        Task {
            try await self.checkShareExtensionPdf()
        }
    }
    
    @MainActor
    func performHomeAction(_ action: HomeAction) {
        self.action = action
        self.trackActionChosen(action: action)
        
        switch action {
        case .appExtension:
            assertionFailure("App Extension behaviour is not supposed to be triggered by a CTA")
            break
        case .imageToPdf:
            self.importOptionGroup = .image
        case .wordToPdf, .excelToPdf, .powerpointToPdf, .importPdf, .formFill, .removePassword, .addPassword:
            self.openFilePicker(fileSource: .files)
        case .sign, .addText:
            self.importOptionGroup = .fileAndScan
        case .createPdf:
            self.createPdf()
        case .scan:
            self.scanPdf()
        case .merge:
            self.pdfMergeViewModel.merge()
        case .readPdf:
            self.pdfReadViewModel.read(pdf: nil)
        case .split:
            self.pdfSplitViewModel.split(pdf: nil,
                                         onSplitCompleted: { [weak self] in
                self?.trackFullActionCompleted()
                self?.mainCoordinator.goToArchive()
            })
        }
    }
    
    @MainActor
    func handleImportOption(importOption: ImportOption) {
        switch importOption {
        case .camera: self.openCamera()
        case .gallery: self.openGallery()
        case .scan: self.scanPdf()
        case .file(let fileSource):
            switch fileSource {
            case .google: self.openFilePicker(fileSource: .google)
            case .dropbox: self.openFilePicker(fileSource: .dropbox)
            case .icloud: self.openFilePicker(fileSource: .icloud)
            case .files: self.openFilePicker(fileSource: .files)
            }
        }
    }
    
    @MainActor
    func openFilePicker(fileSource: FileSource) {
        self.trackFullActionChosen(importOption: .file(fileSource: fileSource))
        self.importOptionGroup = nil
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            guard let importFileOption = self.action?.importFileOption else {
                assertionFailure("Missing expected import file option for current action")
                return
            }
            self.importFileOption = importFileOption
        }
    }
    
    @MainActor
    func openCamera() {
        self.importOptionGroup = nil
        self.trackFullActionChosen(importOption: .camera)
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            self.cameraShow = true
        }
    }
    
    @MainActor
    func openGallery() {
        self.importOptionGroup = nil
        self.trackFullActionChosen(importOption: .gallery)
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            self.imagePickerShow = true
        }
    }
    
    @MainActor
    func scanPdf() {
        self.importOptionGroup = nil
        // In this case ImportOption.scan is not actually been selected by the user,
        // but is provided for coherence
        self.trackFullActionChosen(importOption: .scan)
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            self.showScanner()
        }
    }
    
    @MainActor
    func convertImage(uiImage: UIImage) {
        self.cameraShow = false
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            self.convertUiImageToPdf(uiImage: uiImage, filename: nil)
        }
    }
    
    @MainActor
    func convertScan(scannerResult: ScannerResult) {
        self.scannerShow = false
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            PdfScanUtility.convertScan(scannerResult: scannerResult, asyncOperation: self.asyncSubject(\.asyncPdf))
        }
    }
    
    @MainActor
    func processPickedFileUrl(_ fileUrl: URL?) {
        guard let fileUrl else {
            assertionFailure("Missing expected url")
            self.asyncPdf = AsyncOperation(status: .error(.unknownError))
            return
        }
        
        self.importFileOption = nil
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            switch self.action {
            case .imageToPdf:
                self.convertFileImageByURL(fileImageUrl: fileUrl)
            case .wordToPdf, .excelToPdf, .powerpointToPdf, .sign, .formFill, .addText, .createPdf:
                self.convertFileByUrl(fileUrl: fileUrl)
            case .importPdf, .removePassword, .addPassword:
                self.importPdf(pdfUrl: fileUrl)
            case .scan, .appExtension, .none, .merge, .split, .readPdf:
                assertionFailure("Selected file url is not handled for the current action")
            }
        }
    }
    
    @MainActor
    func importPdf(pdfUrl: URL) {
        guard let pdf = Pdf(pdfUrl: pdfUrl) else {
            assertionFailure("Missing expected file for give url")
            return
        }
        
        self.currentAnalyticsFileExtension = pdfUrl.pathExtension
        if pdf.pdfDocument.isLocked, self.action?.homePostImportAction == .addPassword {
            self.addPasswordError = .pdfHasPassword
        } else if !pdf.pdfDocument.isLocked, self.action?.homePostImportAction == .removePassword {
            self.removePasswordError = .pdfNoPassword
        } else {
            self.pdfUnlockViewModel.unlockPdf(pdf: pdf)
        }
    }
    
    func setPassword(_ password: String) {
        self.internalSetPassword(password)
        debugPrint(for: self, message: "New password: \(password)")
        self.analyticsManager.track(event: .passwordAdded)
    }
    
    func goToArchive() {
        self.mainCoordinator.goToArchive()
        self.pdfSaved = nil
    }
    
    func share() {
        guard let pdfSaved else {
            assertionFailure("Missing expected pdfSaved entity")
            return
        }
        self.pdfShareCoordinator.share(pdf: pdfSaved, applyPostProcess: false, onComplete: { [weak self] in
            self?.mainCoordinator.startReview()
        })
        self.pdfSaved = nil
    }
    
    @MainActor
    private func convertFileImageByURL(fileImageUrl: URL) {
        do {
            let imageData = try Data(contentsOf: fileImageUrl)
            guard let uiImage = UIImage(data: imageData) else {
                self.asyncImageLoading = AsyncOperation(status: .error(.unknownError))
                return
            }
            self.currentAnalyticsFileExtension = fileImageUrl.pathExtension
            self.convertUiImageToPdf(uiImage: uiImage, filename: fileImageUrl.filename)
        } catch {
            debugPrint(for: self, message: "Error retrieving file. Error: \(error)")
            self.asyncImageLoading = AsyncOperation(status: .error(.unknownError))
        }
    }
    
    @MainActor
    private func convertFileByUrl(fileUrl: URL) {
        let fileUtType = UTType(filenameExtension: fileUrl.pathExtension)
        if fileUtType?.conforms(to: .pdf) ?? false {
            self.importPdf(pdfUrl: fileUrl)
        } else {
            self.asyncPdf = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
            Processor.generatePDF(from: fileUrl, options: [:]) { data, error in
                if let error = error {
                    debugPrint(for: self, message: "Error converting word file. Error: \(error)")
                    self.asyncPdf = AsyncOperation(status: .error(.unknownError))
                } else if let data = data, var pdf = Pdf(data: data) {
                    self.currentAnalyticsFileExtension = fileUrl.pathExtension
                    pdf.updateFilename(fileUrl.filename)
                    self.asyncPdf = AsyncOperation(status: .data(pdf))
                } else {
                    self.asyncPdf = AsyncOperation(status: .error(.unknownError))
                }
            }
        }
    }
    
    private func loadTransferable(from imageSelection: PhotosPickerItem) -> Progress {
        return imageSelection.loadTransferable(type: PickedImage.self) { result in
            DispatchQueue.main.async {
                guard imageSelection == self.imageSelection else {
                    print("Failed to get the selected item.")
                    return
                }
                switch result {
                case .success(let image?):
                    self.asyncImageLoading = AsyncOperation(status: .data(()))
                    self.convertUiImageToPdf(uiImage: image.uiImage, filename: nil)
                case .success(nil):
                    self.asyncImageLoading = AsyncOperation(status: .empty)
                case .failure(let error):
                    let convertedError = SharedUnderlyingError.convertError(fromError: error)
                    self.asyncImageLoading = AsyncOperation(status: .error(convertedError))
                }
            }
        }
    }
    
    private func convertUiImageToPdf(uiImage: UIImage, filename: String?) {
        let pdfDocument = PDFUtility.convertUiImageToPdf(uiImage: uiImage)
        var pdf = Pdf(pdfDocument: pdfDocument)
        if let filename {
            pdf.updateFilename(filename)
        }
        self.asyncPdf = AsyncOperation(status: .data(pdf))
    }
    
    @MainActor
    private func showScanner() {
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .authorized, .notDetermined:
            self.scannerShow = true
        default:
            self.cameraPermissionDeniedShow = true
        }
    }
    
    @MainActor
    private func checkShareExtensionPdf() async throws {
        let pdfDataExpected = SharedStorage.pdfDataShareExtensionExistanceFlag
        let pdfData = SharedStorage.pdfDataShareExtension
        
        let resetSharedStorage = {
            SharedStorage.pdfDataShareExtension = nil
            SharedStorage.pdfDataShareExtensionExistanceFlag = false
            SharedStorage.pdfDataShareExtensionPassword = nil
        }
        
        if let pdfData = pdfData {
            let fileSizeWithUnit = ByteCountFormatter.string(fromByteCount: Int64(pdfData.count), countStyle: .file)
            debugPrint("Share Extension - Loaded pdf data with size: \(fileSizeWithUnit)")
        }
        
        guard pdfDataExpected, let pdfData = pdfData else {
            if pdfDataExpected {
                self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfMissingRawData))
                resetSharedStorage()
            } else if pdfData != nil {
                self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfExistingUnexpectedRawData))
                resetSharedStorage()
            }
            return
        }
        
        guard var pdf = Pdf(data: pdfData) else {
            self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfCannotDecode))
            resetSharedStorage()
            return
        }
        
        if pdf.pdfDocument.isEncrypted {
            let password = SharedStorage.pdfDataShareExtensionPassword ?? ""
            
            guard pdf.pdfDocument.unlock(withPassword: password) else {
                self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfInvalidPasswordForLockedFile))
                resetSharedStorage()
                return
            }
            
            guard let pdfEncryptedData = pdf.pdfDocument.dataRepresentation() else {
                self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfMissingDataForUnlockedFile))
                resetSharedStorage()
                return
            }
            guard let pdfDecryptedData = try? PDFUtility.removePassword(data: pdfEncryptedData, existingPDFPassword: password) else {
                self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfDecryptionFailed))
                resetSharedStorage()
                return
            }
            guard var pdfDecrypted = Pdf(data: pdfDecryptedData) else {
                self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfCannotDecodeDecryptedData))
                resetSharedStorage()
                return
            }
            pdfDecrypted.updatePassword(password)
            pdf = pdfDecrypted
        }
        resetSharedStorage()
        // TODO: Ask the user whether to discard the current pdf or not
        if self.asyncPdf.data != nil {
            self.asyncPdf = AsyncOperation(status: .empty)
            // This is a workaround to force swiftui to update its state and dismiss
            // the current modal for the pdf edit flow, so that the new one can be
            // shown in its place.
            try await Task.sleep(until: .now + .seconds(0.5), clock: .continuous)
        }
        
        self.analyticsManager.track(event: .homeFullActionCompleted(homeAction: .appExtension, importOption: nil, fileExtension: "pdf"))
        self.asyncPdf = AsyncOperation(status: .data(pdf))
    }
    
    private func createPdf() {
        self.trackFullActionChosen(importOption: nil)
        self.asyncPdf = AsyncOperation(status: .data(Pdf()))
    }
    
    private func performHomePostImportAction(_ action: HomePostImportAction) {
        switch action {
        case .addPassword:
            self.addPasswordShow = true
        case .removePassword:
            self.internalSetPassword(nil)
            debugPrint(for: self, message: "Password removed")
            self.analyticsManager.track(event: .passwordRemoved)
        }
    }
    
    private func internalSetPassword(_ password: String?) {
        guard var pdf = self.asyncPdf.data else {
            assertionFailure("Missing expected pdf ")
            self.asyncPdf = AsyncOperation(status: .error(.unknownError))
            return
        }
        do {
            pdf.updatePassword(password)
            self.pdfSaved = try self.repository.savePdf(pdf: pdf)
            if password != nil {
                self.addPasswordCompletedShow = true
            } else {
                self.removePasswordCompletedShow = true
            }
            self.asyncPdf = AsyncOperation(status: .empty)
        } catch {
            debugPrint(for: self, message: "Pdf save failed with error: \(error)")
            self.asyncPdf = AsyncOperation(status: .error(.unknownError))
        }
    }
    
    private func trackActionChosen(action: HomeAction) {
        self.analyticsManager.track(event: .homeActionChosen(homeAction: action))
    }
    
    private func trackFullActionChosen(importOption: ImportOption?) {
        if let action = self.action {
            self.currentAnalyticsImportOption = importOption
            self.analyticsManager.track(event: .homeFullActionChosen(homeAction: action, importOption: importOption))
        }
    }
    
    private func trackFullActionCompleted() {
        if let action = self.action {
            self.analyticsManager.track(event: .homeFullActionCompleted(homeAction: action,
                                                                        importOption: self.currentAnalyticsImportOption,
                                                                        fileExtension: self.currentAnalyticsFileExtension))
        }
        self.currentAnalyticsImportOption = nil
        self.currentAnalyticsFileExtension = nil
    }
}



================================================
FILE: pdfexpert/ViewModels/ImageCropFlow.swift
================================================
//
//  ImageCropFlow.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/09/23.
//

import Foundation
import Factory
import UIKit
import Mantis

extension Container {
    var imageCropFlow: Factory<ImageCropFlow> {
        self { ImageCropFlow() }
    }
}

class ImageCropFlow: ObservableObject {
    
    typealias ImageCroppedCallback = ((UIImage) -> ())
    
    @Published var cropperShow: Bool = false
    @Published var image: UIImage? = nil {
        didSet {
            self.onCropCompleted(image: image)
        }
    }
    @Published var cropShapeType: Mantis.CropShapeType = .rect
    @Published var presetFixedRatioType: Mantis.PresetFixedRatioType = .canUseMultiplePresetFixedRatio()
    @Published var type: ImageCropperType = .normal
    
    private var onImageCropped: ImageCroppedCallback? = nil
    
    func startFlow(
        image: UIImage,
        cropShapeType: Mantis.CropShapeType = .rect,
        presetFixedRatioType: Mantis.PresetFixedRatioType = .canUseMultiplePresetFixedRatio(),
        type: ImageCropperType = .normal,
        onImageCropped: @escaping ImageCroppedCallback
    ) {
        self.cropperShow = true
        self.image = image
        self.cropShapeType = cropShapeType
        self.presetFixedRatioType = presetFixedRatioType
        self.type = type
        self.onImageCropped = onImageCropped
    }
    
    func onCropViewDismiss() {
        self.onCropCompleted(image: nil)
    }
    
    private func onCropCompleted(image: UIImage?) {
        if let image {
            self.onImageCropped?(image)
        }
        self.onImageCropped = nil
    }
}



================================================
FILE: pdfexpert/ViewModels/OnboardingViewModel.swift
================================================
//
//  OnboardingViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 25/05/23.
//

import Foundation
import Factory

extension Container {
    var onboardingViewModel: Factory<OnboardingViewModel> {
        self { OnboardingViewModel() }
    }
}

struct OnboardingItem {
    let imageName: String
    let title: String
    let description: String
}

public class OnboardingViewModel : ObservableObject {
    
    let items: [OnboardingItem] = [
        OnboardingItem(
            imageName: "onboarding_convert",
            title: "Convert files to PDF",
            description: "You can convert to pdf a lot of file types from the programs you prefer."
        ),
        OnboardingItem(
            imageName: "onboarding_signature",
            title: "Enter and edit your signature",
            description: "Insert your signature in the pdf you created with a single tap."
        ),
        OnboardingItem(
            imageName: "onboarding_password",
            title: "Protect your files with password",
            description: "Enter a password to protect your pdf, you can delete it and change it whenever you want."
        ),
        OnboardingItem(
            imageName: "onboarding_chat_pdf",
            title: "Chat with any PDF files",
            description: "You can ask questions to any PDF and get quick insights and clarifications."
        ),
    ]
    
    @Published var monetizationShow: Bool = false
    @Published var pageIndex = 0
    
    @Injected(\.store) private var store
    @Injected(\.mainCoordinator) private var coordinator
    @Injected(\.cacheManager) private var cacheManager
    @Injected(\.analyticsManager) private var analyticsManager
    
    func onMonetizationClose() {
        self.coordinator.goToMain()
    }
    
    func continueButtonPressed() {
        if self.pageIndex >= self.items.count - 1 {
            self.analyticsManager.track(event: .onboardingCompleted)
            self.closeOnboarding()
        } else {
            self.pageIndex += 1
        }
    }
    
    func skipButtonPressed() {
        self.analyticsManager.track(event: .onboardingSkipped)
        self.closeOnboarding()
    }
    
    private func closeOnboarding() {
        self.cacheManager.onboardingShown = true
        
        if self.store.isPremium.value {
            self.coordinator.goToMain()
        } else {
            self.monetizationShow = true
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfEditViewModel.swift
================================================
//
//  PdfEditViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 11/04/23.
//

import Foundation
import Factory
import SwiftUI
import UIKit
import PhotosUI
import PSPDFKit

@MainActor
extension Container {
    var pdfEditViewModel: ParameterFactory<PdfEditViewModel.InputParameter, PdfEditViewModel> {
        self { PdfEditViewModel(inputParameter: $0) }
    }
}

enum PdfEditStartAction {
    case openFillWidget
    case openFillForm
    case openSignature
}

enum EditAction: CaseIterable {
    case password
    case compression
    case split
}

@MainActor
class PdfEditViewModel: ObservableObject {
    
    struct InputParameter {
        let pdf: Pdf
        let startAction: PdfEditStartAction?
        let shouldShowCloseWarning: Binding<Bool>
    }
    
    @Published private(set)var pdf: Pdf
    @Published var pdfCurrentPageIndex: Int = 0
    @Published var pageImages: [UIImage] = []
    @Published var pdfThumbnails: [UIImage] = []
    @Published var pdfSaveError: PdfEditSaveError? = nil
    @Published var filePickerShow: Bool = false
    @Published var cameraShow: Bool = false
    @Published var imagePickerShow: Bool = false
    @Published var scannerShow: Bool = false
    @Published var cameraPermissionDeniedShow: Bool = false
    @Published var missingWidgetWarningShow: Bool = false
    
    @Published var imageSelection: PhotosPickerItem? = nil {
        didSet {
            if let imageSelection {
                let progress = self.loadTransferable(from: imageSelection)
                self.asyncImageLoading = AsyncOperation(status: .loading(progress))
            } else {
                self.asyncImageLoading = AsyncOperation(status: .empty)
            }
        }
    }
    
    @Published var asyncImageLoading: AsyncOperation<(), SharedUnderlyingError> = AsyncOperation(status: .empty)
    @Published var asyncPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
        didSet {
            if let pdf = self.asyncPdf.data  {
                self.appendPdfToPdf(pdf: pdf)
                self.asyncPdf = AsyncOperation(status: .empty)
            }
        }
    }
    
    @Published var saveSuccessfulAlertShow: Bool = false
    
    @Published var pdfFilename: String {
        didSet {
            self.onPdfChanged()
        }
    }
    @Published var compression: CompressionOption {
        didSet {
            self.onPdfChanged()
        }
    }
    
    @Published var signatureAddViewShow: Bool = false
    @Published var fillFormViewShow: Bool = false
    @Published var fillWidgetViewShow: Bool = false
    
    @Published var editOptionListShow: Bool = false
    @Published var passwordTextFieldShow: Bool = false
    @Published var removePasswordAlertShow: Bool = false
    @Published var splitSuccessAlertShow: Bool = false
    @Published var compressionShow: Bool = false
    
    @Injected(\.repository) private var repository
    @Injected(\.mainCoordinator) private var mainCoordinator
    @Injected(\.pdfCoordinator) private var pdfCoordinator
    @Injected(\.analyticsManager) private var analyticsManager
    @Injected(\.pdfShareCoordinator) var pdfShareCoordinator
    @Injected(\.pdfSplitViewModel) var pdfSplitViewModel
    
    lazy var pdfUnlockViewModel: PdfUnlockViewModel = {
        Container.shared.pdfUnlockViewModel(PdfUnlockViewModel.Params(asyncUnlockedPdfSingleOutput: self.asyncSubject(\.asyncPdf)))
    }()
    
    // This boolean is set to true every time a change is applied to the original pdf.
    // TODO: Find a more robust solution
    var shouldShowCloseWarning: Binding<Bool>
    var urlToFileToConvert: URL?
    var imageToConvert: UIImage?
    var scannerResult: ScannerResult?
    
    var currentAnalyticsPdfInputType: AnalyticsPdfInputType? = nil
    var currentAnalyticsInputFileExtension: String? = nil
    var startAction: PdfEditStartAction? = nil
    
    init(inputParameter: InputParameter) {
        self.pdf = inputParameter.pdf
        self.pdfFilename = inputParameter.pdf.filename
        self.compression = inputParameter.pdf.compression
        self.startAction = inputParameter.startAction
        self.shouldShowCloseWarning = inputParameter.shouldShowCloseWarning
        self.refreshImages()
        self.refreshThumbnails()
    }
    
    @MainActor
    func onAppear() {
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            
            if let startAction = self.startAction {
                switch startAction {
                case .openFillWidget:
                    if PDFUtility.hasPdfWidget(pdf: self.pdf) {
                        self.fillWidgetViewShow = true
                    } else {
                        self.missingWidgetWarningShow = true
                    }
                case .openFillForm:
                    self.fillFormViewShow = true
                case .openSignature:
                    self.signatureAddViewShow = true
                }
            }
            self.startAction = nil
        }
    }
    
    func deleteCurrentPage() {
        guard self.pdfThumbnails.count == self.pdf.pdfDocument.pageCount else {
            assertionFailure("Inconsistency error: pdf thumbnails count doesn't match pdf pages count")
            return
        }
        guard self.pageImages.count == self.pdf.pdfDocument.pageCount else {
            assertionFailure("Inconsistency error: pdf page images count doesn't match pdf pages count")
            return
        }
        let maxIndex = self.pdf.pdfDocument.pageCount
        
        guard self.pdfCurrentPageIndex >= 0, self.pdfCurrentPageIndex < maxIndex else {
            debugPrint(for: self, message: "Out of bound index!")
            return
        }
        self.pdf.pdfDocument.removePage(at: self.pdfCurrentPageIndex)
        self.pdfThumbnails.remove(at: self.pdfCurrentPageIndex)
        self.pageImages.remove(at: self.pdfCurrentPageIndex)
        
        let newMaxIndex = self.pdf.pdfDocument.pageCount
        
        if self.pdfCurrentPageIndex >= newMaxIndex {
            self.pdfCurrentPageIndex = (newMaxIndex > 0) ? newMaxIndex - 1 : 0
        }
        
        self.shouldShowCloseWarning.wrappedValue = true
        
        self.analyticsManager.track(event: .pageRemoved)
    }
    
    func openFilePicker() {
        self.filePickerShow = true
        self.currentAnalyticsPdfInputType = .file
    }
    
    func openCamera() {
        self.cameraShow = true
        self.currentAnalyticsPdfInputType = .camera
    }
    
    func openGallery() {
        self.imagePickerShow = true
        self.currentAnalyticsPdfInputType = .gallery
    }
    
    func openScanner() {
        self.currentAnalyticsPdfInputType = .scan
        self.showScanner()
    }
    
    func save() {
        do {
            try self.internalSave()
            self.saveSuccessfulAlertShow = true
        } catch let error as PdfEditSaveError  {
            debugPrint(for: self, message: "Pdf save failed with error: \(error)")
            self.pdfSaveError = error
        } catch {
            self.pdfSaveError = .unknown
        }
    }
    
    func share() {
        do {
            try self.internalSave()
            self.internalShare()
        } catch let error as PdfEditSaveError  {
            debugPrint(for: self, message: "Pdf save failed with error: \(error)")
            self.pdfSaveError = error
        } catch {
            self.pdfSaveError = .unknown
        }
    }
    
    func goToArchive() {
        self.mainCoordinator.closePdfEditFlow()
        self.mainCoordinator.goToArchive()
    }
    
    func showAddSignature() {
        self.signatureAddViewShow = true
    }
    
    func showFillForm() {
        self.fillFormViewShow = true
    }
    
    func showFillWidget() {
        if PDFUtility.hasPdfWidget(pdf: self.pdf) {
            self.fillWidgetViewShow = true
        } else {
            self.missingWidgetWarningShow = true
        }
    }
    
    @MainActor
    func handleEditAction(_ action: EditAction) {
        
        self.editOptionListShow = false
        
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            
            switch action {
            case .password:
                if self.pdf.password != nil {
                    self.removePasswordAlertShow = true
                } else {
                    self.passwordTextFieldShow = true
                }
            case .compression:
                self.compressionShow = true
            case .split:
                self.pdfSplitViewModel.split(pdf: self.pdf, onSplitCompleted: { [weak self] in
                    self?.splitSuccessAlertShow = true
                })
            }
        }
    }
    
    func setPassword(_ password: String) {
        self.internalSetPassword(password)
        debugPrint(for: self, message: "New password: \(password)")
        self.analyticsManager.track(event: .passwordAdded)
    }
    
    func removePassword() {
        self.internalSetPassword(nil)
        debugPrint(for: self, message: "Password removed")
        self.analyticsManager.track(event: .passwordRemoved)
    }
    
    @MainActor
    func convert() {
        if let urlToFileToConvert = self.urlToFileToConvert {
            self.urlToFileToConvert = nil
            self.convertFileByUrl(fileUrl: urlToFileToConvert)
        } else if let imageToConvert = self.imageToConvert {
            self.imageToConvert = nil
            self.appendUiImageToPdf(uiImage: imageToConvert)
        } else if let scannerResult = self.scannerResult {
            self.scannerResult = nil
            PdfScanUtility.convertScan(scannerResult: scannerResult, asyncOperation: self.asyncSubject(\.asyncPdf))
        }
    }
    
    func updatePdf(pdf: Pdf) {
        // TODO: Update thumbnails only for changed pages
        self.pdf = pdf
        self.shouldShowCloseWarning.wrappedValue = true
        self.refreshThumbnails()
        self.refreshImages()
    }
    
    func handlePageReordering(fromIndex: Int, toIndex: Int) {
        if fromIndex != toIndex {
            // exchangePage throws an exception if used after pages are added. Apparently it doesn't update its internal indices when adding pages,
            // which it relies upon to perform the swap. A manual workaround using removePage and insert methods seems to work fine, though.
//            self.pdf.pdfDocument.exchangePage(at: fromIndex, withPageAt: toIndex)
            if let toPage = self.pdf.pdfDocument.page(at: toIndex), let fromPage = self.pdf.pdfDocument.page(at: fromIndex) {
                self.pdf.pdfDocument.removePage(at: fromIndex)
                self.pdf.pdfDocument.insert(toPage, at: fromIndex)
                self.pdf.pdfDocument.removePage(at: toIndex)
                self.pdf.pdfDocument.insert(fromPage, at: toIndex)
                
                self.pdfThumbnails.move(fromOffsets: IndexSet(integer: fromIndex), toOffset: (toIndex > fromIndex ? (toIndex + 1) : toIndex))
                self.pageImages.move(fromOffsets: IndexSet(integer: fromIndex), toOffset: (toIndex > fromIndex ? (toIndex + 1) : toIndex))
                if self.pdfCurrentPageIndex == fromIndex {
                    self.pdfCurrentPageIndex = toIndex
                } else if self.pdfCurrentPageIndex == toIndex {
                    self.pdfCurrentPageIndex = fromIndex
                }
                self.shouldShowCloseWarning.wrappedValue = true
            }
        }
    }
    
    private func internalSave() throws {
        guard self.pdf.pdfDocument.pageCount > 0 else {
            throw PdfEditSaveError.noPages
        }
        self.pdf = try self.repository.savePdf(pdf: self.pdf)
        self.shouldShowCloseWarning.wrappedValue = false
    }
    
    private func internalShare() {
        self.pdfShareCoordinator.share(pdf: self.pdf, applyPostProcess: true, onComplete: { [weak self] in
            self?.pdfCoordinator.startReview()
        })
    }
    
    private func onPdfChanged() {
        if self.pdf.filename != self.pdfFilename {
            self.pdf.updateFilename(self.pdfFilename)
            self.shouldShowCloseWarning.wrappedValue = true
            self.analyticsManager.track(event: .pdfRenamed)
        }
        if self.pdf.compression != self.compression {
            self.pdf.updateCompression(self.compression)
            self.shouldShowCloseWarning.wrappedValue = true
            self.analyticsManager.track(event: .compressionOptionChanged(compressionOption: self.compression))
        }
    }
    
    @MainActor
    private func convertFileByUrl(fileUrl: URL) {
        let fileUtType = UTType(filenameExtension: fileUrl.pathExtension)
        if fileUtType?.conforms(to: .pdf) ?? false {
            self.importPdf(pdfUrl: fileUrl)
        } else if fileUtType?.conforms(to: .image) ?? false {
            self.convertFileImageByURL(fileImageUrl: fileUrl)
        } else {
            self.asyncPdf = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
            Processor.generatePDF(from: fileUrl, options: [:]) { data, error in
                if let error = error {
                    debugPrint(for: self, message: "Error converting word file. Error: \(error)")
                    self.asyncPdf = AsyncOperation(status: .error(.unknownError))
                } else if let data = data, let pdf = Pdf(data: data) {
                    self.currentAnalyticsInputFileExtension = fileUrl.pathExtension
                    self.asyncPdf = AsyncOperation(status: .data(pdf))
                } else {
                    self.asyncPdf = AsyncOperation(status: .error(.unknownError))
                }
            }
        }
    }
    
    @MainActor
    func importPdf(pdfUrl: URL) {
        guard let pdf = Pdf(pdfUrl: pdfUrl) else {
            assertionFailure("Missing expected file for give url")
            return
        }
        
        self.currentAnalyticsInputFileExtension = pdfUrl.pathExtension
        self.pdfUnlockViewModel.unlockPdf(pdf: pdf)
    }
    
    @MainActor
    private func convertFileImageByURL(fileImageUrl: URL) {
        do {
            let imageData = try Data(contentsOf: fileImageUrl)
            guard let uiImage = UIImage(data: imageData) else {
                self.asyncImageLoading = AsyncOperation(status: .error(.unknownError))
                return
            }
            self.currentAnalyticsInputFileExtension = fileImageUrl.pathExtension
            self.appendUiImageToPdf(uiImage: uiImage)
        } catch {
            debugPrint(for: self, message: "Error retrieving file. Error: \(error)")
            self.asyncImageLoading = AsyncOperation(status: .error(.unknownError))
        }
    }
    
    private func loadTransferable(from imageSelection: PhotosPickerItem) -> Progress {
        return imageSelection.loadTransferable(type: PickedImage.self) { result in
            DispatchQueue.main.async {
                guard imageSelection == self.imageSelection else {
                    print("Failed to get the selected item.")
                    return
                }
                switch result {
                case .success(let image?):
                    self.asyncImageLoading = AsyncOperation(status: .data(()))
                    self.appendUiImageToPdf(uiImage: image.uiImage)
                case .success(nil):
                    self.asyncImageLoading = AsyncOperation(status: .empty)
                case .failure(let error):
                    let convertedError = SharedUnderlyingError.convertError(fromError: error)
                    self.asyncImageLoading = AsyncOperation(status: .error(convertedError))
                }
            }
        }
    }
    
    private func appendUiImageToPdf(uiImage: UIImage) {
        PDFUtility.appendImageToPdfDocument(pdfDocument: self.pdf.pdfDocument, uiImage: uiImage)
        let pageImage = PDFUtility.generatePdfThumbnail(pdfDocument: self.pdf.pdfDocument,
                                                        size: nil,
                                                        forPageIndex: self.pdf.pdfDocument.pageCount - 1)
        let thumbnail = PDFUtility.generatePdfThumbnail(pdfDocument: self.pdf.pdfDocument,
                                                    size: K.Misc.ThumbnailEditSize,
                                                    forPageIndex: self.pdf.pdfDocument.pageCount - 1)
        if let pageImage = pageImage, let thumbnail = thumbnail {
            self.pageImages.append(pageImage)
            self.pdfThumbnails.append(thumbnail)
        }
        self.shouldShowCloseWarning.wrappedValue = true
        self.trackPageAddedEvent()
    }
    
    private func appendPdfToPdf(pdf: Pdf) {
        PDFUtility.appendPdfDocument(pdf.pdfDocument, toPdfDocument: self.pdf.pdfDocument)
        let pageImages = PDFUtility.generatePdfThumbnails(pdfDocument: pdf.pdfDocument, size: nil).compactMap { $0 }
        self.pageImages.append(contentsOf: pageImages)
        let thumbnails = PDFUtility.generatePdfThumbnails(pdfDocument: pdf.pdfDocument, size: K.Misc.ThumbnailEditSize).compactMap { $0 }
        self.pdfThumbnails.append(contentsOf: thumbnails)
        self.shouldShowCloseWarning.wrappedValue = true
        self.trackPageAddedEvent()
    }
    
    private func showScanner() {
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .authorized, .notDetermined:
            self.scannerShow = true
        default:
            self.cameraPermissionDeniedShow = true
        }
    }
    
    private func internalSetPassword(_ password: String?) {
        if self.pdf.password != password {
            self.pdf.updatePassword(password)
            self.shouldShowCloseWarning.wrappedValue = true
            self.objectWillChange.send()
        }
    }
    
    private func refreshImages() {
        self.pageImages = PDFUtility.generatePdfThumbnails(pdfDocument: self.pdf.pdfDocument, size: nil).compactMap { $0 }
    }
    
    private func refreshThumbnails() {
        self.pdfThumbnails = PDFUtility.generatePdfThumbnails(pdfDocument: self.pdf.pdfDocument, size: K.Misc.ThumbnailEditSize).compactMap { $0 }
    }
    
    private func trackPageAddedEvent() {
        guard let currentAnalyticsPdfInputType = self.currentAnalyticsPdfInputType else {
            assertionFailure("Missing exptected analytics pdf input type")
            return
        }
        self.analyticsManager.track(event: .pageAdded(pdfInputType: currentAnalyticsPdfInputType, fileExtension: self.currentAnalyticsInputFileExtension))
        self.currentAnalyticsPdfInputType = nil
        self.currentAnalyticsInputFileExtension = nil
    }
}

enum PdfEditSaveError: LocalizedError {
    case unknown
    case noPages
    
    var errorDescription: String? {
        switch self {
        case .unknown: return "Internal Error. Please try again later."
        case .noPages: return "Your pdf doesn't contain any pages."
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfFillFormViewModel.swift
================================================
//
//  PdfFillFormViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 26/05/23.
//

import Foundation
import Factory
import PDFKit
import UIKit

extension Container {
    var pdfFillFormViewModel: ParameterFactory<PdfFillFormViewModel.InputParameter, PdfFillFormViewModel> {
        self { PdfFillFormViewModel(inputParameter: $0) }
    }
}

typealias PdfFillFormViewCallback = ((Pdf) -> ())

class PdfFillFormViewModel: ObservableObject {
    
    struct InputParameter {
        let pdf: Pdf
        let currentPageIndex: Int
        let onConfirm: PdfFillFormViewCallback
    }
    
    @Published var pdfDocument: PDFDocument
    @Published var pageImages: [UIImage]
    @Published var pageIndex: Int {
        didSet {
            self.applyCurrentEditedTextAnnotation()
            self.editedPageIndex = nil
        }
    }
    @Published var annotations: [PDFAnnotation]
    @Published var currentTextResizableViewData: TextResizableViewData = TextResizableViewData(text: "", rect: .zero)
    @Published var editedPageIndex: Int? = nil
    @Published var showSuggestedFields: Bool = false {
        didSet {
            if !self.showSuggestedFields {
                self.refreshSuggestedFields()
            }
        }
    }
    @Published var suggestedFields: SuggestedFields? = nil
    
    var pageViewSize: CGSize = .zero
    var unsavedChangesExist: Bool = false
    
    // Used only to perform point and rect conversions from view space to page space and viceversa
    // A dedicated PDFView for each page is needed, because changing page on the fly based on the
    // needed page appears not to be done instantly, giving wrong results.
    // This way we achieve correctness but at the cost of an increased memory consumption.
    private let pdfViews: [PDFView]
    
    @Injected(\.analyticsManager) private var analyticsManager
    private let repository = resolve(\.repository)
    
    private var onConfirm: PdfFillFormViewCallback
    
    private var pdf: Pdf
    
    init(inputParameter: InputParameter) {
        self.pdf = inputParameter.pdf
        var pdfDocumentCopy = PDFDocument()
        if let pdfData = inputParameter.pdf.pdfDocument.dataRepresentation(), let copy = PDFDocument(data: pdfData) {
            pdfDocumentCopy = copy
        }
        self.pdfDocument = pdfDocumentCopy
        
        self.onConfirm = inputParameter.onConfirm
        
        var pdfViews: [PDFView] = []
        var annotationLists: [PDFAnnotation] = []
        var pageImages: [UIImage] = []
        for pageIndex in 0..<pdfDocumentCopy.pageCount {
            if let page = pdfDocumentCopy.page(at: pageIndex) {
                let annotations = page.annotations.supportedAnnotations
                // Store annotations
                annotationLists.append(contentsOf: annotations)
                // Detach annotations from page
                for annotation in annotations {
                    page.removeAnnotation(annotation)
                }
                // Render page
                pageImages.append(page.thumbnail(of: page.bounds(for: .mediaBox).size, for: .mediaBox))
                
                let pdfView = PDFView()
                pdfView.document = pdfDocumentCopy
                pdfView.autoScales = true
                pdfView.displayMode = .singlePage
                pdfView.go(to: page)
                pdfViews.append(pdfView)
            }
        }
        self.annotations = annotationLists
        self.pageImages = pageImages
        self.pdfViews = pdfViews
        
        self.pageIndex = inputParameter.currentPageIndex
        
        self.refreshSuggestedFields()
    }
    
    func onAppear() {
        self.analyticsManager.track(event: .reportScreen(.fillForm))
    }
    
    func getAnnotations(forPageIndex pageIndex: Int) -> [PDFAnnotation] {
        guard let page = self.pdfDocument.page(at: pageIndex) else {
            return []
        }
        return self.annotations
            .filter { $0.page == page }
    }
    
    func tapOnPdfView(positionInView: CGPoint, pageIndex: Int, pageViewSize: CGSize) {
        guard let page = self.pdfDocument.page(at: pageIndex) else {
            return
        }
        
        if self.pageViewSize == .zero {
            self.pageViewSize = pageViewSize
        }
        
        debugPrint(for: self, message: "Tap in: \(positionInView), for page index: \(pageIndex)")
        
        let pointInPage = self.convertPoint(positionInView, viewSize: pageViewSize, toPage: page)
        let textAnnotations = self.annotations.filter { $0.isTextAnnotation }
        let textAnnotationsInPoint = textAnnotations.filter { $0.page == page && $0.verticalCenteredTextBounds.contains(pointInPage) }
        
        if self.editedPageIndex != nil, self.currentTextResizableViewData.rect.contains(positionInView) {
            // Tapping inside the currently selected text resizable view -> Do nothing
            return
        }
        
        if self.editedPageIndex != nil {
            // Tapping outside the currently selected text resizable view -> convert that text resizable view to text annotation
            self.applyCurrentEditedTextAnnotation()
            self.editedPageIndex = nil

            if let textAnnotation = textAnnotationsInPoint.first {
                // Tapping inside a different text annotation -> convert that text annotation to text resizable view
                let rect = self.convertRect(textAnnotation.verticalCenteredTextBounds, viewSize: self.pageViewSize, fromPage: page)
                self.currentTextResizableViewData = TextResizableViewData(text: textAnnotation.text, rect: rect)
                self.editedPageIndex = pageIndex
                self.annotations.removeAll(where: { $0 == textAnnotation })
            }
            // Changes are applied, set the dirty flag
            self.unsavedChangesExist = true
        } else if let textAnnotation = textAnnotationsInPoint.first {
            // Tapping inside a text annotation -> convert that text annotation to text resizable view
            let rect = self.convertRect(textAnnotation.verticalCenteredTextBounds, viewSize: self.pageViewSize, fromPage: page)
            self.currentTextResizableViewData = TextResizableViewData(text: textAnnotation.contents ?? "", rect: rect)
            self.editedPageIndex = pageIndex
            self.annotations.removeAll(where: { $0 == textAnnotation })
            // Nothing changes in this exact instant, but it will if the user modify the text resizable view
            // Just set the dirty flag here to keep it simple
            self.unsavedChangesExist = true
        } else {
            // Tapping in empty area -> create a new text resizable view
            let size = CGSize(width: 100, height: 15)
            let rect = CGRect(x: positionInView.x - (size.width / 2), y: positionInView.y - (size.height / 2), width: size.width, height: size.height)
            self.currentTextResizableViewData = TextResizableViewData(text: "", rect: rect)
            self.editedPageIndex = pageIndex
            // The newly created text resizable view will be added as an annotation upon confirmation
            // thus the dirty flag must be set
            self.unsavedChangesExist = true
        }
    }
    
    func onDeleteAnnotationPressed() {
        self.editedPageIndex = nil
        self.analyticsManager.track(event: .textAnnotationRemoved)
        // A text resizable view has been removed. If that view was associated to an existing text annotation
        // a change has been made to the original file. Just setting the dirty flag anyway to keep it simple
        self.unsavedChangesExist = true
    }
    
    func onConfirmButtonPressed() {
        if self.editedPageIndex != nil {
            self.applyCurrentEditedTextAnnotation()
        }
        
        if self.unsavedChangesExist {
            for pageIndex in 0..<self.pdfDocument.pageCount {
                if let page = self.pdfDocument.page(at: pageIndex) {
                    let pageAnnotations = self.annotations.filter { $0.page == page }
                    // Attach annotations to page
                    for pageAnnotation in pageAnnotations {
                        page.addAnnotation(pageAnnotation)
                    }
                }
            }
            self.pdf.updateDocument(self.pdfDocument)
            self.onConfirm(self.pdf)
        }
        
        self.analyticsManager.track(event: .annotationsConfirmed)
    }
    
    func onSuggestedFieldsButtonPressed() {
        self.showSuggestedFields = true
    }
    
    private func refreshSuggestedFields() {
        self.suggestedFields = try? self.repository.loadSuggestedFields()
    }
    
    private func applyCurrentEditedTextAnnotation() {
        guard let pageIndex = self.editedPageIndex, let page = self.pdfDocument.page(at: pageIndex), !self.currentTextResizableViewData.text.isEmpty else {
            return
        }
        let bounds = self.convertRect(self.currentTextResizableViewData.rect, viewSize: self.pageViewSize, toPage: page)
        let annotation = PDFAnnotation.create(with: self.currentTextResizableViewData.text,
                                              forBounds: bounds,
                                              textColor: .black,
                                              fontName: K.Misc.DefaultAnnotationTextFontName,
                                              withProperties: nil)
        annotation.page = page
        self.annotations.append(annotation)
        self.unsavedChangesExist = true
        self.analyticsManager.track(event: .textAnnotationAdded)
    }
    
    func convertPoint(_ point: CGPoint, viewSize: CGSize, toPage: PDFPage) -> CGPoint {
        guard let pdfView = self.getPdfView(viewSize: viewSize, page: toPage) else {
            return .zero
        }
        return pdfView.convert(point, to: toPage)
    }

    func convertPoint(_ point: CGPoint, viewSize: CGSize, fromPage: PDFPage) -> CGPoint {
        guard let pdfView = self.getPdfView(viewSize: viewSize, page: fromPage) else {
            return .zero
        }
        return pdfView.convert(point, from: fromPage)
    }
    
    func convertRect(_ rect: CGRect, viewSize: CGSize, toPage: PDFPage) -> CGRect {
        guard let pdfView = self.getPdfView(viewSize: viewSize, page: toPage) else {
            return .zero
        }
        return pdfView.convert(rect, to: toPage)
    }
    
    func convertRect(_ rect: CGRect, viewSize: CGSize, fromPage: PDFPage) -> CGRect {
        guard let pdfView = self.getPdfView(viewSize: viewSize, page: fromPage) else {
            return .zero
        }
        return pdfView.convert(rect, from: fromPage)
    }
    
    private func getPdfView(viewSize: CGSize, page: PDFPage) -> PDFView? {
        guard let pdfView = self.pdfViews.first(where: { $0.currentPage == page }) else {
            assertionFailure("Missing PdfView with given page")
            return nil
        }
        pdfView.frame = CGRect(origin: .zero, size: viewSize)
        return pdfView
    }
}

fileprivate extension Array where Element == PDFAnnotation {
    var supportedAnnotations: [PDFAnnotation] {
        self.filter { $0.isTextAnnotation }
    }
}

extension CGRect {
    func getYInverted(forParentSize parentHeight: CGFloat) -> CGRect {
        return CGRect(origin: CGPoint(x: self.origin.x, y: parentHeight-self.origin.y-self.size.height), size: self.size)
    }
}

extension CGPoint {
    func getYInverted(forParentSize parentHeight: CGFloat) -> CGPoint {
        return CGPoint(x: self.x, y: parentHeight-self.y)
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfFillWidgetViewModel.swift
================================================
//
//  PdfFillWidgetViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 22/06/23.
//

import Foundation
import Factory
import PDFKit
import UIKit

extension Container {
    var pdfFillWidgetViewModel: ParameterFactory<PdfFillWidgetViewModel.InputParameter, PdfFillWidgetViewModel> {
        self { PdfFillWidgetViewModel(inputParameter: $0) }
    }
}

typealias PdfFillWidgetViewModelCallback = ((Pdf) -> ())

class PdfFillWidgetViewModel: ObservableObject {
    
    struct InputParameter {
        let pdf: Pdf
        let currentPageIndex: Int
        let onConfirm: PdfFillWidgetViewModelCallback
    }
    
    @Published var pdfDocument: PDFDocument
    @Published var pdfView: PDFView = PDFView()
    @Published var pdfCurrentPageIndex: Int
    
    @Injected(\.analyticsManager) private var analyticsManager
    
    var unsavedChangesExist: Bool = true
    
    private var onConfirm: PdfFillWidgetViewModelCallback
    
    private var pdf: Pdf
    
    init(inputParameter: InputParameter) {
        self.pdf = inputParameter.pdf
        var pdfDocumentCopy = PDFDocument()
        if let pdfData = inputParameter.pdf.pdfDocument.dataRepresentation(), let copy = PDFDocument(data: pdfData) {
            pdfDocumentCopy = copy
        }
        self.onConfirm = inputParameter.onConfirm
        self.pdfDocument = pdfDocumentCopy
        self.pdfCurrentPageIndex = inputParameter.currentPageIndex
        self.pdfView.document = pdfDocumentCopy
        
        if let page = self.pdfView.document?.page(at: inputParameter.currentPageIndex) {
            self.pdfView.go(to: page)
        }
        
        NotificationCenter.default.addObserver(
              self,
              selector: #selector(self.handlePageChange(notification:)),
              name: Notification.Name.PDFViewPageChanged,
              object: nil)
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self, name: Notification.Name.PDFViewPageChanged, object: nil)
    }
    
    func onAppear() {
        self.analyticsManager.track(event: .reportScreen(.fillWidget))
    }
    
    func onCancelButtonPressed() {
        self.analyticsManager.track(event: .fillWidgetCancelled)
    }
    
    func onConfirmButtonPressed() {
        // TODO: Check if there are changes in the annotations and propagate changes only in that case
        self.analyticsManager.track(event: .fillWidgetConfirmed)
        self.pdf.updateDocument(self.pdfDocument)
        self.onConfirm(self.pdf)
    }
    
    @objc private func handlePageChange(notification: Notification) {
        guard let currentPageindex = self.pdfView.currentPageIndex else {
            assertionFailure("Missing expected page index")
            return
        }
        self.pdfCurrentPageIndex = currentPageindex
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfImportMultipleViewModel.swift
================================================
//
//  PdfImportMultipleViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/08/23.
//

import Foundation
import Factory
import SwiftUI
import UniformTypeIdentifiers

extension Container {
    var pdfImportMultipleViewModel: ParameterFactory<PdfImportMultipleViewModel.Params, PdfImportMultipleViewModel> {
        self { PdfImportMultipleViewModel(params: $0) }
    }
}

class PdfImportMultipleViewModel: ObservableObject {
    
    struct Params {
        let asyncPdfs: Binding<AsyncOperation<[Pdf], PdfError>>
    }
    
    @Published var loading: Bool = false
    @Published var showFilePicker: Bool = false
    
    lazy var pdfUnlockViewModel: PdfUnlockViewModel = {
        Container.shared.pdfUnlockViewModel(PdfUnlockViewModel.Params(asyncUnlockedPdfMultipleOutput: self.asyncImportedPdfs))
    }()
    
    var importFileTypes: [UTType] = []
    
    private let asyncImportedPdfs: Binding<AsyncOperation<[Pdf], PdfError>>
    
    init(params: Params) {
        self.asyncImportedPdfs = params.asyncPdfs
    }
    
    func importPdfs(importFileTypes: [UTType]) {
        self.importFileTypes = importFileTypes
        self.showFilePicker = true
    }
    
    @MainActor
    func processSelectedUrls(_ urls: [URL]) {
        guard urls.count > 0 else {
            assertionFailure("Missing selected urls")
            self.asyncImportedPdfs.wrappedValue = .init(status: .error(.urlToPdfConversionError))
            return
        }
        
        self.loading = true
        Task {
            let task = Task<[Pdf], Never> {
                return urls.compactMap { Pdf(pdfUrl: $0) }
            }
            let pdfs = await task.value
            if pdfs.count > 0 {
                self.pdfUnlockViewModel.unlockPdfs(pdfs: pdfs)
            } else {
                self.asyncImportedPdfs.wrappedValue = .init(status: .error(.urlToPdfConversionError))
            }
            self.loading = false
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfImportViewModel.swift
================================================
//
//  PdfImportViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/08/23.
//

import Foundation
import Factory
import SwiftUI
import UniformTypeIdentifiers

extension Container {
    var pdfImportViewModel: ParameterFactory<PdfImportViewModel.Params, PdfImportViewModel> {
        self { PdfImportViewModel(params: $0) }
    }
}

class PdfImportViewModel: ObservableObject {
    
    struct Params {
        let asyncPdf: Binding<AsyncOperation<Pdf, PdfError>>
    }
    
    @Published var loading: Bool = false
    @Published var showFilePicker: Bool = false
    
    lazy var pdfUnlockViewModel: PdfUnlockViewModel = {
        Container.shared.pdfUnlockViewModel(PdfUnlockViewModel.Params(asyncUnlockedPdfSingleOutput: self.asyncImportedPdf))
    }()
    
    var importFileTypes: [UTType] = []
    
    private let asyncImportedPdf: Binding<AsyncOperation<Pdf, PdfError>>
    
    init(params: Params) {
        self.asyncImportedPdf = params.asyncPdf
    }
    
    func importPdf(importFileTypes: [UTType]) {
        self.importFileTypes = importFileTypes
        self.showFilePicker = true
    }
    
    @MainActor
    func processSelectedUrls(_ urls: [URL]) {
        guard let url = urls.first else {
            assertionFailure("Missing selected url")
            self.asyncImportedPdf.wrappedValue = .init(status: .error(.urlToPdfConversionError))
            return
        }
        
        self.loading = true
        Task {
            let task = Task<Pdf?, Never> {
                return Pdf(pdfUrl: url)
            }
            if let pdf = await task.value {
                self.pdfUnlockViewModel.unlockPdf(pdf: pdf)
            } else {
                self.asyncImportedPdf.wrappedValue = .init(status: .error(.urlToPdfConversionError))
            }
            self.loading = false
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfMergeViewModel.swift
================================================
//
//  PdfMergeViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 02/08/23.
//

import Foundation
import Factory
import SwiftUI

@MainActor
extension Container {
    var pdfMergeViewModel: ParameterFactory<PdfMergeViewModel.Params, PdfMergeViewModel> {
        self { PdfMergeViewModel(params: $0) }
    }
}

@MainActor
class PdfMergeViewModel: ObservableObject {
    
    struct Params {
        let asyncPdf: Binding<AsyncOperation<Pdf, PdfError>>
    }
    
    @Published var loading: Bool = false
    @Published var showPdfSorter: Bool = false
    @Published var asyncImportedPdfs: AsyncOperation<[Pdf], PdfError> = AsyncOperation(status: .empty) {
        didSet {
            if let importedPdfs = self.asyncImportedPdfs.data {
                self.onImportCompleted(pdfs: importedPdfs)
                self.asyncImportedPdfs = .init(status: .empty)
            }
        }
    }
    @Published var toBeSortedPdfs: [Pdf] = []
    
    @Injected(\.analyticsManager) private var analyticsManager
    
    lazy var pdfImportMultipleViewModel: PdfImportMultipleViewModel = {
        Container.shared.pdfImportMultipleViewModel(PdfImportMultipleViewModel.Params(asyncPdfs: self.asyncSubject(\.asyncImportedPdfs)))
    }()
    
    private let asyncMergedPdf: Binding<AsyncOperation<Pdf, PdfError>>
    
    init(params: Params) {
        self.asyncMergedPdf = params.asyncPdf
    }
    
    func merge() {
        self.pdfImportMultipleViewModel.importPdfs(importFileTypes: K.Misc.ImportFileTypesForMerge)
    }
    
    func onSortedCancelled() {
        self.toBeSortedPdfs = []
        self.showPdfSorter = false
    }
    
    func onSortedConfirmed() {
        self.showPdfSorter = false
    }
    
    @MainActor
    func onSortedCompleted() {
        if self.toBeSortedPdfs.count > 0 {
            self.mergePdfs(pdfs: self.toBeSortedPdfs)
            self.toBeSortedPdfs = []
        } else {
            self.asyncMergedPdf.wrappedValue = .init(status: .empty)
        }
    }
    
    private func onImportCompleted(pdfs: [Pdf]) {
        if pdfs.count > 1 {
            self.toBeSortedPdfs = pdfs
            self.showPdfSorter = true
        } else if pdfs.count == 1, let pdf = pdfs.first {
            self.asyncMergedPdf.wrappedValue = AsyncOperation(status: .data(pdf))
        } else {
            self.asyncMergedPdf.wrappedValue = .init(status: .empty)
        }
    }
    
    @MainActor
    private func mergePdfs(pdfs: [Pdf]) {
        self.loading = true
        
        Task {
            let task = Task<Pdf, Never> {
                return pdfs.reduce(Pdf()) { accumulatedPdf, currentPdf in
                    var accumulatedPdf = accumulatedPdf
                    let document = accumulatedPdf.pdfDocument
                    PDFUtility.appendPdfDocument(currentPdf.pdfDocument, toPdfDocument: document)
                    accumulatedPdf.updateDocument(document)
                    return accumulatedPdf
                }
            }
            let mergedPdf = await task.value
            self.loading = false
            self.asyncMergedPdf.wrappedValue = AsyncOperation(status: .data(mergedPdf))
            self.analyticsManager.track(event: .pdfMerge)
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfPageRangeEditorViewModel.swift
================================================
//
//  PdfPageRangeEditorViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/08/23.
//

import Foundation
import Factory
import SwiftUI
import Combine

extension Container {
    var pdfPageRangeEditorViewModel: ParameterFactory<PdfPageRangeEditorViewModel.Params, PdfPageRangeEditorViewModel> {
        self { PdfPageRangeEditorViewModel(params: $0) }
    }
}

typealias PdfPageRangeEditorConfirmCallback = () -> ()
typealias PdfPageRangeEditorCancelCallback = () -> ()

enum PdfPageRangeFocusable: Hashable {
    case lowerBound(index: Int)
    case upperBound(index: Int)
}

class PdfPageRangeEditorViewModel: ObservableObject {
    
    struct Params {
        let pageRanges: Binding<[ClosedRange<Int>]>
        let totalPages: Int
        let confirmCallback: PdfPageRangeEditorConfirmCallback
        let cancelCallback: PdfPageRangeEditorCancelCallback
    }
    
    private var pageRanges: Binding<[ClosedRange<Int>]>
    
    @Published var pageRangeLowerBounds: [String]
    @Published var pageRangeUpperBounds: [String]
    
    @Published var pdfPageRangeInFocus: PdfPageRangeFocusable? = nil
    
    private let totalPages: Int
    private let confirmCallback: PdfPageRangeEditorConfirmCallback
    private let cancelCallback: PdfPageRangeEditorCancelCallback
    
    private var cancelBag = Set<AnyCancellable>()
    
    init(params: Params) {
        self.pageRanges = params.pageRanges
        self.totalPages = params.totalPages
        self.confirmCallback = params.confirmCallback
        self.cancelCallback = params.cancelCallback
        
        self.pageRangeLowerBounds = params.pageRanges.wrappedValue.map { "\($0.lowerBound + 1)" }
        self.pageRangeUpperBounds = params.pageRanges.wrappedValue.map { "\($0.upperBound + 1)" }
        
        self.$pdfPageRangeInFocus
            .withPrevious(nil)
            .sink { [weak self] previousField, _ in
                guard let self else { return }
                // Validate the focus field that is losing focus.
                if let previousField {
                    self.validateField(field: previousField)
                }
            }.store(in: &self.cancelBag)
    }
    
    func focus(index: Int, isLowerBound: Bool) {
        self.pdfPageRangeInFocus = isLowerBound ? .lowerBound(index: index) : .upperBound(index: index)
    }
    
    func confirm() {
        self.pdfPageRangeInFocus = nil
        guard let pageRanges = self.getPageRangesFromRangeStrings() else {
            self.cancelCallback()
            return
        }
        self.pageRanges.wrappedValue = pageRanges
        self.confirmCallback()
    }
    
    func cancel() {
        self.pdfPageRangeInFocus = nil
        self.cancelCallback()
    }
    
    func onConfirmRange() {
        self.pdfPageRangeInFocus = nil
    }
    
    func addRange() {
        self.pdfPageRangeInFocus = nil
        self.pageRangeLowerBounds.append("1")
        self.pageRangeUpperBounds.append("\(self.totalPages)")
    }
    
    func removeRange(atIndex index: Int) {
        self.pdfPageRangeInFocus = nil
        self.pageRangeLowerBounds.remove(at: index)
        self.pageRangeUpperBounds.remove(at: index)
    }
    
    func validateLowerBound(forIndex index: Int) {
        guard self.pageRangeLowerBounds.count == self.pageRangeUpperBounds.count else {
            assertionFailure("lower bounds count and upper bounds count don't match")
            return
        }
        
        guard index >= 0, index < self.pageRangeLowerBounds.count else {
            assertionFailure("Given index is out of range!")
            return
        }
        
        let userFriendlyUpperBound = Int(self.pageRangeUpperBounds[index])
        
        guard let userFriendlyUpperBound else {
            assertionFailure("Upper bound strings couldn't be parsed")
            return
        }
        
        let userFriendlyLowerBound = Int(self.pageRangeLowerBounds[index])
        
        if let userFriendlyLowerBound {
            if userFriendlyLowerBound < 1 {
                self.pageRangeLowerBounds[index] = 1.toString
            } else if userFriendlyLowerBound > userFriendlyUpperBound {
                self.pageRangeLowerBounds[index] = userFriendlyUpperBound.toString
            } else {
                // This is a normalizing step. E.g.: Input: 03 -> Output 3
                self.pageRangeLowerBounds[index] = userFriendlyLowerBound.toString
            }
        } else {
            self.pageRangeLowerBounds[index] = 1.toString
        }
    }
    
    func getTextFieldText(index: Int, isLowerBound: Bool) -> Binding<String> {
        // Inline binding avoid out of index exception when deleting an in-focus range
        Binding(get: {
            guard index < self.pageRangeLowerBounds.count else {
                return ""
            }
            return isLowerBound
            ? self.pageRangeLowerBounds[index]
            : self.pageRangeUpperBounds[index]
        }, set: { newValue in
            guard index < self.pageRangeLowerBounds.count else {
                return
            }
            if isLowerBound {
                self.pageRangeLowerBounds[index] = newValue
            } else {
                self.pageRangeUpperBounds[index] = newValue
            }
        })
    }
    
    private func validateField(field: PdfPageRangeFocusable) {
        switch field {
        case .lowerBound(let index):
            self.validateLowerBound(forIndex: index)
        case .upperBound(let index):
            self.validateUpperBound(forIndex: index)
        }
    }
    
    func validateUpperBound(forIndex index: Int) {
        guard self.pageRangeLowerBounds.count == self.pageRangeUpperBounds.count else {
            assertionFailure("lower bounds count and upper bounds count don't match")
            return
        }
        
        guard index >= 0, index < self.pageRangeUpperBounds.count else {
            assertionFailure("Given index is out of range!")
            return
        }
        
        let userFriendlyLowerBound = Int(self.pageRangeLowerBounds[index])
        
        guard let userFriendlyLowerBound else {
            assertionFailure("Lower bound strings couldn't be parsed")
            return
        }
        
        let userFriendlyUpperBound = Int(self.pageRangeUpperBounds[index])
        
        if let userFriendlyUpperBound {
            if userFriendlyUpperBound > self.totalPages {
                self.pageRangeUpperBounds[index] = self.totalPages.toString
            } else if userFriendlyLowerBound > userFriendlyUpperBound {
                self.pageRangeUpperBounds[index] = userFriendlyLowerBound.toString
            } else {
                // This is a normalizing step. E.g.: Input: 03 -> Output 3
                self.pageRangeUpperBounds[index] = userFriendlyUpperBound.toString
            }
        } else {
            self.pageRangeUpperBounds[index] = self.totalPages.toString
        }
    }
    
    private func getPageRangesFromRangeStrings() -> [ClosedRange<Int>]? {
        guard self.pageRangeLowerBounds.count == self.pageRangeUpperBounds.count else {
            assertionFailure("lower bounds count and upper bounds count don't match")
            return nil
        }
        
        var result: [ClosedRange<Int>] = []
        
        for index in 0..<self.pageRangeLowerBounds.count {
            let userFriendlyLowerBound = Int(self.pageRangeLowerBounds[index])
            let userFriendlyUpperBound = Int(self.pageRangeUpperBounds[index])
            if let userFriendlyLowerBound, let userFriendlyUpperBound {
                let lowerBound = userFriendlyLowerBound - 1
                let upperBound = userFriendlyUpperBound - 1
                if lowerBound >= 0, upperBound < self.totalPages, lowerBound <= upperBound {
                    result.append(lowerBound...upperBound)
                } else {
                    assertionFailure("Lower or upper bound contained invalid values")
                }
            } else {
                assertionFailure("Lower or upper bound strings couldn't be parsed")
            }
        }
        
//        print("PdfPageRangeEditorViewModel - Lower Bounds: \(self.pageRangeLowerBounds)")
//        print("PdfPageRangeEditorViewModel - Upper Bounds: \(self.pageRangeUpperBounds)")
//        print("PdfPageRangeEditorViewModel - Result: \(result)")
        
        return result
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfReaderViewModel.swift
================================================
//
//  PdfReaderViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/08/23.
//

import Foundation
import Factory
import SwiftUI
import PDFKit

extension Container {
    var pdfReaderViewModel: ParameterFactory<PdfReaderViewModel.Params, PdfReaderViewModel> {
        self { PdfReaderViewModel(params: $0) }
    }
}

class PdfReaderViewModel: ObservableObject {
    
    struct Params {
        let pdf: Pdf
    }
    
    @Published var pages: [AttributedString?] = []
    @Published var pageIndex: Int = 0 {
        didSet {
            if let page = self.pdfView.document?.page(at: self.pageIndex) {
                self.pdfView.go(to: page)
            }
        }
    }
    
    @Published var pdfView: PDFView = PDFView()
    
    @Published var textMode: Bool = false
    @Published var fontScale: CGFloat = K.Misc.PdfReaderDefaultFontScale
    
    @Published var pageThumbnails: AsyncItem<[UIImage?]> = .empty
    @Published var showPageSelection: Bool = false
    
    @Published var pageImages: AsyncItemFailable<[PdfImage], SharedUnderlyingError> = .empty
    @Published var showPageImages: Bool = false
    
    @Injected(\.analyticsManager) private var analyticsManager
    
    var filename: String { self.pdf.filename }
    var pageCount: Int { self.pdf.pageCount }
    
    private let pdf: Pdf
    
    init(params: Params) {
        self.pdf = params.pdf
        self.updatePages()
        
        var pdfDocumentCopy = PDFDocument()
        if let pdfData = params.pdf.pdfDocument.dataRepresentation(), let copy = PDFDocument(data: pdfData) {
            pdfDocumentCopy = copy
        }
        pdfDocumentCopy.pages.forEach{ $0.annotations.forEach { $0.isReadOnly = true } }
        self.pdfView.document = pdfDocumentCopy
        self.pdfView.displayDirection = .horizontal
        
        NotificationCenter.default.addObserver(
              self,
              selector: #selector(self.handlePageChange(notification:)),
              name: Notification.Name.PDFViewPageChanged,
              object: nil)
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self, name: Notification.Name.PDFViewPageChanged, object: nil)
    }
    
    func onAppear() {
        self.analyticsManager.track(event: .reportScreen(.reader))
    }
    
    func updatePages() {
        self.pages = self.pdf.map { $0.attributedString?.getPdfBodyText(fontScale: self.fontScale) }
    }
    
    @MainActor
    func presentPageSelection() {
        if self.pageThumbnails.hasData {
            self.showPageSelection = true
        } else {
            self.pageThumbnails = .loading(.undeterminedProgress)
            Task {
                let task = Task<[UIImage?], Never> {
                    return PDFUtility.generatePdfThumbnails(pdfDocument: self.pdf.pdfDocument,
                                                            size: K.Misc.ThumbnailSize)
                }
                self.pageThumbnails = .data(await task.value)
                self.showPageSelection = true
            }
        }
    }
    
    @MainActor
    func presentPageImages() {
        guard self.pageIndex < self.pdf.pageCount else {
            self.pageImages = .error(.unknownError)
            return
        }
        
        let page = self.pdf[self.pageIndex]
        
        self.pageImages = .loading(.undeterminedProgress)
        do {
            var images: [PdfImage] = []
            try extractImages(from: page) { image, name in
                let uiImage: UIImage? = {
                    switch image {
                    case .jpg(let data):
                        return UIImage(data: data)
                    case .raw(let cgImage):
                        return UIImage(cgImage: cgImage)
                    }
                }()
                if let uiImage {
                    images.append(PdfImage(image: uiImage, caption: name))
                }
            }
            self.pageImages = .data(images)
            self.showPageImages = true
        } catch {
            self.pageImages = .error(SharedUnderlyingError.convertError(fromError: error))
        }
    }
    
    func switchTextMode() {
        self.textMode = !self.textMode
    }
    
    @objc private func handlePageChange(notification: Notification) {
        guard let currentPageindex = self.pdfView.currentPageIndex, notification.object as? PDFView == self.pdfView else {
            assertionFailure("Missing expected page index")
            return
        }
        self.pageIndex = currentPageindex
    }
}

fileprivate extension NSAttributedString {
    
    func getPdfBodyText(fontScale: CGFloat) -> AttributedString? {
        
        let trimmedAttributedString = self.attributedStringByTrimmingCharacterSet(charSet: .whitespacesAndNewlines)
        
        guard trimmedAttributedString.length > 0 else {
            return nil
        }
        
        var attributedString = AttributedString(trimmedAttributedString)
        attributedString.foregroundColor = ColorPalette.primaryText
        for run in attributedString.runs {
            let fontSize: CGFloat? = run.uiKit.font?.fontDescriptor
                .fontAttributes[UIFontDescriptor.AttributeName.size] as? CGFloat
            let scaledFontSize = (fontSize ?? 16.0) * fontScale
            attributedString[run.range].font = FontPalette.fontMedium(withSize: scaledFontSize)
        }
        return attributedString
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfReadViewModel.swift
================================================
//
//  PdfReadViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/08/23.
//

import Foundation
import Factory

@MainActor
extension Container {
    var pdfReadViewModel: Factory<PdfReadViewModel> {
        self { PdfReadViewModel() }
    }
}

@MainActor
class PdfReadViewModel: ObservableObject {
    
    @Published var asyncImportedPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
        didSet {
            if let importedPdf = self.asyncImportedPdf.data {
                self.toBeReadPdf = importedPdf
                self.asyncImportedPdf = .init(status: .empty)
            }
        }
    }
    @Published var toBeReadPdf: Pdf? = nil
    
    @Injected(\.repository) private var repository
    @Injected(\.analyticsManager) private var analyticsManager
    
    lazy var pdfImportViewModel: PdfImportViewModel = {
        Container.shared.pdfImportViewModel(PdfImportViewModel.Params(asyncPdf: self.asyncSubject(\.asyncImportedPdf)))
    }()
    
    func read(pdf: Pdf?) {
        if let pdf = pdf {
            self.asyncImportedPdf = .init(status: .data(pdf))
        } else {
            self.pdfImportViewModel.importPdf(importFileTypes: K.Misc.ImportFileTypesForRead)
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfSignatureCanvasViewModel.swift
================================================
//
//  PdfSignatureCanvasViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 19/05/23.
//

import Foundation
import Factory
import UIKit
import PencilKit

extension Container {
    var pdfSignatureCanvasViewModel: ParameterFactory<PdfSignatureCanvasViewModel.ConfirmationCallback, PdfSignatureCanvasViewModel> {
        self { PdfSignatureCanvasViewModel(onConfirm: $0) }
    }
}

enum SignatureSource: CaseIterable, Hashable {
    case drawing
    case image
    case camera
}

class PdfSignatureCanvasViewModel: NSObject, ObservableObject {
    
    typealias ConfirmationCallback = ((Signature) -> ())
    
    @Published var canvasView = PKCanvasView()
    @Published var signatureGalleryImage: UIImage? = nil
    @Published var signatureCameraImage: UIImage? = nil
    @Published var shouldSaveSignature: Bool = false
    @Published var pdfSaveError: SharedUnderlyingError? = nil
    @Published var source: SignatureSource = .drawing {
        didSet {
            self.onSourceChanged(oldValue: oldValue)
        }
    }
    
    @Injected(\.repository) private var repository
    @Injected(\.analyticsManager) private var analyticsManager
    @Injected(\.galleryImageProviderFlow) var galleryImageProviderFlow
    @Injected(\.cameraImageProviderFlow) var cameraImageProviderFlow
    @Injected(\.imageCropFlow) var imageCropFlow
    
    var confirmAllowed: Bool {
        switch self.source {
        case .drawing: return self.canvasView.drawing.strokes.count > 0
        case .image: return self.signatureGalleryImage != nil
        case .camera: return self.signatureCameraImage != nil
        }
    }
    
    private var currentSignatureImage: UIImage? {
        switch self.source {
        case .drawing: return self.canvasView.drawing.signatureImage
        case .image: return self.signatureGalleryImage
        case .camera: return self.signatureCameraImage
        }
    }
    
    private let onConfirm: ConfirmationCallback
    
    init(onConfirm: @escaping ConfirmationCallback) {
        self.onConfirm = onConfirm
        super.init()
        self.canvasView.delegate = self
    }
    
    func onClearButtonPressed() {
        self.canvasView.drawing = PKDrawing()
    }
    
    func toggleShouldSave() {
        self.shouldSaveSignature = !self.shouldSaveSignature
    }
    
    func onConfirmButtonPressed() {
        
        guard let currentSignatureImage else {
            assertionFailure("Missing expected current signature image!")
            return
        }
        
        var signature = Signature(image: currentSignatureImage)
        if self.shouldSaveSignature {
            do {
                signature = try self.repository.saveSignature(signature: signature)
            } catch {
                self.pdfSaveError = .convertError(fromError: error)
            }
        }
        self.analyticsManager.track(event: .signatureCreated)
        self.onConfirm(signature)
    }
    
    func onSelectImageButtonPressed() {
        self.startGetImageFlow()
    }
    
    func onTakePictureButtonPressed() {
        self.startTakePictureFlow()
    }
    
    private func onSourceChanged(oldValue: SignatureSource) {
        if oldValue != self.source {
            switch self.source {
            case .drawing:
                break
            case .image:
                if self.signatureGalleryImage == nil {
                    self.startGetImageFlow()
                }
            case .camera:
                if self.signatureCameraImage == nil {
                    self.startTakePictureFlow()
                }
            }
        }
    }
    
    private func startGetImageFlow() {
        self.galleryImageProviderFlow.startFlow { [weak self] in
            self?.imageCropFlow.startFlow(image: $0, onImageCropped: { [weak self]  in
                self?.signatureGalleryImage = $0
            })
        }
    }
    
    private func startTakePictureFlow() {
        self.cameraImageProviderFlow.startFlow { [weak self] in
            self?.imageCropFlow.startFlow(image: $0, onImageCropped: { [weak self]  in
                self?.signatureCameraImage = $0
            })
        }
    }
}

extension PdfSignatureCanvasViewModel: PKCanvasViewDelegate {
    
    func canvasViewDrawingDidChange(_ canvasView: PKCanvasView) {
        if self.canvasView == canvasView {
            // This is needed mainly to refresh the confirm button availability
            self.objectWillChange.send()
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfSignaturePickerViewModel.swift
================================================
//
//  PdfSignaturePickerViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/08/23.
//

import Foundation
import Factory

extension Container {
    var pdfSignaturePickerViewModel: ParameterFactory<PdfSignaturePickerViewModel.Params, PdfSignaturePickerViewModel> {
        self { PdfSignaturePickerViewModel(params: $0) }
    }
}

class PdfSignaturePickerViewModel: ObservableObject {
    
    typealias ConfirmationCallback = ((Signature) -> ())
    typealias CancelCallback = (() -> ())
    typealias CreateNewSignatureCallback = (() -> ())
    
    struct Params {
        let confirmationCallback: ConfirmationCallback
        let cancelCallback: CancelCallback
        let createNewSignatureCallback: CreateNewSignatureCallback
    }
    
    @Published var asyncItems: AsyncOperation<[Signature], SharedLocalizedError> = AsyncOperation(status: .empty)
    @Published var asyncItemDelete: AsyncOperation<(), SharedLocalizedError> = AsyncOperation(status: .empty)
    @Published var isLoading: Bool = false
    
    @Injected(\.repository) var repository
    @Injected(\.analyticsManager) private var analyticsManager
    
    private let onConfirm: ConfirmationCallback
    private let onCancel: CancelCallback
    private let onCreateNewSignature: CreateNewSignatureCallback
    
    init(params: Params) {
        self.onConfirm = params.confirmationCallback
        self.onCancel = params.cancelCallback
        self.onCreateNewSignature = params.createNewSignatureCallback
    }
    
    func pick(item: Signature) {
        self.onConfirm(item)
    }
    
    func delete(item: Signature) {
        self.asyncItemDelete = AsyncOperation(status: .empty)
        do {
            try self.repository.delete(signature: item)
            self.asyncItemDelete = AsyncOperation(status: .empty)
        } catch {
            debugPrint(for: self, message: "Deletion failed. Error: \(error)")
            self.asyncItemDelete = AsyncOperation(status: .error(.unknownError))
        }
        self.refresh()
    }
    
    func delete(indexSet: IndexSet) {
        guard let allSignatures = asyncItems.data else {
            return
        }
        
        let signatures = indexSet.filteredIndexSet { $0 < allSignatures.count }.map { allSignatures[$0] }
        
        self.asyncItemDelete = AsyncOperation(status: .empty)
        do {
            try self.repository.delete(signatures: signatures)
            self.asyncItemDelete = AsyncOperation(status: .empty)
        } catch {
            debugPrint(for: self, message: "Deletion failed. Error: \(error)")
            self.asyncItemDelete = AsyncOperation(status: .error(.unknownError))
        }
        self.refresh()
    }
    
    func onAppear() {
        self.analyticsManager.track(event: .reportScreen(.signaturePicker))
        self.refresh()
    }
    
    func cancel() {
        self.onCancel()
    }
    
    func createNewSignature() {
        self.onCreateNewSignature()
    }
    
    func refresh() {
        do {
            let items = try self.repository.loadSignatures()
            self.asyncItems = AsyncOperation(status: .data(items))
        } catch {
            debugPrint(for: self, message: "Refresh failed. Error: \(error)")
            self.asyncItems = AsyncOperation(status: .error(SharedLocalizedError.unknownError))
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfSignaturePrioviderFlow.swift
================================================
//
//  PdfSignaturePrioviderFlow.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 29/08/23.
//

import Foundation
import Factory
import UIKit

extension Container {
    var pdfSignaturePrioviderFlow: Factory<PdfSignaturePrioviderFlow> {
        self { PdfSignaturePrioviderFlow() }
    }
}

class PdfSignaturePrioviderFlow: ObservableObject {
    
    typealias SignatureSelectedCallback = ((UIImage) -> ())
    
    @Published var showSignatureCreation: Bool = false
    @Published var showSignaturePicker: Bool = false
    
    @Injected(\.repository) private var repository
    
    private var onSignatureSelected: SignatureSelectedCallback?
    
    func startFlow(onSignatureSelected: @escaping SignatureSelectedCallback) {
        self.onSignatureSelected = onSignatureSelected
        if (try? self.repository.getDoSignatureExist()) ?? false {
            self.showSignaturePicker = true
        } else {
            self.showSignatureCreation = true
        }
    }
    
    func onSignatureSelected(signature: Signature) {
        self.showSignatureCreation = false
        self.showSignaturePicker = false
        self.onSignatureSelected?(signature.image)
    }
    
    @MainActor
    func onCreateNewSignature() {
        self.showSignaturePicker = false
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            self.showSignatureCreation = true
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfSignatureViewModel.swift
================================================
//
//  PdfSignatureViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 10/05/23.
//

import Foundation
import Factory
import PDFKit
import UIKit
import Combine

extension Container {
    var pdfSignatureViewModel: ParameterFactory<PdfSignatureViewModel.InputParameter, PdfSignatureViewModel> {
        self { PdfSignatureViewModel(inputParameter: $0) }
    }
}

typealias PdfSignatureCallback = ((Pdf) -> ())

class PdfSignatureViewModel: ObservableObject {
    
    struct InputParameter {
        let pdf: Pdf
        let currentPageIndex: Int
        let onConfirm: PdfSignatureCallback
    }
    
    @Published var pdfDocument: PDFDocument
    @Published var pageImages: [UIImage]
    @Published var pageIndex: Int
    @Published var editedPageIndex: Int? = nil
    @Published var annotations: [PDFAnnotation]
    @Published var signatureRect: CGRect = .zero
    @Published var signatureImage: UIImage? = nil
    
    var pageViewSize: CGSize = .zero
    var unsavedChangesExist: Bool = false
    
    // Used only to perform point and rect conversions from view space to page space and viceversa
    // A dedicated PDFView for each page is needed, because changing page on the fly based on the
    // needed page appears not to be done instantly, giving wrong results.
    // This way we achieve correctness but at the cost of an increased memory consumption.
    private let pdfViews: [PDFView]
    
    @Injected(\.analyticsManager) private var analyticsManager
    @Injected(\.pdfSignaturePrioviderFlow) var pdfSignaturePrioviderFlow
    
    private var onConfirm: PdfSignatureCallback
    private var pdf: Pdf
    private var isReplacing: Bool = false
    
    private var cancelBag = Set<AnyCancellable>()
    
    init(inputParameter: InputParameter) {
        self.pdf = inputParameter.pdf
        var pdfDocumentCopy = PDFDocument()
        if let pdfData = inputParameter.pdf.pdfDocument.dataRepresentation(), let copy = PDFDocument(data: pdfData) {
            pdfDocumentCopy = copy
        }
        self.pdfDocument = pdfDocumentCopy
        
        self.onConfirm = inputParameter.onConfirm
        
        var pdfViews: [PDFView] = []
        var annotationLists: [PDFAnnotation] = []
        var pageImages: [UIImage] = []
        for pageIndex in 0..<pdfDocumentCopy.pageCount {
            if let page = pdfDocumentCopy.page(at: pageIndex) {
                let annotations = page.annotations.signatureAnnotations
                // Store annotations
                annotationLists.append(contentsOf: annotations)
                // Detach annotations from page
                for annotation in annotations {
                    page.removeAnnotation(annotation)
                }
                // Render page
                pageImages.append(page.thumbnail(of: page.bounds(for: .mediaBox).size, for: .mediaBox))
                
                let pdfView = PDFView()
                pdfView.document = pdfDocumentCopy
                pdfView.autoScales = true
                pdfView.displayMode = .singlePage
                pdfView.go(to: page)
                pdfViews.append(pdfView)
            }
        }
        self.annotations = annotationLists
        self.pageImages = pageImages
        self.pdfViews = pdfViews
        
        self.pageIndex = inputParameter.currentPageIndex
        
        self.$pageIndex
            .sink { [weak self] _ in
                self?.applyCurrentEditedAnnotation()
            }.store(in: &self.cancelBag)
    }
    
    func onAppear() {
        self.analyticsManager.track(event: .reportScreen(.signature))
    }
    
    func getAnnotations(forPageIndex pageIndex: Int) -> [PDFAnnotation] {
        guard let page = self.pdfDocument.page(at: pageIndex) else {
            return []
        }
        return self.annotations
            .filter { $0.page == page }
    }
    
    func tapOnPdfView(positionInView: CGPoint, pageIndex: Int, pageViewSize: CGSize) {
        guard let page = self.pdfDocument.page(at: pageIndex) else {
            return
        }
        
        self.pageViewSize = pageViewSize
        
        let pointInPage = self.convertPoint(positionInView, viewSize: pageViewSize, toPage: page)
        let annotationsInPoint = self.annotations.filter { $0.page == page && $0.bounds.contains(pointInPage) }
        
        if self.signatureImage != nil, self.signatureRect.contains(positionInView) {
            // Tapping inside the currently selected image resizable view -> Do nothing
            return
        }
        
        if self.signatureImage != nil {
            // Tapping outside the currently selected image resizable view -> convert that image resizable view to signature annotation
            self.applyCurrentEditedAnnotation()

            if let annotationInPoint = annotationsInPoint.first {
                // Tapping inside a different signature annotation -> convert that signature annotation to image resizable view
                self.convertAnnotationToView(annotation: annotationInPoint,
                                             pageIndex: pageIndex)
            }
            // Changes are applied, set the dirty flag
            self.unsavedChangesExist = true
        } else if let annotationInPoint = annotationsInPoint.first {
            // Tapping inside a signature annotation -> convert that signature annotation to image resizable view
            self.convertAnnotationToView(annotation: annotationInPoint,
                                         pageIndex: pageIndex)
            // Nothing changes in this exact instant, but it will if the user changes the image of the signature
            // Just set the dirty flag here to keep it simple
            self.unsavedChangesExist = true
        } else {
            // Tapping in empty area -> start the signature creation flow
            self.editedPageIndex = pageIndex
            self.startSignatureSelectionFlow(isReplacing: false)
        }
    }
    
    func onDeleteAnnotationPressed() {
        self.signatureImage = nil
        self.editedPageIndex = nil
        self.analyticsManager.track(event: .signatureRemoved)
        // A image resizable view has been removed. If that view was associated to an existing signature annotation
        // a change has been made to the original file. Just setting the dirty flag anyway to keep it simple.
        self.unsavedChangesExist = true
    }
    
    func onReplaceAnnotationPressed() {
        self.startSignatureSelectionFlow(isReplacing: true)
    }
    
    func onConfirmButtonPressed() {
        self.applyCurrentEditedAnnotation()
        
        if self.unsavedChangesExist {
            for pageIndex in 0..<self.pdfDocument.pageCount {
                if let page = self.pdfDocument.page(at: pageIndex) {
                    let pageAnnotations = self.annotations.filter { $0.page == page }
                    // Attach annotations to page
                    for pageAnnotation in pageAnnotations {
                        page.addAnnotation(pageAnnotation)
                    }
                }
            }
            self.pdf.updateDocument(self.pdfDocument)
            self.onConfirm(self.pdf)
        }
        
        self.analyticsManager.track(event: .signaturesConfirmed)
    }
    
    private func applyCurrentEditedAnnotation() {
        if let signatureImage = self.signatureImage,
           let pageIndex = self.editedPageIndex,
           let page = self.pdfDocument.page(at: pageIndex) {
            let bounds = self.convertRect(self.signatureRect, viewSize: self.pageViewSize, toPage: page)
            let annotation = PDFAnnotation.createSignature(with: signatureImage, forBounds: bounds)
            annotation.page = page
            self.annotations.append(annotation)
            self.unsavedChangesExist = true
            self.analyticsManager.track(event: .signatureAdded)
        }
        self.signatureImage = nil
        self.editedPageIndex = nil
    }
    
    private func convertAnnotationToView(annotation: PDFAnnotation,
                                         pageIndex: Int) {
        guard let page = self.pdfDocument.page(at: pageIndex) else {
            assertionFailure("Missing page with given page index")
            return
        }
        
        self.signatureRect = self.convertRect(annotation.bounds, viewSize: self.pageViewSize, fromPage: page)
        self.signatureImage = annotation.image
        self.annotations.removeAll(where: { $0 == annotation })
        self.editedPageIndex = pageIndex
    }
    
    func startSignatureSelectionFlow(isReplacing: Bool) {
        self.isReplacing = isReplacing
        self.pdfSignaturePrioviderFlow.startFlow { [weak self] signatureImage in
            self?.onSignatureSelected(signatureImage: signatureImage)
        }
    }
    
    func onSignatureSelected(signatureImage: UIImage) {
        guard let page = self.pdfDocument.page(at: self.pageIndex) else {
            assertionFailure("Missing page with given page index")
            return
        }
        guard let pdfView = self.getPdfView(viewSize: self.pageViewSize, page: page) else {
            assertionFailure("Missing page view with given page")
            return
        }
        self.signatureImage = signatureImage
        if !self.isReplacing {
            let startingSignatureWidthOverPdfViewWidth = 0.7
            let margin: CGFloat = 40.0
            
            let signatureDefaultViewWidth: CGFloat = pdfView.bounds.size.width * startingSignatureWidthOverPdfViewWidth
            let signatureDefaultViewHeight: CGFloat = signatureDefaultViewWidth / signatureImage.size.aspectRatio
            
            var signatureDefaultViewSize = CGSize(width: signatureDefaultViewWidth,
                                                  height: signatureDefaultViewHeight)
            signatureDefaultViewSize = signatureDefaultViewSize.clipToSize(pdfView.bounds.size,
                                                                           horizontalMargin: margin,
                                                                           verticalMargin: margin,
                                                                           keepAspectRatio: true)
            
            self.signatureRect = CGRect(origin: CGPoint(x: pdfView.bounds.size.width * 0.5 - signatureDefaultViewSize.width / 2,
                                                        y: pdfView.bounds.size.height * 0.5 - signatureDefaultViewSize.height / 2) ,
                                        size: signatureDefaultViewSize)
        }
        // The newly created image resizable view will be added as a signature annotation upon confirmation
        // thus the dirty flag must be set
        self.unsavedChangesExist = true
    }
    
    func convertPoint(_ point: CGPoint, viewSize: CGSize, toPage: PDFPage) -> CGPoint {
        guard let pdfView = self.getPdfView(viewSize: viewSize, page: toPage) else {
            return .zero
        }
        return pdfView.convert(point, to: toPage)
    }

    func convertPoint(_ point: CGPoint, viewSize: CGSize, fromPage: PDFPage) -> CGPoint {
        guard let pdfView = self.getPdfView(viewSize: viewSize, page: fromPage) else {
            return .zero
        }
        return pdfView.convert(point, from: fromPage)
    }
    
    func convertRect(_ rect: CGRect, viewSize: CGSize, toPage: PDFPage) -> CGRect {
        guard let pdfView = self.getPdfView(viewSize: viewSize, page: toPage) else {
            return .zero
        }
        return pdfView.convert(rect, to: toPage)
    }
    
    func convertRect(_ rect: CGRect, viewSize: CGSize, fromPage: PDFPage) -> CGRect {
        guard let pdfView = self.getPdfView(viewSize: viewSize, page: fromPage) else {
            return .zero
        }
        return pdfView.convert(rect, from: fromPage)
    }
    
    private func getPdfView(viewSize: CGSize, page: PDFPage) -> PDFView? {
        guard let pdfView = self.pdfViews.first(where: { $0.currentPage == page }) else {
            assertionFailure("Missing PdfView with given page")
            return nil
        }
        pdfView.frame = CGRect(origin: .zero, size: viewSize)
        return pdfView
    }
}

fileprivate extension Array where Element == PDFAnnotation {
    var signatureAnnotations: [PDFAnnotation] {
        self.filter { $0.isSignatureAnnotation }
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfSortViewModel.swift
================================================
//
//  PdfSortViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 02/08/23.
//

import Foundation
import Factory
import SwiftUI

extension Container {
    var pdfSortViewModel: ParameterFactory<PdfSortViewModel.Params, PdfSortViewModel> {
        self { PdfSortViewModel(params: $0) }
    }
}

typealias PdfSortConfirmCallback = () -> ()
typealias PdfSortCancelCallback = () -> ()

class PdfSortViewModel: ObservableObject {
    
    struct Params {
        let pdfs: Binding<[Pdf]>
        let confirmButtonText: String
        let confirmCallback: PdfSortConfirmCallback
        let cancelCallback: PdfSortCancelCallback
    }
    
    let confirmButtonText: String
    
    @Binding var pdfs: [Pdf]
    
    private let confirmCallback: PdfSortConfirmCallback
    private let cancelCallback: PdfSortCancelCallback
    
    init(params: Params) {
        self._pdfs = params.pdfs
        self.confirmButtonText = params.confirmButtonText
        self.confirmCallback = params.confirmCallback
        self.cancelCallback = params.cancelCallback
    }
    
    func confirm() {
        self.confirmCallback()
    }
    
    func cancel() {
        self.cancelCallback()
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfSplitViewModel.swift
================================================
//
//  PdfSplitViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/08/23.
//

import Foundation
import Factory
import SwiftUI

@MainActor
extension Container {
    var pdfSplitViewModel: Factory<PdfSplitViewModel> {
        self { PdfSplitViewModel() }
    }
}

typealias SplitCompletedCallback = (() -> ())

@MainActor
class PdfSplitViewModel: ObservableObject {
    
    @Published var showPageRangeEditor: Bool = false
    @Published var showSuccess: Bool = false
    @Published var asyncImportedPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
        didSet {
            if let importedPdf = self.asyncImportedPdf.data {
                self.onImportCompleted(pdf: importedPdf)
                self.asyncImportedPdf = .init(status: .empty)
            }
        }
    }
    @Published var toBeSplitPdf: Pdf? = nil
    @Published var pageRanges: [ClosedRange<Int>] = []
    @Published var asyncSplit: AsyncEmptyFailable<PdfSplitError> = .idle
    
    @Injected(\.repository) private var repository
    @Injected(\.analyticsManager) private var analyticsManager
    
    lazy var pdfImportViewModel: PdfImportViewModel = {
        Container.shared.pdfImportViewModel(PdfImportViewModel.Params(asyncPdf: self.asyncSubject(\.asyncImportedPdf)))
    }()
    
    var totalPages: Int = 0
    
    private var onSplitCompleted: SplitCompletedCallback?
    
    func split(pdf: Pdf?, onSplitCompleted: SplitCompletedCallback?) {
        self.onSplitCompleted = onSplitCompleted
        if let pdf = pdf {
            self.asyncImportedPdf = .init(status: .data(pdf))
        } else {
            self.pdfImportViewModel.importPdf(importFileTypes: K.Misc.ImportFileTypesForSplit)
        }
    }
    
    func onPageRangeEditingCancelled() {
        self.toBeSplitPdf = nil
        self.showPageRangeEditor = false
    }
    
    func onPageRangeEditingConfirmed() {
        self.showPageRangeEditor = false
    }
    
    @MainActor
    func onPageRangeEditingCompleted() {
        self.splitPdf()
    }
    
    private func onImportCompleted(pdf: Pdf) {
        guard pdf.pageCount > 0 else {
            self.asyncSplit = .error(.pdfNoPage)
            return
        }
        guard pdf.pageCount > 1 else {
            // TODO: Decide whether pdf must still be saved or not
            self.asyncSplit = .error(.pdfSinglePage)
            return
        }
        self.toBeSplitPdf = pdf
        self.pageRanges = [0...pdf.pageCount - 1]
        self.totalPages = pdf.pageCount
        self.showPageRangeEditor = true
    }
    
    @MainActor
    private func splitPdf() {
        guard let pdf = self.toBeSplitPdf else {
            self.asyncSplit = .idle
            return
        }
        guard self.pageRanges.count > 0 else {
            assertionFailure("Page range array is empty!")
            self.asyncSplit = .error(.unknownError)
            return
        }
        self.asyncSplit = .loading(Progress.undeterminedProgress)
        
        Task {
            do {
                let splitPdfs = try await Self.splitPdf(pdf: pdf, pageRanges: self.pageRanges)
                try self.savePdfs(pdfs: splitPdfs)
                self.asyncSplit = .idle
                self.analyticsManager.track(event: .pdfSplit)
                self.onSplitCompleted?()
            } catch let splitError as PdfSplitError {
                self.asyncSplit = .error(splitError)
            } catch {
                self.asyncSplit = .error(PdfSplitError.convertError(fromError: error))
            }
            
            self.toBeSplitPdf = nil
            self.pageRanges = []
            self.totalPages = 0
        }
    }
    
    private static func splitPdf(pdf: Pdf, pageRanges: [ClosedRange<Int>]) async throws -> [Pdf] {
        var pdfs: [Pdf] = []
        for pageRange in pageRanges {
            pdfs.append(try await Self.getPdfSlice(fromPdf: pdf, pageRange: pageRange))
        }
        return pdfs
    }
    
    private func savePdfs(pdfs: [Pdf]) throws {
        // Any error is not blocking the entire save sequence
        var occurredError: Error?
        for pdf in pdfs {
            do {
                _ = try self.repository.savePdf(pdf: pdf)
            } catch {
                occurredError = error
            }
        }
        
        if let occurredError {
            throw occurredError
        }
    }
    
    private static func getPdfSlice(fromPdf pdf: Pdf, pageRange: ClosedRange<Int>) async throws -> Pdf {
        guard pageRange.overlaps(0...pdf.pageCount) else {
            throw PdfSplitError.incompatibleRange
        }
        let task = Task<Pdf, Never> {
            var pdfSlice = Pdf()
            let pdfSliceDocument = pdfSlice.pdfDocument
            for pageIndex in pageRange {
                if let page = pdf.pdfDocument.page(at: pageIndex) {
                    pdfSliceDocument.insert(page, at: pdfSliceDocument.pageCount)
                } else {
                    assertionFailure("Missing expected page!")
                }
            }
            pdfSlice.updateFilename(pdf.filename + pageRange.pdfFilenameSuffix)
            return pdfSlice
        }
        return await task.value
    }
}

fileprivate extension ClosedRange where Bound == Int {
    var pdfFilenameSuffix: String {
        "-\(self.lowerBound + 1)-\(self.upperBound + 1)"
    }
}



================================================
FILE: pdfexpert/ViewModels/PdfUnlockViewModel.swift
================================================
//
//  PdfUnlockViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 02/08/23.
//

import Foundation
import Factory
import SwiftUI

extension Container {
    var pdfUnlockViewModel: ParameterFactory<PdfUnlockViewModel.Params, PdfUnlockViewModel> {
        self { PdfUnlockViewModel(params: $0) }
    }
}

class PdfUnlockViewModel: ObservableObject {
    
    struct Params {
        let asyncUnlockedPdfMultipleOutput: Binding<AsyncOperation<[Pdf], PdfError>>?
        let asyncUnlockedPdfSingleOutput: Binding<AsyncOperation<Pdf, PdfError>>?
        
        init(asyncUnlockedPdfMultipleOutput: Binding<AsyncOperation<[Pdf], PdfError>>) {
            self.asyncUnlockedPdfMultipleOutput = asyncUnlockedPdfMultipleOutput
            self.asyncUnlockedPdfSingleOutput = nil
        }
        
        init(asyncUnlockedPdfSingleOutput: Binding<AsyncOperation<Pdf, PdfError>>) {
            self.asyncUnlockedPdfMultipleOutput = nil
            self.asyncUnlockedPdfSingleOutput = asyncUnlockedPdfSingleOutput
        }
    }
    
    @Published var showPasswordInputView: Bool = false
    @Published var passwordText: String = ""
    @Published var asyncUnlockedPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
        didSet {
            switch self.asyncUnlockedPdf.status {
            case .empty:
                // Just in case this reset is caused by an error alert dismiss, go the next pdf
                self.unlockNextPdf()
            case .loading:
                break
            case .error:
                // The error will be shown in the view
                break
            case .data(let unlockedPdf):
                self.onUnlockCompleted(forPdf: unlockedPdf)
            }
        }
    }
    
    var unlockingPdf: Pdf? = nil
    
    private let asyncUnlockedPdfMultipleOutput: Binding<AsyncOperation<[Pdf], PdfError>>?
    private let asyncUnlockedPdfSingleOutput: Binding<AsyncOperation<Pdf, PdfError>>?
    
    private var toBeUnlockedPdfs: [Pdf] = []
    private var unlockedPdfs: [Pdf] = []
    
    init(params: Params) {
        self.asyncUnlockedPdfMultipleOutput = params.asyncUnlockedPdfMultipleOutput
        self.asyncUnlockedPdfSingleOutput = params.asyncUnlockedPdfSingleOutput
    }
    
    func unlockPdfs(pdfs: [Pdf]) {
        guard pdfs.count > 0 else {
            self.asyncUnlockedPdfMultipleOutput?.wrappedValue = .init(status: .empty)
            self.asyncUnlockedPdfSingleOutput?.wrappedValue = .init(status: .empty)
            return
        }
        self.toBeUnlockedPdfs = pdfs
        self.unlockNextPdf()
    }
    
    func unlockPdf(pdf: Pdf) {
        // Must skip a frame to make the view correctly dismiss and show again the password input alert
        DispatchQueue.main.async { [weak self] in
            guard let self else { return }
            
            if pdf.pdfDocument.isLocked {
                self.unlockingPdf = pdf
                self.showPasswordInputView = true
            } else {
                self.onUnlockCompleted(forPdf: pdf)
            }
        }
    }
    
    @MainActor
    func decryptPdf() {
        guard let pdf = self.unlockingPdf else {
            assertionFailure("Missing expected pdf")
            self.asyncUnlockedPdf = AsyncOperation(status: .empty)
            return
        }
        self.asyncUnlockedPdf = .init(status: .loading(Progress(totalUnitCount: 1)))
        Task {
            let task = Task<AsyncOperation<Pdf, PdfError>, Never> {
                return PDFUtility.decryptFile(pdf: pdf, password: self.passwordText)
            }
            self.asyncUnlockedPdf = await task.value
            self.passwordText = ""
            self.unlockingPdf = nil
        }
    }
    
    private func unlockNextPdf() {
        guard let pdf = self.toBeUnlockedPdfs.popLast() else {
            self.asyncUnlockedPdfMultipleOutput?.wrappedValue = AsyncOperation(status: .data(self.unlockedPdfs))
            if let unlockedPdf = self.unlockedPdfs.first {
                self.asyncUnlockedPdfSingleOutput?.wrappedValue = AsyncOperation(status: .data(unlockedPdf))
            } else {
                self.asyncUnlockedPdfSingleOutput?.wrappedValue = AsyncOperation(status: .empty)
            }
            self.unlockedPdfs = []
            return
        }
        
        self.unlockPdf(pdf: pdf)
    }
    
    private func onUnlockCompleted(forPdf pdf: Pdf) {
        self.unlockedPdfs.append(pdf)
        self.unlockNextPdf()
    }
}



================================================
FILE: pdfexpert/ViewModels/ReviewFlow.swift
================================================
//
//  ReviewFlow.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/08/23.
//

import Foundation
import Factory
import SwiftUI
import StoreKit

extension Container {
    var reviewFlow: Factory<ReviewFlow> {
        self { ReviewFlow() }
    }
}

class ReviewFlow: ObservableObject {
    
    @Published var showPreReviewView: Bool = false
    @Published var showLowReviewView: Bool = false
    
    @Injected(\.analyticsManager) var analyticsManager
    @Injected(\.cacheManager) var cacheManager
    @Injected(\.store) var store
    
    private var shouldShow: Bool {
        return self.neverSeenBefore && self.store.isPremium.value
    }
    
    private var neverSeenBefore: Bool {
        #if DEBUG
            if K.Test.Review.ShowAlways {
                return true
            } else {
                return !self.cacheManager.preReviewShown
            }
        #else
            !self.cacheManager.preReviewShown
        #endif
    }
    
    func startFlowIfNeeded() {
        if self.shouldShow {
            self.cacheManager.preReviewShown = true
            self.showPreReviewView = true
        }
    }
    
    @MainActor
    func onPreReviewRateSelected(preReviewRate: Int, nativeReviewCallback: @escaping (() -> ())) {
        Task {
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            self.showPreReviewView = false
            try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
            if preReviewRate >= K.Review.MinimumRateForNativePopup {
                nativeReviewCallback()
            } else {
                self.showLowReviewView = true
            }
        }
    }
    
    func onPreReviewLowRateFeedbackSent(feedback: String) {
        self.showLowReviewView = false
        if !feedback.isEmpty {
            self.analyticsManager.track(event: .reviewLowRateFeedback(feedback: feedback))
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/SubscribeViewModel.swift
================================================
//
//  SubscribeViewModel.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 23/02/23.
//

import Foundation
import StoreKit
import Combine
import Factory
import Collections

protocol SubscriptionPlan: Hashable {
    var product: Product? { get }
}

struct SubscriptionPlanCombo<T: SubscriptionPlan> {
    let standardSubscriptionPlan: T?
    let freeTrialSubscriptionPlan: T?
    
    func getPlan(forFreeTrialState freeTrialState: Bool) -> T? {
        return freeTrialState ? self.freeTrialSubscriptionPlan : self.standardSubscriptionPlan
    }
}

class SubscribeViewModel<S: SubscriptionPlan>: ObservableObject {
    
    @Published var isPremium: Bool = false
    @Published var restorePurchaseRequest: AsyncOperation<Bool, SharedUnderlyingError> = AsyncOperation(status: .empty)
    @Published var purchaseRequest: AsyncOperation<(), SharedUnderlyingError> = AsyncOperation(status: .empty)
    
    @Published var currentSubscriptionPlan: S?
    
    @Injected(\.store) private var store
    @Injected(\.analyticsManager) private var analyticsManager
    
    private var cancelBag = Set<AnyCancellable>()
    
    init() {
        self.store.isPremium.sink { self.onPremiumStateChanged(isPremium: $0) }.store(in: &self.cancelBag)
    }
    
    @MainActor
    open func refresh() {}
    
    @MainActor
    func subscribe() {
        
        guard let product = self.currentSubscriptionPlan?.product else {
            self.purchaseRequest = AsyncOperation(status: .error(.unknownError))
            return
        }
        
        self.purchaseRequest = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
        
        Task {
            do {
                _ = try await self.store.purchase(product)
                self.purchaseRequest = AsyncOperation(status: .data(()))
            } catch let error {
                print("Subscribe Error: " + error.localizedDescription)
                let convertedError = SharedUnderlyingError.convertError(fromError: error)
                self.purchaseRequest = AsyncOperation(status: .error(convertedError))
            }
        }
    }
    
    @MainActor
    func restorePurchases() {
        Task {
            self.restorePurchaseRequest = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
            //This call displays a system prompt that asks users to authenticate with their App Store credentials.
            //Call this function only in response to an explicit user action, such as tapping a button.
            do {
                let currentIsPremium = self.isPremium
                try await AppStore.sync()
                await self.store.updateCustomerProductStatus()
                self.restorePurchaseRequest = AsyncOperation(status: .data(self.isPremium && self.isPremium != currentIsPremium))
            } catch {
                let convertedError = SharedUnderlyingError.convertError(fromError: error)
                self.restorePurchaseRequest = AsyncOperation(status: .error(convertedError))
            }
        }
    }
    
    @MainActor
    func onAppear() {
        self.analyticsManager.track(event: .reportScreen(.subscription))
        self.analyticsManager.track(event: .subscriptionShown)
        self.refresh()
    }
    
    private func onPremiumStateChanged(isPremium: Bool) {
        self.isPremium = isPremium
    }
}

// MARK: - Errors

enum RefreshError: LocalizedError, UnderlyingError {
    case unknownError
    case underlyingError(errorDescription: String)
    case missingExpectedSubscriptionPlanError
    
    static func getUnknownError() -> Self { Self.unknownError }
    
    static func getUnderlyingError(errorDescription: String) -> Self {
        return .underlyingError(errorDescription: errorDescription)
    }
    
    var errorDescription: String? {
        switch self {
        case .unknownError: return "Internal Error. Please try again later"
        case .underlyingError(let errorMessage): return errorMessage
        case .missingExpectedSubscriptionPlanError: return "Internal Error. Please try again later"
        }
    }
}



================================================
FILE: pdfexpert/ViewModels/SubscriptionPairsViewModel.swift
================================================
//
//  SubscriptionPairsViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 13/04/23.
//

import Foundation
import StoreKit
import Combine
import Factory

extension Container {
    var subscribtionPairsViewModel: Factory<SubscriptionPairsViewModel> {
        self { SubscriptionPairsViewModel() }
    }
}

struct SubscriptionPlanPairItem: SubscriptionPlan {
    let product: Product?
    let title: String
    let weeklyPriceAndPeriod: String
    let fullDescriptionText: String
}

fileprivate extension Product {
    var subscriptionPlanPairItem: SubscriptionPlanPairItem? {
        return SubscriptionPlanPairItem(
            product: self,
            title: self.title,
            weeklyPriceAndPeriod: self.weeklyPriceAndPeriod,
            fullDescriptionText: self.fullDescriptionText
        )
    }
}

fileprivate let productMetaViewValuePairs: String = "pairs"

class SubscriptionPairsViewModel: SubscribeViewModel<SubscriptionPlanPairItem> {
    
    typealias PlanPair = SubscriptionPlanCombo<SubscriptionPlanPairItem>
    
    @Published var selectedSubscriptionPairIndex: Int = 0 {
        didSet { self.updateCurrentSubscriptionPlan() }
    }
    @Published var isFreeTrialEnabled: Bool = false {
        didSet { self.updateCurrentSubscriptionPlan() }
    }
    @Published var asyncSubscriptionPlanPairs: AsyncOperation<[PlanPair], RefreshError> = AsyncOperation(status: .empty) {
        didSet { self.updateCurrentSubscriptionPlan() }
    }
    
    @Published var currentSubscriptionPlanPair: PlanPair?
    
    @Injected(\.store) private var store
    
    @MainActor
    override func refresh() {
        
        self.asyncSubscriptionPlanPairs = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
        
        Task {
            do {
                try await self.store.refreshAll()
                let subscriptionPlanPairs = try await self.productsToSubscriptionPairs(products: self.store.subscriptions)
                if subscriptionPlanPairs.count > 0 {
                    self.asyncSubscriptionPlanPairs = AsyncOperation(status: .data(subscriptionPlanPairs))
                } else {
                    self.asyncSubscriptionPlanPairs = AsyncOperation(status: .error(.missingExpectedSubscriptionPlanError))
                }
            } catch {
                let convertedError = RefreshError.convertError(fromError: error)
                self.asyncSubscriptionPlanPairs = AsyncOperation(status: .error(convertedError))
            }
        }
    }
    
    private func productsToSubscriptionPairs(products: [Product]) async throws -> [PlanPair] {
        let subscriptionProducts = getSubscriptionsForView(products: products, store: self.store, viewKey: productMetaViewValuePairs)
        return try await subscriptionProducts.subscriptionPairs(periodOrderDesc: true, conversion: { $0?.subscriptionPlanPairItem })
    }
    
    private func updateCurrentSubscriptionPlan() {
        guard let subscriptionPlanPairs = self.asyncSubscriptionPlanPairs.data,
              self.selectedSubscriptionPairIndex >= 0,
              self.selectedSubscriptionPairIndex < subscriptionPlanPairs.count else {
            return
        }
        let currentSubscriptionPlanPair = subscriptionPlanPairs[self.selectedSubscriptionPairIndex]
        if self.isFreeTrialEnabled {
            self.currentSubscriptionPlan = currentSubscriptionPlanPair.freeTrialSubscriptionPlan ?? currentSubscriptionPlanPair.standardSubscriptionPlan
        } else {
            self.currentSubscriptionPlan = currentSubscriptionPlanPair.standardSubscriptionPlan ?? currentSubscriptionPlanPair.freeTrialSubscriptionPlan
        }
        self.currentSubscriptionPlanPair = currentSubscriptionPlanPair
    }
}



================================================
FILE: pdfexpert/ViewModels/SubscriptionPickerViewModel.swift
================================================
//
//  SubscriptionPickerViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 08/08/23.
//

import Foundation
import StoreKit
import Combine
import Factory

extension Container {
    var subscriptionPickerViewModel: Factory<SubscriptionPickerViewModel> {
        self { SubscriptionPickerViewModel() }
    }
}

struct SubscriptionPlanPickerItem: SubscriptionPlan {
    let product: Product?
    let title: String
    let period: String
    let weeklyPriceAndPeriod: String
    let fullDescriptionText: String
    let priceText: String
    let bestDiscountText: String?
}

fileprivate extension Product {
    func getSubscriptionPlanPickerItem(totalProducts: [Product]) -> SubscriptionPlanPickerItem {
        return SubscriptionPlanPickerItem(
            product: self,
            title: self.title,
            period: self.period,
            weeklyPriceAndPeriod: self.weeklyPriceAndPeriod,
            fullDescriptionText: self.fullDescriptionText,
            priceText: self.priceText,
            bestDiscountText: self.getBestDiscount(forProducts: totalProducts)
        )
    }
}

class SubscriptionPickerViewModel: SubscribeViewModel<SubscriptionPlanPickerItem> {
    
    fileprivate static let productMetaViewValue: String = "picker"
    
    typealias PlanPair = SubscriptionPlanCombo<SubscriptionPlanPickerItem>
    
    @Published var selectedSubscriptionPairIndex: Int = 0 {
        didSet { self.updateCurrentSubscriptionPlan() }
    }
    @Published var isFreeTrialEnabled: Bool = false {
        didSet { self.updateCurrentSubscriptionPlan() }
    }
    @Published var asyncSubscriptionPlanPairs: AsyncOperation<[PlanPair], RefreshError> = AsyncOperation(status: .empty) {
        didSet { self.updateCurrentSubscriptionPlan() }
    }
    
    @Published var currentSubscriptionPlanPair: PlanPair?
    
    var subscriptionPlans: [SubscriptionPlanPickerItem] {
        guard let pairs = self.asyncSubscriptionPlanPairs.data else {
            return []
        }
        let plans = pairs.compactMap { $0.freeTrialSubscriptionPlan ?? $0.standardSubscriptionPlan }
        guard plans.count == pairs.count else {
            return []
        }
        return plans
    }
    
    @Injected(\.store) private var store
    
    @MainActor
    override func refresh() {
        
        self.asyncSubscriptionPlanPairs = .init(status: .loading(.undeterminedProgress))
        
        Task {
            do {
                try await self.store.refreshAll()
                let subscriptionPlanPairs = try await self.productsToSubscriptionPairs(products: self.store.subscriptions)
                if subscriptionPlanPairs.count > 0 {
                    self.asyncSubscriptionPlanPairs = .init(status: .data(subscriptionPlanPairs))
                } else {
                    self.asyncSubscriptionPlanPairs = .init(status: .error(.missingExpectedSubscriptionPlanError))
                }
            } catch {
                let convertedError = RefreshError.convertError(fromError: error)
                self.asyncSubscriptionPlanPairs = AsyncOperation(status: .error(convertedError))
            }
        }
    }
    
    private func productsToSubscriptionPairs(products: [Product]) async throws -> [PlanPair] {
        let subscriptionProducts = getSubscriptionsForView(products: products, store: self.store, viewKey: Self.productMetaViewValue)
        return try await subscriptionProducts.subscriptionPairs(periodOrderDesc: false, conversion: { $0?.getSubscriptionPlanPickerItem(totalProducts: products) })
    }
    
    private func updateCurrentSubscriptionPlan() {
        guard let subscriptionPlanPairs = self.asyncSubscriptionPlanPairs.data,
              self.selectedSubscriptionPairIndex >= 0,
              self.selectedSubscriptionPairIndex < subscriptionPlanPairs.count else {
            return
        }
        let currentSubscriptionPlanPair = subscriptionPlanPairs[self.selectedSubscriptionPairIndex]
        if self.isFreeTrialEnabled {
            self.currentSubscriptionPlan = currentSubscriptionPlanPair.freeTrialSubscriptionPlan ?? currentSubscriptionPlanPair.standardSubscriptionPlan
        } else {
            self.currentSubscriptionPlan = currentSubscriptionPlanPair.standardSubscriptionPlan ?? currentSubscriptionPlanPair.freeTrialSubscriptionPlan
        }
        self.currentSubscriptionPlanPair = currentSubscriptionPlanPair
    }
}



================================================
FILE: pdfexpert/ViewModels/SubscriptionVerticalViewModel.swift
================================================
//
//  SubscriptionVerticalViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 13/04/23.
//

import Foundation
import StoreKit
import Combine
import Factory

enum SubscriptionVerticalViewMode {
    case highlightLongPeriod
    case highlightShortPeriod
}

extension Container {
    var subscriptionVerticalViewModel: ParameterFactory<SubscriptionVerticalViewMode, SubscriptionVerticalViewModel> {
        self { SubscriptionVerticalViewModel(mode: $0) }
    }
}

struct SubscriptionPlanVerticalItem: SubscriptionPlan {
    let product: Product?
    let titleShort: String
    let weeklyPriceAndPeriod: String
    let fullDescriptionText: String
    let freeTrialText: String?
    let bestDiscountText: String?
    let discountText: String?
}

fileprivate extension Product {
    func getSubscriptionPlanVerticalItem(totalProducts: [Product], hideBestDiscount: Bool) -> SubscriptionPlanVerticalItem {
        return SubscriptionPlanVerticalItem(
            product: self,
            titleShort: self.titleShort,
            weeklyPriceAndPeriod: self.weeklyPriceAndPeriod,
            fullDescriptionText: self.fullDescriptionText,
            freeTrialText: self.freeTrialText,
            bestDiscountText: hideBestDiscount ? nil : self.getBestDiscount(forProducts: totalProducts),
            discountText: self.getDiscount(forProducts: totalProducts)
        )
    }
}

fileprivate let productMetaViewValueVertical: String = "vertical"

class SubscriptionVerticalViewModel: SubscribeViewModel<SubscriptionPlanVerticalItem> {
    
    @Published var asyncSubscriptionPlanList: AsyncOperation<[SubscriptionPlanVerticalItem], RefreshError> = AsyncOperation(status: .empty) {
        didSet { self.updateCurrentSubscriptionPlan() }
    }
    
    @Published var selectedSubscriptionItemIndex: Int = 0 {
        didSet { self.updateCurrentSubscriptionPlan() }
    }
    
    @Injected(\.store) private var store
    
    private let mode: SubscriptionVerticalViewMode
    
    init(mode: SubscriptionVerticalViewMode) {
        self.mode = mode
        super.init()
    }
    
    @MainActor
    override func refresh() {
        
        self.asyncSubscriptionPlanList = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
        
        Task {
            do {
                try await self.store.refreshAll()
                let subscriptionPlanList = try await self.productsToSubscriptionList(products: self.store.subscriptions)
                if subscriptionPlanList.count > 0 {
                    self.asyncSubscriptionPlanList = AsyncOperation(status: .data(subscriptionPlanList))
                } else {
                    self.asyncSubscriptionPlanList = AsyncOperation(status: .error(.missingExpectedSubscriptionPlanError))
                }
            } catch {
                let convertedError = RefreshError.convertError(fromError: error)
                self.asyncSubscriptionPlanList = AsyncOperation(status: .error(convertedError))
            }
        }
    }
    
    private func productsToSubscriptionList(products: [Product]) async throws -> [SubscriptionPlanVerticalItem] {
        var subscriptions = getSubscriptionsForView(products: products, store: self.store, viewKey: productMetaViewValueVertical)
        
        subscriptions.sort { product1, product2 in
            product1.subscription?.subscriptionPeriod.days ?? 0 > product2.subscription?.subscriptionPeriod.days ?? 0
        }
        
        var hideBestDiscount = false
        switch self.mode {
        case .highlightLongPeriod:
            break
        case .highlightShortPeriod:
            hideBestDiscount = true
            subscriptions.reverse()
        }
        
        return subscriptions.map { $0.getSubscriptionPlanVerticalItem(totalProducts: subscriptions, hideBestDiscount: hideBestDiscount) }
    }
    
    private func updateCurrentSubscriptionPlan() {
        guard let subscriptionPlanList = self.asyncSubscriptionPlanList.data,
              self.selectedSubscriptionItemIndex >= 0,
              self.selectedSubscriptionItemIndex < subscriptionPlanList.count else {
            return
        }
        self.currentSubscriptionPlan = subscriptionPlanList[self.selectedSubscriptionItemIndex]
    }
}



================================================
FILE: pdfexpert/ViewModels/SuggestedFieldsFormViewModel.swift
================================================
//
//  SuggestedFieldsFormViewModel.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 07/09/23.
//

import Foundation
import Factory

extension Container {
    var suggestedFieldsFormViewModel: Factory<SuggestedFieldsFormViewModel> {
        self { SuggestedFieldsFormViewModel() }
    }
}

class SuggestedFieldsFormViewModel: ObservableObject {
    
    @Published var firstName: String
    @Published var lastName: String
    @Published var address: String
    @Published var city: String
    @Published var country: String
    @Published var email: String
    @Published var phone: String
    
    @Injected(\.analyticsManager) private var analyticsManager
    private let repository = resolve(\.repository)
    
    private var suggestedFields: SuggestedFields
    
    init() {
        self.suggestedFields = (try? self.repository.loadSuggestedFields()) ?? SuggestedFields()
        self._firstName = .init(initialValue: self.suggestedFields.firstName ?? "")
        self._lastName = .init(initialValue: self.suggestedFields.lastName ?? "")
        self._address = .init(initialValue: self.suggestedFields.address ?? "")
        self._city = .init(initialValue: self.suggestedFields.city ?? "")
        self._country = .init(initialValue: self.suggestedFields.country ?? "")
        self._email = .init(initialValue: self.suggestedFields.email ?? "")
        self._phone = .init(initialValue: self.suggestedFields.phone ?? "")
    }
    
    func onAppear() {
        self.analyticsManager.track(event: .reportScreen(.suggestedFields))
    }
    
    func onConfirmButtonPressed() {
        self.update(keyPath: \.firstName, value: self.firstName)
        self.update(keyPath: \.lastName, value: self.lastName)
        self.update(keyPath: \.address, value: self.address)
        self.update(keyPath: \.city, value: self.city)
        self.update(keyPath: \.country, value: self.country)
        self.update(keyPath: \.email, value: self.email)
        self.update(keyPath: \.phone, value: self.phone)
        
        do {
            _ = try self.repository.saveSuggestedFields(suggestedFields: self.suggestedFields)
        } catch {
            debugPrint(for: self, message: "Error: \(error)")
        }
    }
    
    private func update(keyPath: WritableKeyPath<SuggestedFields, String?>, value: String) {
        let trimmedValue = value.trimmingCharacters(in: .whitespacesAndNewlines)
        self.suggestedFields[keyPath: keyPath] = trimmedValue.isEmpty ? nil : trimmedValue
    }
}




================================================
FILE: pdfexpert/Views/ContentView.swift
================================================
//
//  ContentView.swift
//  OpenAI chat-dalle
//
//  Created by kz on 07/02/2023.
//

import SwiftUI
import Factory

struct ContentView: View {
    
    @Injected(\.appTrackingTransparancy) var appTrackingTransparency
    @InjectedObject(\.mainCoordinator) var coordinator
    @Injected(\.store) var store
    @Injected(\.configService) var configService
    @Injected(\.attibutionManager) var attibutionManager
    
    var body: some View {
        self.content
            .background(ColorPalette.primaryBG)
            .reviewFlowView(flow: self.coordinator.reviewFlow)
            .onReceive(NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification)) { _ in
                Task {
                    await self.appTrackingTransparency.requestPermissionIfNeeded()
                }
                self.configService.onApplicationDidBecomeActive()
            }
            .onOpenURL { url in
                self.coordinator.handleOpenUrl(url: url)
                self.attibutionManager.onOpenUrl(url: url)
            }
    }
    
    var content: some View {
        switch self.coordinator.rootView {
        case .onboarding:
            return AnyView(
                NavigationStack(path: self.$coordinator.path) {
                    WelcomeView()
                        .navigationDestination(for: MainCoordinator.Route.self) { route in
                            switch route {
                            case .onboarding:
                                OnboardingView()
                            }
                        }
                }
            )
        case .main:
            return AnyView(MainTabView())
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}



================================================
FILE: pdfexpert/Views/.DS_Store
================================================
[Non-text file]


================================================
FILE: pdfexpert/Views/Archive/ArchiveView.swift
================================================
//
//  ArchiveView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/04/23.
//

import SwiftUI
import Factory

struct ArchiveView: View {
    
    @InjectedObject(\.archiveViewModel) var viewModel
    
    @State private var showingDeleteAlert = false
    @State private var itemToDelete: Pdf? = nil
    @State private var importTutorialShow: Bool = false
    
    var body: some View {
        ZStack {
            self.content
            if self.viewModel.isLoading {
                AnyView(self.getLoadingView())
            }
        }
        .background(ColorPalette.primaryBG)
        .onAppear() {
            self.viewModel.onAppear()
        }
        .asyncView(asyncOperation: self.$viewModel.asyncItemDelete)
        .fullScreenCover(isPresented: self.$importTutorialShow) {
            ImportTutorialView()
        }
        .showShareView(coordinator: self.viewModel.pdfShareCoordinator)
    }
    
    var content: some View {
        switch self.viewModel.asyncItems.status {
        case .empty: return AnyView(Spacer())
        case .loading: return AnyView(self.getLoadingView())
        case .data(let items): return AnyView(self.getItemList(items: items))
        case .error: return AnyView(self.getErrorView())
        }
    }
    
    func getItemList(items: [Pdf]) -> some View {
        if items.count > 0 {
            return AnyView(
                List(items) { item in
                    Button(action: { self.viewModel.editItem(item: item) }) {
                        HStack(spacing: 16) {
                            self.getPdfThumbnail(forPdf: item)
                                .frame(width: 86)
                            VStack(spacing: 0) {
                                Spacer()
                                Text(item.filename)
                                    .font(forCategory: .body1)
                                    .foregroundColor(ColorPalette.primaryText)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .lineLimit(1)
                                Spacer().frame(height: 16)
                                HStack(spacing: 16) {
                                    Text(item.pageCountText)
                                        .font(forCategory: .body2)
                                        .foregroundColor(ColorPalette.fourthText)
                                        .frame(maxWidth: .infinity, alignment: .leading)
                                    if item.password != nil {
                                        Image("password_entered")
                                    }
                                    Button(action: { self.viewModel.shareItem(item: item) }) {
                                        Image(systemName: "square.and.arrow.up")
                                            .font(.system(size: 20).bold())
                                            .foregroundColor(ColorPalette.primaryText)
                                    }
                                }
                                Spacer()
                            }
                            .frame(maxWidth: .infinity)
                        }
                        .padding(.trailing, 16)
                        .background(ColorPalette.secondaryBG)
                    }
                    .frame(height: 94)
                    .cornerRadius(10)
                    .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
                    .listRowSeparator(.hidden)
                    .listRowBackground(Color(.clear))
                    .swipeActions(allowsFullSwipe: false, content: {
                        Button(role: .none, action: {
                            self.itemToDelete = item
                            self.showingDeleteAlert = true
                        }, label: {
                            Image(systemName: "trash")
                        })
                        .tint(Color.red)
                    })
                    .actionDialog(
                        Text("Are you sure?"),
                        isPresented: self.$showingDeleteAlert,
                        titleVisibility: .visible
                    ) {
                        Button("Delete", role: .destructive) {
                            self.showingDeleteAlert = false
                            withAnimation {
                                if let itemToDelete = self.itemToDelete {
                                    self.viewModel.delete(item: itemToDelete)
                                }
                            }
                        }
                    }
                }
                    // Needed to use a custom background color in case of List with inset list style
                    .scrollContentBackground(.hidden)
                    .listStyle(.inset)
                    .safeAreaInset(edge: .bottom) {
                        Button(action: { self.importTutorialShow = true }) {
                            HStack(spacing: 8) {
                                Image("info")
                                    .resizable()
                                    .frame(width: 18, height: 18)
                                Text("Convert from any file")
                                    .frame(maxHeight: .infinity)
                                    .font(forCategory: .button)
                                    .foregroundColor(ColorPalette.primaryText)
                            }
                            .contentShape(Capsule())
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 48)
                        .background(self.defaultGradientBackground)
                        .cornerRadius(10)
                        .padding(EdgeInsets(top: 0, leading: 32, bottom: 32, trailing: 32))
                    }
            )
        } else {
            return AnyView(self.getEmptyView)
        }
    }
    
    var getEmptyView: some View {
        VStack(spacing: 16) {
            Spacer()
            Image("archive_empty")
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(height: 80)
            Text("You haven’t converted any files yet")
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity, alignment: .center)
                .multilineTextAlignment(.center)
            Spacer()
        }
        .padding([.leading, .trailing], 16)
    }
    
    func getLoadingView() -> some View {
        AnimationType.dots.view.background(Color(.black).opacity(0.3))
    }
    
    func getErrorView() -> some View {
        VStack(spacing: 16) {
            Spacer()
            Image("subscription_error")
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(height: 80)
            Text("Oh Know!")
                .font(forCategory: .largeTitle)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity, alignment: .center)
            Text("Something went wrong,\n Please try again.")
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.primaryText)
                .multilineTextAlignment(.center)
                .frame(maxWidth: .infinity, alignment: .center)
            self.getDefaultButton(text: "Retry",
                                  onButtonPressed: self.viewModel.refresh)
            Spacer()
        }
        .padding([.leading, .trailing], 16)
    }
    
    @ViewBuilder private func getPdfThumbnail(forPdf pdf: Pdf) -> some View {
        if let thumbnail = pdf.thumbnail {
            Color.clear
                .overlay(Image(uiImage: thumbnail)
                    .resizable()
                    .scaledToFill())
                .clipShape(RoundedRectangle(cornerRadius: 10,
                            style: .continuous))
        } else {
            ColorPalette.secondaryBG
                .cornerRadius(10)
        }
    }
}

extension Pdf {
    
    var pageCountText: String {
        "\(self.pageCount) pages"
    }
}

struct ArchiveView_Previews: PreviewProvider {
    static var previews: some View {
        ArchiveView()
    }
}



================================================
FILE: pdfexpert/Views/Camera/CameraView.swift
================================================
//
//  CameraView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 30/03/23.
//

import SwiftUI

struct CameraView: View {
    @StateObject var model: CameraViewModel

    @State var currentZoomFactor: CGFloat = 1.0
    
    @Environment(\.dismiss) var dismiss

    var captureButton: some View {
        Button(action: {
            model.capturePhoto()
        }, label: {
            Circle()
                .foregroundColor(.white)
                .frame(width: 80, height: 80, alignment: .center)
                .overlay(
                    Circle()
                        .stroke(Color.black.opacity(0.8), lineWidth: 2)
                        .frame(width: 65, height: 65, alignment: .center)
                )
        })
    }

    var flipCameraButton: some View {
        Button(action: {
            model.flipCamera()
        }, label: {
            Circle()
                .foregroundColor(Color.gray.opacity(0.2))
                .frame(width: 45, height: 45, alignment: .center)
                .overlay(
                    Image(systemName: "camera.rotate.fill")
                        .foregroundColor(.white))
        })
    }

    var body: some View {
        NavigationView {
            ZStack {
                GeometryReader { reader in
                    ZStack {
                        Color.black.edgesIgnoringSafeArea(.all)
                        
                        VStack {
                            Button(action: {
                                model.switchFlash()
                            }, label: {
                                Image(systemName: model.isFlashOn ? "bolt.fill" : "bolt.slash.fill")
                                    .font(.system(size: 20, weight: .medium, design: .default))
                            })
                            .accentColor(model.isFlashOn ? .yellow : .white)
                            
                            CameraPreviewView(session: model.session)
                                .gesture(
                                    DragGesture().onChanged({ (val) in
                                        //  Only accept vertical drag
                                        if abs(val.translation.height) > abs(val.translation.width) {
                                            //  Get the percentage of vertical screen space covered by drag
                                            let percentage: CGFloat = -(val.translation.height / reader.size.height)
                                            //  Calculate new zoom factor
                                            let calc = currentZoomFactor + percentage
                                            //  Limit zoom factor to a maximum of 5x and a minimum of 1x
                                            let zoomFactor: CGFloat = min(max(calc, 1), 5)
                                            //  Store the newly calculated zoom factor
                                            currentZoomFactor = zoomFactor
                                            //  Sets the zoom factor to the capture device session
                                            model.zoom(with: zoomFactor)
                                        }
                                    })
                                )
                                .onAppear {
                                    model.configure()
                                }
                                .alert(isPresented: $model.showAlertError, content: {
                                    let error = self.model.error!
                                    if let confirmText = error.confirmText, let confirmAction = error.confirmAction {
                                        return Alert(title: Text(error.title),
                                                     message: Text(error.message),
                                                     primaryButton: .default(Text(confirmText), action: {
                                            confirmAction()
                                        }),
                                                     secondaryButton: .default(Text(error.dismissText), action: {
                                            model.showAlertError = false
                                        }))
                                    } else {
                                        return Alert(title: Text(error.title),
                                                     message: Text(error.message),
                                                     dismissButton: .default(Text(error.dismissText), action: {
                                            model.showAlertError = false
                                        }))
                                    }
                                })
                                .overlay(
                                    Group {
                                        if model.willCapturePhoto {
                                            Color.black
                                        }
                                    }
                                )
                                .animation(.easeInOut, value: model.willCapturePhoto)
                            
                            
                            HStack {
                                Spacer().frame(width: 60)
                                
                                Spacer()
                                
                                captureButton
                                
                                Spacer()
                                
                                flipCameraButton
                                
                            }
                            .padding(.horizontal, 20)
                        }
                    }
                }
                self.getCloseButton(color: .white, onClose: { self.dismiss() })
            }
        }
    }
}

extension CameraError {
    var title: String {
        switch self {
        case .permissionDenied: return "No Permission"
        case .cameraUnavailable: return "Camera unavailable"
        }
    }
    
    var message: String {
        switch self {
        case .permissionDenied: return "You have denied permission to access the camera of your device. Please go to your phone Settings to change your camera permission to be able to take pictures of your documents."
        case .cameraUnavailable: return "Unable to access camera"
        }
    }
    
    var dismissText: String {
        switch self {
        case .permissionDenied: return "Cancel"
        case .cameraUnavailable: return "OK"
        }
    }
    
    var confirmText: String? {
        switch self {
        case .permissionDenied: return "Settings"
        case .cameraUnavailable: return nil
        }
    }
    
    var confirmAction: (() -> ())? {
        switch self {
        case .permissionDenied: return {
            if let appSettingsUrl = URL(string: UIApplication.openSettingsURLString) {
            UIApplication.shared.open(appSettingsUrl,
                                          options: [:],
                                          completionHandler: nil)
                                      }
        }
        case .cameraUnavailable: return nil
        }
    }
}

struct CameraView_Previews: PreviewProvider {
    static var previews: some View {
        CameraView(model: CameraViewModel(onImageCaptured: { _ in }))
    }
}



================================================
FILE: pdfexpert/Views/ChatPdf/ChatPdfSelectionView.swift
================================================
//
//  ChatPdfSelectionView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 19/07/23.
//

import SwiftUI
import Factory

struct ChatPdfSelectionView: View {
    
    @InjectedObject(\.chatPdfSelectionViewModel) var viewModel
    
    var body: some View {
        VStack {
            Spacer()
            Text("Our PDF AI summarize and answer questions for free. Drop your PDF here.")
                .font(forCategory: .body2)
                .foregroundColor(ColorPalette.primaryText)
                .multilineTextAlignment(.center)
                .padding([.leading, .trailing], 32)
            Spacer().frame(height: 60)
            self.buttonView
            Spacer().frame(height: 50)
            self.warningView
                .padding([.leading, .trailing], 32)
            Spacer()
        }
        .ignoresSafeArea(.keyboard)
        .background(ColorPalette.primaryBG)
        .onAppear() {
            self.viewModel.onAppear()
        }
        .formSheet(item: self.$viewModel.importOptionGroup) {
            OptionListView.getImportView(forImportOptionGroup: $0,
                                         importViewCallback: { self.viewModel.handleImportOption(importOption: $0) })
        }
        .filePicker(item: self.$viewModel.importFileOption, onPickedFiles: {
            self.viewModel.processPickedFileUrl($0.first)
        })
        .fullScreenCover(isPresented: self.$viewModel.scannerShow) {
            // Scanner
            ScannerView(onScannerResult: {
                self.viewModel.convertScan(scannerResult: $0)
            })
        }
        .fullScreenCover(item: self.$viewModel.chatPdfInitParams) { chatPdfInitParams in
            let parameters = ChatPdfViewModel.Parameters(chatPdfInitParams: chatPdfInitParams)
            ChatPdfView(viewModel: Container.shared.chatPdfViewModel(parameters))
        }
        .fullScreenCover(isPresented: self.$viewModel.monetizationShow) {
            self.getSubscriptionView(onComplete: {
                self.viewModel.monetizationShow = false
            })
        }
        .asyncView(asyncOperation: self.$viewModel.asyncImportPdf,
                   loadingView: { AnimationType.pdf.view })
        .asyncView(asyncOperation: self.$viewModel.asyncChatPdfSetup)
        .showUnlockView(viewModel: self.viewModel.pdfUnlockViewModel)
        .alertCameraPermission(isPresented: self.$viewModel.cameraPermissionDeniedShow)
    }
    
    @ViewBuilder var buttonView: some View {
        Button(action: self.viewModel.getPdfButtonPressed) {
            GeometryReader { geometryReader in
                Group {
                    Image(systemName: "arrow.up.circle.fill")
                        .resizable()
                        .aspectRatio(1, contentMode: .fit)
                        .frame(width: 48)
                        .foregroundColor(ColorPalette.secondaryText)
                }
                .frame(width: geometryReader.size.width * 0.7, height: geometryReader.size.height)
                .overlay(RoundedRectangle(cornerRadius: 8)
                    .strokeBorder(style: StrokeStyle(lineWidth: 2, dash: [10]))
                    .foregroundColor(ColorPalette.primaryText))
                .position(x: geometryReader.size.width/2, y: geometryReader.size.height/2)
                .contentShape(RoundedRectangle(cornerRadius: 8))
            }
        }
        .frame(height: 130)
    }
    
    @ViewBuilder var warningView: some View {
        HStack(spacing: 8) {
            Image(systemName: "exclamationmark.circle")
                .resizable()
                .aspectRatio(1, contentMode: .fit)
                .frame(width: 18)
                
                .foregroundColor(ColorPalette.thirdText)
            Text("PDF are limited to 32MB per file\nand are limited to 2000 pages")
                .font(forCategory: .caption1)
                .foregroundColor(ColorPalette.thirdText)
                .minimumScaleFactor(0.5)
        }
    }
}

struct ChatPdfSelectionView_Previews: PreviewProvider {
    static var previews: some View {
        ChatPdfSelectionView()
    }
}



================================================
FILE: pdfexpert/Views/ChatPdf/ChatPdfView.swift
================================================
//
//  ChatPdfView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 19/07/23.
//

import SwiftUI
import Factory

struct ChatPdfView: View {
    
    @StateObject var viewModel: ChatPdfViewModel
    
    @State var typingMessage: String = ""
    @Namespace var bottomID
    
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        NavigationStack {
            VStack(alignment: .leading){
                if !self.viewModel.messages.isEmpty {
                    ScrollViewReader { reader in
                        ScrollView(.vertical) {
                            ForEach(self.viewModel.messages.indices, id: \.self){ index in
                                let message = self.viewModel.messages[index]
                                MessageView(message: message,
                                            onSuggestedQuestionTapped: {
                                    self.viewModel.getResponse(text: $0)
                                })
                            }
                            Text("").id(self.bottomID)
                        }
                        .onAppear{
                            if self.isScrollToAvailable {
                                withAnimation{
                                    reader.scrollTo(self.bottomID)
                                }
                            }
                        }
                        .onChange(of: self.viewModel.messages.count){ _ in
                            if self.isScrollToAvailable {
                                withAnimation{
                                    reader.scrollTo(self.bottomID)
                                }
                            }
                        }
                    }
                } else {
                    VStack{
                        Image(systemName: "ellipses.bubble")
                            .font(forCategory: .largeTitle)
                        Text("Write your first message!")
                            .font(forCategory: .body2)
                            .foregroundColor(ColorPalette.primaryText)
                            .padding(10)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                }
                
                HStack(alignment: .center){
                    TextField("Type your Message...", text: self.$typingMessage, axis: .vertical)
                        .padding()
                        .font(forCategory: .body2)
                        .foregroundColor(ColorPalette.primaryText)
                        .lineLimit(3)
                        .disableAutocorrection(true)
                        .autocapitalization(.none)
                    Button {
                        if self.typingMessage != "" {
                            self.viewModel.getResponse(text: self.typingMessage)
                            self.typingMessage = ""
                        }
                    } label: {
                        Image(systemName: self.typingMessage == "" ? "circle" : "paperplane.fill")
                            .resizable()
                            .scaledToFit()
                            .foregroundColor(self.typingMessage == "" ? .white.opacity(0.75) : .white)
                            .frame(width: 20, height: 20)
                            .padding()
                    }
                }
                .onDisappear {
                    UIApplication.dismissKeyboard()
                }
                .background(ColorPalette.secondaryBG)
                .cornerRadius(12)
                .padding([.leading, .trailing, .bottom], 10)
                .shadow(color: .black, radius: 0.5)
            }
            .background(ColorPalette.primaryBG)
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle("Chat")
            .addSystemCloseButton(color: ColorPalette.primaryText, onPress: { self.dismiss() })
            .onAppear() {
                self.viewModel.onAppear()
            }
            .onDisappear() {
                self.viewModel.onDisappear()
            }
        }
        .background(ColorPalette.primaryBG)
    }
}

struct ChatPdfView_Previews: PreviewProvider {
    
    private static let testRef = ChatPdfRef(sourceId: "test_source_id")
    private static let testSummary = "Welcome Message"
    private static let testSuggestedQuestions = [
        "How many pages this file has?",
        "Which color is more predominant?",
        "Who is the author?",
    ]
    private static let testSetupData = ChatPdfSetupData(summary: testSummary,
                                                        suggestedQuestions: testSuggestedQuestions)
    private static let testInitParams = ChatPdfInitParams(chatPdfRef: testRef,
                                                                 setupData: testSetupData)
    private static let testParameters = ChatPdfViewModel.Parameters(chatPdfInitParams: testInitParams)
    
    static var previews: some View {
        let _ = Container.shared.chatPdfManager.register { ChatPdfManagerMock() }
        ChatPdfView(viewModel: Container.shared.chatPdfViewModel(self.testParameters))
    }
}



================================================
FILE: pdfexpert/Views/ChatPdf/MessageIndicatorView.swift
================================================
//
//  MessageIndicatorView.swift
//  OpenAI GPT-DALL-E
//
//  Created by kz on 06/02/2023.
//

import SwiftUI

struct MessageIndicatorView: View {
    var body: some View {
        HStack {
            DotView()
            DotView(delay: 0.2)
            DotView(delay: 0.4)
        }
        .padding(12)
        .background(Color.gray.opacity(0.25))
        .cornerRadius(25)
    }
}

struct DotView: View {

    @State var scale: CGFloat = 0.5
    @State var delay: Double = 0
    var body: some View {
        Circle()
            .frame(width: 7, height: 7)
            .scaleEffect(self.scale)
            .onAppear {
                withAnimation(Animation.easeInOut.repeatForever().delay(self.delay)) {
                    self.scale = 1
                }
            }
    }
}

struct MessageIndicatorView_Previews: PreviewProvider {
    static var previews: some View {
        MessageIndicatorView()
    }
}



================================================
FILE: pdfexpert/Views/ChatPdf/MessageView.swift
================================================
//
//  MessageView.swift
//  ChattingAPP
//
//  Created by kz on 02/02/2023.
//

import SwiftUI
import Factory

struct MessageView: View {
    
    let message: ChatPdfMessage
    let onSuggestedQuestionTapped: ((String) -> ())
    
    var body: some View {
        HStack(spacing: 0) {
            VStack(alignment: .leading, spacing: 0) {
                HStack(alignment: self.message.alignment){
                    switch self.message.type {
                    case .text:
                        let output = self.message.content.trimmingCharacters(in: .whitespacesAndNewlines)
                        Text(output)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .foregroundColor(self.message.textColor)
                            .font(forCategory: .caption1)
                    case .indicator:
                        MessageIndicatorView()
                    }
                }
                if self.message.suggestedQuestions.count > 0 {
                    Spacer().frame(height: 16)
                    Text("Suggested questions:")
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .foregroundColor(self.message.textColor)
                        .font(forCategory: .caption1)
                    Spacer().frame(height: 16)
                    ForEach(self.message.suggestedQuestions, id:\.self) { suggestedQuestion in
                        Text(suggestedQuestion)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .foregroundColor(ColorPalette.secondaryText)
                            .font(FontCategory.caption1.font.bold())
                            .onTapGesture {
                                self.onSuggestedQuestionTapped(suggestedQuestion)
                            }
                        Spacer().frame(height: 16)
                    }
                }
            }
            .padding([.top, .bottom])
            .padding([.leading, .trailing], 16)
            Spacer()
        }
        .background(RoundedCorner(radius: 16, corners: self.message.roundedCorners)
            .fill(self.message.backgroundColor))
        .shadow(radius: self.message.shadowRadius)
        .padding([.leading], self.message.paddingLeading)
        .padding([.trailing], self.message.paddingTrailing)
    }
}

fileprivate extension ChatPdfMessage {
    
    var backgroundColor: Color {
        switch self.role {
        case .user: return ColorPalette.secondaryText
        case .assistant: return ColorPalette.primaryText
        }
    }
    
    var textColor: Color {
        switch self.role {
        case .user: return ColorPalette.primaryText
        case .assistant: return ColorPalette.primaryBG
        }
    }
    
    var shadowRadius: CGFloat {
        switch self.role {
        case .user: return 0.0
        case .assistant: return 0.5
        }
    }
    
    var alignment: VerticalAlignment {
        switch self.role {
        case .user: return .center
        case .assistant: return .top
        }
    }
    
    var paddingLeading: CGFloat {
        switch self.role {
        case .user: return 60
        case .assistant: return 16
        }
    }
    
    var paddingTrailing: CGFloat {
        switch self.role {
        case .user: return 16
        case .assistant: return 60
        }
    }
    
    var roundedCorners: UIRectCorner {
        switch self.role {
        case .user: return [.bottomLeft, .bottomRight, .topLeft]
        case .assistant: return [.bottomLeft, .bottomRight, .topRight]
        }
    }
}

struct MessageView_Previews: PreviewProvider {
    
    static var previews: some View {
        ScrollView {
            VStack {
                MessageView(
                    message: ChatPdfMessage(role: .assistant, type: .text, content: "This text explains in detail the meaning of life, without ambiguities, questionable assumptions or subjective points of view of any kind. The author also warns the reader that fully reading this text will cause an invitable transcendence to a new state of existence, and thus doing so only if truly prepared.", suggestedQuestions: [
                        "Can you give me a hint about the meaning of life, while avoiding transcendence?",
                        "Can I use the meaning of life for commercial purposes?",
                        "Who is the author?"
                    ]),
                    onSuggestedQuestionTapped: { print("Suggested question: '\($0)'") }
                )
                .padding()
                .previewDisplayName("Introductory Message")
                MessageView(
                    message: ChatPdfMessage(role: .user, type: .text, content: "Test Message"),
                    onSuggestedQuestionTapped: { print("Suggested question: '\($0)'") }
                )
                .padding()
                .previewDisplayName("User Message")
                MessageView(
                    message: ChatPdfMessage(role: .assistant, type: .text, content: "Test Message"),
                    onSuggestedQuestionTapped: { print("Suggested question: '\($0)'") }
                )
                .padding()
                .previewDisplayName("Chat Bot Message")
                MessageView(
                    message: ChatPdfMessage(role: .assistant, type: .text, content: "I guess you guys aren't ready for that, yet. But your kids are gonna love it"),
                    onSuggestedQuestionTapped: { print("Suggested question: '\($0)'") }
                )
                .padding()
                MessageView(
                    message: ChatPdfMessage(role: .assistant, type: .text, content: "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam eaque ipsa, quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt, explicabo. Nemo enim ipsam voluptatem, quia voluptas sit, aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos, qui ratione voluptatem sequi nesciunt, neque porro quisquam est, qui dolorem ipsum, quia dolor sit, amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt, ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur?"),
                    onSuggestedQuestionTapped: { print("Suggested question: '\($0)'") }
                )
                .padding()
            }
            .previewLayout(PreviewLayout.fixed(width: 500, height: 1500))
        }
    }
}




================================================
FILE: pdfexpert/Views/Common/AddPasswordView.swift
================================================
//
//  AddPasswordView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 26/07/23.
//

import SwiftUI

typealias AddPasswordCallback = (String) -> ()

struct AddPasswordView: ViewModifier {
    
    @Binding var show: Bool
    
    @State var passwordText: String = ""
    
    let addPasswordCallback: AddPasswordCallback

    func body(content: Content) -> some View {
        content
            .alert("Protect PDF using password", isPresented: self.$show, actions: {
            SecureField("Enter Password", text: self.$passwordText)
            Button("Confirm", action: {
                self.addPasswordCallback(self.passwordText)
                self.passwordText = ""
            })
            Button("Cancel", role: .cancel, action: {})
        }, message: {
            Text("Enter a password to protect your PDF file.")
        })
    }
}

extension View {
    func addPasswordView(show: Binding<Bool>,
                         addPasswordCallback: @escaping AddPasswordCallback) -> some View {
        modifier(AddPasswordView(show: show, addPasswordCallback: addPasswordCallback))
    }
}

struct AddPasswordView_Previews: PreviewProvider {
    static var previews: some View {
        Color(.white)
            .addPasswordView(show: .constant(true),
                             addPasswordCallback: { print("Add Password completed: \($0)") })
    }
}



================================================
FILE: pdfexpert/Views/Common/CameraImageProviderFlowView.swift
================================================
//
//  CameraImageProviderFlowView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/09/23.
//

import SwiftUI
import Factory

struct CameraImageProviderFlowView: ViewModifier {
    
    @ObservedObject var flow: CameraImageProviderFlow

    func body(content: Content) -> some View {
        content
            .fullScreenCover(isPresented: self.$flow.cameraShow) {
                CameraView(model: Container.shared.cameraViewModel({ uiImage in
                    self.flow.onPhotoCaptured(image: uiImage)
                }))
            }
    }
}

extension View {
    func cameraImageProviderView(flow: CameraImageProviderFlow) -> some View {
        self.modifier(CameraImageProviderFlowView(flow: flow))
    }
}



================================================
FILE: pdfexpert/Views/Common/GalleryImageProviderFlowView.swift
================================================
//
//  GalleryImageProviderFlowView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/09/23.
//

import SwiftUI
import PhotosUI

struct GalleryImageProviderFlowView: ViewModifier {
    
    @ObservedObject var flow: GalleryImageProviderFlow

    func body(content: Content) -> some View {
        content
            .photosPicker(isPresented: self.$flow.imagePickerShow,
                          selection: self.$flow.imageSelection,
                          matching: .images)
            .asyncFailableView(asyncItem: self.$flow.asyncImageLoading)
    }
}

extension View {
    func galleryImageProviderView(flow: GalleryImageProviderFlow) -> some View {
        self.modifier(GalleryImageProviderFlowView(flow: flow))
    }
}



================================================
FILE: pdfexpert/Views/Common/ImageCropFlowView.swift
================================================
//
//  ImageCropFlowView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/09/23.
//

import SwiftUI
import Mantis

struct ImageCropFlowView: ViewModifier {
    
    @ObservedObject var flow: ImageCropFlow

    func body(content: Content) -> some View {
        content
            .fullScreenCover(isPresented: self.$flow.cropperShow) {
                ImageCropper(image: self.$flow.image,
                             cropShapeType: self.$flow.cropShapeType,
                             presetFixedRatioType: self.$flow.presetFixedRatioType,
                             type: self.$flow.type)
                .onDisappear(perform: self.flow.onCropViewDismiss)
                .ignoresSafeArea()
            }
    }
}

extension View {
    func imageCropView(flow: ImageCropFlow) -> some View {
        self.modifier(ImageCropFlowView(flow: flow))
    }
}



================================================
FILE: pdfexpert/Views/Common/ImportOption.swift
================================================
//
//  ImportOption.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 19/07/23.
//

import Foundation
import SwiftUI

enum ImportOption: Hashable, Identifiable {
    
    var id: Self { return self }
    
    case camera
    case gallery
    case scan
    case file(fileSource: FileSource)
}

enum ImportOptionGroup: Hashable, Identifiable {
    
    var id: Self { return self }
    
    case image
    case fileAndScan
    
    var options: [ImportOption] {
        switch self {
        case .image: return [.camera, .gallery, .file(fileSource: .files)]
        case .fileAndScan: return [.file(fileSource: .files), .scan]
        }
    }
}

extension OptionListView {
    
    @ViewBuilder static func getImportView(forImportOptionGroup importOptionGroup: ImportOptionGroup,
                                           importViewCallback: @escaping (ImportOption) -> ()) -> some View {
        OptionListView(title: "Import from", items: importOptionGroup.options.map { importOption in
            let callback = { importViewCallback(importOption) }
            switch importOption {
            case .camera:
                return OptionItem(title: "Camera",
                                  imageName: "camera",
                                  callBack: callback)
            case .gallery:
                return OptionItem(title: "Gallery",
                                  imageName: "gallery",
                                  callBack: callback)
            case .scan:
                return OptionItem(title: "Scan a file",
                           imageName: "scan",
                           callBack: callback)
            case .file(let fileSource):
                switch fileSource {
                case .google:
                    return OptionItem(title: "Google Drive",
                               imageName: "home_file_source_google",
                               callBack: callback)
                case .dropbox:
                    return OptionItem(title: "Dropbox",
                               imageName: "home_file_source_dropbox",
                               callBack: callback)
                case .icloud:
                    return OptionItem(title: "iCloud",
                               imageName: "home_file_source_icloud",
                               callBack: callback)
                case .files:
                    return OptionItem(title: "Files",
                               imageName: "home_file_source_files",
                               callBack: callback)
                }
            }
        })
    }
}



================================================
FILE: pdfexpert/Views/Common/OptionItemView.swift
================================================
//
//  OptionItemView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 29/03/23.
//

import SwiftUI

struct OptionItemView: View {
    
    let title: String
    let imageName: String
    let onPressed: () -> ()
    
    var body: some View {
        Button(action: { self.onPressed() }) {
            HStack(spacing: 16) {
                Image(self.imageName)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 20, height: 20)
                Text(self.title)
                    .font(forCategory: .headline)
                    .foregroundColor(ColorPalette.primaryText)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            .padding(.leading, 16)
            .padding(.trailing, 16)
        }
        .frame(height: 48)
        .frame(maxWidth: .infinity)
        .overlay(RoundedRectangle(cornerRadius: 8).stroke(ColorPalette.thirdText, lineWidth: 1))
    }
}

struct OptionItemView_Previews: PreviewProvider {
    static var previews: some View {
        OptionItemView(title: "File", imageName: "edit_option_password_unlock", onPressed: {})
    }
}



================================================
FILE: pdfexpert/Views/Common/OptionListView.swift
================================================
//
//  OptionListView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 29/03/23.
//

import SwiftUI

struct OptionItem {
    let title: String
    let imageName: String
    let callBack: () -> ()
}

struct OptionListView: View {
    
    let title: String
    let items: [OptionItem]
    
    var body: some View {
        VStack {
            Text(self.title)
                .frame(maxWidth: .infinity, alignment: .leading)
                .font(forCategory: .headline)
                .foregroundColor(ColorPalette.primaryText)
            Spacer(minLength: 20)
            ForEach(self.items, id: \.title) { item in
                OptionItemView(title: item.title, imageName: item.imageName, onPressed: item.callBack)
                Spacer().frame(height: 10)
            }
        }
        .padding(EdgeInsets(top: 44, leading: 16, bottom: 32, trailing: 16))
        .background(ColorPalette.secondaryBG)
        .cornerRadius(20, corners: [.topLeft, .topRight])
    }
}

struct OptionListView_Previews: PreviewProvider {
    
    static let items = [
        OptionItem(title: "File", imageName: "file", callBack: {}),
        OptionItem(title: "Gallery", imageName: "gallery", callBack: {}),
        OptionItem(title: "Camera", imageName: "camera", callBack: {}),
    ]
    
    static var previews: some View {
        OptionListView(title: "Import from", items: items)
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfImageViewerView.swift
================================================
//
//  PdfImageViewerView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 23/08/23.
//

import SwiftUI
import Factory

struct PdfImage {
    let image: UIImage?
    let caption: String
}

struct PdfImageViewerView: View {
    
    let pageIndex: Int
    let images: [PdfImage]
    
    @State var imageIndex: Int = 0
    
    @Environment(\.dismiss) var dismiss
    
    @Injected(\.analyticsManager) private var analyticsManager
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 16) {
                if self.images.count > 0 {
                    TabView(selection: self.$imageIndex) {
                        ForEach(Array(self.images.enumerated()), id:\.offset) { _, image in
                            VStack(spacing: 16) {
                                if let uiImage = image.image {
                                    GeometryReader { proxy in
                                        Image(uiImage: uiImage)
                                            .resizable()
                                            .scaledToFit()
                                            .frame(width: proxy.size.width, height: proxy.size.height)
                                            .clipShape(Rectangle())
                                            .modifier(ZoomImageModifier(contentSize: CGSize(width: proxy.size.width, height: proxy.size.height)))
                                    }
                                } else {
                                    Spacer()
                                    Text("Couldn't extract this image")
                                        .font(forCategory: .body1)
                                        .foregroundColor(ColorPalette.primaryText)
                                    Spacer()
                                }
                                Text(image.caption)
                                    .font(forCategory: .body1)
                                    .foregroundColor(ColorPalette.primaryText)
                                    .frame(height: 100)
                            }
                        }
                    }
                    .tabViewStyle(.page(indexDisplayMode: .never))
                    .background(ColorPalette.primaryBG)
                    self.pageCounter(currentPageIndex: self.imageIndex,
                                     totalPages: self.images.count)
                } else {
                    Spacer()
                    Text("There are no images on this page")
                        .font(forCategory: .body1)
                        .foregroundColor(ColorPalette.primaryText)
                        .frame(maxWidth: .infinity)
                    Spacer()
                }
            }
            .padding(16)
            .background(ColorPalette.primaryBG)
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle("Page \(self.pageIndex + 1)")
            .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
                self.dismiss()
            })
        }
        .background(ColorPalette.primaryBG)
        .onAppear {
            self.analyticsManager.track(event: .reportScreen(.pageSelection))
        }
    }
}

struct PdfImageViewerView_Previews: PreviewProvider {
    static var previews: some View {
        PdfImageViewerView(pageIndex: 0, images: [
            PdfImage(image: UIImage(named: "onboarding_chat_pdf"), caption: "onboarding chat pdf"),
            PdfImage(image: nil, caption: "onboarding chat pdf"),
            PdfImage(image: UIImage(named: "onboarding_convert"), caption: "onboarding convert"),
            PdfImage(image: UIImage(named: "onboarding_password"), caption: "onboarding password"),
            PdfImage(image: UIImage(named: "onboarding_signature"), caption: "onboarding signature"),
        ])
        .previewDisplayName("Standard")
        PdfImageViewerView(pageIndex: 0, images: [])
            .previewDisplayName("Empty")
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfImportMultipleView.swift
================================================
//
//  PdfImportMultipleView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/08/23.
//

import SwiftUI
import Factory

struct PdfImportMultipleView: ViewModifier {
    
    @ObservedObject var viewModel: PdfImportMultipleViewModel

    func body(content: Content) -> some View {
        content
            .filePicker(isPresented: self.$viewModel.showFilePicker,
                        fileTypes: self.viewModel.importFileTypes,
                        multipleSelection: true,
                        onPickedFiles: {
                self.viewModel.processSelectedUrls($0)
            })
            .showUnlockView(viewModel: self.viewModel.pdfUnlockViewModel)
            .loadingView(show: self.$viewModel.loading)
    }
}

extension View {
    func showImportMultipleView(viewModel: PdfImportMultipleViewModel) -> some View {
        modifier(PdfImportMultipleView(viewModel: viewModel))
    }
}

struct PdfImportMultipleView_Previews: PreviewProvider {
    
    static let asyncPdfs: AsyncOperation<[Pdf], PdfError> = .init(status: .empty)
    static let viewModel = Container.shared
        .pdfImportMultipleViewModel(.init(asyncPdfs: .constant(Self.asyncPdfs)))
    
    static var previews: some View {
        Color(.white)
            .showImportMultipleView(viewModel: Self.viewModel)
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfImportView.swift
================================================
//
//  PdfImportView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/08/23.
//

import SwiftUI
import Factory

struct PdfImportView: ViewModifier {
    
    @ObservedObject var viewModel: PdfImportViewModel

    func body(content: Content) -> some View {
        content
            .filePicker(isPresented: self.$viewModel.showFilePicker,
                        fileTypes: self.viewModel.importFileTypes,
                        multipleSelection: false,
                        onPickedFiles: {
                self.viewModel.processSelectedUrls($0)
            })
            .showUnlockView(viewModel: self.viewModel.pdfUnlockViewModel)
            .loadingView(show: self.$viewModel.loading)
    }
}

extension View {
    func showImportView(viewModel: PdfImportViewModel) -> some View {
        modifier(PdfImportView(viewModel: viewModel))
    }
}

struct PdfImportView_Previews: PreviewProvider {
    
    static let asyncPdf: AsyncOperation<Pdf, PdfError> = .init(status: .empty)
    static let viewModel = Container.shared
        .pdfImportViewModel(.init(asyncPdf: .constant(Self.asyncPdf)))
    
    static var previews: some View {
        Color(.white)
            .showImportView(viewModel: Self.viewModel)
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfMergeView.swift
================================================
//
//  PdfMergeView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 02/08/23.
//

import SwiftUI
import Factory

struct PdfMergeView: ViewModifier {
    
    @ObservedObject var viewModel: PdfMergeViewModel

    func body(content: Content) -> some View {
        content
            .showImportMultipleView(viewModel: self.viewModel.pdfImportMultipleViewModel)
            .loadingView(show: self.$viewModel.loading)
            .asyncView(asyncOperation: self.$viewModel.asyncImportedPdfs)
            .showSortView(isPresented: self.$viewModel.showPdfSorter,
                          onDismiss: { self.viewModel.onSortedCompleted() },
                          params: PdfSortViewModel.Params(
                            pdfs: self.$viewModel.toBeSortedPdfs,
                            confirmButtonText: "Merge PDF",
                            confirmCallback: {
                                self.viewModel.onSortedConfirmed()
                            },
                            cancelCallback: {
                                self.viewModel.onSortedCancelled()
                            }))
    }
}

extension View {
    func showMergeView(viewModel: PdfMergeViewModel) -> some View {
        modifier(PdfMergeView(viewModel: viewModel))
    }
}

struct PdfMergeView_Previews: PreviewProvider {
    
    static let asyncPdf: AsyncOperation<Pdf, PdfError> = .init(status: .empty)
    static let viewModel = Container.shared
        .pdfMergeViewModel(.init(asyncPdf: .constant(Self.asyncPdf)))
    
    static var previews: some View {
        Color(.white)
            .showMergeView(viewModel: Self.viewModel)
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfPageRangeEditorView.swift
================================================
//
//  PdfPageRangeEditorView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/08/23.
//

import SwiftUI
import Factory

struct PdfPageRangeEditorView: View {
    
    @ObservedObject var viewModel: PdfPageRangeEditorViewModel
    
    @Injected(\.analyticsManager) private var analyticsManager
    
    @FocusState private var pdfPageRangeInFocus: PdfPageRangeFocusable?
    
    @Namespace var bottomID
    
    @State var previousNumberOfRanges: Int = 0
    
    var body: some View {
        NavigationStack {
            ZStack {
                self.listView
                self.bottomView
                    .ignoresSafeArea(.keyboard)
            }
            .padding(.top, 48)
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle("Split pages into ranges")
            .background(ColorPalette.primaryBG)
            .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
                self.viewModel.cancel()
            })
            .toolbar {
                ToolbarItemGroup(placement: .keyboard) {
                    Spacer()
                    Button(action: {
                        self.viewModel.onConfirmRange()
                    }) {
                        Text("Done")
                            .foregroundColor(ColorPalette.secondaryText)
                            .bold()
                    }
                }
            }
        }
        .background(ColorPalette.primaryBG)
        .onAppear {
            self.analyticsManager.track(event: .reportScreen(.pageRangeEditor))
        }
        // The focus state in the viewmodel is the one in charge and allow field validation.
        // The one in the view must by synced with it
        .onChange(of: self.viewModel.pdfPageRangeInFocus) { self.pdfPageRangeInFocus = $0 }
    }
    
    private var listView: some View {
        ScrollViewReader { scrollViewProxy in
            List {
                ForEach(Array(self.viewModel.pageRangeLowerBounds.enumerated()), id:\.offset) { index, item in
                    self.getItemView(atIndex: index)
                        .listRowBackground(ColorPalette.secondaryBG)
                }
                .onChange(of: self.viewModel.pageRangeLowerBounds.count) { newValue in
                    if self.isScrollToAvailable, newValue > self.previousNumberOfRanges {
                        withAnimation {
                            scrollViewProxy.scrollTo(self.bottomID, anchor: .bottom)
                        }
                    }
                    self.previousNumberOfRanges = newValue
                }
                HStack {
                    Spacer()
                    self.addRangeButton
                }
                .listRowBackground(ColorPalette.primaryBG)
                .listRowSeparator(.hidden)
                Spacer()
                    .frame(height: 135)
                    .listRowBackground(ColorPalette.primaryBG)
                    .id(self.bottomID)
            }
            .safeAreaInset(edge: .bottom, content: {
                Spacer().frame(height: 8)
            })
            .scrollContentBackground(.hidden)
        }
    }
    
    private var bottomView: some View {
        VStack(spacing: 0) {
            Spacer()
            VStack(spacing: 0) {
                self.getDefaultButton(text: "Split PDF", onButtonPressed: {
                    self.viewModel.confirm()
                })
                .padding([.leading, .trailing], 16)
                .padding(.bottom, 80)
                .padding(.top, 16)
            }.background(ColorPalette.primaryBG)
        }
    }
    
    private var addRangeButton: some View {
        Button(action: {
            withAnimation {
                self.viewModel.addRange()
            }
        }) {
            HStack(spacing: 10) {
                Image(systemName: "plus.circle.fill")
                    .foregroundColor(ColorPalette.secondaryText)
                Text("Add new range")
                    .font(forCategory: .body1)
                    .foregroundColor(ColorPalette.secondaryText)
                    .lineLimit(1)
            }
        }
    }
    
    private func getRangeHeader(atIndex index: Int) -> some View {
        HStack {
            Text("Range \(index + 1)")
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.primaryText)
            Spacer()
            if index > 0 {
                Button(action: {
                    withAnimation {
                        self.viewModel.removeRange(atIndex: index)
                    }
                }) {
                    Image(systemName: "trash.fill")
                        .foregroundColor(ColorPalette.thirdText)
                }
            }
        }
    }
    
    private func getItemView(atIndex index: Int) -> some View {
        Section(header: self.getRangeHeader(atIndex: index)) {
            self.getBoundView(index: index, isLowerBound: true)
            self.getBoundView(index: index, isLowerBound: false)
        }
    }
    
    private func getBoundView(index: Int, isLowerBound: Bool) -> some View {
        ZStack {
            HStack {
                Text(isLowerBound ? "From page number" : "To page number")
                    .font(forCategory: .callout)
                    .foregroundColor(ColorPalette.thirdText)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .lineLimit(1)
                TextField("", text: self.viewModel.getTextFieldText(index: index,
                                                                    isLowerBound: isLowerBound))
                .font(forCategory: .body2)
                .foregroundColor(ColorPalette.primaryText)
                .lineLimit(1)
                .disableAutocorrection(true)
                .autocapitalization(.none)
                .fixedSize(horizontal: true, vertical: true)
                .allowsHitTesting(false)
                .focused(self.$pdfPageRangeInFocus,
                         equals: isLowerBound ? .lowerBound(index: index) : .upperBound(index: index))
                .keyboardType(.numberPad)
            }
            Button("") {
                self.viewModel.focus(index: index, isLowerBound: isLowerBound)
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
        }
    }
}

extension View {
    func showPageRangeEditorView(isPresented: Binding<Bool>,
                                 onDismiss: (() -> Void)?,
                                 params: PdfPageRangeEditorViewModel.Params) -> some View {
        self.fullScreenCover(isPresented: isPresented, onDismiss: onDismiss) {
            let viewModel = Container.shared.pdfPageRangeEditorViewModel(params)
            PdfPageRangeEditorView(viewModel: viewModel)
        }
    }
}

struct PdfPageRangeEditorView_Previews: PreviewProvider {
    
    static let params = PdfPageRangeEditorViewModel.Params(
        pageRanges: .constant([0...1, 0...1]),
        totalPages: 10,
        confirmCallback: { print("Split confirmed!") },
        cancelCallback: { print("Split cancelled...") })
    
    static var previews: some View {
        Color(.white)
            .showPageRangeEditorView(isPresented: .constant(true),
                                     onDismiss: { print("Split completed.") },
                                     params: Self.params)
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfPageSelectionView.swift
================================================
//
//  PdfPageSelectionView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/08/23.
//

import SwiftUI
import Factory

struct PdfPageSelectionView: View {
    
    @Binding var pageIndex: Int
    
    let title: String
    let pageThumbnails: [UIImage?]
    
    @Injected(\.analyticsManager) private var analyticsManager
    
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        NavigationStack {
            ScrollViewReader { reader in
                ScrollView {
                    LazyVStack(spacing: 0) {
                        ForEach(Array(self.pageThumbnails.enumerated()), id:\.offset) { index, pageThumbnail in
                            Button(action: {
                                self.pageIndex = index
                                self.dismiss()
                            }) {
                                HStack {
                                    Text("\(index)")
                                        .foregroundColor(ColorPalette.primaryText)
                                        .font(forCategory: .body2)
                                        .minimumScaleFactor(0.5)
                                        .frame(width: 40, alignment: .leading)
                                    self.getPdfPageThumbnail(fromImage: pageThumbnail)
                                        .frame(width: 86)
                                        .padding([.top, .bottom], 8)
                                    Spacer()
                                }
                                .padding([.trailing, .leading], 16)
                            }
                            .frame(height: 94)
                            .background(self.getPageBackgroundColor(forPageIndex: index))
                            .id(index)
                        }
                    }
                    .onAppear{
                        if self.isScrollToAvailable {
                            reader.scrollTo(self.pageIndex, anchor: .center)
                        }
                    }
                }
                .padding([.top, .bottom], 16)
                .background(ColorPalette.primaryBG)
            }
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle(self.title)
            .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
                self.dismiss()
            })
        }
        .background(ColorPalette.primaryBG)
        .onAppear {
            self.analyticsManager.track(event: .reportScreen(.pageSelection))
        }
    }
    
    func getPageBackgroundColor(forPageIndex pageIndex: Int) -> Color {
        if self.pageIndex == pageIndex {
            return ColorPalette.secondaryBG
        } else {
            return .clear
        }
    }
    
    @ViewBuilder private func getPdfPageThumbnail(fromImage image: UIImage?) -> some View {
        if let thumbnail = image {
            Color.clear
                .overlay(Image(uiImage: thumbnail)
                    .resizable()
                    .scaledToFill())
                .clipShape(RoundedRectangle(cornerRadius: 10,
                            style: .continuous))
        } else {
            ColorPalette.secondaryBG
                .cornerRadius(10)
        }
    }
}

struct PdfPageSelectionView_Previews: PreviewProvider {
    
    static var previews: some View {
        if let pdf = K.Test.DebugPdf {
            let thumbnails = PDFUtility.generatePdfThumbnails(pdfDocument: pdf.pdfDocument,
                                                              size: K.Misc.ThumbnailSize)
            PdfPageSelectionView(pageIndex: .constant(0),
                                 title: pdf.filename,
                                 pageThumbnails: thumbnails)
        }
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfReaderView.swift
================================================
//
//  PdfReaderView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/08/23.
//

import SwiftUI
import Factory

struct PdfReaderView: View {
    
    @Injected(\.analyticsManager) private var analyticsManager
    
    @Environment(\.dismiss) var dismiss
    
    @StateObject var viewModel: PdfReaderViewModel
    
    var body: some View {
        NavigationStack {
            self.contentView
            .padding(16)
            .background(ColorPalette.primaryBG)
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle(self.viewModel.filename)
            .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
                self.dismiss()
            })
            .toolbar {
                ToolbarItemGroup(placement: .navigationBarTrailing) {
                    self.toolbar
                }
            }
            .fullScreenCover(isPresented: self.$viewModel.showPageSelection) {
                PdfPageSelectionView(pageIndex: self.$viewModel.pageIndex,
                                     title: self.viewModel.filename,
                                     pageThumbnails: self.viewModel.pageThumbnails.data ?? [])
            }
            .fullScreenCover(isPresented: self.$viewModel.showPageImages) {
                PdfImageViewerView(pageIndex: self.viewModel.pageIndex,
                                   images: self.viewModel.pageImages.data ?? [])
            }
        }
        .background(ColorPalette.primaryBG)
        .onAppear(perform: self.viewModel.onAppear)
        .asyncView(asyncItem: self.$viewModel.pageThumbnails)
        .asyncView(asyncItem: self.$viewModel.pageImages)
    }
    
    @ViewBuilder var contentView: some View {
        VStack(spacing: 16) {
            if self.viewModel.textMode {
                self.textView
            } else {
                self.standardView
            }
            self.pageCounter(currentPageIndex: self.viewModel.pageIndex,
                             totalPages: self.viewModel.pageCount)
        }
    }
    
    var textView: some View {
        TabView(selection: self.$viewModel.pageIndex) {
            ForEach(Array(self.viewModel.pages.enumerated()), id:\.offset) { _, page in
                if let page = page {
                    ScrollView {
                        Text(page)
                    }
                } else {
                    Text("No text available on this page")
                        .font(forCategory: .body1)
                        .foregroundColor(ColorPalette.primaryText)
                }
            }
        }
        .tabViewStyle(.page(indexDisplayMode: .never))
        .background(ColorPalette.primaryBG)
    }
    
    var standardView: some View {
        PdfKitViewBinder(
            pdfView: self.$viewModel.pdfView,
            singlePage: false,
            pageMargins: UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0),
            backgroundColor: UIColor(ColorPalette.primaryBG),
            usePaginator: true
        )
    }
    
    @ViewBuilder var toolbar: some View {
        Button(action: { self.viewModel.switchTextMode() }) {
            Image(systemName: self.viewModel.textMode ? "doc" : "doc.text")
                .foregroundColor(ColorPalette.primaryText)
        }
        Button(action: { self.viewModel.presentPageImages() }) {
            Image(systemName: "photo.stack")
                .foregroundColor(ColorPalette.primaryText)
        }
        Button(action: { self.viewModel.presentPageSelection() }) {
            Image("page_selection")
                .foregroundColor(ColorPalette.primaryText)
        }
    }
}

extension View {
    func showPdfReaderView(item: Binding<Pdf?>) -> some View {
        self.fullScreenCover(item: item) { pdf in
            let params = PdfReaderViewModel.Params(pdf: pdf)
            let viewModel = Container.shared.pdfReaderViewModel(params)
            PdfReaderView(viewModel: viewModel)
        }
    }
}

struct PdfReaderView_Previews: PreviewProvider {
    
    static var previews: some View {
        Color.white
            .showPdfReaderView(item: .constant(K.Test.DebugPdf))
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfReadView.swift
================================================
//
//  PdfReadView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 21/08/23.
//

import SwiftUI

struct PdfReadViewModifier: ViewModifier {
    
    @ObservedObject var viewModel: PdfReadViewModel
    
    func body(content: Content) -> some View {
        content
            .showImportView(viewModel: self.viewModel.pdfImportViewModel)
            .asyncView(asyncItem: self.$viewModel.asyncImportedPdf)
            .showPdfReaderView(item: self.$viewModel.toBeReadPdf)
    }
}

extension View {
    func showReadView(viewModel: PdfReadViewModel) -> some View {
        self.modifier(PdfReadViewModifier(viewModel: viewModel))
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfShareView.swift
================================================
//
//  PdfShareView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/07/23.
//

import SwiftUI
import Factory

struct PdfShareView: ViewModifier {
    
    @ObservedObject var coordinator: PdfShareCoordinator

    func body(content: Content) -> some View {
        content
            .showSubscriptionView(self.$coordinator.monetizationShow, onComplete: { self.coordinator.onMonetizationClose() })
            .sharePdf(self.$coordinator.pdfToBeShared,
                      applyPostProcess: self.coordinator.applyPostProcess,
                      onDismiss: { self.coordinator.onShareDismiss() })
    }
}

extension View {
    func showShareView(coordinator: PdfShareCoordinator) -> some View {
        modifier(PdfShareView(coordinator: coordinator))
    }
}

struct PdfShareView_Previews: PreviewProvider {
    
    static let coordinator = Container.shared.pdfShareCoordinator()
    
    static var previews: some View {
        Color(.white)
            .showShareView(coordinator: Self.coordinator)
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfSortView.swift
================================================
//
//  PdfSortView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 02/08/23.
//

import SwiftUI
import Factory

struct PdfSortView: View {
    
    @ObservedObject var viewModel: PdfSortViewModel
    
    @Injected(\.analyticsManager) private var analyticsManager
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                List {
                    ForEach(Array(self.viewModel.pdfs.enumerated()), id:\.offset) { _, item in
                        self.getItemView(forItem: item)
                            .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
                            .listRowSeparator(.hidden)
                            .listRowBackground(Color(.clear))
                    }
                    .onMove { from, to in
                        self.viewModel.pdfs.move(fromOffsets: from, toOffset: to)
                    }
                }
                .environment(\.editMode, .constant(.active))
                .scrollContentBackground(.hidden)
                .listStyle(.inset)
                Spacer()
                self.getDefaultButton(text: self.viewModel.confirmButtonText, onButtonPressed: {
                    self.viewModel.confirm()
                })
            }
            .padding([.leading, .trailing], 16)
            .padding(.top, 48)
            .padding(.bottom, 80)
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle("Drag and drop to sort your documents")
            .background(ColorPalette.primaryBG)
            .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
                self.viewModel.cancel()
            })
        }
        .background(ColorPalette.primaryBG)
        .onAppear {
            self.analyticsManager.track(event: .reportScreen(.sortPdf))
        }
    }
    
    private func getItemView(forItem item: Pdf) -> some View {
        HStack(spacing: 16) {
            self.getPdfThumbnail(forPdf: item)
                .frame(width: 86)
            VStack(spacing: 0) {
                Spacer()
                Text(item.filename)
                    .font(forCategory: .body1)
                    .foregroundColor(ColorPalette.primaryText)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .lineLimit(1)
                Spacer().frame(height: 16)
                HStack(spacing: 16) {
                    Text(item.pageCountText)
                        .font(forCategory: .body1)
                        .foregroundColor(ColorPalette.fourthText)
                        .frame(maxWidth: .infinity, alignment: .leading)
                }
                Spacer()
            }
            .frame(maxWidth: .infinity)
            
        }
        .padding(.trailing, 16)
        .background(ColorPalette.secondaryBG)
        .frame(height: 94)
        .cornerRadius(10)
    }
    
    @ViewBuilder private func getPdfThumbnail(forPdf pdf: Pdf) -> some View {
        if let thumbnail = pdf.thumbnail {
            Color.clear
                .overlay(Image(uiImage: thumbnail)
                    .resizable()
                    .scaledToFill())
                .clipShape(RoundedRectangle(cornerRadius: 10,
                                            style: .continuous))
        } else {
            ColorPalette.secondaryBG
                .cornerRadius(10)
        }
    }
}

extension View {
    func showSortView(isPresented: Binding<Bool>,
                      onDismiss: (() -> Void)?,
                      params: PdfSortViewModel.Params) -> some View {
        self.fullScreenCover(isPresented: isPresented, onDismiss: onDismiss) {
            let viewModel = Container.shared.pdfSortViewModel(params)
            PdfSortView(viewModel: viewModel)
        }
    }
}

struct PdfSortView_Previews: PreviewProvider {
    
    static let params = PdfSortViewModel.Params(
        pdfs: .constant([K.Test.DebugPdf, K.Test.DebugPdf, K.Test.DebugPdf].compactMap { $0 }),
        confirmButtonText: "Merge PDF",
        confirmCallback: { print("Sort confirmed!") },
        cancelCallback: { print("Sort cancelled...") })
    
    static var previews: some View {
        Color(.white)
            .showSortView(isPresented: .constant(true),
                          onDismiss: { print("Sort completed.") },
                          params: Self.params)
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfSplitView.swift
================================================
//
//  PdfSplitView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 04/08/23.
//

import SwiftUI
import Factory

struct PdfSplitView: ViewModifier {
    
    @ObservedObject var viewModel: PdfSplitViewModel
    
    func body(content: Content) -> some View {
        content
            .showImportView(viewModel: self.viewModel.pdfImportViewModel)
            .asyncView(asyncItem: self.$viewModel.asyncImportedPdf)
            .asyncView(asyncItem: self.$viewModel.asyncSplit)
            .showPageRangeEditorView(isPresented: self.$viewModel.showPageRangeEditor,
                                     onDismiss: { self.viewModel.onPageRangeEditingCompleted() },
                                     params: PdfPageRangeEditorViewModel.Params(
                                        pageRanges: self.$viewModel.pageRanges,
                                        totalPages: self.viewModel.totalPages,
                                        confirmCallback: {
                                            self.viewModel.onPageRangeEditingConfirmed()
                                        },
                                        cancelCallback: {
                                            self.viewModel.onPageRangeEditingCancelled()
                                        }))
    }
}

extension View {
    func showSplitView(viewModel: PdfSplitViewModel) -> some View {
        modifier(PdfSplitView(viewModel: viewModel))
    }
}

struct PdfSplitView_Previews: PreviewProvider {
    
    static let viewModel = Container.shared.pdfSplitViewModel()
    
    static var previews: some View {
        Color(.white)
            .showSplitView(viewModel: Self.viewModel)
    }
}



================================================
FILE: pdfexpert/Views/Common/PdfUnlockView.swift
================================================
//
//  PdfUnlockView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 02/08/23.
//

import SwiftUI
import Factory

struct PdfUnlockView: ViewModifier {
    
    @ObservedObject var viewModel: PdfUnlockViewModel
    
    func body(content: Content) -> some View {
        content
            .alert("Your pdf is protected",
                   isPresented: self.$viewModel.showPasswordInputView,
                   actions: {
                SecureField("Enter Password", text: self.$viewModel.passwordText)
                Button("Confirm", action: {
                    self.viewModel.decryptPdf()
                })
                Button("Cancel", role: .cancel, action: {})
            }, message: {
                Text("Enter the password of\n\(self.viewModel.unlockingPdf?.filename ?? "")\nin order to import it.")
            })
            .asyncView(asyncOperation: self.$viewModel.asyncUnlockedPdf)
    }
}

extension View {
    func showUnlockView(viewModel: PdfUnlockViewModel) -> some View {
        modifier(PdfUnlockView(viewModel: viewModel))
    }
}

struct PdfUnlockView_Previews: PreviewProvider {
    
    static let asyncUnlockedPdfSingle: AsyncOperation<Pdf, PdfError> = .init(status: .empty)
    static let viewModel = Container.shared
        .pdfUnlockViewModel(.init(asyncUnlockedPdfSingleOutput: .constant(Self.asyncUnlockedPdfSingle)))
    
    static var previews: some View {
        Color(.white)
            .showUnlockView(viewModel: Self.viewModel)
    }
}



================================================
FILE: pdfexpert/Views/Common/SuggestedFieldsFormView.swift
================================================
//
//  SuggestedFieldsFormView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 07/09/23.
//

import SwiftUI
import Factory

struct SuggestedFieldsFormView: View {
    
    @InjectedObject(\.suggestedFieldsFormViewModel) var viewModel: SuggestedFieldsFormViewModel
    
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        NavigationStack {
            // The ZStack is needed to disable keyboard avoiding for the footer
            // while keeping it for the textfields in the content view
            ZStack {
                self.contentView
                self.footerView
                    .ignoresSafeArea(.keyboard)
            }
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle("Personal data")
            .background(ColorPalette.primaryBG)
            .addSystemCloseButton(color: ColorPalette.primaryText,
                                  onPress: {
                self.dismiss()
            })
        }
        .background(ColorPalette.primaryBG)
        .onAppear(perform: self.viewModel.onAppear)
    }
    
    private var contentView: some View {
        VStack(spacing: 0) {
            Form {
                Section(header: self.headerView) {}
                self.getTextField(name: "First Name",
                                  text: self.$viewModel.firstName,
                                  textContentType: .givenName)
                self.getTextField(name: "Last Name",
                                  text: self.$viewModel.lastName,
                                  textContentType: .familyName)
                self.getTextField(name: "Address",
                                  text: self.$viewModel.address,
                                  textContentType: .streetAddressLine1)
                self.getTextField(name: "City",
                                  text: self.$viewModel.city,
                                  textContentType: .addressCity)
                self.getTextField(name: "Country",
                                  text: self.$viewModel.country,
                                  textContentType: .countryName)
                self.getTextField(name: "Email",
                                  text: self.$viewModel.email,
                                  textContentType: .emailAddress,
                                  keyboardType: .emailAddress)
                self.getTextField(name: "Phone",
                                  text: self.$viewModel.phone,
                                  textContentType: .telephoneNumber,
                                  keyboardType: .numberPad)
                // This space is needed to create an inset equivalent to the footerView height
                Spacer().frame(height: 90)
                    .listRowBackground(ColorPalette.primaryBG)
            }
            .foregroundColor(ColorPalette.primaryText)
            .background(ColorPalette.primaryBG)
            .scrollContentBackground(.hidden)
        }
    }
    
    private var footerView: some View {
        VStack(spacing: 0) {
            Spacer()
            self.getDefaultButton(text: "Finish", onButtonPressed: {
                self.viewModel.onConfirmButtonPressed()
                self.dismiss()
            })
            .padding([.top, .leading, .trailing], 16)
            .padding(.bottom, 80)
            .background(ColorPalette.primaryBG)
        }
    }
    
    private var headerView: some View {
        Text("Enter your data to allow us to help you fill in the forms faster")
            .multilineTextAlignment(.center)
            .foregroundColor(ColorPalette.primaryText)
            .font(forCategory: .body2)
            .textCase(nil)
            .frame(maxWidth: .infinity)
    }
    
    private func getTextField(
        name: String,
        text: Binding<String>,
        textContentType: UITextContentType? = nil,
        keyboardType: UIKeyboardType = .default
    ) -> some View {
        Section(header:Text(name)
            .font(forCategory: .caption1)
            .foregroundColor(ColorPalette.primaryText)
        ) {
            TextField("Add \(name)", text: text)
                .frame(maxWidth: .infinity)
                .font(forCategory: .body2)
                .foregroundColor(ColorPalette.primaryText)
                .textContentType(textContentType)
                .keyboardType(keyboardType)
        }
        .listRowBackground(ColorPalette.secondaryBG)
    }
}

struct SuggestedFieldsFormView_Previews: PreviewProvider {
    static var previews: some View {
        SuggestedFieldsFormView()
    }
}



================================================
FILE: pdfexpert/Views/Home/HomeItemView.swift
================================================
//
//  HomeItemView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/03/23.
//

import SwiftUI

struct HomeItemView: View {
    
    let title: String
    let description: String
    let imageName: String
    let onButtonPressed: () -> ()
    
    var body: some View {
        Button(action: {
            self.onButtonPressed()
        }) {
            GeometryReader { geometryReader in
                VStack(spacing: 0) {
                    Spacer().frame(height: 24)
                    Image(self.imageName)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(height: UIDevice.current.userInterfaceIdiom == .pad ? 54.0 : 32.0)
                    Spacer().frame(height: 16)
                    Text(self.title)
                        .font(forCategory: .body1)
                        .foregroundColor(ColorPalette.primaryText)
                        .frame(maxWidth: .infinity, alignment: .center)
                        .minimumScaleFactor(0.5)
                        .multilineTextAlignment(.center)
                        .lineLimit(1)
                        .padding([.leading, .trailing], 12)
                    Spacer().frame(height: 4)
                    Text(self.description)
                        .font(forCategory: .caption1)
                        .foregroundColor(ColorPalette.primaryText)
                        .frame(maxWidth: .infinity, alignment: .center)
                        .minimumScaleFactor(0.5)
                        .multilineTextAlignment(.center)
                        .lineLimit(3)
                        .padding([.leading, .trailing], 12)
                    Spacer()
                    Spacer().frame(height: 12)
                }
            }
        }
        .background(
            self.defaultGradientBackground
            .cornerRadius(10)
        )
    }
}

struct HomeItemView_Previews: PreviewProvider {
    static var previews: some View {
        GeometryReader { geometryReader in
            HomeItemView(title: "Powerpoint to PDF",
                         description: "Make PPT file easy to view by converting them to PDF converting them to PDF",
                         imageName: "home_image_to_pdf",
                         onButtonPressed: {})
            .aspectRatio(1.0, contentMode: .fit)
            .frame(width: geometryReader.size.width * 0.5)
        }
    }
}



================================================
FILE: pdfexpert/Views/Home/HomeView.swift
================================================
//
//  HomeView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/03/23.
//

import SwiftUI
import Factory
import PhotosUI

struct HomeItem: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let imageName: String
    let homeAction: HomeAction
}

struct HomeView: View {
    
    @InjectedObject(\.homeViewModel) var viewModel
    
    let mostUsedItems: [HomeItem] = [
        HomeItem(title: "Image to PDF",
                 description: "Convert image to PDF in seconds",
                 imageName: "home_image_to_pdf",
                 homeAction: .imageToPdf),
        HomeItem(title: "Scan",
                 description: "Scan file from your smartphone or your camera",
                 imageName: "home_scan",
                 homeAction: .scan),
        HomeItem(title: "Read PDF",
                 description: "Read PDF improves the readability of your PDF",
                 imageName: "home_read",
                 homeAction: .readPdf)
    ]
    
    let convertItems: [HomeItem] = [
        HomeItem(title: "Word to PDF",
                 description: "Make DOC file easy to read by converting them to PDF",
                 imageName: "home_word_to_pdf",
                 homeAction: .wordToPdf),
        HomeItem(title: "Excel to PDF",
                 description: "Make EXCEL file easy to read by converting them to PDF",
                 imageName: "home_excel_to_pdf",
                 homeAction: .excelToPdf),
        HomeItem(title: "Powerpoint to PDF",
                 description: "Make PPT file easy to view by converting them to PDF",
                 imageName: "home_power_to_pdf",
                 homeAction: .powerpointToPdf)
    ]
    
    let organizeItems: [HomeItem] = [
        HomeItem(title: "Merge PDF",
                 description: "Combine pdf files in the order you want",
                 imageName: "home_merge",
                 homeAction: .merge),
        HomeItem(title: "Split PDF",
                 description: "Separate a set of pages for easy conversion into PDF",
                 imageName: "home_split",
                 homeAction: .split),
    ]
        
    let editItems: [HomeItem] = [
        HomeItem(title: "Sign PDF",
                 description: "Sign a document or send a signature request to others",
                 imageName: "home_sign",
                 homeAction: .sign),
        HomeItem(title: "Fill in a form",
                 description: "Fill in a form or file",
                 imageName: "home_fill_form",
                 homeAction: .formFill),
        HomeItem(title: "Add text",
                 description: "Add text on your files",
                 imageName: "home_add_text",
                 homeAction: .addText),
        HomeItem(title: "Create PDF",
                 description: "Create a pdf from scratch and edit it",
                 imageName: "home_create_pdf",
                 homeAction: .createPdf)
    ]
    
    let importItems: [HomeItem] = [
        HomeItem(title: "Import PDF",
                 description: "Import pdf from your files",
                 imageName: "home_import_pdf",
                 homeAction: .importPdf)
    ]
    
    let protectItems: [HomeItem] = [
        HomeItem(title: "Unlock PDF",
                 description: "Unlock a PDF",
                 imageName: "home_remove_password",
                 homeAction: .removePassword),
        HomeItem(title: "PDF Protector",
                 description: "Enter a password to protect your pdf",
                 imageName: "home_add_password",
                 homeAction: .addPassword)
    ]
    
    private static let standardGridItemLayout: [GridItem] = {
        if UIDevice.current.userInterfaceIdiom == .pad {
            return [GridItem(.flexible(), spacing: 14),
                    GridItem(.flexible(), spacing: 14),
                    GridItem(.flexible(), spacing: 14),
                    GridItem(.flexible(), spacing: 14)]
        } else {
            return [GridItem(.flexible(), spacing: 14),
                    GridItem(.flexible(), spacing: 14)]
        }
    }()
    
    private static let expandedGridItemLayout: [GridItem] = {
        if UIDevice.current.userInterfaceIdiom == .pad {
            return [
                    GridItem(.flexible(), spacing: 14),
                    GridItem(.flexible(), spacing: 14)]
        } else {
            return [GridItem(.flexible(), spacing: 14)]
        }
    }()
    
    var body: some View {
        ScrollView {
            VStack {
                LazyVGrid(columns: Self.expandedGridItemLayout, spacing: 14) {
                    self.section(forItems: self.mostUsedItems, sectionTitle: "Most used", aspectRatio: 2.5)
                }
                .padding(14)
                LazyVGrid(columns: Self.standardGridItemLayout, spacing: 14) {
                    self.section(forItems: self.convertItems, sectionTitle: "Convert to PDF")
                    self.section(forItems: self.organizeItems, sectionTitle: "Organize PDF")
                    self.section(forItems: self.editItems, sectionTitle: "Edit PDF")
                    self.section(forItems: self.importItems, sectionTitle: "Convert from PDF")
                    self.section(forItems: self.protectItems, sectionTitle: "Protect PDF")
                }
                .padding(14)
            }
        }
        .padding(.top, 16)
        .listStyle(.plain)
        .background(ColorPalette.primaryBG)
        .onAppear() {
            self.viewModel.onAppear()
        }
        .formSheet(item: self.$viewModel.importOptionGroup) {
            OptionListView.getImportView(forImportOptionGroup: $0,
                                         importViewCallback: { self.viewModel.handleImportOption(importOption: $0) })
        }
        .filePicker(item: self.$viewModel.importFileOption, onPickedFiles: {
            self.viewModel.processPickedFileUrl($0.first)
        })
        .fullScreenCover(isPresented: self.$viewModel.scannerShow) {
            // Scanner
            ScannerView(onScannerResult: {
                self.viewModel.convertScan(scannerResult: $0)
            })
        }
        .fullScreenCover(isPresented: self.$viewModel.cameraShow) {
            // Camera for image capture
            CameraView(model: Container.shared.cameraViewModel({ uiImage in
                self.viewModel.convertImage(uiImage: uiImage)
            }))
        }
        // Photo gallery picker
        .photosPicker(isPresented: self.$viewModel.imagePickerShow,
                      selection: self.$viewModel.imageSelection,
                      matching: .images)
        .asyncView(asyncOperation: self.$viewModel.asyncPdf,
                   loadingView: { AnimationType.pdf.view })
        .asyncView(asyncOperation: self.$viewModel.asyncImageLoading,
                   loadingView: { AnimationType.pdf.view })
        .alertCameraPermission(isPresented: self.$viewModel.cameraPermissionDeniedShow)
        .addPasswordView(show: self.$viewModel.addPasswordShow,
                         addPasswordCallback: { self.viewModel.setPassword($0) })
        .addPasswordCompletedAlert(show: self.$viewModel.addPasswordCompletedShow,
                                   goToArchiveCallback: { self.viewModel.goToArchive() },
                                   sharePdfCallback: { self.viewModel.share() })
        .removePasswordCompletedAlert(show: self.$viewModel.removePasswordCompletedShow,
                                      goToArchiveCallback: { self.viewModel.goToArchive() },
                                      sharePdfCallback: { self.viewModel.share() })
        .showError(self.$viewModel.addPasswordError)
        .showError(self.$viewModel.removePasswordError)
        .showShareView(coordinator: self.viewModel.pdfShareCoordinator)
        .showMergeView(viewModel: self.viewModel.pdfMergeViewModel)
        .showSplitView(viewModel: self.viewModel.pdfSplitViewModel)
        .showReadView(viewModel: self.viewModel.pdfReadViewModel)
        .showUnlockView(viewModel: self.viewModel.pdfUnlockViewModel)
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification)) { _ in
            self.viewModel.onDidBecomeActive()
        }
    }
    
    @ViewBuilder func section(forItems items: [HomeItem],
                              sectionTitle: String,
                              aspectRatio: CGFloat = 1.0) -> some View {
        Section {
            ForEach(items, id: \.id) { item in
                HomeItemView(title: item.title,
                             description: item.description,
                             imageName: item.imageName,
                             onButtonPressed: { self.viewModel.performHomeAction(item.homeAction) })
                .aspectRatio(aspectRatio, contentMode: .fit)
                .listRowSeparator(.hidden)
                .listRowBackground(Color(.clear))
                .listRowInsets(EdgeInsets())
            }
        } header: {
            Text(sectionTitle)
                .font(forCategory: .headline)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
    }
}

extension View {
    @ViewBuilder func addPasswordCompletedAlert(show: Binding<Bool>,
                                                goToArchiveCallback: @escaping () -> (),
                                                sharePdfCallback: @escaping () -> ()) -> some View {
        self.alert("PDF Protected!", isPresented: show, actions: {
            Button("Go to files", action: goToArchiveCallback)
            Button("Share pdf", action: sharePdfCallback)
        }, message: {
            Text("Your pdf has been successfully protected")
        })
    }
    
    @ViewBuilder func removePasswordCompletedAlert(show: Binding<Bool>,
                                                   goToArchiveCallback: @escaping () -> (),
                                                   sharePdfCallback: @escaping () -> ()) -> some View {
        self.alert("PDF Unlocked!", isPresented: show, actions: {
            Button("Go to files", action: goToArchiveCallback)
            Button("Share pdf", action: sharePdfCallback)
        }, message: {
            Text("Your pdf has been successfully unlocked")
        })
    }
}

extension ImportOptionGroup: FormSheetItem {
    var viewSize: CGSize {
        switch self {
        case .image: return CGSize(width: 400.0, height: 250.0)
        case .fileAndScan: return CGSize(width: 400.0, height: 220.0)
        }
    }
}

struct HomeView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            HomeView()
        }
        .background(ColorPalette.primaryBG)
    }
}



================================================
FILE: pdfexpert/Views/ImportTutorial/ImportTutorialPageView.swift
================================================
//
//  ImportTutorialPageView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 08/05/23.
//

import SwiftUI

struct ImportTutorialPageView: View {
    
    let title: String
    let imageName: String
    let description: String
    
    var body: some View {
        VStack(spacing: 0) {
            Spacer()
            Text(self.title)
                .font(forCategory: .title2)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity)
                .frame(height: 80, alignment: .top)
                .padding([.leading, .trailing], 32)
                .multilineTextAlignment(.center)
            Spacer().frame(height: 20)
            Image(self.imageName)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(maxHeight: 600)
            Spacer().frame(height: 40)
            Text(self.description)
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity)
                .frame(height: 80, alignment: .top)
                .padding([.leading, .trailing], 32)
                .multilineTextAlignment(.center)
            Spacer()
        }
    }
}

struct ImportTutorialPageView_Previews: PreviewProvider {
    
    static var previews: some View {
        ImportTutorialPageView(title: "Convert PDF from\nyour app",
                               imageName: "import_tutorial_1",
                               description: "Open the application that contains the pdf you want to convert")
        ImportTutorialPageView(title: "Convert PDF from\nyour app",
                               imageName: "import_tutorial_2",
                               description: "Select the pdf and press the button \"Open in\" or menu")
        ImportTutorialPageView(title: "Convert PDF from\nyour app",
                               imageName: "import_tutorial_3",
                               description: "Select the \(K.Misc.AppTitle) app to import the PDF")
    }
}



================================================
FILE: pdfexpert/Views/ImportTutorial/ImportTutorialView.swift
================================================
//
//  ImportTutorialView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 08/05/23.
//

import SwiftUI
import Factory
import PagerTabStripView

struct ImportTutorialItem {
    let title: String
    let imageName: String
    let description: String
}

struct ImportTutorialView: View {
    
    static let items: [ImportTutorialItem] = [
        ImportTutorialItem(title: "Convert PDF from\nyour app",
                           imageName: "import_tutorial_1",
                           description: "Open the application that contains the pdf you want to convert"),
        ImportTutorialItem(title: "Convert PDF from\nyour app",
                           imageName: "import_tutorial_2",
                           description: "Select the pdf and press the button \"Open in\" or menu"),
        ImportTutorialItem(title: "Convert PDF from\nyour app",
                           imageName: "import_tutorial_3",
                           description: "Select the \(K.Misc.AppTitle) app to import the PDF"),
    ]
    
    var pageCount: Int { Self.items.count }
    
    @State var pageIndex: Int = 0
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                PagerTabStripView(
                    swipeGestureEnabled: .constant(false),
                    selection: self.$pageIndex
                ) {
                    ForEach(Array(Self.items.enumerated()), id: \.offset) { index, item in
                        ImportTutorialPageView(title: item.title,
                                               imageName: item.imageName,
                                               description: item.description)
                        .pagerTabItem(tag: index) { }
                    }
                }
                .pagerTabStripViewStyle(.bar() { Color(.clear) })
                PageControl(currentPageIndex: self.pageIndex,
                            numberOfPages: self.pageCount,
                            currentPageColor: ColorPalette.buttonGradientStart,
                            normalPageColor: ColorPalette.buttonGradientStart.opacity(0.3),
                            enableInteraction: false)
                .frame(height: 40)
                Spacer()
                self.getDefaultButton(text: self.buttonText,
                                      onButtonPressed: self.onButtonPressed)
                .padding([.leading, .trailing], 16)
            }
            .padding(.top, 16)
            .padding(.bottom, 30)
            .background(ColorPalette.primaryBG)
            .addSystemCloseButton(color: ColorPalette.primaryText, onPress: { self.dismiss() })
            .onAppear() {
                Container.shared.analyticsManager().track(event: .reportScreen(.importTutorial))
            }
        }
        .background(ColorPalette.primaryBG)
    }
    
    private var buttonText: String {
        self.pageIndex + 1 < self.pageCount ? "Continue" : "Ok, I got it"
    }
    
    private func onButtonPressed() {
        if self.pageIndex + 1 < self.pageCount {
            self.pageIndex += 1
        } else {
            Container.shared.analyticsManager().track(event: .importTutorialCompleted)
            self.dismiss()
        }
    }
}

struct ImportTutorialView_Previews: PreviewProvider {
    static var previews: some View {
        ImportTutorialView()
    }
}



================================================
FILE: pdfexpert/Views/Main/MainTabView.swift
================================================
//
//  MainTabView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 06/04/23.
//

import SwiftUI
import Factory

fileprivate extension MainTab {
    
    var name: String {
        switch self {
        case .archive: return "File"
        case .home: return "Explore"
        case .chatPdf: return "ChatPDF"
        }
    }
    
    var imageName: String {
        switch self {
        case .archive: return "tab_archive"
        case .home: return "tab_home"
        case .chatPdf: return "tab_chat_pdf"
        }
    }
}

struct MainTabView: View {
    
    @InjectedObject(\.mainCoordinator) var mainCoordinator
    
    var body: some View {
        TabView(selection: self.$mainCoordinator.tab) {
            ForEach(MainTab.allCases, id:\.self) { tab in
                NavigationStack {
                    self.getRootView(forTab: tab)
                        .navigationTitle(tab.name)
                        .navigationBarTitleDisplayMode(.inline)
                        .toolbarBackground(ColorPalette.secondaryBG, for: .navigationBar)
                        .toolbarBackground(.visible, for: .navigationBar)
                        .settingsButton(showSettings: self.$mainCoordinator.settingsShow)
                }
                .tabItem {
                    Label(tab.name, image: tab.imageName)
                }
                .tag(tab.rawValue)
            }
        }
        .background(ColorPalette.primaryBG)
        .pdfEditFlowView(pdfEditFlowData: self.$mainCoordinator.pdfEditFlowData)
        .settingsView(showSettings: self.$mainCoordinator.settingsShow)
    }
    
    @MainActor @ViewBuilder private func getRootView(forTab tab: MainTab) -> some View {
        switch tab {
        case .archive: ArchiveView()
        case .home: HomeView()
        case .chatPdf: ChatPdfSelectionView()
        }
    }
}

fileprivate extension View {
    
    func pdfEditFlowView(pdfEditFlowData: Binding<PdfEditFlowData?>) -> some View {
        self.fullScreenCover(item: pdfEditFlowData) { data in
            PdfFlowView(
                pdf: data.pdf,
                startAction: data.startAction,
                shouldShowCloseWarning: data.isNewPdf
            )
        }
    }
    
    func settingsView(showSettings: Binding<Bool>) -> some View {
        self.fullScreenCover(isPresented: showSettings) {
            NavigationStack {
                SettingsView()
                    .navigationBarTitleDisplayMode(.inline)
                    .navigationTitle("Settings")
                    .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
                        showSettings.wrappedValue = false
                    })
            }
            .background(ColorPalette.primaryBG)
        }
    }
    
    func settingsButton(showSettings: Binding<Bool>) -> some View {
        self.toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button(action: { showSettings.wrappedValue = true }) {
                    Image(systemName: "gearshape")
                        .foregroundColor(ColorPalette.primaryText)
                }
            }
        }
    }
}

struct MainTabView_Previews: PreviewProvider {
    static var previews: some View {
        MainTabView()
    }
}



================================================
FILE: pdfexpert/Views/Navigation/Deeplink.swift
================================================
//
//  Deeplink.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 29/08/23.
//

import Foundation

enum Deeplink {
    case chatPdf
    
    init?(fromCustomUrl url: URL) {
        guard url.absoluteString.starts(with: SharedStorage.schema) else {
            return nil
        }
        
        switch url.absoluteString {
        case "\(SharedStorage.schema)chatpdf":
            self = .chatPdf
        default:
            return nil
        }
    }
}



================================================
FILE: pdfexpert/Views/Navigation/MainCoordinator.swift
================================================
//
//  MainCoordinator.swift
//  ChatAI
//
//  Created by Pcnaid Inc on 24/02/23.
//

import Foundation
import SwiftUI
import Factory

enum MainTab: Int, CaseIterable {
    case archive
    case home
    case chatPdf
}

struct PdfEditFlowData: Hashable, Identifiable {
    
    var id: Self { return self }
    
    let pdf: Pdf
    let startAction: PdfEditStartAction?
    let isNewPdf: Bool
}

class MainCoordinator: ObservableObject {
    
    enum RootView {
        case onboarding
        case main
    }
    
    enum Route: Hashable {
        case onboarding
    }
    
    @Published var rootView: RootView = .onboarding
    @Published var tab: MainTab = MainTab.home
    @Published var path: [Route] = []
    @Published var pdfEditFlowData: PdfEditFlowData? = nil
    @Published var settingsShow: Bool = false
    
    @Injected(\.cacheManager) private var cacheManager
    @Injected(\.reviewFlow) var reviewFlow
    
    init() {
        if self.cacheManager.onboardingShown {
            self.rootView = .main
        } else {
            self.rootView = .onboarding
        }
    }
    
    func showOnboarding() {
        self.path.append(.onboarding)
    }
    
    func goToMain() {
        self.rootView = .main
    }
    
    func goToArchive() {
        self.tab = MainTab.archive
    }
    
    func showPdfEditFlow(pdf: Pdf, startAction: PdfEditStartAction? = nil, isNewPdf: Bool) {
        self.pdfEditFlowData = PdfEditFlowData(pdf: pdf, startAction: startAction, isNewPdf: isNewPdf)
    }
    
    func closePdfEditFlow() {
        self.pdfEditFlowData = nil
    }
    
    func handleOpenUrl(url: URL) {
        if let deeplink = Deeplink(fromCustomUrl: url) {
            self.handleDeeplink(deeplink: deeplink)
        }
    }
    
    func startReview() {
        self.reviewFlow.startFlowIfNeeded()
    }
    
    private func handleDeeplink(deeplink: Deeplink) {
        switch deeplink {
        case .chatPdf:
            self.cacheManager.onboardingShown = true
            self.rootView = .main
            self.tab = .chatPdf
        }
    }
}

extension Container {
    var mainCoordinator: Factory<MainCoordinator> {
        self { MainCoordinator() }.singleton
    }
}



================================================
FILE: pdfexpert/Views/Navigation/PdfCoordinator.swift
================================================
//
//  PdfCoordinator.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 11/04/23.
//

import Foundation
import Factory

class PdfCoordinator: ObservableObject {
    
    enum RootView {
        case edit
    }
    
    @Published var rootView: RootView = .edit
    
    @Injected(\.reviewFlow) var reviewFlow
    
    func startReview() {
        self.reviewFlow.startFlowIfNeeded()
    }
}

extension Container {
    var pdfCoordinator: Factory<PdfCoordinator> {
        self { PdfCoordinator() }.shared
    }
}



================================================
FILE: pdfexpert/Views/Navigation/PdfShareCoordinator.swift
================================================
//
//  PdfShareCoordinator.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/07/23.
//

import Foundation
import Factory

extension Container {
    var pdfShareCoordinator: Factory<PdfShareCoordinator> {
        self { PdfShareCoordinator() }
    }
}

class PdfShareCoordinator: ObservableObject {
    
    @Published var monetizationShow: Bool = false
    @Published var pdfToBeShared: Pdf?
    
    var applyPostProcess: Bool = false
    var onComplete: () -> () = {}
    
    @Injected(\.analyticsManager) private var analyticsManager
    @Injected(\.store) private var store
    
    private var pdfWantToBeShared: Pdf? = nil
    
    func share(pdf: Pdf, applyPostProcess: Bool, onComplete: @escaping () -> ()) {
        self.analyticsManager.track(event: .pdfShared)
        self.applyPostProcess = applyPostProcess
        self.onComplete = onComplete
        if self.store.isPremium.value {
            self.pdfToBeShared = pdf
        } else {
            self.monetizationShow = true
            // Store pdf to share it after a successful subscription
            self.pdfWantToBeShared = pdf
        }
    }
    
    func onShareDismiss() {
        self.onComplete()
    }
    
    func onMonetizationClose() {
        if self.store.isPremium.value {
            // Share previously stored pdf, if existing.
            self.pdfToBeShared = self.pdfWantToBeShared
            self.pdfWantToBeShared = nil
        }
    }
}



================================================
FILE: pdfexpert/Views/Onboarding/OnboardingPageView.swift
================================================
//
//  OnboardingPageView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 25/05/23.
//

import SwiftUI

struct OnboardingPageView: View {
    
    let imageName: String
    let title: String
    let description: String
    
    var body: some View {
        VStack(spacing: 0) {
            Spacer()
            Image(self.imageName)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(maxHeight: 600)
            Spacer().frame(height: 40)
            Text(self.title)
                .font(forCategory: .title2)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity)
                .frame(height: 70, alignment: .top)
                .padding([.leading, .trailing], 32)
                .multilineTextAlignment(.center)
            Spacer().frame(height: 16)
            Text(self.description)
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity)
                .frame(height: 80, alignment: .top)
                .padding([.leading, .trailing], 32)
                .multilineTextAlignment(.center)
            Spacer()
        }
    }
}

struct OnboardingPageView_Previews: PreviewProvider {
    static var previews: some View {
        OnboardingPageView(
            imageName: "onboarding_chat_pdf",
            title: "Chat with any PDF files",
            description: "You can ask questions to any PDF and get quick insights and clarifications."
        )
        OnboardingPageView(
            imageName: "onboarding_convert",
            title: "Convert files\nto PDF",
            description: "You can convert to pdf a lot of file types from the programs you prefer."
        )
        OnboardingPageView(
            imageName: "onboarding_signature",
            title: "Enter and edit your\nsignature",
            description: "Insert your signature in the pdf you created with a single tap."
        )
        OnboardingPageView(
            imageName: "onboarding_password",
            title: "Protect your files with\npassword",
            description: "Enter a password to protect your pdf, you can delete it and change it whenever you want."
        )
    }
}



================================================
FILE: pdfexpert/Views/Onboarding/OnboardingView.swift
================================================
//
//  OnboardingView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 25/05/23.
//

import SwiftUI
import PagerTabStripView
import Factory

struct OnboardingView: View {
    
    @InjectedObject(\.onboardingViewModel) var viewModel
    
    @State private var rect: CGRect = .zero
    
    var pageCount: Int { self.viewModel.items.count }
    
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        VStack(spacing: 0) {
            Spacer()
            PagerTabStripView(selection: self.$viewModel.pageIndex) {
                ForEach(Array(self.viewModel.items.enumerated()), id: \.offset) { index, item in
                    OnboardingPageView(imageName: item.imageName,
                                       title: item.title,
                                       description: item.description)
                    .pagerTabItem(tag: index) { }
                }
            }
            .pagerTabStripViewStyle(.bar() { Color(.clear) })
            Spacer()
            PageControl(currentPageIndex: self.viewModel.pageIndex,
                        numberOfPages: self.pageCount,
                        currentPageColor: ColorPalette.buttonGradientStart,
                        normalPageColor: ColorPalette.buttonGradientStart.opacity(0.3),
                        enableInteraction: false)
            .frame(height: 40)
            Spacer().frame(height: 40)
            self.getDefaultButton(text: "Continue",
                                  onButtonPressed: self.viewModel.continueButtonPressed)
            .padding([.leading, .trailing], 16)
        }
        .padding(.top, 16)
        .padding(.bottom, 64)
        .background(ColorPalette.primaryBG)
        .navigationBarBackButtonHidden()
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button(action: { self.viewModel.skipButtonPressed() }) {
                    Text("Skip")
                        .font(forCategory: .body1)
                        .foregroundColor(ColorPalette.primaryText)
                }
            }
        }
        .toolbarBackground(ColorPalette.primaryBG, for: .navigationBar)
        .onAppear() {
            Container.shared.analyticsManager().track(event: .reportScreen(.onboarding))
        }
        .fullScreenCover(isPresented: self.$viewModel.monetizationShow) {
            self.getSubscriptionView(onComplete: {
                self.viewModel.onMonetizationClose()
            })
        }
    }
}

struct OnboardingView_Previews: PreviewProvider {
    static var previews: some View {
        OnboardingView()
    }
}



================================================
FILE: pdfexpert/Views/Pdf/PdfCompressionPickerView.swift
================================================
//
//  PdfCompressionPickerView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/07/23.
//

import SwiftUI
import Factory

struct PdfCompressionPickerView: View {
    
    @Binding var compressionOption: CompressionOption
    
    @State var currentCompressionOption: CompressionOption
    
    @Environment(\.dismiss) var dismiss
    
    @Injected(\.analyticsManager) private var analyticsManager
    
    init(compressionOption: Binding<CompressionOption>) {
        self._compressionOption = compressionOption
        self._currentCompressionOption = State(initialValue: compressionOption.wrappedValue)
    }
    
    var body: some View {
        VStack(spacing: 16) {
            ForEach(CompressionOption.orderedList, id:\.self) { option in
                Button(action: { self.currentCompressionOption = option }) {
                    Group {
                        HStack(spacing: 16) {
                            VStack(spacing: 6) {
                                Text(option.titleText)
                                    .font(forCategory: .body1)
                                    .foregroundColor(ColorPalette.primaryText)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                Text(option.descriptionText)
                                    .font(forCategory: .callout)
                                    .foregroundColor(ColorPalette.primaryText)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            }
                            self.getCheckbox(forCompressionOption: option)
                        }
                        .padding(16)
                    }
                    .background(ColorPalette.secondaryBG)
                    .overlay(RoundedRectangle(cornerRadius: 8)
                        .strokeBorder(style: StrokeStyle(lineWidth: 1))
                        .foregroundColor(ColorPalette.thirdText))
                    .contentShape(RoundedRectangle(cornerRadius: 8))
                }
                .frame(height: 74)
            }
            Spacer()
            self.getDefaultButton(text: "Finish", onButtonPressed: {
                self.compressionOption = self.currentCompressionOption
                self.dismiss()
            })
        }
        .padding([.leading, .trailing], 16)
        .padding(.top, 48)
        .padding(.bottom, 80)
        .navigationTitle("Choose a compression for your pdf")
        .background(ColorPalette.primaryBG)
        .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
            self.dismiss()
        })
        .onAppear {
            self.analyticsManager.track(event: .reportScreen(.compressionPicker))
        }
    }
    
    @ViewBuilder func getCheckbox(forCompressionOption compressionOption: CompressionOption) -> some View {
        if compressionOption == self.currentCompressionOption {
            ZStack {
                Image(systemName: "circle.fill")
                    .resizable()
                    .aspectRatio(1, contentMode: .fit)
                    .frame(width: 20, height: 20)
                    .foregroundColor(ColorPalette.secondaryText)
                Image(systemName: "checkmark")
                    .font(.system(size: 10, weight: .bold))
                    .frame(width: 10, height: 10)
                    .foregroundColor(ColorPalette.primaryText)
            }
        } else {
            Image(systemName: "circle")
                .resizable()
                .aspectRatio(1, contentMode: .fit)
                .frame(width: 20, height: 20)
                .foregroundColor(ColorPalette.primaryText)
        }
    }
}
                            
fileprivate extension CompressionOption {
    
    var titleText: String {
        switch self {
        case .high: return "Maximum compression"
        case .medium: return "Recommended compression"
        case .low: return "Low compression"
        case .noCompression: return "No compression"
        }
    }
    
    var descriptionText: String {
        switch self {
        case .high: return "Lower quality, higher compression"
        case .medium: return "Good quality, good compression"
        case .low: return "High quality, less compression"
        case .noCompression: return "Top quality, no compression"
        }
    }
    
    static var orderedList: [CompressionOption] {
        self.allCases.reversed()
    }
}

struct PdfCompressionPickerView_Previews: PreviewProvider {
    static var previews: some View {
        PdfCompressionPickerView(compressionOption: .constant(.noCompression))
    }
}



================================================
FILE: pdfexpert/Views/Pdf/PdfEditView.swift
================================================
//
//  PdfEditView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 11/04/23.
//

import SwiftUI
import Factory
import PhotosUI

struct PdfEditView: View {
    
    fileprivate static let cellSide: CGFloat = 80.0
    fileprivate static let selectedCellBorderWidth: CGFloat = 4.0
    
    @StateObject var viewModel: PdfEditViewModel
    @State private var showingImageInputPicker = false
    @State private var showingDeleteConfermation = false
    
    @State private var draggedImage: UIImage? = nil
    
    var body: some View {
        VStack(spacing: 16) {
            VStack(spacing: 16) {
                VStack(spacing: 0) {
                    Spacer()
                    self.pdfView
                    Spacer()
                }
                self.pageListView
                self.editButtonsView
            }
            .padding([.leading, .trailing], 16)
            self.editOptionsView
        }
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(self.$viewModel.pdfFilename)
        .ignoresSafeArea(.keyboard)
        .background(ColorPalette.primaryBG)
        .toolbar {
            ToolbarItemGroup(placement: .navigationBarTrailing) {
                if self.viewModel.pageImages.count > 0 {
                    Button(action: { self.showingDeleteConfermation = true }) {
                        Image(systemName: "trash")
                            .foregroundColor(ColorPalette.primaryText)
                    }
                }
                Button(action: { self.viewModel.editOptionListShow = true }) {
                    Image(systemName: "ellipsis.circle")
                        .foregroundColor(ColorPalette.primaryText)
                }
            }
        }

        .onAppear(perform:self.viewModel.onAppear)
        // File picker
        .filePicker(isPresented: self.$viewModel.filePickerShow,
                    fileTypes: K.Misc.ImportFileTypesForAddPage,
                    onPickedFiles: {
            // Callback is called on modal dismiss, thus we can assign and convert in a row
            self.viewModel.urlToFileToConvert = $0.first
            self.viewModel.convert()
        })
        // Camera for image capture
        .fullScreenCover(isPresented: self.$viewModel.cameraShow) {
            CameraView(model: Container.shared.cameraViewModel({ uiImage in
                self.viewModel.cameraShow = false
                self.viewModel.imageToConvert = uiImage
            })).onDisappear { self.viewModel.convert() }
        }
        // Photo gallery picker
        .photosPicker(isPresented: self.$viewModel.imagePickerShow,
                      selection: self.$viewModel.imageSelection,
                      matching: .images)
        // Scanner
        .fullScreenCover(isPresented: self.$viewModel.scannerShow) {
            ScannerView(onScannerResult: {
                self.viewModel.scannerShow = false
                self.viewModel.scannerResult = $0
            }).onDisappear { self.viewModel.convert() }
        }
        .fullScreenCover(isPresented: self.$viewModel.signatureAddViewShow) {
            let inputParameter = PdfSignatureViewModel
                .InputParameter(pdf: self.viewModel.pdf,
                                currentPageIndex: self.viewModel.pdfCurrentPageIndex,
                                onConfirm: { self.viewModel.updatePdf(pdf: $0) })
            PdfSignatureView(viewModel: Container.shared.pdfSignatureViewModel(inputParameter))
        }
        .fullScreenCover(isPresented: self.$viewModel.fillFormViewShow) {
            let inputParameter = PdfFillFormViewModel
                .InputParameter(pdf: self.viewModel.pdf,
                                currentPageIndex: self.viewModel.pdfCurrentPageIndex,
                                onConfirm: { self.viewModel.updatePdf(pdf: $0) })
            PdfFillFormView(viewModel: Container.shared.pdfFillFormViewModel(inputParameter))
        }
        .fullScreenCover(isPresented: self.$viewModel.fillWidgetViewShow) {
            let inputParameter = PdfFillWidgetViewModel
                .InputParameter(pdf: self.viewModel.pdf,
                                currentPageIndex: self.viewModel.pdfCurrentPageIndex,
                                onConfirm: { self.viewModel.updatePdf(pdf: $0) })
            PdfFillWidgetView(viewModel: Container.shared.pdfFillWidgetViewModel(inputParameter))
        }
        .fullScreenCover(isPresented: self.$viewModel.compressionShow) {
            PdfCompressionPickerView(compressionOption: self.$viewModel.compression)
        }
        .asyncView(asyncOperation: self.$viewModel.asyncPdf,
                   loadingView: { AnimationType.pdf.view })
        .asyncView(asyncOperation: self.$viewModel.asyncImageLoading,
                   loadingView: { AnimationType.pdf.view })
        .alertCameraPermission(isPresented: self.$viewModel.cameraPermissionDeniedShow)
        .alert("Info", isPresented: self.$viewModel.missingWidgetWarningShow, actions: {
            Button("Ok", role: .cancel, action: {})
        }, message: {
            Text("Your pdf has no  fields that you can fill in.")
        })
        .showError(self.$viewModel.pdfSaveError)
        .formSheet(isPresented: self.$viewModel.editOptionListShow,
                   size: CGSize(width: 400.0, height: 250.0)) {
            self.editListView
        }
        .saveSuccessfullAlert(show: self.$viewModel.saveSuccessfulAlertShow,
                             goToArchiveCallback: { self.viewModel.goToArchive() },
                             sharePdfCallback: { self.viewModel.share() })
        .removePasswordView(show: self.$viewModel.removePasswordAlertShow,
                            removePasswordCallback: self.viewModel.removePassword)
        .addPasswordView(show: self.$viewModel.passwordTextFieldShow,
                         addPasswordCallback: { self.viewModel.setPassword($0) })
        .showShareView(coordinator: self.viewModel.pdfShareCoordinator)
        .showUnlockView(viewModel: self.viewModel.pdfUnlockViewModel)
        .showSplitView(viewModel: self.viewModel.pdfSplitViewModel)
        .splitSuccessfulAlert(show: self.$viewModel.splitSuccessAlertShow,
                              goToArchiveCallback: { self.viewModel.goToArchive() })
    }
    
    @ViewBuilder var pdfView: some View {
        if self.viewModel.pageImages.count > 0 {
            TabView(selection: self.$viewModel.pdfCurrentPageIndex) {
                ForEach(Array(self.viewModel.pageImages.enumerated()), id:\.offset) { (pageIndex, pageImage) in
                    ZStack {
                        Image(uiImage: pageImage)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                    }
                }
            }
            .tabViewStyle(.page(indexDisplayMode: .never))
        } else {
            self.emptyView
        }
    }
    
    var emptyView: some View {
        VStack(spacing: 16) {
            Spacer()
            Image("archive_empty")
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(height: 80)
            Text("You have no pages")
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity, alignment: .center)
                .multilineTextAlignment(.center)
            self.getDefaultButton(text: "Add a new page") {
                self.showingImageInputPicker = true
            }
            Spacer()
        }
    }
    
    var editButtonsView: some View {
        HStack {
            self.getDefaultButton(text: "Save PDF") {
                self.viewModel.save()
            }
            Button(action: { self.viewModel.share() }) {
                Image(systemName: "square.and.arrow.up")
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .font(.system(size: 16).bold())
                    .foregroundColor(ColorPalette.primaryText)
                    .contentShape(Capsule())
            }
            .frame(width: 64, height: 48)
            .background(self.defaultGradientBackground)
            .cornerRadius(10)
        }
    }
    
    var pageListView: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            LazyHStack {
                ForEach(Array(self.viewModel.pdfThumbnails.enumerated()), id: \.offset) { index, image in
                    Button(action: {
                        self.viewModel.pdfCurrentPageIndex = index
                    }) {
                        self.getThumbnailCell(image: image)
                            .applyCellStyle(highlight: index == self.viewModel.pdfCurrentPageIndex)
                    }
                    .actionDialog(
                        Text("Action"),
                        isPresented: self.$showingDeleteConfermation,
                        titleVisibility: .visible
                    ) {
                        Button("Delete this page", role: .destructive) {
                            self.showingDeleteConfermation = false
                            withAnimation {
                                self.viewModel.deleteCurrentPage()
                            }
                        }
                    }
                }
            }
            .padding([.trailing, .leading], Self.selectedCellBorderWidth)
        }
        .frame(height: Self.cellSide + Self.selectedCellBorderWidth)
    }
    
    var editOptionsView: some View {
        HStack {
            self.addPageButton.frame(maxWidth: .infinity)
            self.showAddSignatureButton.frame(maxWidth: .infinity)
            self.showFillFormButton.frame(maxWidth: .infinity)
            self.showFillWidgetButton.frame(maxWidth: .infinity)
        }
        .padding([.trailing, .leading], 16)
        .frame(height: 100)
        .frame(maxWidth: .infinity)
        .background(ColorPalette.secondaryBG)
    }
    
    var addPageButton: some View {
        Button(action: {
            self.showingImageInputPicker = true
        }) {
            self.getEditOptionView(text: "Add page", imageName: "edit_add_file")
        }
        .actionDialog(
            Text("Choose your source"),
            isPresented: self.$showingImageInputPicker,
            titleVisibility: .visible
        ) {
            Button("Photo Gallery") {
                self.viewModel.openGallery()
            }
            Button("Camera") {
                self.viewModel.openCamera()
            }
            Button("File") {
                self.viewModel.openFilePicker()
            }
            Button("Scan") {
                self.viewModel.openScanner()
            }
            Button("Cancel", role: .cancel) {}
        }
    }
    
    func getThumbnailCell(image: UIImage) -> some View {
        return AnyView(
            Image(uiImage: image)
                .resizable()
                .aspectRatio(contentMode: .fill)
                .onDrag {
                    self.draggedImage = image
                    return NSItemProvider()
                }
                .onDrop(of: [.image],
                        delegate: PdfEditDropViewDelegate(destinationItem: image,
                                                          draggedItem: self.$draggedImage,
                                                          viewModel: self.viewModel))
        )
    }
    
    var showFillWidgetButton: some View {
        Button(action: { self.viewModel.showFillWidget() }) {
            self.getEditOptionView(text: "Fill Form", imageName: "edit_fill_form")
        }
    }
    
    var showFillFormButton: some View {
        Button(action: { self.viewModel.showFillForm() }) {
            self.getEditOptionView(text: "Add text", imageName: "edit_add_text")
        }
    }
    
    var showAddSignatureButton: some View {
        Button(action: { self.viewModel.showAddSignature() }) {
            self.getEditOptionView(text: "Signature", imageName: "edit_signature")
        }
    }
    
    func getEditOptionView(text: String, imageName: String) -> some View {
        return VStack(spacing: 6) {
            Spacer()
            Image(imageName)
                .resizable()
                .aspectRatio(contentMode: .fill)
                .frame(width: 32, height: 32)
                .foregroundColor(ColorPalette.primaryText)
            Text(text)
                .font(forCategory: .callout)
                .foregroundColor(ColorPalette.primaryText)
            Spacer()
        }
    }
    
    @ViewBuilder var editListView: some View {
        OptionListView(title: "Edit pdf", items: EditAction.allCases.map { editAction in
            let callback = { self.viewModel.handleEditAction(editAction) }
            switch editAction {
            case .password:
                if self.viewModel.pdf.password != nil {
                    return OptionItem(title: "Unlock",
                                      imageName: "edit_option_password_unlock",
                                      callBack: callback)
                } else {
                    return OptionItem(title: "Protect",
                                      imageName: "edit_option_password_lock",
                                      callBack: callback)
                }
            case .compression:
                return OptionItem(title: "Compress",
                                  imageName: "edit_option_compress",
                                  callBack: callback)
            case .split:
                return OptionItem(title: "Split",
                                  imageName: "edit_option_split",
                                  callBack: callback)
            }
        })
    }
}

fileprivate extension View {
    func applyCellStyle(highlight: Bool) -> some View {
        self
            .frame(width: PdfEditView.cellSide, height: PdfEditView.cellSide)
            .cornerRadius(16)
            .if(highlight) { view in
                view.overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(ColorPalette.buttonGradientStart,
                                lineWidth: PdfEditView.selectedCellBorderWidth)
                )
            }
    }
    
    @ViewBuilder func saveSuccessfullAlert(show: Binding<Bool>,
                                          goToArchiveCallback: @escaping () -> (),
                                          sharePdfCallback: @escaping () -> ()) -> some View {
        self.alert("PDF saved!", isPresented: show, actions: {
            Button("Go to files", action: goToArchiveCallback)
            Button("Share pdf", action: sharePdfCallback)
            Button("Continue edit", action: {})
        }, message: {
            Text("Your pdf has been successfully saved")
        })
    }
    
    func splitSuccessfulAlert(show: Binding<Bool>,
                              goToArchiveCallback: @escaping () -> ()) -> some View {
        self.alert("PDF split!", isPresented: show, actions: {
            Button("Go to files", action: goToArchiveCallback)
            Button("Continue edit", action: {})
        }, message: {
            Text("Your pdf has been successfully split and saved!")
        })
    }
}

fileprivate extension MarginsOption {
    
    var iconImage: some View {
        let insets: EdgeInsets = {
            switch self {
            case .noMargins: return EdgeInsets(top: 4, leading: 3, bottom: 4, trailing: 3)
            case .mediumMargins: return EdgeInsets(top: 8, leading: 6, bottom: 8, trailing: 6)
            case .heavyMargins: return EdgeInsets(top: 12, leading: 9, bottom: 12, trailing: 9)
            }
        }()
        return ColorPalette.fourthText
            .cornerRadius(4)
            .padding(insets)
            .overlay(RoundedRectangle(cornerRadius: 5).stroke(ColorPalette.primaryText, lineWidth: 2))
    }
}

struct PdfEditView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            if let pdf = K.Test.DebugPdf {
                let inputParameter = PdfEditViewModel.InputParameter(pdf: pdf,
                                                                     startAction: nil,
                                                                     shouldShowCloseWarning: .constant(true))
                AnyView(PdfEditView(viewModel: Container.shared.pdfEditViewModel(inputParameter)))
            } else {
                AnyView(Spacer())
            }
        }
    }
}

fileprivate struct PdfEditDropViewDelegate: DropDelegate {
    
    let destinationItem: UIImage
    @Binding var draggedItem: UIImage?
    var viewModel: PdfEditViewModel
    
    func dropUpdated(info: DropInfo) -> DropProposal? {
        return DropProposal(operation: .move)
    }
    
    func performDrop(info: DropInfo) -> Bool {
        self.draggedItem = nil
        return true
    }
    
    func dropEntered(info: DropInfo) {
        // Swap Items
        if let draggedItem {
            let fromIndex = self.viewModel.pdfThumbnails.firstIndex(of: draggedItem)
            if let fromIndex {
                let toIndex = self.viewModel.pdfThumbnails.firstIndex(of: self.destinationItem)
                if let toIndex, fromIndex != toIndex {
                    self.viewModel.handlePageReordering(fromIndex: fromIndex, toIndex: toIndex)
                }
            }
        }
    }
}



================================================
FILE: pdfexpert/Views/Pdf/PdfFillFormView.swift
================================================
//
//  PdfFillFormView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 26/05/23.
//

import SwiftUI
import Factory
import PDFKit

struct PdfFillFormView: View {
    
    @StateObject var viewModel: PdfFillFormViewModel
    @Environment(\.dismiss) var dismiss
    @State var showCancelWarningDialog: Bool = false
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                VStack(spacing: 0) {
                    Spacer()
                    GeometryReader { parentGeometryReader in
                        TabView(selection: self.$viewModel.pageIndex) {
                            ForEach(Array(self.viewModel.pageImages.enumerated()), id:\.offset) { (pageIndex, page) in
                                GeometryReader { geometryReader in
                                    HStack {
                                        Spacer()
                                        ZStack {
                                            Image(uiImage: page)
                                                .resizable()
                                                .aspectRatio(contentMode: .fit)
                                                .ignoresSafeArea(.keyboard)
                                            self.getAnnotationViews(forPageIndex: pageIndex)
                                                .ignoresSafeArea(.keyboard)
                                        }
                                        Spacer()
                                    }
                                    .onTapGesture {
                                        self.viewModel.tapOnPdfView(positionInView: $0,
                                                                    pageIndex: pageIndex,
                                                                    pageViewSize: geometryReader.size)
                                    }
                                    .position(x: geometryReader.size.width / 2, y: geometryReader.size.height / 2)
                                }
                            }
                        }
                        .tabViewStyle(.page(indexDisplayMode: .never))
                        .position(x: parentGeometryReader.size.width / 2, y: parentGeometryReader.size.height / 2)
                        .frame(width: parentGeometryReader.size.width,
                               height: parentGeometryReader.size.height)
                    }
                    .background(ColorPalette.primaryBG)
                    .navigationBarTitleDisplayMode(.inline)
                    .navigationTitle("Tap where you wish to add text")
                    Spacer()
                }
                self.pageCounter(currentPageIndex: self.viewModel.pageIndex,
                                 totalPages: self.viewModel.pageImages.count)
                Spacer().frame(height: 50)
                self.getDefaultButton(text: "Finish", onButtonPressed: {
                    self.viewModel.onConfirmButtonPressed()
                    self.dismiss()
                })
                Spacer().frame(height: 60)
            }
            .padding([.leading, .trailing], 16)
            .ignoresSafeArea(.keyboard)
            .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
                if self.viewModel.unsavedChangesExist {
                    self.showCancelWarningDialog = true
                } else {
                    self.dismiss()
                }
            })
            .toolbar(content: {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { self.viewModel.onSuggestedFieldsButtonPressed() }) {
                        Image("suggested_fields")
                            .foregroundColor(ColorPalette.primaryText)
                    }
                }
            })
            .alert("Are you sure?",
                   isPresented: self.$showCancelWarningDialog,
                   actions: {
                Button("No", role: .cancel, action: {})
                Button("Yes", role: .destructive, action: {
                    self.dismiss()
                })
            }, message: { Text("If you quit, you will lose the changes you have just made.") })
            .background(ColorPalette.primaryBG)
        }
        .onAppear(perform: self.viewModel.onAppear)
        .fullScreenCover(isPresented: self.$viewModel.showSuggestedFields) {
            SuggestedFieldsFormView()
        }
    }
    
    @ViewBuilder func getAnnotationViews(forPageIndex pageIndex: Int) -> some View {
        ForEach(self.viewModel.getAnnotations(forPageIndex: pageIndex), id:\.self) { pageAnnotation in
            self.getView(forAnnotation: pageAnnotation)
        }
        if self.viewModel.editedPageIndex == pageIndex {
            TextResizableView(data: self.$viewModel.currentTextResizableViewData,
                              fontName: K.Misc.DefaultAnnotationTextFontName,
                              fontColor: .black,
                              color: .orange,
                              borderWidth: 4,
                              minSize: CGSize(width: 5, height: 5),
                              handleSize: 25,
                              handleTapSize: 50,
                              suggestedWords: self.viewModel.suggestedFields?.fields ?? [],
                              deleteCallback: self.viewModel.onDeleteAnnotationPressed)
        }
    }
    
    @ViewBuilder func getView(forAnnotation annotation: PDFAnnotation) -> some View {
        if let page = annotation.page {
            GeometryReader { geometryReader in
                let annotationBounds = self.viewModel.convertRect(annotation.verticalCenteredTextBounds,
                                                                        viewSize: geometryReader.size,
                                                                        fromPage: page)
                let position = CGPoint(x: annotationBounds.origin.x + annotationBounds.size.width / 2,
                                       y: annotationBounds.origin.y + annotationBounds.size.height / 2)
                Text(annotation.contents ?? "")
                    .font(Font(UIFont.font(named: K.Misc.DefaultAnnotationTextFontName,
                                           fitting: annotation.contents ?? "",
                                           into: annotationBounds.size,
                                           with: [:],
                                           options: [])))
                    .foregroundColor(Color(annotation.fontColor ?? .black))
                    .frame(width: annotationBounds.width, height: annotationBounds.height)
                    .position(position)
            }
        }
    }
}

struct PdfFillFormView_Previews: PreviewProvider {
    static var previews: some View {
        if let pdf = K.Test.DebugPdf {
            let inputParameter = PdfFillFormViewModel.InputParameter(pdf: pdf,
                                                                     currentPageIndex: 0,
                                                                     onConfirm: { _ in })
            AnyView(PdfFillFormView(viewModel: Container.shared.pdfFillFormViewModel(inputParameter)))
        } else {
            AnyView(Spacer())
        }
    }
}



================================================
FILE: pdfexpert/Views/Pdf/PdfFillWidgetView.swift
================================================
//
//  PdfFillWidgetView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 22/06/23.
//

import SwiftUI
import Factory

struct PdfFillWidgetView: View {
    
    @StateObject var viewModel: PdfFillWidgetViewModel
    @Environment(\.dismiss) var dismiss
    @State var showCancelWarningDialog: Bool = false
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                VStack(spacing: 0) {
                    Spacer()
                    PdfKitViewBinder(
                        pdfView: self.$viewModel.pdfView,
                        singlePage: false,
                        pageMargins: UIEdgeInsets(top: 0, left: 0, bottom: 24, right: 0),
                        backgroundColor: UIColor(ColorPalette.primaryBG),
                        usePaginator: true
                    )
                    .padding([.leading, .trailing], 16)
                    .background(ColorPalette.primaryBG)
                    .navigationBarTitleDisplayMode(.inline)
                    .navigationTitle("Tap to fill in")
                    Spacer()
                }
                self.pageCounter(currentPageIndex: self.viewModel.pdfCurrentPageIndex,
                                 totalPages: self.viewModel.pdfDocument.pageCount)
                Spacer().frame(height: 50)
                self.getDefaultButton(text: "Finish", onButtonPressed: {
                    self.viewModel.onConfirmButtonPressed()
                    self.dismiss()
                })
                Spacer().frame(height: 60)
            }
            .ignoresSafeArea(.keyboard)
            .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
                if self.viewModel.unsavedChangesExist {
                    self.showCancelWarningDialog = true
                } else {
                    self.viewModel.onCancelButtonPressed()
                    self.dismiss()
                }
            })
            .alert("Are you sure?",
                   isPresented: self.$showCancelWarningDialog,
                   actions: {
                Button("No", role: .cancel, action: {})
                Button("Yes", role: .destructive, action: {
                    self.viewModel.onCancelButtonPressed()
                    self.dismiss()
                })
            }, message: { Text("If you quit, you will lose the changes you have just made.") })
        }
        .onAppear(perform: self.viewModel.onAppear)
    }
}

struct PdfFillWidgetView_Previews: PreviewProvider {
    static var previews: some View {
        if let pdf = K.Test.DebugPdf {
            let inputParameter = PdfFillWidgetViewModel.InputParameter(pdf: pdf,
                                                                       currentPageIndex: 0,
                                                                       onConfirm: { _ in })
            AnyView(PdfFillWidgetView(viewModel: Container.shared.pdfFillWidgetViewModel(inputParameter)))
        } else {
            AnyView(Spacer())
        }
    }
}



================================================
FILE: pdfexpert/Views/Pdf/PdfFlowView.swift
================================================
//
//  PdfFlowView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 11/04/23.
//

import SwiftUI
import Factory

struct PdfFlowView: View {
    
    @InjectedObject(\.pdfCoordinator) var coordinator
    @Environment(\.dismiss) var dismiss
    let pdf: Pdf
    let startAction: PdfEditStartAction?
    
    @State var shouldShowCloseWarning: Bool
    @State var showCloseWarningDialog: Bool = false
    
    var body: some View {
        self.content
    }
    
    @ViewBuilder var content: some View {
        switch self.coordinator.rootView {
        case .edit:
            NavigationStack {
                let inputParameter = PdfEditViewModel.InputParameter(pdf: self.pdf,
                                                                     startAction: self.startAction,
                                                                     shouldShowCloseWarning: self.$shouldShowCloseWarning)
                PdfEditView(viewModel: Container.shared.pdfEditViewModel(inputParameter))
                    .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
                        if self.shouldShowCloseWarning {
                            self.showCloseWarningDialog = true
                        } else {
                            self.dismiss()
                        }
                    })
                    .alert("Are you sure?",
                           isPresented: self.$showCloseWarningDialog,
                           actions: {
                        Button("No", role: .cancel, action: {})
                        Button("Yes", role: .destructive, action: {
                            self.dismiss()
                        })
                    }, message: { Text("If you quit, you will lose the changes to your current file.") })
            }
            .reviewFlowView(flow: self.coordinator.reviewFlow)
        }
    }
}

struct PdfView_Previews: PreviewProvider {
    static var previews: some View {
        if let pdf = K.Test.DebugPdf {
            AnyView(PdfFlowView(pdf: pdf, startAction: nil, shouldShowCloseWarning: true))
        } else {
            AnyView(Color(.clear))
        }
    }
}



================================================
FILE: pdfexpert/Views/Pdf/PdfSignatureCanvasView.swift
================================================
//
//  PdfSignatureCanvasView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 19/05/23.
//

import SwiftUI
import PencilKit
import Factory

struct PdfSignatureCanvasView: View {
    
    @StateObject var viewModel: PdfSignatureCanvasViewModel
    
    var body: some View {
        VStack(spacing: 0) {
            Text("Add Signature")
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.secondaryBG)
                .frame(maxWidth: .infinity)
            Spacer().frame(height: 10)
            self.tabsView
            Spacer().frame(height: 10)
            Spacer()
            self.contentView.frame(height: 120)
            Spacer().frame(height: 40)
            self.saveButton
            Spacer().frame(height: 20)
            self.getDefaultButton(text: "Confirm",
                                  enabled: self.viewModel.confirmAllowed,
                                  onButtonPressed: { self.viewModel.onConfirmButtonPressed() })
        }
        .padding(16)
        .background(ColorPalette.primaryText)
        .galleryImageProviderView(flow: self.viewModel.galleryImageProviderFlow)
        .cameraImageProviderView(flow: self.viewModel.cameraImageProviderFlow)
        .imageCropView(flow: self.viewModel.imageCropFlow)
    }
    
    var tabsView: some View {
        HStack(spacing: 16) {
            ForEach(SignatureSource.allCases, id:\.self) { source in
                Button(action: { self.viewModel.source = source }) {
                    Label(title: {
                        Text(source.text)
                            .lineLimit(1)
                            .font(forCategory: .caption1)
                            .foregroundColor(
                                self.viewModel.source == source
                                ? ColorPalette.secondaryText
                                : ColorPalette.primaryBG
                            )
                    }, icon: {
                        source.icon
                            .resizable()
                            .scaledToFit()
                            .frame(width: 16, height: 16)
                            .foregroundColor(
                                self.viewModel.source == source
                                ? ColorPalette.secondaryText
                                : ColorPalette.primaryBG
                            )
                    })
                }
            }
        }
    }
    
    @ViewBuilder var contentView: some View {
        switch self.viewModel.source {
        case .drawing: self.drawContentView
        case .image: self.imageContentView
        case .camera: self.cameraContentView
        }
    }
    
    var drawContentView: some View {
        VStack(spacing: 0) {
            HStack(spacing: 6) {
                Spacer().frame(width: 24)
                VStack(spacing: 0) {
                    PencilKitView(canvasView: self.$viewModel.canvasView,
                                  backgroundColor: ColorPalette.primaryText,
                                  inkColor: .black,
                                  onSaved: {})
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    ColorPalette.thirdText.frame(height: 1)
                }
                Button(action: { self.viewModel.onClearButtonPressed() }) {
                    Image(systemName: "xmark.circle.fill")
                        .resizable()
                        .foregroundColor(ColorPalette.thirdText)
                        .frame(width: 24, height: 24)
                        .scaledToFit()
                }
            }
            Spacer().frame(height: 6)
            Text("Sign in here")
                .font(forCategory: .body2)
                .foregroundColor(ColorPalette.thirdText)
        }
    }
    
    var imageContentView: some View {
        VStack(spacing: 0) {
            Button(action: { self.viewModel.onSelectImageButtonPressed() }) {
                if let uiImage = self.viewModel.signatureGalleryImage {
                    Image(uiImage: uiImage)
                        .resizable()
                        .scaledToFit()
                } else {
                    Color.clear
                }
            }
            .frame(maxHeight: .infinity)
            Spacer().frame(height: 6)
            Text("Select Image")
                .font(forCategory: .body2)
                .foregroundColor(ColorPalette.thirdText)
        }
    }
    
    var cameraContentView: some View {
        VStack(spacing: 0) {
            Button(action: { self.viewModel.onTakePictureButtonPressed() }) {
                if let uiImage = self.viewModel.signatureCameraImage {
                    Image(uiImage: uiImage)
                        .resizable()
                        .scaledToFit()
                } else {
                    Color.clear
                }
            }
            .frame(maxHeight: .infinity)
            Spacer().frame(height: 6)
            Text("Take a Picture")
                .font(forCategory: .body2)
                .foregroundColor(ColorPalette.thirdText)
        }
    }
    
    var saveButton: some View {
        Button(action: { self.viewModel.toggleShouldSave() }) {
            Label {
                Text("Memorize signature")
                    .padding(.trailing, 6)
            } icon: {
                Image(
                    systemName: self.viewModel.shouldSaveSignature
                    ? "checkmark.circle.fill"
                    : "checkmark.circle"
                )
                .resizable()
                .scaledToFit()
                .padding([.top, .bottom, .leading], 6)
            }
            .font(forCategory: .callout)
            .foregroundColor(
                self.viewModel.shouldSaveSignature
                ? ColorPalette.buttonGradientStart
                : ColorPalette.thirdText
            )
            .frame(height: 40)
        }
        .frame(height: 40)
        .overlay(Capsule().stroke(
            self.viewModel.shouldSaveSignature
            ? ColorPalette.buttonGradientStart
            : ColorPalette.thirdText,
            lineWidth: 1
        ))
    }
}

fileprivate extension SignatureSource {
    var text: String {
        switch self {
        case .drawing: return "Drawing"
        case .image: return "From Image"
        case .camera: return "From Camera"
        }
    }
    
    var icon: Image {
        switch self {
        case .drawing: return Image("sign_drawing")
        case .image: return Image(systemName: "photo")
        case .camera: return Image(systemName: "camera")
        }
    }
}

struct PdfSignatureCanvasView_Previews: PreviewProvider {
    
    static let drawing = PKDrawing()
    
    static var previews: some View {
        PdfSignatureCanvasView(viewModel: Container.shared
            .pdfSignatureCanvasViewModel({ _ in print("Confirm button pressed") }))
    }
}



================================================
FILE: pdfexpert/Views/Pdf/PdfSignaturePickerView.swift
================================================
//
//  PdfSignaturePickerView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 28/08/23.
//

import SwiftUI
import Factory

struct PdfSignaturePickerView: View {
    
    @StateObject var viewModel: PdfSignaturePickerViewModel
    
    @State private var editMode: EditMode = .inactive
    
    var body: some View {
        ZStack {
            VStack(spacing: 0) {
                Spacer().frame(height: 16)
                Text("Your Signatures")
                    .font(forCategory: .body1)
                    .foregroundColor(ColorPalette.primaryBG)
                Spacer().frame(height: 16)
                self.content
                Spacer().frame(height: 16)
                self.addNewButton
            }
            if self.viewModel.isLoading {
                self.loadingView
            }
            self.getCloseButton(color: ColorPalette.primaryBG,
                                onClose: { self.viewModel.cancel() })
            self.getEditButton(color: ColorPalette.buttonGradientStart,
                               font: FontCategory.body1.font,
                               editMode: self.$editMode)
        }
        .background(ColorPalette.primaryText)
        .onAppear {
            self.viewModel.onAppear()
        }
    }
    
    @ViewBuilder var content: some View {
        switch self.viewModel.asyncItems.status {
        case .empty: Spacer()
        case .loading: self.loadingView
        case .data(let items): self.getItemList(items: items)
        case .error: self.errorView
        }
    }
    
    @ViewBuilder func getItemList(items: [Signature]) -> some View {
        if items.count > 0 {
            List {
                ForEach(items) { item in
                    Button(action: {
                        if self.editMode == .inactive {
                            self.viewModel.pick(item: item)
                        }
                    }) {
                        HStack(spacing: 0) {
                            Spacer()
                            Image(uiImage: item.image)
                                .resizable()
                                .scaledToFit()
                                .padding([.leading, .trailing], 16)
                            Spacer()
                        }
                    }
                    .padding([.top, .bottom], 16)
                    .frame(height: 100)
                    .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
                    .listRowBackground(Color(.clear))
                }
                .onDelete { indexSet in
                    self.viewModel.delete(indexSet: indexSet)
                }   
            }
            // Needed to use a custom background color in case of List with inset list style
            .scrollContentBackground(.hidden)
            .listStyle(.inset)
            .environment(\.editMode, self.$editMode)
        } else {
            self.emptyView
        }
    }
    
    var emptyView: some View {
        VStack(spacing: 16) {
            Spacer()
            Text("No signature added")
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.thirdText)
                .frame(maxWidth: .infinity, alignment: .center)
                .multilineTextAlignment(.center)
            Spacer()
        }
        .padding([.leading, .trailing], 16)
    }
    
    var loadingView: some View {
        AnimationType.dots.view.background(Color(.black).opacity(0.3))
    }
    
    var errorView: some View {
        VStack(spacing: 16) {
            Spacer()
            Image("subscription_error")
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(height: 80)
            Text("Oh Know!")
                .font(forCategory: .largeTitle)
                .foregroundColor(ColorPalette.primaryBG)
                .frame(maxWidth: .infinity, alignment: .center)
            Text("Something went wrong,\n Please try again.")
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.primaryBG)
                .multilineTextAlignment(.center)
                .frame(maxWidth: .infinity, alignment: .center)
            self.getDefaultButton(text: "Retry",
                                  onButtonPressed: self.viewModel.refresh)
            Spacer()
        }
        .padding([.leading, .trailing], 16)
    }
    
    var addNewButton: some View {
        HStack(spacing: 0) {
            Spacer()
            Button(action: { self.viewModel.createNewSignature() }) {
                Label("Add new signature", systemImage: "plus.circle.fill")
                    .font(forCategory: .body1)
                    .foregroundColor(ColorPalette.buttonGradientStart)
            }
        }
        .frame(maxWidth: .infinity)
        .frame(height: 48)
        .padding(.trailing, 16)
    }
}

struct PdfSignaturePickerView_Previews: PreviewProvider {
    
    static let params = PdfSignaturePickerViewModel.Params(
        confirmationCallback: { _ in print("Signature confirmed!") },
        cancelCallback: { print("Signature selection cancelled") },
        createNewSignatureCallback: { print("Create new signature!") }
    )
    
    static var previews: some View {
        PdfSignaturePickerView(viewModel: Container.shared.pdfSignaturePickerViewModel(Self.params))
    }
}



================================================
FILE: pdfexpert/Views/Pdf/PdfSignatureProviderFlowView.swift
================================================
//
//  PdfSignatureProviderFlowView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 29/08/23.
//

import SwiftUI
import Factory

struct PdfSignatureProviderFlowView: ViewModifier {
    
    @ObservedObject var flow: PdfSignaturePrioviderFlow

    func body(content: Content) -> some View {
        content
            .formSheet(isPresented: self.$flow.showSignatureCreation,
                       size: CGSize(width: 400, height: 385)) {
                PdfSignatureCanvasView(viewModel: Container.shared.pdfSignatureCanvasViewModel({
                    self.flow.onSignatureSelected(signature: $0)
                }))
                .background(ColorPalette.primaryText)
            }.formSheet(isPresented: self.$flow.showSignaturePicker,
                        size: CGSize(width: 400, height: 700)) {
                let params = PdfSignaturePickerViewModel.Params(confirmationCallback: {
                    self.flow.onSignatureSelected(signature: $0)
                }, cancelCallback: {
                    self.flow.showSignaturePicker = false
                }, createNewSignatureCallback: {
                    self.flow.onCreateNewSignature()
                })
                PdfSignaturePickerView(viewModel: Container.shared.pdfSignaturePickerViewModel(params))
                    .background(ColorPalette.primaryText)
            }
    }
}

extension View {
    func pdfSignatureProviderView(flow: PdfSignaturePrioviderFlow) -> some View {
        self.modifier(PdfSignatureProviderFlowView(flow: flow))
    }
}



================================================
FILE: pdfexpert/Views/Pdf/PdfSignatureView.swift
================================================
//
//  PdfSignatureView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 10/05/23.
//

import SwiftUI
import Factory
import PDFKit

struct PdfSignatureView: View {
    
    @StateObject var viewModel: PdfSignatureViewModel
    @Environment(\.dismiss) var dismiss
    @State var showCancelWarningDialog: Bool = false
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                VStack(spacing: 0) {
                    Spacer()
                    self.pdfView
                    Spacer()
                }
                self.pageCounter(currentPageIndex: self.viewModel.pageIndex,
                                 totalPages: self.viewModel.pageImages.count)
                Spacer().frame(height: 50)
                self.getDefaultButton(text: "Finish", onButtonPressed: {
                    self.viewModel.onConfirmButtonPressed()
                    self.dismiss()
                })
                Spacer().frame(height: 60)
            }
            .background(ColorPalette.primaryBG)
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle("Tap where you wish to sign")
            .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
                if self.viewModel.unsavedChangesExist {
                    self.showCancelWarningDialog = true
                } else {
                    self.dismiss()
                }
            })
            .pdfSignatureProviderView(flow: self.viewModel.pdfSignaturePrioviderFlow)
            .alert("Are you sure?",
                    isPresented: self.$showCancelWarningDialog,
                    actions: {
                Button("No", role: .cancel, action: {})
                Button("Yes", role: .destructive, action: {
                    self.dismiss()
                })
            }, message: { Text("If you quit, you will lose the signatures you've just added.") })
        }
        .onAppear(perform: self.viewModel.onAppear)
    }
    
    var pdfView: some View {
        VStack(spacing: 0) {
            Spacer()
            GeometryReader { parentGeometryReader in
                TabView(selection: self.$viewModel.pageIndex) {
                    ForEach(Array(self.viewModel.pageImages.enumerated()), id:\.offset) { (pageIndex, page) in
                        GeometryReader { geometryReader in
                            HStack {
                                Spacer()
                                ZStack {
                                    Image(uiImage: page)
                                        .resizable()
                                        .aspectRatio(contentMode: .fit)
                                        .ignoresSafeArea(.keyboard)
                                    self.getAnnotationViews(forPageIndex: pageIndex)
                                        .ignoresSafeArea(.keyboard)
                                }
                                Spacer()
                            }
                            .onTapGesture {
                                self.viewModel.tapOnPdfView(positionInView: $0,
                                                            pageIndex: pageIndex,
                                                            pageViewSize: geometryReader.size)
                            }
                            .position(x: geometryReader.size.width / 2, y: geometryReader.size.height / 2)
                        }
                    }
                }
                .tabViewStyle(.page(indexDisplayMode: .never))
                .position(x: parentGeometryReader.size.width / 2, y: parentGeometryReader.size.height / 2)
                .frame(width: parentGeometryReader.size.width,
                       height: parentGeometryReader.size.height)
            }
            .background(ColorPalette.primaryBG)
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle("Tap where you wish to add text")
            Spacer()
        }
    }
    
    @ViewBuilder func getAnnotationViews(forPageIndex pageIndex: Int) -> some View {
        ForEach(self.viewModel.getAnnotations(forPageIndex: pageIndex), id:\.self) { pageAnnotation in
            self.getView(forAnnotation: pageAnnotation)
        }
        if self.viewModel.editedPageIndex == pageIndex, let signatureImage = self.viewModel.signatureImage {
            ImageResizableView(
                uiImage: signatureImage,
                imageRect: self.$viewModel.signatureRect,
                borderColor: ColorPalette.thirdText,
                borderWidth: 2,
                handleColor: ColorPalette.buttonGradientStart,
                handleSize: 10,
                handleTapSize: 50,
                keepAspectRatio: true
            )
            .contextMenu {
                Button(role: .destructive) {
                    self.viewModel.onDeleteAnnotationPressed()
                } label: {
                    Text("Delete")
                }
                Button {
                    self.viewModel.onReplaceAnnotationPressed()
                } label: {
                    Text("Replace")
                }
            }
        }
    }
    
    @ViewBuilder func getView(forAnnotation annotation: PDFAnnotation) -> some View {
        if let page = annotation.page {
            GeometryReader { geometryReader in
                let annotationBounds = self.viewModel.convertRect(annotation.bounds,
                                                                  viewSize: geometryReader.size,
                                                                  fromPage: page)
                let position = CGPoint(x: annotationBounds.origin.x + annotationBounds.size.width / 2,
                                       y: annotationBounds.origin.y + annotationBounds.size.height / 2)
                Image(uiImage: annotation.image)
                    .resizable()
                    .frame(width: annotationBounds.width, height: annotationBounds.height)
                    .position(position)
            }
        }
    }
}

struct PdfSignatureView_Previews: PreviewProvider {
    static var previews: some View {
        if let pdf = K.Test.DebugPdf {
            let inputParameter = PdfSignatureViewModel.InputParameter(pdf: pdf,
                                                                      currentPageIndex: 0,
                                                                      onConfirm: { _ in })
            AnyView(PdfSignatureView(viewModel: Container.shared.pdfSignatureViewModel(inputParameter)))
        } else {
            AnyView(Spacer())
        }
    }
}



================================================
FILE: pdfexpert/Views/Review/PreReviewPopupLowRateView.swift
================================================
//
//  PreReviewPopupLowRateView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/08/23.
//

import SwiftUI

typealias PreReviewLowRateSendFeedbackCallback = ((String) -> ())

struct PreReviewPopupLowRateView: View {
    
    @Binding var isPresenting: Bool
    let onSendFeedback: PreReviewLowRateSendFeedbackCallback
    
    @State var feedbackText: String
    @State var remainingCharactersText: String
    
    init(isPresenting: Binding<Bool>,
         initialFeedbackText: String = "",
         onSendFeedback: @escaping PreReviewLowRateSendFeedbackCallback) {
        self._isPresenting = isPresenting
        self.onSendFeedback = onSendFeedback
        self._feedbackText = .init(initialValue: initialFeedbackText)
        self._remainingCharactersText = .init(initialValue: Self.getRemainigCharactersText(forFeedbackText: initialFeedbackText))
    }
    
    var body: some View {
        ZStack {
            self.getCloseButton(
                color: ColorPalette.primaryText,
                leftSide: false,
                padding: 12
            ) {
                self.isPresenting = false
            }
            VStack(spacing: 0) {
                Spacer().frame(height: 12)
                Image("review_low_rate")
                    .resizable()
                    .scaledToFit()
                    .frame(height: 60)
                    .foregroundColor(ColorPalette.extra)
                Spacer().frame(height: 30)
                Text("Your opinion matter to us!")
                    .font(forCategory: .headline)
                    .foregroundColor(ColorPalette.primaryText)
                    .frame(maxWidth: .infinity)
                Spacer().frame(height: 8)
                Text("Would you like to share your feedback with us to improve the app?")
                    .font(forCategory: .body2)
                    .foregroundColor(ColorPalette.primaryText)
                    .multilineTextAlignment(.center)
                    .frame(maxWidth: .infinity)
                Spacer().frame(height: 18)
                VStack(spacing: 0) {
                    ZStack {
                        TextEditor(text: self.$feedbackText)
                            .font(forCategory: .caption1)
                            .foregroundColor(ColorPalette.primaryText)
                            .scrollContentBackground(.hidden)
                            .overlay(RoundedRectangle(cornerRadius: 10)
                                .stroke(ColorPalette.primaryBG, lineWidth: 1))
                            .onChange(of: self.feedbackText) { newValue in
                                let maxLength = K.Review.FeedbackMaxCharacters
                                if newValue.count > maxLength  {
                                    self.feedbackText = String(newValue.prefix(maxLength))
                                }
                                self.remainingCharactersText = Self.getRemainigCharactersText(forFeedbackText: self.feedbackText)
                            }
                        if self.feedbackText.isEmpty {
                            VStack {
                                Text("Write your feedback here")
                                    .font(forCategory: .caption1)
                                    .foregroundColor(ColorPalette.thirdText)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                Spacer()
                            }
                            .padding(.leading, 6)
                            .padding(.top, 8)
                        }
                        VStack(spacing: 0) {
                            Spacer()
                            Text(self.remainingCharactersText)
                                .font(forCategory: .caption2)
                                .foregroundColor(ColorPalette.thirdText)
                                .frame(maxWidth: .infinity, alignment: .trailing)
                                .padding(.trailing, 6)
                                .padding(.bottom, 8)
                        }
                    }
                    .frame(height: 100)
                }
                Spacer().frame(height: 20)
                self.getDefaultButton(text: "Send Feedback") {
                    self.onSendFeedback(self.feedbackText)
                }
            }
            .padding(16)
        }
        .frame(width: 340)
        .fixedSize(horizontal: false, vertical: true)
        .background(ColorPalette.secondaryBG)
        .cornerRadius(8)
    }
    
    private static func getRemainigCharactersText(forFeedbackText feedbackText: String) -> String {
        let maxLength = K.Review.FeedbackMaxCharacters
        let remainingCharacters = feedbackText.count
        return "\(remainingCharacters)/\(maxLength)"
    }
}

extension View {
    func preReviewLowRatePopup(
        isPresenting: Binding<Bool>,
        onSendFeedback: @escaping PreReviewLowRateSendFeedbackCallback
    ) -> some View {
        self.popup(isPresenting: isPresenting,
                   popupContent: { PreReviewPopupLowRateView(isPresenting: isPresenting,
                                                             onSendFeedback: onSendFeedback) })
    }
}

struct PreReviewPopupLowRateView_Previews: PreviewProvider {
    static var previews: some View {
        PreReviewPopupLowRateView(
            isPresenting: .constant(true),
            onSendFeedback: { result in print("Feedback: \(result)") }
        )
    }
}



================================================
FILE: pdfexpert/Views/Review/PreReviewPopupView.swift
================================================
//
//  PreReviewPopupView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/08/23.
//

import SwiftUI

typealias PreReviewResultCallback = ((Int) -> ())

struct PreReviewPopupView: View {
    
    @Binding var isPresenting: Bool
    let onConfirm: PreReviewResultCallback
    
    @State var selectedRate: Int? = nil
    
    var body: some View {
        ZStack {
            self.getCloseButton(
                color: ColorPalette.primaryText,
                leftSide: false,
                padding: 12
            ) {
                self.isPresenting = false
            }
            VStack(spacing: 0) {
                Spacer().frame(height: 40)
                Text("Do you like our app?")
                    .font(forCategory: .headline)
                    .foregroundColor(ColorPalette.primaryText)
                    .frame(maxWidth: .infinity)
                Spacer().frame(height: 8)
                Text("Give us a quick rating so we\nknow how you like it")
                    .font(forCategory: .body2)
                    .foregroundColor(ColorPalette.primaryText)
                    .multilineTextAlignment(.center)
                    .frame(maxWidth: .infinity)
                Spacer().frame(height: 30)
                HStack(spacing: 10) {
                    ForEach(1..<6) { rateValue in
                        self.getRateView(forRateValue: rateValue)
                    }
                }
                .frame(height: 32)
                Spacer().frame(height: 44)
            }
            .padding(16)
        }
        .frame(width: 340)
        .fixedSize(horizontal: false, vertical: true)
        .background(ColorPalette.secondaryBG)
        .cornerRadius(8)
    }
    
    private func getRateView(forRateValue rateValue: Int) -> some View {
        Button(action: { self.onRateTapped(withRateValue: rateValue) }) {
            Image(systemName: self.getRateSystemName(forRateValue: rateValue))
                .resizable()
                .frame(width: 32, height: 32)
                .foregroundColor(ColorPalette.extra)
        }
    }
    
    private func getRateSystemName(forRateValue rateValue: Int) -> String {
        if let selectedRate, selectedRate >= rateValue {
            return "star.fill"
        } else {
            return "star"
        }
    }
    
    private func onRateTapped(withRateValue rateValue: Int) {
        self.selectedRate = rateValue
        self.onConfirm(rateValue)
    }
}

extension View {
    func preReviewPopup(
        isPresenting: Binding<Bool>,
        onConfirm: @escaping PreReviewResultCallback
    ) -> some View {
        self.popup(isPresenting: isPresenting,
                   popupContent: { PreReviewPopupView(isPresenting: isPresenting,
                                                      onConfirm: onConfirm) })
    }
}

struct PreReviewPopupView_Previews: PreviewProvider {
    static var previews: some View {
        PreReviewPopupView(
            isPresenting: .constant(true),
            onConfirm: { result in print("Result: \(result)") }
        )
    }
}



================================================
FILE: pdfexpert/Views/Review/ReviewFlowView.swift
================================================
//
//  ReviewFlowView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/08/23.
//

import SwiftUI

struct ReviewFlowView: ViewModifier {
    
    @ObservedObject var flow: ReviewFlow
    
    @Environment(\.requestReview) var requestReview

    func body(content: Content) -> some View {
        content
            .preReviewPopup(isPresenting: self.$flow.showPreReviewView,
                            onConfirm: { preReviewRate in
                self.flow.onPreReviewRateSelected(preReviewRate: preReviewRate,
                                                  nativeReviewCallback: { self.requestReview() })
            })
            .preReviewLowRatePopup(isPresenting: self.$flow.showLowReviewView,
                                   onSendFeedback: { feedback in
                self.flow.onPreReviewLowRateFeedbackSent(feedback: feedback)
            })
    }
}

extension View {
    func reviewFlowView(flow: ReviewFlow) -> some View {
        self.modifier(ReviewFlowView(flow: flow))
    }
}



================================================
FILE: pdfexpert/Views/Scan/ScannerView.swift
================================================
//
//  ScannerView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/03/23.
//

import SwiftUI
import VisionKit

struct ScannerView: UIViewControllerRepresentable {
    
    let onScannerResult: ScannerResultCallback
    
    func makeUIViewController(context: Context) -> some UIViewController {
        let controller = VNDocumentCameraViewController()
        controller.delegate = context.coordinator
        return controller
    }
    
    func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) {}
    
    func makeCoordinator() -> ScannerViewCoordinator {
        ScannerViewCoordinator(onScannerResult: self.onScannerResult)
    }
}

struct ScannerResult {
    let scan: VNDocumentCameraScan
}

typealias ScannerResultCallback = (ScannerResult) -> ()

class ScannerViewCoordinator: NSObject, VNDocumentCameraViewControllerDelegate {
    
    let onScannerResult: ScannerResultCallback

    init(onScannerResult: @escaping ScannerResultCallback) {
        self.onScannerResult = onScannerResult
    }
    
    func documentCameraViewController(_ controller: VNDocumentCameraViewController,
                                      didFinishWith scan: VNDocumentCameraScan) {
        self.onScannerResult(ScannerResult(scan: scan))
    }
}

struct ScannerView_Previews: PreviewProvider {
    static var previews: some View {
        ScannerView(onScannerResult: { _ in })
    }
}



================================================
FILE: pdfexpert/Views/Settings/SettingsView.swift
================================================
//
//  SettingsView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 03/04/23.
//

import SwiftUI
import Factory

struct DisclamerItem: Hashable {
    let text: String
    let urlString: String
}

struct SettingsView: View {
    
    @Environment(\.dismiss) var dismiss
    
    private let disclamers = [
        DisclamerItem(text: "Privacy policy", urlString: K.Misc.PrivacyPolicyUrlString),
        DisclamerItem(text: "Terms and conditions", urlString: K.Misc.TermsAndConditionsUrlString)
    ]
    
    var body: some View {
        List(self.disclamers, id: \.self) { disclamer in
            Link(destination: URL(string: disclamer.urlString)!) {
                HStack {
                    Text(disclamer.text)
                        .font(forCategory: .body1)
                        .foregroundColor(ColorPalette.primaryText)
                    Spacer()
                    Self.getSystemChevron(color: ColorPalette.primaryText,
                                          directionRight: true)
                }
            }
            .listRowSeparator(.hidden)
            .listRowBackground(Color(.clear))
        }
        .padding(.top, 16)
        .listStyle(.plain)
        .background(ColorPalette.primaryBG)
        .onAppear() {
            Container.shared.analyticsManager().track(event: .reportScreen(.settings))
        }
    }
}

struct SettingsView_Previews: PreviewProvider {
    static var previews: some View {
        SettingsView()
    }
}



================================================
FILE: pdfexpert/Views/Subscription/SubscriptionErrorView.swift
================================================
//
//  SubscriptionErrorView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 03/04/23.
//

import SwiftUI

struct SubscriptionErrorView: View {
    
    var onButtonPressed: () -> ()
    
    var body: some View {
        VStack(spacing: 16) {
            Spacer()
            Image("subscription_error")
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(height: 80)
            Text("Oh Know!")
                .font(forCategory: .largeTitle)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity, alignment: .center)
            Text("Something went wrong,\n Please try again.")
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.primaryText)
                .multilineTextAlignment(.center)
                .frame(maxWidth: .infinity, alignment: .center)
            Spacer()
            self.getDefaultButton(text: "Retry",
                                  onButtonPressed: self.onButtonPressed)
        }
        .padding([.leading, .trailing], 16)
        .padding([.top, .bottom], 64)
    }
}

struct SubscriptionErrorView_Previews: PreviewProvider {
    static var previews: some View {
        SubscriptionErrorView(onButtonPressed: {})
            .background(ColorPalette.primaryBG)
    }
}



================================================
FILE: pdfexpert/Views/Subscription/SubscriptionFreeTrialToggleView.swift
================================================
//
//  SubscriptionFreeTrialToggleView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 09/08/23.
//

import SwiftUI

struct SubscriptionFreeTrialToggleView: View {
    
    @Binding var isFreeTrial: Bool
    
    var body: some View {
        Button(action: {
            self.isFreeTrial.toggle()
        }) {
            HStack {
                self.freeTrialDescriptionView
                self.checkmark
            }
            .padding([.leading, .trailing], 16)
        }
        .frame(maxWidth: .infinity)
        .frame(height: 62)
        .background(RoundedRectangle(cornerRadius: 10)
            .foregroundColor(ColorPalette.secondaryBG))
        .overlay(RoundedRectangle(cornerRadius: 10)
            .stroke(self.isFreeTrial ? ColorPalette.buttonGradientStart : .clear, lineWidth: 2))
    }
    
    var freeTrialDescriptionView: some View {
        return VStack(spacing: 0) {
            Text("Not sure yet?")
                .font(forCategory: .body1)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity, alignment: .leading)
            Spacer().frame(height: 4)
            Text("Enable the free trial")
                .font(forCategory: .caption1)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
    }
    
    var checkmark: some View {
        Group {
            if self.isFreeTrial {
                Image(systemName: "checkmark.circle")
                    .resizable()
                    .foregroundColor(ColorPalette.buttonGradientStart)
            } else {
                Image(systemName: "circle")
                    .resizable()
                    .foregroundColor(ColorPalette.thirdText)
            }
        }.frame(width: 22, height: 22)
    }
}

struct SubscriptionFreeTrialToggleView_Previews: PreviewProvider {
    static var previews: some View {
        SubscriptionFreeTrialToggleView(isFreeTrial: .constant(true))
    }
}



================================================
FILE: pdfexpert/Views/Subscription/SubscriptionPairsItemView.swift
================================================
//
//  SubscriptionPairsItemView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/03/23.
//

import SwiftUI

struct SubscriptionPairsItemView: View {
    
    let subscriptionPlan: SubscriptionPlanPairItem
    let isSelected: Bool
    let onTap: (() -> ())
    
    var body: some View {
        Button(action: {
            self.onTap()
        }) {
            VStack(spacing: 0) {
                HStack(alignment: .top, spacing: 12) {
                    Text(self.subscriptionPlan.title)
                        .font(forCategory: .body1)
                        .foregroundColor(ColorPalette.primaryText)
                        .frame(maxWidth: 110, alignment: .leading)
                        .multilineTextAlignment(.leading)
                    Spacer()
                    self.checkmark
                }
                Spacer().frame(height: 6)
                Text("Maximum flexibility, you decide when to cancel")
                    .font(forCategory: .caption2)
                    .foregroundColor(ColorPalette.thirdText)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .multilineTextAlignment(.leading)
                Spacer(minLength: 12)
                Text(self.subscriptionPlan.weeklyPriceAndPeriod)
                    .font(forCategory: .caption2)
                    .foregroundColor(ColorPalette.thirdText)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            .frame(maxWidth: .infinity)
            .padding([.leading, .trailing, .top], 12)
            .padding(.bottom, 16)
        }
        .frame(maxWidth: .infinity)
        .background(RoundedRectangle(cornerRadius: 10).foregroundColor(ColorPalette.secondaryBG))
        .overlay(RoundedRectangle(cornerRadius: 10)
            .stroke(self.isSelected ? ColorPalette.buttonGradientStart : ColorPalette.thirdText, lineWidth: 2))
    }
    
    var checkmark: some View {
        Group {
            if self.isSelected {
                AnyView(Image(systemName: "checkmark.circle")
                    .resizable()
                    .foregroundColor(ColorPalette.buttonGradientStart))
            } else {
                AnyView(Spacer())
            }
        }.frame(width: 22, height: 22)
    }
}

struct SubscriptionPairsItemView_Previews: PreviewProvider {
    
    private static let subscriptionPlanYearly = {
        SubscriptionPlanPairItem(product: nil,
                                 title: "Premium 1 year",
                                 weeklyPriceAndPeriod: "$1,38/week",
                                 fullDescriptionText: "")
    }()
    private static let subscriptionPlanMonthly = {
        SubscriptionPlanPairItem(product: nil,
                                 title: "Premium 1 month",
                                 weeklyPriceAndPeriod: "$2,09/week",
                                 fullDescriptionText: "")
    }()
    
    static var previews: some View {
        HStack(spacing: 16) {
            SubscriptionPairsItemView(subscriptionPlan: Self.subscriptionPlanYearly,
                                 isSelected: true,
                                 onTap: {})
            SubscriptionPairsItemView(subscriptionPlan: Self.subscriptionPlanMonthly,
                                 isSelected: false,
                                 onTap: {})
        }
        .padding([.leading, .trailing], 16)
        .frame(minHeight: 161, maxHeight: 200)
    }
}



================================================
FILE: pdfexpert/Views/Subscription/SubscriptionPairsView.swift
================================================
//
//  SubscriptionPairsView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 31/03/23.
//

import SwiftUI
import Factory

struct SubscriptionPairsView: View {
    
    @InjectedObject(\.subscribtionPairsViewModel) var viewModel
    var onComplete: () -> ()
    
    var body: some View {
        ZStack {
            self.getCloseButton(color: ColorPalette.primaryText.opacity(0.3)) {
                self.onComplete()
            }
            self.content
        }
        .background(ColorPalette.primaryBG)
        .asyncView(asyncOperation: self.$viewModel.purchaseRequest)
        .asyncView(asyncOperation: self.$viewModel.restorePurchaseRequest)
        .onAppear() {
            self.viewModel.onAppear()
        }
        .onChange(of: self.viewModel.isPremium, perform: { newValue in
            if newValue {
                self.onComplete()
            }
        })
    }
    
    var content: some View {
        switch self.viewModel.asyncSubscriptionPlanPairs.status {
        case .empty: return AnyView(Spacer())
        case .loading: return AnyView(AnimationType.dots.view)
        case .data: return AnyView(self.mainView)
        case .error: return AnyView(SubscriptionErrorView(onButtonPressed: {
            self.viewModel.refresh()
        }))
        }
    }
    
    var mainView: some View {
        VStack(spacing: 0) {
            self.restorePurchaseButton
            VStack(spacing: 0) {
                Spacer()
                Spacer().frame(height: 20)
                Image("logo_large")
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(maxHeight: 400)
                Spacer().frame(height: 20)
                Spacer()
            }
            VStack(spacing: 0) {
                Text(K.Misc.AppTitle)
                    .font(forCategory: .largeTitle)
                    .foregroundColor(ColorPalette.primaryText)
                    .frame(maxWidth: .infinity, alignment: .leading)
                Spacer().frame(height: 16)
                Text("Edit, convert PDFs and receive constant updates and advanced Premium features. ")
                    .font(forCategory: .body1)
                    .foregroundColor(ColorPalette.primaryText)
                    .lineLimit(2)
                    .minimumScaleFactor(0.5)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .multilineTextAlignment(.leading)
            }
            VStack(spacing: 0) {
                Spacer().frame(height: 42)
                self.subscriptionPlanPairsView
                Spacer().frame(height: 16)
            }
            self.freeTrialView
            self.getDefaultButton(text: "Continue",
                                  onButtonPressed: { self.viewModel.subscribe() })
            self.currentSubscriptionPlanView
        }
        .padding([.leading, .trailing], 16)
    }
    
    var restorePurchaseButton: some View {
        Button(action: { self.viewModel.restorePurchases() }) {
            Text("Restore purchase")
                .frame(maxHeight: .infinity)
                .underline()
                .font(forCategory: .linkText)
                .foregroundColor(ColorPalette.primaryText)
        }
        .frame(maxWidth: .infinity)
        .frame(height: 44)
    }
    
    private var freeTrialView: some View {
        VStack(spacing: 0) {
            if let currentSubscriptionPlanPair = self.viewModel.currentSubscriptionPlanPair,
               currentSubscriptionPlanPair.standardSubscriptionPlan != nil,
               currentSubscriptionPlanPair.freeTrialSubscriptionPlan != nil {
                SubscriptionFreeTrialToggleView(isFreeTrial: self.$viewModel.isFreeTrialEnabled)
                Spacer().frame(height: 20)
            }
        }
    }
    
    var currentSubscriptionPlanView: some View {
        Text(self.viewModel.currentSubscriptionPlan?.fullDescriptionText ?? "")
            .font(forCategory: .headline)
            .foregroundColor(ColorPalette.primaryText)
            .frame(maxWidth: .infinity, alignment: .center)
            .frame(height: 40)
            .minimumScaleFactor(0.5)
    }
    
    var subscriptionPlanPairsView: some View {
        if let subscriptionPlanPairs = self.viewModel.asyncSubscriptionPlanPairs.data {
            return AnyView(HStack(spacing: 16) {
                ForEach(Array(subscriptionPlanPairs.enumerated()), id: \.offset) { index, subscriptionPlanPair in
                    if let subscriptionPlan = self.getSubscriptionPlan(from: subscriptionPlanPair) {
                        SubscriptionPairsItemView(subscriptionPlan: subscriptionPlan,
                                             isSelected: self.viewModel.selectedSubscriptionPairIndex == index,
                                             onTap: { self.viewModel.selectedSubscriptionPairIndex = index })
                    }
                }
            }
                .frame(minHeight: 161, maxHeight: 200))
        } else {
            return AnyView(Spacer().frame(height: 1))
        }
    }
    
    func getSubscriptionPlan(from subscriptionPlanPair: SubscriptionPairsViewModel.PlanPair) -> SubscriptionPlanPairItem? {
        if self.viewModel.isFreeTrialEnabled {
            return subscriptionPlanPair.freeTrialSubscriptionPlan ?? subscriptionPlanPair.standardSubscriptionPlan
        } else {
            return subscriptionPlanPair.standardSubscriptionPlan ?? subscriptionPlanPair.freeTrialSubscriptionPlan
        }
    }
}

struct SubscriptionPairsView_Previews: PreviewProvider {
    static var previews: some View {
        SubscriptionPairsView(onComplete: {})
    }
}



================================================
FILE: pdfexpert/Views/Subscription/SubscriptionPickerPlanListView.swift
================================================
//
//  SubscriptionPickerPlanListView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 10/08/23.
//

import SwiftUI
import Factory

struct SubscriptionPickerPlanListView: View {
    
    @ObservedObject var viewModel: SubscriptionPickerViewModel
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        VStack(spacing: 0) {
            Text("Choose period")
                .font(forCategory: .button)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity, alignment: .leading)
            Spacer().frame(height: 20)
            ForEach(Array(self.viewModel.subscriptionPlans.enumerated()), id: \.offset) { index, item in
                VStack(spacing: 0) {
                    self.getSubscriptionPlan(subscriptionPlan: item, index: index)
                    Spacer().frame(height: 21)
                }
            }
        }
        .padding([.leading, .trailing], 16)
        .padding(.top, 20)
    }
    
    private func getSubscriptionPlan(subscriptionPlan: SubscriptionPlanPickerItem,
                                     index: Int) -> some View {
        ZStack {
            Button(action: {
                self.dismiss()
                self.viewModel.selectedSubscriptionPairIndex = index
            }) {
                HStack(spacing: 0) {
                    Text(subscriptionPlan.period + " |")
                        .font(forCategory: .button)
                        .foregroundColor(ColorPalette.primaryText)
                    Spacer().frame(width: 6)
                    Text(subscriptionPlan.priceText)
                        .font(forCategory: .button)
                        .foregroundColor(ColorPalette.thirdText)
                    Spacer()
                    Text(subscriptionPlan.weeklyPriceAndPeriod)
                        .font(forCategory: .caption1)
                        .foregroundColor(ColorPalette.thirdText)
                }
                .padding(16)
            }
            .overlay(RoundedRectangle(cornerRadius: 10)
                .stroke(
                    self.viewModel.selectedSubscriptionPairIndex == index
                    ? ColorPalette.buttonGradientStart
                    : ColorPalette.fourthText,
                    lineWidth: self.viewModel.selectedSubscriptionPairIndex == index ? 2 : 1)
            )
            if let bestDiscountText = subscriptionPlan.bestDiscountText {
                HStack {
                    Spacer()
                    GeometryReader { geometry in
                        HStack {
                            Spacer()
                            Text(bestDiscountText)
                                .font(forCategory: .callout)
                                .foregroundColor(.black)
                                .frame(alignment: .trailing)
                                .padding([.leading, .trailing], 6)
                                .padding([.bottom, .top], 2)
                                .background(ColorPalette.extra)
                                .cornerRadius(2)
                        }.position(x: geometry.size.width/2, y: 0)
                    }
                }
                .padding([.trailing], 16)
            }
        }
        .padding([.leading, .trailing], 1)
        .frame(maxWidth: .infinity)
        .frame(height: 48)
    }
}

struct SubscriptionPickerPlanListView_Previews: PreviewProvider {
    static var previews: some View {
        Color.white
            .sheetAutoHeight(isPresented: .constant(true),
                             backgroundColor: ColorPalette.secondaryBG,
                             topCornerRadius: 10) {
                SubscriptionPickerPlanListView(viewModel: Container.shared.subscriptionPickerViewModel())
            }
    }
}



================================================
FILE: pdfexpert/Views/Subscription/SubscriptionPickerPlanView.swift
================================================
//
//  SubscriptionPickerPlanView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 09/08/23.
//

import SwiftUI

struct SubscriptionPickerPlanView: View {
    
    let subscriptionPlanPickerItem: SubscriptionPlanPickerItem?
    let pickerButtonPressed: () -> ()
    
    var body: some View {
        Group {
            VStack(spacing: 0) {
                HStack(alignment: .top, spacing: 12) {
                    Text(self.subscriptionPlanPickerItem?.title ?? "")
                        .font(forCategory: .body1)
                        .foregroundColor(ColorPalette.primaryText)
                        .multilineTextAlignment(.leading)
                    Spacer()
                    self.checkmark
                }
                Spacer()
                Text("Maximum flexibility, you decide\nhow long to stay")
                    .font(forCategory: .caption2)
                    .foregroundColor(ColorPalette.thirdText)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .multilineTextAlignment(.leading)
                Spacer()
                HStack {
                    Text(self.subscriptionPlanPickerItem?.weeklyPriceAndPeriod ?? "")
                        .font(forCategory: .caption2)
                        .foregroundColor(ColorPalette.primaryText)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    self.pickerView
                }
            }
            .padding(16)
        }
        .frame(maxWidth: .infinity)
        .frame(height: 134)
        .background(RoundedRectangle(cornerRadius: 10).foregroundColor(ColorPalette.secondaryBG))
        .overlay(RoundedRectangle(cornerRadius: 10)
            .stroke(ColorPalette.buttonGradientStart, lineWidth: 2))
        .padding([.leading, .trailing], 1)
    }
    
    private var checkmark: some View {
        ZStack {
            Circle().fill(.white)
                .padding(4)
            Image(systemName: "checkmark.circle.fill")
                .resizable()
                .foregroundColor(ColorPalette.buttonGradientStart)
        }.frame(width: 24, height: 24)
    }
    
    private var pickerView: some View {
        Button(action: { self.pickerButtonPressed() }) {
            HStack(spacing: 12) {
                Text(self.subscriptionPlanPickerItem?.period ?? "")
                    .font(forCategory: .callout)
                    .foregroundColor(ColorPalette.primaryText)
                Image(systemName: "chevron.down")
                    .foregroundColor(ColorPalette.primaryText)
            }
            .padding(.leading, 21)
            .padding(.trailing, 16)
        }
        .frame(height: 26)
        .background(Capsule().foregroundColor(ColorPalette.buttonGradientStart))
    }
}

struct SubscriptionPickerPlanView_Previews: PreviewProvider {
    
    private static let subscriptionPlanYearly = {
        SubscriptionPlanPickerItem(
            product: nil,
            title: "Premium 1 year",
            period: "Yearly",
            weeklyPriceAndPeriod: "$1,38/week",
            fullDescriptionText: "Free for 7 days, then $89.99/year",
            priceText: "$89.99",
            bestDiscountText: "53% DISCOUNT"
        )
    }()
    
    static var previews: some View {
        SubscriptionPickerPlanView(subscriptionPlanPickerItem: Self.subscriptionPlanYearly,
                                   pickerButtonPressed: { print("Picker Button Pressed") })
    }
}



================================================
FILE: pdfexpert/Views/Subscription/SubscriptionPickerView.swift
================================================
//
//  SubscriptionPickerView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 08/08/23.
//

import SwiftUI
import Factory

struct SubscriptionPickerView: View {
    
    fileprivate struct SubscriptionFeature: Hashable {
        let imageName: String
        let text: String
    }
    
    private let subscriptionFeatures: [SubscriptionFeature] = [
        SubscriptionFeature(imageName: "subscription_feature_convert",
                       text: "Convert file to PDF"),
        SubscriptionFeature(imageName: "subscription_feature_chat_pdf",
                       text: "Ask any question to PDF and get insights fast"),
        SubscriptionFeature(imageName: "subscription_feature_signature",
                       text: "Enter and edit your signature"),
        SubscriptionFeature(imageName: "subscription_feature_password",
                       text: "Protect your files with password"),
        SubscriptionFeature(imageName: "subscription_feature_edit",
                       text: "Edit, save and share your PDF"),
    ]
    
    @InjectedObject(\.subscriptionPickerViewModel) var viewModel
    
    @State var showPlansPicker: Bool = false
    
    var onComplete: () -> ()
    
    var body: some View {
        ZStack {
            self.getCloseButton(color: ColorPalette.primaryText.opacity(0.3)) {
                self.onComplete()
            }
            self.content
        }
        .background(ColorPalette.primaryBG)
        .asyncView(asyncItem: self.$viewModel.purchaseRequest)
        .asyncView(asyncItem: self.$viewModel.restorePurchaseRequest)
        .onAppear() {
            self.viewModel.onAppear()
        }
        .sheetAutoHeight(isPresented: self.$showPlansPicker,
                         backgroundColor: ColorPalette.secondaryBG,
                         topCornerRadius: 10,
                         content: {
            SubscriptionPickerPlanListView(viewModel: self.viewModel)
        })
        .onChange(of: self.viewModel.isPremium, perform: { newValue in
            if newValue {
                self.onComplete()
            }
        })
    }
    
    @ViewBuilder var content: some View {
        switch self.viewModel.asyncSubscriptionPlanPairs.status {
        case .empty: Spacer()
        case .loading: AnimationType.dots.view
        case .data: self.mainView
        case .error: SubscriptionErrorView(onButtonPressed: {
            self.viewModel.refresh()
        })
        }
    }
    
    var mainView: some View {
        VStack(spacing: 0) {
            self.restorePurchaseButton
            ScrollView {
                VStack(spacing: 0) {
                    Spacer().frame(height: 26)
                    Text("Choose a plan")
                        .font(forCategory: .body1)
                        .foregroundColor(ColorPalette.primaryText)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    Spacer().frame(height: 26)
                    SubscriptionPickerPlanView(subscriptionPlanPickerItem: self.viewModel.currentSubscriptionPlan,
                                               pickerButtonPressed: {
                        self.showPlansPicker = true
                    })
                    Spacer().frame(height: 20)
                    Spacer()
                }
                VStack(spacing: 0) {
                    Text("What you get")
                        .font(forCategory: .body1)
                        .foregroundColor(ColorPalette.primaryText)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    Spacer().frame(height: 16)
                    ForEach(self.subscriptionFeatures, id:\.self) { feature in
                        VStack(spacing: 0) {
                            self.getSubscriptionFeature(feature: feature)
                            ColorPalette.fourthText.frame(height: 1)
                        }
                    }
                }
            }
            .scrollIndicators(.hidden)
            VStack(spacing: 0) {
                self.freeTrialView
                self.getDefaultButton(text: "Continue",
                                      onButtonPressed: { self.viewModel.subscribe() })
                self.currentSubscriptionPlanView
            }
            .background(ColorPalette.primaryBG)
            .padding(.top, 16)
        }
        .padding([.leading, .trailing], 16)
    }
    
    private var restorePurchaseButton: some View {
        Button(action: { self.viewModel.restorePurchases() }) {
            Text("Restore purchase")
                .frame(maxHeight: .infinity)
                .underline()
                .font(forCategory: .linkText)
                .foregroundColor(ColorPalette.primaryText)
        }
        .frame(maxWidth: .infinity)
        .frame(height: 44)
    }
    
    private func getSubscriptionFeature(feature: SubscriptionFeature) -> some View {
        HStack(spacing: 16) {
            Image(feature.imageName)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width: 20, height: 20)
            Text(feature.text)
                .font(forCategory: .caption1)
                .foregroundColor(ColorPalette.primaryText)
                .frame(maxWidth: .infinity, alignment: .leading)
            Image(systemName: "checkmark.circle")
                .font(.system(size: 22).bold())
                .foregroundColor(ColorPalette.buttonGradientStart)
        }
        .frame(height: 52)
    }
    
    private var freeTrialView: some View {
        VStack(spacing: 0) {
            if let currentSubscriptionPlanPair = self.viewModel.currentSubscriptionPlanPair,
               currentSubscriptionPlanPair.standardSubscriptionPlan != nil,
               currentSubscriptionPlanPair.freeTrialSubscriptionPlan != nil {
                SubscriptionFreeTrialToggleView(isFreeTrial: self.$viewModel.isFreeTrialEnabled)
                Spacer().frame(height: 20)
            }
        }
    }
    
    private var currentSubscriptionPlanView: some View {
        Text(self.viewModel.currentSubscriptionPlan?.fullDescriptionText ?? "")
            .font(forCategory: .headline)
            .foregroundColor(ColorPalette.primaryText)
            .frame(maxWidth: .infinity, alignment: .center)
            .frame(height: 40)
            .minimumScaleFactor(0.5)
    }
}

struct SubscriptionPickerView_Previews: PreviewProvider {
    static var previews: some View {
        SubscriptionPickerView(onComplete: {})
    }
}



================================================
FILE: pdfexpert/Views/Subscription/SubscriptionVerticalItemView.swift
================================================
//
//  SubscriptionVerticalItemView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 12/04/23.
//

import SwiftUI

struct SubscriptionVerticalItemView: View {
    
    let subscriptionPlan: SubscriptionPlanVerticalItem
    let isSelected: Bool
    let onTap: (() -> ())
    
    var body: some View {
        Button(action: {
            self.onTap()
        }) {
            ZStack {
                HStack(spacing: 12) {
                    self.checkmark
                    VStack(spacing: 4) {
                        if let freeTrialText = self.subscriptionPlan.freeTrialText {
                            Text(freeTrialText)
                                .font(forCategory: .body1)
                                .foregroundColor(ColorPalette.extra)
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .lineLimit(1)
                        }
                        Text(self.subscriptionPlan.titleShort)
                            .font(forCategory: .body2)
                            .foregroundColor(ColorPalette.primaryText)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .lineLimit(1)
                        if let discountText = self.subscriptionPlan.discountText {
                            Text(discountText)
                                .font(forCategory: .caption2)
                                .foregroundColor(ColorPalette.thirdText)
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .lineLimit(1)
                        }
                    }
                }
                .padding([.leading, .trailing], 16)
                .frame(maxHeight: .infinity)
                .background(RoundedRectangle(cornerRadius: 10).foregroundColor(isSelected ? ColorPalette.secondaryBG : .clear))
                .overlay(RoundedRectangle(cornerRadius: 10).stroke(
                    ColorPalette.secondaryBG,
                    lineWidth: 2)
                )
                if let bestDiscountText = self.subscriptionPlan.bestDiscountText {
                    HStack {
                        Spacer()
                        GeometryReader { geometry in
                            HStack {
                                Spacer()
                                Text(bestDiscountText)
                                    .font(forCategory: .callout)
                                    .foregroundColor(.black)
                                    .frame(alignment: .trailing)
                                    .padding([.leading, .trailing], 6)
                                    .padding([.bottom, .top], 2)
                                    .background(ColorPalette.extra)
                                    .cornerRadius(2)
                            }.position(x: geometry.size.width/2, y: 0)
                        }
                    }
                    .padding([.trailing], 16)
                }
            }
        }
        .frame(minHeight: self.viewHeight)
    }
    
    var viewHeight: CGFloat {
        self.subscriptionPlan.freeTrialText != nil ? 86 : 76
    }
    
    var checkmark: some View {
        ZStack {
            if self.isSelected {
                Image(systemName: "circle.fill")
                    .resizable()
                    .foregroundColor(.white)
                Image(systemName: "checkmark.circle.fill")
                    .resizable()
                    .foregroundColor(ColorPalette.buttonGradientStart)
            } else {
                Image(systemName: "circle")
                    .resizable()
                    .foregroundColor(ColorPalette.fourthText)
            }
        }.frame(width: 24, height: 24)
    }
}

struct SubscriptionVerticalItemView_Previews: PreviewProvider {
    private static let subscriptionPlanYearly = {
        SubscriptionPlanVerticalItem(product: nil,
                                     titleShort: "Yearly",
                                     weeklyPriceAndPeriod: "$1,38/week",
                                     fullDescriptionText: "Free for 7 days, then $89.99/year",
                                     freeTrialText: "FREE TRIAL for 7 days",
                                     bestDiscountText: "53% DISCOUNT",
                                     discountText: "12 months at $1.99, save 53%"
        )
    }()
    private static let subscriptionPlanMonthly = {
        SubscriptionPlanVerticalItem(product: nil,
                                     titleShort: "Monthly",
                                     weeklyPriceAndPeriod: "$2,47/week",
                                     fullDescriptionText: "$89.99/month",
                                     freeTrialText: nil,
                                     bestDiscountText: nil,
                                     discountText: "4 weeks at $1.92, save 20%"
        )
    }()
    private static let subscriptionPlanWeekly = {
        SubscriptionPlanVerticalItem(product: nil,
                                     titleShort: "Weekly",
                                     weeklyPriceAndPeriod: "$4,99/week",
                                     fullDescriptionText: "$4,99/week",
                                     freeTrialText: nil,
                                     bestDiscountText: nil,
                                     discountText: nil
        )
    }()
    
    static var previews: some View {
        VStack(spacing: 16) {
            Spacer()
            SubscriptionVerticalItemView(subscriptionPlan: Self.subscriptionPlanYearly,
                                 isSelected: true,
                                 onTap: {})
            SubscriptionVerticalItemView(subscriptionPlan: Self.subscriptionPlanMonthly,
                                 isSelected: false,
                                 onTap: {})
            SubscriptionVerticalItemView(subscriptionPlan: Self.subscriptionPlanWeekly,
                                 isSelected: false,
                                 onTap: {})
            Spacer()
        }
        .padding([.leading, .trailing], 16)
        .background(ColorPalette.primaryBG)
    }
}



================================================
FILE: pdfexpert/Views/Subscription/SubscriptionVerticalView.swift
================================================
//
//  SubscriptionVerticalView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 12/04/23.
//

import SwiftUI
import Factory

struct SubscriptionVerticalView: View {
    
    @StateObject var viewModel: SubscriptionVerticalViewModel
    
    var onComplete: () -> ()
    
    var body: some View {
        ZStack {
            self.getCloseButton(color: ColorPalette.primaryText.opacity(0.3)) {
                self.onComplete()
            }
            self.content
        }
        .background(ColorPalette.primaryBG)
        .asyncView(asyncOperation: self.$viewModel.purchaseRequest)
        .asyncView(asyncOperation: self.$viewModel.restorePurchaseRequest)
        .onAppear() {
            self.viewModel.onAppear()
        }
        .onChange(of: self.viewModel.isPremium, perform: { newValue in
            if newValue {
                self.onComplete()
            }
        })
    }
    
    var content: some View {
        switch self.viewModel.asyncSubscriptionPlanList.status {
        case .empty: return AnyView(Spacer())
        case .loading: return AnyView(AnimationType.dots.view)
        case .data: return AnyView(self.mainView)
        case .error: return AnyView(SubscriptionErrorView(onButtonPressed: {
            self.viewModel.refresh()
        }))
        }
    }
    
    var mainView: some View {
        VStack(spacing: 0) {
            self.restorePurchaseButton
            VStack(spacing: 0) {
                Spacer()
                Spacer().frame(height: 20)
                Image("logo_large")
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(maxHeight: 400)
                Spacer().frame(height: 20)
                Spacer()
            }
            VStack(spacing: 0) {
                Text(K.Misc.AppTitle)
                    .font(forCategory: .largeTitle)
                    .foregroundColor(ColorPalette.primaryText)
                    .frame(maxWidth: .infinity, alignment: .leading)
                Spacer().frame(height: 16)
                Text("No obligation, you can cancel whenever you want.")
                    .font(forCategory: .body2)
                    .foregroundColor(ColorPalette.primaryText)
                    .lineLimit(2)
                    .minimumScaleFactor(0.5)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .multilineTextAlignment(.leading)
            }
            VStack(spacing: 0) {
                Spacer().frame(height: 20)
                self.subscriptionPlansView
                Spacer().frame(height: 4)
            }
            self.getDefaultButton(text: "Continue",
                                  onButtonPressed: { self.viewModel.subscribe() })
            self.currentSubscriptionPlanView
        }
        .padding([.leading, .trailing], 16)
    }
    
    var restorePurchaseButton: some View {
        Button(action: { self.viewModel.restorePurchases() }) {
            Text("Restore purchase")
                .frame(maxHeight: .infinity)
                .underline()
                .font(forCategory: .linkText)
                .foregroundColor(ColorPalette.primaryText)
        }
        .frame(maxWidth: .infinity)
        .frame(height: 44)
    }
    
    var currentSubscriptionPlanView: some View {
        Text(self.viewModel.currentSubscriptionPlan?.fullDescriptionText ?? "")
            .font(forCategory: .headline)
            .foregroundColor(ColorPalette.primaryText)
            .frame(maxWidth: .infinity, alignment: .center)
            .frame(height: 40)
            .minimumScaleFactor(0.5)
    }
    
    var subscriptionPlansView: some View {
        if let subscriptionPlanList = self.viewModel.asyncSubscriptionPlanList.data {
            return AnyView(
                ForEach(Array(subscriptionPlanList.enumerated()), id: \.offset) { index, subscriptionPlanVerticalItem in
                    SubscriptionVerticalItemView(subscriptionPlan: subscriptionPlanVerticalItem,
                                                 isSelected: self.viewModel.selectedSubscriptionItemIndex == index,
                                                 onTap: { self.viewModel.selectedSubscriptionItemIndex = index })
                    .frame(maxHeight: 200)
                    Spacer().frame(height: 16)
                }
            )
        } else {
            return AnyView(Spacer().frame(height: 1))
        }
    }
}

struct SubscriptionVerticalView_Previews: PreviewProvider {
    
    static let highlightLongPeriodViewModel = SubscriptionVerticalViewModel(mode: .highlightLongPeriod)
    static let highlightShortPeriodViewModel = SubscriptionVerticalViewModel(mode: .highlightShortPeriod)
    
    static var previews: some View {
        SubscriptionVerticalView(viewModel: Self.highlightLongPeriodViewModel,
                                 onComplete: { print("Complete!") })
        .previewDisplayName("Highlight Long Period")
        SubscriptionVerticalView(viewModel: Self.highlightShortPeriodViewModel,
                                 onComplete: { print("Complete!") })
        .previewDisplayName("Highlight Short Period")
    }
}



================================================
FILE: pdfexpert/Views/Welcome/WelcomeView.swift
================================================
//
//  WelcomeView.swift
//  PdfExpert
//
//  Created by Pcnaid Inc on 03/04/23.
//

import SwiftUI
import Factory

struct WelcomeView: View {
    
    @Injected(\.mainCoordinator) private var coordinator
    
    var body: some View {
        ZStack {
            GeometryReader { geometry in
                VStack(spacing: 16) {
                    Image("logo_large")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(maxHeight: 600)
                        .padding(60)
                    Text("Welcome in \(K.Misc.AppTitle):\nConvert & Edit")
                        .font(forCategory: .title1)
                        .foregroundColor(ColorPalette.primaryText)
                        .multilineTextAlignment(.center)
                        .frame(maxWidth: .infinity, alignment: .center)
                    Text("The PDF editor for iPhone")
                        .font(forCategory: .headline)
                        .foregroundColor(ColorPalette.primaryText)
                        .multilineTextAlignment(.center)
                        .frame(maxWidth: .infinity, alignment: .center)
                }
                .position(x: geometry.size.width/2, y: geometry.size.height/3)
            }
            VStack {
                Spacer()
                self.getDefaultButton(text: "Start",
                                      onButtonPressed: self.coordinator.showOnboarding)
            }
        }
        .padding([.leading, .trailing], 16)
        .padding([.top, .bottom], 64)
        .background(ColorPalette.primaryBG)
    }
}

struct WelcomeView_Previews: PreviewProvider {
    static var previews: some View {
        WelcomeView()
    }
}



================================================
FILE: pdfexpert.xcodeproj/project.pbxproj
================================================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 56;
	objects = {

/* Begin PBXBuildFile section */
		8902898D29DC1F10007E6372 /* PageControl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8902898C29DC1F10007E6372 /* PageControl.swift */; };
		89127AA12A177E370059005F /* PencilKitView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89127AA02A177E370059005F /* PencilKitView.swift */; };
		89127AA32A177F170059005F /* PdfSignatureCanvasView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89127AA22A177F170059005F /* PdfSignatureCanvasView.swift */; };
		89127AA52A17A3600059005F /* PdfSignatureCanvasViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89127AA42A17A3600059005F /* PdfSignatureCanvasViewModel.swift */; };
		89127AA72A17C1980059005F /* PencilKit+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89127AA62A17C1980059005F /* PencilKit+Extensions.swift */; };
		891A07E929E028EE0002FA3A /* CloudKitSyncMonitor in Frameworks */ = {isa = PBXBuildFile; productRef = 891A07E829E028EE0002FA3A /* CloudKitSyncMonitor */; };
		891AE58B2A03E80300DBC246 /* ObservableObject+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 891AE58A2A03E80300DBC246 /* ObservableObject+Extensions.swift */; };
		892201D92A0BA64600832CF2 /* ImageAnnotationStamp.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892201D82A0BA64600832CF2 /* ImageAnnotationStamp.swift */; };
		892201DC2A0BA70300832CF2 /* PdfSignatureView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892201DB2A0BA70300832CF2 /* PdfSignatureView.swift */; };
		892201DE2A0BA72D00832CF2 /* PdfSignatureViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892201DD2A0BA72D00832CF2 /* PdfSignatureViewModel.swift */; };
		8928F3D12A30BAFB001C1853 /* PickedImage.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8928F3D02A30BAFB001C1853 /* PickedImage.swift */; };
		892CC6922AAA23AE000DEC21 /* CDSuggestedFields.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892CC6912AAA23AE000DEC21 /* CDSuggestedFields.swift */; };
		892CC6942AAA243E000DEC21 /* SuggestedFields+Persistable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892CC6932AAA243E000DEC21 /* SuggestedFields+Persistable.swift */; };
		892CC6962AAA2641000DEC21 /* SuggestedFieldsFormView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892CC6952AAA2641000DEC21 /* SuggestedFieldsFormView.swift */; };
		892CC6982AAA2660000DEC21 /* SuggestedFieldsFormViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892CC6972AAA2660000DEC21 /* SuggestedFieldsFormViewModel.swift */; };
		892E404F2A25E5D9000EEE23 /* PDFAnnotation+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892E404E2A25E5D9000EEE23 /* PDFAnnotation+Extensions.swift */; };
		8932ECE52A20DC7700CBCD7A /* PdfFillFormView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8932ECE42A20DC7700CBCD7A /* PdfFillFormView.swift */; };
		8932ECE72A20DCB900CBCD7A /* PdfFillFormViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8932ECE62A20DCB900CBCD7A /* PdfFillFormViewModel.swift */; };
		8932ECE92A20F10500CBCD7A /* TextResizableView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8932ECE82A20F10500CBCD7A /* TextResizableView.swift */; };
		8933490C2A24AE880005D484 /* PdfKitViewBinder.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8933490B2A24AE880005D484 /* PdfKitViewBinder.swift */; };
		8934ACC72A6AE96700F6CDA8 /* ChatPdfInitParams.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8934ACC62A6AE96700F6CDA8 /* ChatPdfInitParams.swift */; };
		8936AA312A682812005F6C73 /* ProjectInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 8936AA302A682812005F6C73 /* ProjectInfo.plist */; };
		8936AA332A6828C9005F6C73 /* ProjectInfo.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA322A6828C9005F6C73 /* ProjectInfo.swift */; };
		8936AA382A68299B005F6C73 /* ChatPdfManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA352A68299B005F6C73 /* ChatPdfManager.swift */; };
		8936AA392A68299B005F6C73 /* ChatPdfManagerMock.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA362A68299B005F6C73 /* ChatPdfManagerMock.swift */; };
		8936AA3C2A682CDA005F6C73 /* ChatPdfSelectionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA3B2A682CDA005F6C73 /* ChatPdfSelectionView.swift */; };
		8936AA3E2A682F8E005F6C73 /* ChatPdfSelectionViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA3D2A682F8E005F6C73 /* ChatPdfSelectionViewModel.swift */; };
		8936AA402A683FB5005F6C73 /* ImportOption.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA3F2A683FB5005F6C73 /* ImportOption.swift */; };
		8936AA422A6840D1005F6C73 /* ChatPdfView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA412A6840D1005F6C73 /* ChatPdfView.swift */; };
		8936AA442A684128005F6C73 /* ChatPdfViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA432A684128005F6C73 /* ChatPdfViewModel.swift */; };
		893875012A7BDD3B00267AFD /* LoadingView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893875002A7BDD3B00267AFD /* LoadingView.swift */; };
		893AAFCB2A39B2AF00EF9B00 /* FormSheet.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893AAFCA2A39B2AF00EF9B00 /* FormSheet.swift */; };
		893B04BD2AA9C2C100F86813 /* CoreGraphics+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893B04BC2AA9C2C100F86813 /* CoreGraphics+Extensions.swift */; };
		893BE52B2A6A7864004B05B9 /* CombineMoya in Frameworks */ = {isa = PBXBuildFile; productRef = 893BE52A2A6A7864004B05B9 /* CombineMoya */; };
		893BE52D2A6A78BB004B05B9 /* ChatPdfManagerImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893BE52C2A6A78BB004B05B9 /* ChatPdfManagerImpl.swift */; };
		893BE52F2A6A7C0C004B05B9 /* NetworkUtility.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893BE52E2A6A7C0C004B05B9 /* NetworkUtility.swift */; };
		893BE5352A6A96F5004B05B9 /* ChatPdfRef+Decodable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893BE5342A6A96F5004B05B9 /* ChatPdfRef+Decodable.swift */; };
		893BE5372A6A9708004B05B9 /* ChatPdfMessage+Decodable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893BE5362A6A9708004B05B9 /* ChatPdfMessage+Decodable.swift */; };
		893C8FC929DED190000E35BD /* ArchiveView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FC829DED190000E35BD /* ArchiveView.swift */; };
		893C8FCB29DED1AF000E35BD /* ArchiveViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FCA29DED1AF000E35BD /* ArchiveViewModel.swift */; };
		893C8FCE29DED254000E35BD /* AppCoreData.xcdatamodeld in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FCC29DED254000E35BD /* AppCoreData.xcdatamodeld */; };
		893C8FD029DED278000E35BD /* Persistence.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FCF29DED278000E35BD /* Persistence.swift */; };
		893C8FD329DED2E9000E35BD /* Repository.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FD129DED2E9000E35BD /* Repository.swift */; };
		893C8FD429DED2E9000E35BD /* RepositoryImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FD229DED2E9000E35BD /* RepositoryImpl.swift */; };
		893C8FDE29DED7F4000E35BD /* PdfUtility.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FDD29DED7F4000E35BD /* PdfUtility.swift */; };
		893C8FE129DEDAF4000E35BD /* test.pdf in Resources */ = {isa = PBXBuildFile; fileRef = 893C8FE029DEDAF4000E35BD /* test.pdf */; };
		893DE8DA29E7F85C0043C02C /* SubscriptionPairsViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893DE8D929E7F85C0043C02C /* SubscriptionPairsViewModel.swift */; };
		893DE8DC29E7F9A10043C02C /* SubscriptionVerticalViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893DE8DB29E7F9A10043C02C /* SubscriptionVerticalViewModel.swift */; };
		893E849129D5874D00F6B99A /* CameraView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849029D5874D00F6B99A /* CameraView.swift */; };
		893E849429D5878E00F6B99A /* CameraViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849329D5878E00F6B99A /* CameraViewModel.swift */; };
		893E849C29D5944E00F6B99A /* PhotoCaptureProcessor.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849629D5944E00F6B99A /* PhotoCaptureProcessor.swift */; };
		893E849D29D5944E00F6B99A /* CameraService+Enums.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849729D5944E00F6B99A /* CameraService+Enums.swift */; };
		893E849E29D5944E00F6B99A /* CameraPreviewView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849829D5944E00F6B99A /* CameraPreviewView.swift */; };
		893E849F29D5944E00F6B99A /* ImageResizer.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849929D5944E00F6B99A /* ImageResizer.swift */; };
		893E84A029D5944E00F6B99A /* CameraService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849A29D5944E00F6B99A /* CameraService.swift */; };
		893E84A129D5944E00F6B99A /* CameraService+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849B29D5944E00F6B99A /* CameraService+Extensions.swift */; };
		893E84A429D5BFBB00F6B99A /* PSPDFKit in Frameworks */ = {isa = PBXBuildFile; productRef = 893E84A329D5BFBB00F6B99A /* PSPDFKit */; };
		893E84A629D5C5E200F6B99A /* ActivityViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E84A529D5C5E200F6B99A /* ActivityViewController.swift */; };
		893EB5012AA717B80066914E /* FacebookCore in Frameworks */ = {isa = PBXBuildFile; productRef = 893EB5002AA717B80066914E /* FacebookCore */; };
		893EB5032AA71FFD0066914E /* BranchAnalyticsPlatform.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893EB5022AA71FFD0066914E /* BranchAnalyticsPlatform.swift */; };
		893EB5052AA722EF0066914E /* StoreKit+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893EB5042AA722EF0066914E /* StoreKit+Extensions.swift */; };
		893EB5072AA723C80066914E /* AnalyticsDefaultParameters.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893EB5062AA723C80066914E /* AnalyticsDefaultParameters.swift */; };
		893ED9D02A6920F2004EE67C /* ChatPdfRef.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893ED9CF2A6920F2004EE67C /* ChatPdfRef.swift */; };
		893ED9D22A6926E8004EE67C /* ChatPdfMessage.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893ED9D12A6926E8004EE67C /* ChatPdfMessage.swift */; };
		893ED9D42A692805004EE67C /* CombineUtils.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893ED9D32A692805004EE67C /* CombineUtils.swift */; };
		893ED9D92A693013004EE67C /* MessageView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893ED9D72A693013004EE67C /* MessageView.swift */; };
		893ED9DA2A693013004EE67C /* MessageIndicatorView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893ED9D82A693013004EE67C /* MessageIndicatorView.swift */; };
		89407EF12AA8ADD200169801 /* GalleryImageProviderFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EF02AA8ADD200169801 /* GalleryImageProviderFlow.swift */; };
		89407EF32AA8B0C800169801 /* GalleryImageProviderFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EF22AA8B0C800169801 /* GalleryImageProviderFlowView.swift */; };
		89407EF52AA8BDE600169801 /* CameraImageProviderFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EF42AA8BDE600169801 /* CameraImageProviderFlow.swift */; };
		89407EF72AA8BEC200169801 /* CameraImageProviderFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EF62AA8BEC200169801 /* CameraImageProviderFlowView.swift */; };
		89407EFA2AA8C4C400169801 /* Mantis in Frameworks */ = {isa = PBXBuildFile; productRef = 89407EF92AA8C4C400169801 /* Mantis */; };
		89407EFC2AA8D22D00169801 /* ImageCropFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EFB2AA8D22D00169801 /* ImageCropFlow.swift */; };
		89407EFE2AA8D23B00169801 /* ImageCropFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EFD2AA8D23B00169801 /* ImageCropFlowView.swift */; };
		89407F002AA8D54800169801 /* ImageCropper.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EFF2AA8D54800169801 /* ImageCropper.swift */; };
		8940FB912A710D8D00A00D8D /* AddPasswordView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8940FB902A710D8D00A00D8D /* AddPasswordView.swift */; };
		8942034529DC12BC004D610B /* PagerTabStripView in Frameworks */ = {isa = PBXBuildFile; productRef = 8942034429DC12BC004D610B /* PagerTabStripView */; };
		89429F862A9C8ECC00465420 /* PdfSignaturePickerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F852A9C8ECC00465420 /* PdfSignaturePickerView.swift */; };
		89429F882A9C8EFC00465420 /* PdfSignaturePickerViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F872A9C8EFC00465420 /* PdfSignaturePickerViewModel.swift */; };
		89429F8A2A9C937300465420 /* Signature.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F892A9C937300465420 /* Signature.swift */; };
		89429F8C2A9C937C00465420 /* CDSignature.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F8B2A9C937C00465420 /* CDSignature.swift */; };
		89429F912A9CFFDC00465420 /* Persistable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F902A9CFFDC00465420 /* Persistable.swift */; };
		89429F932A9CFFF100465420 /* Pdf+Persistable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F922A9CFFF100465420 /* Pdf+Persistable.swift */; };
		89429F952A9D001A00465420 /* Signature+Persistable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F942A9D001A00465420 /* Signature+Persistable.swift */; };
		89431FC62A9900740042A636 /* MathUtils.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89431FC52A9900740042A636 /* MathUtils.swift */; };
		89436AB829E5556600060605 /* PdfCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436AB729E5556600060605 /* PdfCoordinator.swift */; };
		89436ABB29E557D500060605 /* PdfFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436ABA29E557D500060605 /* PdfFlowView.swift */; };
		89436ABD29E5586600060605 /* PdfEditView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436ABC29E5586600060605 /* PdfEditView.swift */; };
		89436ABF29E55EA000060605 /* Pdf.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436ABE29E55EA000060605 /* Pdf.swift */; };
		89436AC329E59C0E00060605 /* PdfEditViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436AC229E59C0E00060605 /* PdfEditViewModel.swift */; };
		89436AC729E5B99100060605 /* PdfKitView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436AC629E5B99100060605 /* PdfKitView.swift */; };
		89436D192A936C9F000868B5 /* PdfReadView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D182A936C9F000868B5 /* PdfReadView.swift */; };
		89436D1B2A939CBB000868B5 /* PdfReadViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D1A2A939CBB000868B5 /* PdfReadViewModel.swift */; };
		89436D1D2A93AE76000868B5 /* PdfReaderView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D1C2A93AE76000868B5 /* PdfReaderView.swift */; };
		89436D1F2A93AEB4000868B5 /* PdfReaderViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D1E2A93AEB4000868B5 /* PdfReaderViewModel.swift */; };
		89436D212A93B97E000868B5 /* NSAttributedString+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D202A93B97E000868B5 /* NSAttributedString+Extensions.swift */; };
		89436D232A93C1CE000868B5 /* PdfPageSelectionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D222A93C1CE000868B5 /* PdfPageSelectionView.swift */; };
		8945D2BC2A03C41000AFF51A /* PdfScanUtility.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8945D2BB2A03C41000AFF51A /* PdfScanUtility.swift */; };
		89460C6029DAC36600E39BAC /* SubscriptionErrorView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89460C5F29DAC36600E39BAC /* SubscriptionErrorView.swift */; };
		89467AD72A9E4C6B00FC01FC /* Deeplink.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89467AD62A9E4C6B00FC01FC /* Deeplink.swift */; };
		894827B02AA5D65600030C4E /* BranchSDK in Frameworks */ = {isa = PBXBuildFile; productRef = 894827AF2AA5D65600030C4E /* BranchSDK */; };
		894827B22AA5D68D00030C4E /* AttributionManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894827B12AA5D68D00030C4E /* AttributionManager.swift */; };
		894827B42AA5D6FF00030C4E /* AttibutionManagerImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894827B32AA5D6FF00030C4E /* AttibutionManagerImpl.swift */; };
		894AC3642A02952A00BA5553 /* Foundation+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894AC3632A02952A00BA5553 /* Foundation+Extensions.swift */; };
		894B019F2A0902BC00FF6198 /* ImportTutorialView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894B019E2A0902BC00FF6198 /* ImportTutorialView.swift */; };
		894B01A12A09030000FF6198 /* ImportTutorialPageView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894B01A02A09030000FF6198 /* ImportTutorialPageView.swift */; };
		894C4A692AA0C04B0001F51E /* PopupView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894C4A682AA0C04B0001F51E /* PopupView.swift */; };
		894C4A6B2AA0C23F0001F51E /* PreReviewPopupView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894C4A6A2AA0C23F0001F51E /* PreReviewPopupView.swift */; };
		894C4A6E2AA0CB470001F51E /* ReviewFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894C4A6D2AA0CB470001F51E /* ReviewFlow.swift */; };
		894C4A702AA0CCFC0001F51E /* ReviewFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894C4A6F2AA0CCFC0001F51E /* ReviewFlowView.swift */; };
		894C4A722AA0DB9A0001F51E /* PreReviewPopupLowRateView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894C4A712AA0DB9A0001F51E /* PreReviewPopupLowRateView.swift */; };
		894CB09E2A851FE50008008A /* ChatPdfSetupData.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894CB09D2A851FE50008008A /* ChatPdfSetupData.swift */; };
		894CB0A02A8520AD0008008A /* ChatPdfSetupData+Decodable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894CB09F2A8520AD0008008A /* ChatPdfSetupData+Decodable.swift */; };
		894D485829D42C9E002B0230 /* OptionItemView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894D485729D42C9D002B0230 /* OptionItemView.swift */; };
		894D485A29D42CC5002B0230 /* OptionListView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894D485929D42CC5002B0230 /* OptionListView.swift */; };
		894D485C29D42FE1002B0230 /* RoundedCorner.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894D485B29D42FE1002B0230 /* RoundedCorner.swift */; };
		89504A462A448252000BCACD /* PdfFillWidgetView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89504A452A448252000BCACD /* PdfFillWidgetView.swift */; };
		89504A482A44829C000BCACD /* PdfFillWidgetViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89504A472A44829C000BCACD /* PdfFillWidgetViewModel.swift */; };
		8955ED922A1F61A9009985EE /* OnboardingView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8955ED912A1F61A9009985EE /* OnboardingView.swift */; };
		8955ED942A1F61BD009985EE /* OnboardingPageView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8955ED932A1F61BD009985EE /* OnboardingPageView.swift */; };
		8955ED962A1F73DC009985EE /* OnboardingViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8955ED952A1F73DC009985EE /* OnboardingViewModel.swift */; };
		8957FBA82A77C646008B31ED /* PdfShareCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8957FBA72A77C646008B31ED /* PdfShareCoordinator.swift */; };
		8957FBAA2A77E6F7008B31ED /* PdfShareView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8957FBA92A77E6F7008B31ED /* PdfShareView.swift */; };
		8957FBAC2A7801BA008B31ED /* PdfCompressionPickerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8957FBAB2A7801BA008B31ED /* PdfCompressionPickerView.swift */; };
		895C1BB02A04FA53005EA190 /* ShareViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895C1BAF2A04FA53005EA190 /* ShareViewController.swift */; };
		895C1BB32A04FA53005EA190 /* MainInterface.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 895C1BB12A04FA53005EA190 /* MainInterface.storyboard */; };
		895C1BC02A051261005EA190 /* SharedStorage.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895C1BBF2A051261005EA190 /* SharedStorage.swift */; };
		895C1BC12A051261005EA190 /* SharedStorage.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895C1BBF2A051261005EA190 /* SharedStorage.swift */; };
		895FE2C429D6D7E500A99D5B /* ScannerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895FE2C329D6D7E500A99D5B /* ScannerView.swift */; };
		895FE2C629D6E17600A99D5B /* AnimationPalette.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895FE2C529D6E17600A99D5B /* AnimationPalette.swift */; };
		895FE2CB29D6E9B800A99D5B /* SubscriptionPairsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895FE2CA29D6E9B800A99D5B /* SubscriptionPairsView.swift */; };
		895FE2CD29D724B900A99D5B /* SubscriptionPairsItemView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895FE2CC29D724B900A99D5B /* SubscriptionPairsItemView.swift */; };
		895FE2D029D7392F00A99D5B /* Collections in Frameworks */ = {isa = PBXBuildFile; productRef = 895FE2CF29D7392F00A99D5B /* Collections */; };
		895FE2D229D7392F00A99D5B /* OrderedCollections in Frameworks */ = {isa = PBXBuildFile; productRef = 895FE2D129D7392F00A99D5B /* OrderedCollections */; };
		8962D6062A9E28FB008426A2 /* PdfSignaturePrioviderFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8962D6052A9E28FB008426A2 /* PdfSignaturePrioviderFlow.swift */; };
		8962D6082A9E2A57008426A2 /* PdfSignatureProviderFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8962D6072A9E2A57008426A2 /* PdfSignatureProviderFlowView.swift */; };
		8966B6F22AA9FCE0005E6DED /* SuggestedFields.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8966B6F12AA9FCE0005E6DED /* SuggestedFields.swift */; };
		8968761A2A7CE87A0014A320 /* PdfSplitViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896876192A7CE87A0014A320 /* PdfSplitViewModel.swift */; };
		8968761C2A7CEB650014A320 /* PdfImportViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8968761B2A7CEB650014A320 /* PdfImportViewModel.swift */; };
		8968761E2A7CEE320014A320 /* PdfImportView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8968761D2A7CEE320014A320 /* PdfImportView.swift */; };
		896876202A7CF1E10014A320 /* PdfImportMultipleViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8968761F2A7CF1E00014A320 /* PdfImportMultipleViewModel.swift */; };
		896876222A7CF3220014A320 /* PdfImportMultipleView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896876212A7CF3220014A320 /* PdfImportMultipleView.swift */; };
		896876242A7D05040014A320 /* PdfSplitView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896876232A7D05040014A320 /* PdfSplitView.swift */; };
		896876262A7D2EB80014A320 /* PdfPageRangeEditorViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896876252A7D2EB80014A320 /* PdfPageRangeEditorViewModel.swift */; };
		896876282A7D2EC20014A320 /* PdfPageRangeEditorView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896876272A7D2EC20014A320 /* PdfPageRangeEditorView.swift */; };
		896CCF6D2A28910B008F268E /* SizePrinter.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896CCF6C2A28910B008F268E /* SizePrinter.swift */; };
		896CCF6F2A28AEAC008F268E /* UIFont+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896CCF6E2A28AEAC008F268E /* UIFont+Extensions.swift */; };
		897911ED29E70541008B7088 /* SubscriptionVerticalView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 897911EC29E70541008B7088 /* SubscriptionVerticalView.swift */; };
		897911EF29E70558008B7088 /* SubscriptionVerticalItemView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 897911EE29E70558008B7088 /* SubscriptionVerticalItemView.swift */; };
		897967862A73E59B00E91F8E /* URL+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 897967852A73E59B00E91F8E /* URL+Extensions.swift */; };
		89851B5E2A13DB1A00ABF58F /* ImageResizableView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89851B5D2A13DB1A00ABF58F /* ImageResizableView.swift */; };
		8991485129E851B500DD01F2 /* ConfigService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8991485029E851B500DD01F2 /* ConfigService.swift */; };
		8991485329E851BD00DD01F2 /* RemoteConfigManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8991485229E851BD00DD01F2 /* RemoteConfigManager.swift */; };
		8991485629E85DE500DD01F2 /* CombineExt in Frameworks */ = {isa = PBXBuildFile; productRef = 8991485529E85DE500DD01F2 /* CombineExt */; };
		89923E5F29D4350F00E246FC /* AppTrackingTransparencyImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89923E5D29D4350F00E246FC /* AppTrackingTransparencyImpl.swift */; };
		89923E6029D4350F00E246FC /* AppTrackingTransparency.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89923E5E29D4350F00E246FC /* AppTrackingTransparency.swift */; };
		89923E6729D437F500E246FC /* FirebasePerformance in Frameworks */ = {isa = PBXBuildFile; productRef = 89923E6629D437F500E246FC /* FirebasePerformance */; };
		89923E6929D46A9900E246FC /* FilePicker.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89923E6829D46A9900E246FC /* FilePicker.swift */; };
		89923E6B29D47B9E00E246FC /* pdf-scanning.json in Resources */ = {isa = PBXBuildFile; fileRef = 89923E6A29D47B9E00E246FC /* pdf-scanning.json */; };
		8995694229D33B1300566EF4 /* HomeItemView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8995694129D33B1300566EF4 /* HomeItemView.swift */; };
		8995694429D3450300566EF4 /* HomeViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8995694329D3450300566EF4 /* HomeViewModel.swift */; };
		899F484429DF128200E7E1E4 /* MainTabView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 899F484329DF128200E7E1E4 /* MainTabView.swift */; };
		89AAFEA129DB2672002D348E /* CacheManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89AAFE9F29DB2672002D348E /* CacheManager.swift */; };
		89AAFEA229DB2672002D348E /* CacheManagerImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89AAFEA029DB2672002D348E /* CacheManagerImpl.swift */; };
		89AAFEA729DB2AC4002D348E /* WelcomeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89AAFEA629DB2AC4002D348E /* WelcomeView.swift */; };
		89ABAA592A97B29C00721045 /* PdfDocument+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89ABAA582A97B29C00721045 /* PdfDocument+Extensions.swift */; };
		89B72A3329DADC790076884F /* SettingsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89B72A3229DADC790076884F /* SettingsView.swift */; };
		89BB2DB72A7A5EFC009E6738 /* PdfMergeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DB62A7A5EFC009E6738 /* PdfMergeView.swift */; };
		89BB2DB92A7A6050009E6738 /* PdfMergeViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DB82A7A6050009E6738 /* PdfMergeViewModel.swift */; };
		89BB2DBB2A7A7DD7009E6738 /* PdfUnlockViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DBA2A7A7DD7009E6738 /* PdfUnlockViewModel.swift */; };
		89BB2DBD2A7A80A8009E6738 /* PdfUnlockView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DBC2A7A80A8009E6738 /* PdfUnlockView.swift */; };
		89BB2DBF2A7AB0CE009E6738 /* PdfSortViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DBE2A7AB0CE009E6738 /* PdfSortViewModel.swift */; };
		89BB2DC12A7AB4A8009E6738 /* PdfSortView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DC02A7AB4A8009E6738 /* PdfSortView.swift */; };
		89C2500F2A72B2BC00184C45 /* CDPdf.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89C2500E2A72B2BC00184C45 /* CDPdf.swift */; };
		89CD7A9A29D32855003F1C3A /* PdfExpertApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7A9929D32855003F1C3A /* PdfExpertApp.swift */; };
		89CD7AA129D32856003F1C3A /* Preview Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 89CD7AA029D32856003F1C3A /* Preview Assets.xcassets */; };
		89CD7B3029D329B1003F1C3A /* Colors.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 89CD7AAE29D329B1003F1C3A /* Colors.xcassets */; };
		89CD7B3329D329B1003F1C3A /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 89CD7AB229D329B1003F1C3A /* Assets.xcassets */; };
		89CD7B3429D329B1003F1C3A /* Products.plist in Resources */ = {isa = PBXBuildFile; fileRef = 89CD7AB429D329B1003F1C3A /* Products.plist */; };
		89CD7B4A29D329B1003F1C3A /* loading.json in Resources */ = {isa = PBXBuildFile; fileRef = 89CD7ACC29D329B1003F1C3A /* loading.json */; };
		89CD7B4B29D329B1003F1C3A /* AsyncView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7ACF29D329B1003F1C3A /* AsyncView.swift */; };
		89CD7B4C29D329B1003F1C3A /* CircularProgressView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD029D329B1003F1C3A /* CircularProgressView.swift */; };
		89CD7B4D29D329B1003F1C3A /* UnderlyingError.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD129D329B1003F1C3A /* UnderlyingError.swift */; };
		89CD7B4E29D329B1003F1C3A /* LottieView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD229D329B1003F1C3A /* LottieView.swift */; };
		89CD7B4F29D329B1003F1C3A /* ParentalCheck.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD329D329B1003F1C3A /* ParentalCheck.swift */; };
		89CD7B5029D329B1003F1C3A /* String+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD529D329B1003F1C3A /* String+Extensions.swift */; };
		89CD7B5129D329B1003F1C3A /* UIApplication+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD629D329B1003F1C3A /* UIApplication+Extensions.swift */; };
		89CD7B5229D329B1003F1C3A /* View+Alert.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD729D329B1003F1C3A /* View+Alert.swift */; };
		89CD7B5329D329B1003F1C3A /* View+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD829D329B1003F1C3A /* View+Extensions.swift */; };
		89CD7B5429D329B1003F1C3A /* Color+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD929D329B1003F1C3A /* Color+Extensions.swift */; };
		89CD7B5529D329B1003F1C3A /* Enum+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7ADA29D329B1003F1C3A /* Enum+Extensions.swift */; };
		89CD7B5629D329B1003F1C3A /* Async.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7ADB29D329B1003F1C3A /* Async.swift */; };
		89CD7B5729D329B1003F1C3A /* DebugUtils.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7ADC29D329B1003F1C3A /* DebugUtils.swift */; };
		89CD7B5F29D329B1003F1C3A /* StoreImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AE529D329B1003F1C3A /* StoreImpl.swift */; };
		89CD7B6529D329B1003F1C3A /* Store.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AEB29D329B1003F1C3A /* Store.swift */; };
		89CD7B6E29D329B1003F1C3A /* Constants.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AF629D329B1003F1C3A /* Constants.swift */; };
		89CD7B7029D329B1003F1C3A /* FontPalette.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AF929D329B1003F1C3A /* FontPalette.swift */; };
		89CD7B7129D329B1003F1C3A /* ColorPalette.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AFA29D329B1003F1C3A /* ColorPalette.swift */; };
		89CD7B7329D329B1003F1C3A /* SubscribeViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AFD29D329B1003F1C3A /* SubscribeViewModel.swift */; };
		89CD7B9329D329B1003F1C3A /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7B2629D329B1003F1C3A /* ContentView.swift */; };
		89CD7B9729D329B1003F1C3A /* SharedErrors.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7B2C29D329B1003F1C3A /* SharedErrors.swift */; };
		89CD7B9829D329B1003F1C3A /* SubscriptionViewUtility.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7B2D29D329B1003F1C3A /* SubscriptionViewUtility.swift */; };
		89CD7B9929D329B1003F1C3A /* View+Preview.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7B2E29D329B1003F1C3A /* View+Preview.swift */; };
		89CD7B9A29D329B1003F1C3A /* View+Internal.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7B2F29D329B1003F1C3A /* View+Internal.swift */; };
		89CD7BA529D32C52003F1C3A /* Lottie in Frameworks */ = {isa = PBXBuildFile; productRef = 89CD7BA429D32C52003F1C3A /* Lottie */; };
		89CD7BA829D32C72003F1C3A /* Factory in Frameworks */ = {isa = PBXBuildFile; productRef = 89CD7BA729D32C72003F1C3A /* Factory */; };
		89CD7BAB29D32CE5003F1C3A /* FirebaseAnalyticsSwift in Frameworks */ = {isa = PBXBuildFile; productRef = 89CD7BAA29D32CE5003F1C3A /* FirebaseAnalyticsSwift */; };
		89CD7BAD29D32CE5003F1C3A /* FirebaseCrashlytics in Frameworks */ = {isa = PBXBuildFile; productRef = 89CD7BAC29D32CE5003F1C3A /* FirebaseCrashlytics */; };
		89CD7BB629D32E69003F1C3A /* MainCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7BB429D32E69003F1C3A /* MainCoordinator.swift */; };
		89CD7BBB29D330FB003F1C3A /* HomeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7BBA29D330FB003F1C3A /* HomeView.swift */; };
		89CD7BBD29D331AA003F1C3A /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7BBC29D331AA003F1C3A /* AppDelegate.swift */; };
		89D1FE7E2A84D428009AC57C /* SubscriptionPickerPlanListView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89D1FE7D2A84D428009AC57C /* SubscriptionPickerPlanListView.swift */; };
		89D1FE802A84D76B009AC57C /* FullScreenClearBackground.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89D1FE7F2A84D76B009AC57C /* FullScreenClearBackground.swift */; };
		89D79DF82A654DC80086A8E5 /* Poppins-ExtraLightItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DE62A654DC70086A8E5 /* Poppins-ExtraLightItalic.ttf */; };
		89D79DF92A654DC80086A8E5 /* Poppins-SemiBold.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DE72A654DC70086A8E5 /* Poppins-SemiBold.ttf */; };
		89D79DFA2A654DC80086A8E5 /* Poppins-Black.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DE82A654DC80086A8E5 /* Poppins-Black.ttf */; };
		89D79DFB2A654DC80086A8E5 /* Poppins-ThinItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DE92A654DC80086A8E5 /* Poppins-ThinItalic.ttf */; };
		89D79DFC2A654DC80086A8E5 /* Poppins-Light.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DEA2A654DC80086A8E5 /* Poppins-Light.ttf */; };
		89D79DFD2A654DC80086A8E5 /* Poppins-BlackItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DEB2A654DC80086A8E5 /* Poppins-BlackItalic.ttf */; };
		89D79DFE2A654DC80086A8E5 /* Poppins-Medium.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DEC2A654DC80086A8E5 /* Poppins-Medium.ttf */; };
		89D79DFF2A654DC80086A8E5 /* Poppins-Italic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DED2A654DC80086A8E5 /* Poppins-Italic.ttf */; };
		89D79E002A654DC80086A8E5 /* Poppins-ExtraBold.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DEE2A654DC80086A8E5 /* Poppins-ExtraBold.ttf */; };
		89D79E012A654DC80086A8E5 /* Poppins-Thin.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DEF2A654DC80086A8E5 /* Poppins-Thin.ttf */; };
		89D79E022A654DC80086A8E5 /* Poppins-ExtraLight.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF02A654DC80086A8E5 /* Poppins-ExtraLight.ttf */; };
		89D79E032A654DC80086A8E5 /* Poppins-ExtraBoldItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF12A654DC80086A8E5 /* Poppins-ExtraBoldItalic.ttf */; };
		89D79E042A654DC80086A8E5 /* Poppins-LightItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF22A654DC80086A8E5 /* Poppins-LightItalic.ttf */; };
		89D79E052A654DC80086A8E5 /* Poppins-Regular.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF32A654DC80086A8E5 /* Poppins-Regular.ttf */; };
		89D79E062A654DC80086A8E5 /* Poppins-MediumItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF42A654DC80086A8E5 /* Poppins-MediumItalic.ttf */; };
		89D79E072A654DC80086A8E5 /* Poppins-BoldItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF52A654DC80086A8E5 /* Poppins-BoldItalic.ttf */; };
		89D79E082A654DC80086A8E5 /* Poppins-Bold.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF62A654DC80086A8E5 /* Poppins-Bold.ttf */; };
		89D79E092A654DC80086A8E5 /* Poppins-SemiBoldItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF72A654DC80086A8E5 /* Poppins-SemiBoldItalic.ttf */; };
		89E55BDC29DC64840073F268 /* AnalyticsManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E55BD829DC64840073F268 /* AnalyticsManager.swift */; };
		89E55BDE29DC64840073F268 /* FirebaseAnalyticsPlatform.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E55BDA29DC64840073F268 /* FirebaseAnalyticsPlatform.swift */; };
		89E55BDF29DC64840073F268 /* AnalyticsManagerImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E55BDB29DC64840073F268 /* AnalyticsManagerImpl.swift */; };
		89E55BE229DC66240073F268 /* AnalyticsPlatform.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E55BE129DC66240073F268 /* AnalyticsPlatform.swift */; };
		89E601622A829556009492DA /* SubscriptionPickerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E601612A829556009492DA /* SubscriptionPickerView.swift */; };
		89E601642A8295A2009492DA /* SubscriptionPickerViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E601632A8295A2009492DA /* SubscriptionPickerViewModel.swift */; };
		89EBC9052A83CC3000BDBBD4 /* SubscriptionFreeTrialToggleView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89EBC9042A83CC3000BDBBD4 /* SubscriptionFreeTrialToggleView.swift */; };
		89EBC9072A83D0DB00BDBBD4 /* SubscriptionPickerPlanView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89EBC9062A83D0DB00BDBBD4 /* SubscriptionPickerPlanView.swift */; };
		89ED72BB2A9F6B3A004F541F /* AdSupport.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 89ED72B82A9F69E5004F541F /* AdSupport.framework */; };
		89F9E4F92A95FEEE0001D48B /* PDFImageExtractor.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89F9E4F82A95FEED0001D48B /* PDFImageExtractor.swift */; };
		89F9E4FB2A9606ED0001D48B /* PdfImageViewerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89F9E4FA2A9606ED0001D48B /* PdfImageViewerView.swift */; };
		89F9E4FD2A9635EC0001D48B /* ZoomImageModifier.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89F9E4FC2A9635EC0001D48B /* ZoomImageModifier.swift */; };
		C999928D2DAF4C9B003C3643 /* GoogleService-Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = C999928C2DAF4C9B003C3643 /* GoogleService-Info.plist */; };
		C9CEF5DD2DAF973100980C8A /* Montserrat-ExtraBold.ttf in Resources */ = {isa = PBXBuildFile; fileRef = C9CEF5DC2DAF973100980C8A /* Montserrat-ExtraBold.ttf */; };
		C9CEF5DF2DAF974500980C8A /* Montserrat-Medium.ttf in Resources */ = {isa = PBXBuildFile; fileRef = C9CEF5DE2DAF974500980C8A /* Montserrat-Medium.ttf */; };
		C9CEF5E12DAF975200980C8A /* Montserrat-Regular.ttf in Resources */ = {isa = PBXBuildFile; fileRef = C9CEF5E02DAF975200980C8A /* Montserrat-Regular.ttf */; };
		C9CEF5E32DAF975A00980C8A /* Montserrat-Bold.ttf in Resources */ = {isa = PBXBuildFile; fileRef = C9CEF5E22DAF975A00980C8A /* Montserrat-Bold.ttf */; };
		C9CEF5E72DB02DBA00980C8A /* ShareFileExtension.appex in Embed Foundation Extensions */ = {isa = PBXBuildFile; fileRef = 895C1BAD2A04FA53005EA190 /* ShareFileExtension.appex */; settings = {ATTRIBUTES = (RemoveHeadersOnCopy, ); }; };
		C9CEF5EC2DB03CCE00980C8A /* SceneDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = C9CEF5EB2DB03CCB00980C8A /* SceneDelegate.swift */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		C9CEF5E82DB02DBA00980C8A /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 89CD7A8E29D32855003F1C3A /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 895C1BAC2A04FA53005EA190;
			remoteInfo = ShareFileExtension;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		C9CEF5EA2DB02DBB00980C8A /* Embed Foundation Extensions */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 13;
			files = (
				C9CEF5E72DB02DBA00980C8A /* ShareFileExtension.appex in Embed Foundation Extensions */,
			);
			name = "Embed Foundation Extensions";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		8902898C29DC1F10007E6372 /* PageControl.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PageControl.swift; sourceTree = "<group>"; };
		89127AA02A177E370059005F /* PencilKitView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PencilKitView.swift; sourceTree = "<group>"; };
		89127AA22A177F170059005F /* PdfSignatureCanvasView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignatureCanvasView.swift; sourceTree = "<group>"; };
		89127AA42A17A3600059005F /* PdfSignatureCanvasViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignatureCanvasViewModel.swift; sourceTree = "<group>"; };
		89127AA62A17C1980059005F /* PencilKit+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "PencilKit+Extensions.swift"; sourceTree = "<group>"; };
		891AE58A2A03E80300DBC246 /* ObservableObject+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ObservableObject+Extensions.swift"; sourceTree = "<group>"; };
		892201D82A0BA64600832CF2 /* ImageAnnotationStamp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImageAnnotationStamp.swift; sourceTree = "<group>"; };
		892201DB2A0BA70300832CF2 /* PdfSignatureView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignatureView.swift; sourceTree = "<group>"; };
		892201DD2A0BA72D00832CF2 /* PdfSignatureViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignatureViewModel.swift; sourceTree = "<group>"; };
		8928F3D02A30BAFB001C1853 /* PickedImage.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PickedImage.swift; sourceTree = "<group>"; };
		892CC6912AAA23AE000DEC21 /* CDSuggestedFields.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CDSuggestedFields.swift; sourceTree = "<group>"; };
		892CC6932AAA243E000DEC21 /* SuggestedFields+Persistable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "SuggestedFields+Persistable.swift"; sourceTree = "<group>"; };
		892CC6952AAA2641000DEC21 /* SuggestedFieldsFormView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SuggestedFieldsFormView.swift; sourceTree = "<group>"; };
		892CC6972AAA2660000DEC21 /* SuggestedFieldsFormViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SuggestedFieldsFormViewModel.swift; sourceTree = "<group>"; };
		892E404E2A25E5D9000EEE23 /* PDFAnnotation+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "PDFAnnotation+Extensions.swift"; sourceTree = "<group>"; };
		8932ECE42A20DC7700CBCD7A /* PdfFillFormView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfFillFormView.swift; sourceTree = "<group>"; };
		8932ECE62A20DCB900CBCD7A /* PdfFillFormViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfFillFormViewModel.swift; sourceTree = "<group>"; };
		8932ECE82A20F10500CBCD7A /* TextResizableView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TextResizableView.swift; sourceTree = "<group>"; };
		8933490B2A24AE880005D484 /* PdfKitViewBinder.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfKitViewBinder.swift; sourceTree = "<group>"; };
		8934ACC62A6AE96700F6CDA8 /* ChatPdfInitParams.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfInitParams.swift; sourceTree = "<group>"; };
		8936AA2A2A67F975005F6C73 /* ci_post_clone.sh */ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = ci_post_clone.sh; sourceTree = "<group>"; };
		8936AA302A682812005F6C73 /* ProjectInfo.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = ProjectInfo.plist; sourceTree = "<group>"; };
		8936AA322A6828C9005F6C73 /* ProjectInfo.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ProjectInfo.swift; sourceTree = "<group>"; };
		8936AA352A68299B005F6C73 /* ChatPdfManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ChatPdfManager.swift; sourceTree = "<group>"; };
		8936AA362A68299B005F6C73 /* ChatPdfManagerMock.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ChatPdfManagerMock.swift; sourceTree = "<group>"; };
		8936AA3B2A682CDA005F6C73 /* ChatPdfSelectionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfSelectionView.swift; sourceTree = "<group>"; };
		8936AA3D2A682F8E005F6C73 /* ChatPdfSelectionViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfSelectionViewModel.swift; sourceTree = "<group>"; };
		8936AA3F2A683FB5005F6C73 /* ImportOption.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImportOption.swift; sourceTree = "<group>"; };
		8936AA412A6840D1005F6C73 /* ChatPdfView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfView.swift; sourceTree = "<group>"; };
		8936AA432A684128005F6C73 /* ChatPdfViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfViewModel.swift; sourceTree = "<group>"; };
		893875002A7BDD3B00267AFD /* LoadingView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LoadingView.swift; sourceTree = "<group>"; };
		893AAFCA2A39B2AF00EF9B00 /* FormSheet.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FormSheet.swift; sourceTree = "<group>"; };
		893B04BC2AA9C2C100F86813 /* CoreGraphics+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "CoreGraphics+Extensions.swift"; sourceTree = "<group>"; };
		893BE52C2A6A78BB004B05B9 /* ChatPdfManagerImpl.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfManagerImpl.swift; sourceTree = "<group>"; };
		893BE52E2A6A7C0C004B05B9 /* NetworkUtility.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NetworkUtility.swift; sourceTree = "<group>"; };
		893BE5342A6A96F5004B05B9 /* ChatPdfRef+Decodable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ChatPdfRef+Decodable.swift"; sourceTree = "<group>"; };
		893BE5362A6A9708004B05B9 /* ChatPdfMessage+Decodable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ChatPdfMessage+Decodable.swift"; sourceTree = "<group>"; };
		893C8FC829DED190000E35BD /* ArchiveView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ArchiveView.swift; sourceTree = "<group>"; };
		893C8FCA29DED1AF000E35BD /* ArchiveViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ArchiveViewModel.swift; sourceTree = "<group>"; };
		893C8FCD29DED254000E35BD /* PdfExpert.xcdatamodel */ = {isa = PBXFileReference; lastKnownFileType = wrapper.xcdatamodel; path = PdfExpert.xcdatamodel; sourceTree = "<group>"; };
		893C8FCF29DED278000E35BD /* Persistence.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Persistence.swift; sourceTree = "<group>"; };
		893C8FD129DED2E9000E35BD /* Repository.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Repository.swift; sourceTree = "<group>"; };
		893C8FD229DED2E9000E35BD /* RepositoryImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = RepositoryImpl.swift; sourceTree = "<group>"; };
		893C8FDD29DED7F4000E35BD /* PdfUtility.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfUtility.swift; sourceTree = "<group>"; };
		893C8FE029DEDAF4000E35BD /* test.pdf */ = {isa = PBXFileReference; lastKnownFileType = image.pdf; path = test.pdf; sourceTree = "<group>"; };
		893C8FE229DF0145000E35BD /* PdfExpert.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = PdfExpert.entitlements; sourceTree = "<group>"; };
		893DE8D929E7F85C0043C02C /* SubscriptionPairsViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPairsViewModel.swift; sourceTree = "<group>"; };
		893DE8DB29E7F9A10043C02C /* SubscriptionVerticalViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionVerticalViewModel.swift; sourceTree = "<group>"; };
		893DE8DD29E832B90043C02C /* LocalProductionProducts.storekit */ = {isa = PBXFileReference; lastKnownFileType = text; path = LocalProductionProducts.storekit; sourceTree = "<group>"; };
		893E849029D5874D00F6B99A /* CameraView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CameraView.swift; sourceTree = "<group>"; };
		893E849329D5878E00F6B99A /* CameraViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CameraViewModel.swift; sourceTree = "<group>"; };
		893E849629D5944E00F6B99A /* PhotoCaptureProcessor.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PhotoCaptureProcessor.swift; sourceTree = "<group>"; };
		893E849729D5944E00F6B99A /* CameraService+Enums.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "CameraService+Enums.swift"; sourceTree = "<group>"; };
		893E849829D5944E00F6B99A /* CameraPreviewView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CameraPreviewView.swift; sourceTree = "<group>"; };
		893E849929D5944E00F6B99A /* ImageResizer.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ImageResizer.swift; sourceTree = "<group>"; };
		893E849A29D5944E00F6B99A /* CameraService.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CameraService.swift; sourceTree = "<group>"; };
		893E849B29D5944E00F6B99A /* CameraService+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "CameraService+Extensions.swift"; sourceTree = "<group>"; };
		893E84A529D5C5E200F6B99A /* ActivityViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ActivityViewController.swift; sourceTree = "<group>"; };
		893EB5022AA71FFD0066914E /* BranchAnalyticsPlatform.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BranchAnalyticsPlatform.swift; sourceTree = "<group>"; };
		893EB5042AA722EF0066914E /* StoreKit+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "StoreKit+Extensions.swift"; sourceTree = "<group>"; };
		893EB5062AA723C80066914E /* AnalyticsDefaultParameters.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AnalyticsDefaultParameters.swift; sourceTree = "<group>"; };
		893ED9CF2A6920F2004EE67C /* ChatPdfRef.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfRef.swift; sourceTree = "<group>"; };
		893ED9D12A6926E8004EE67C /* ChatPdfMessage.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfMessage.swift; sourceTree = "<group>"; };
		893ED9D32A692805004EE67C /* CombineUtils.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CombineUtils.swift; sourceTree = "<group>"; };
		893ED9D72A693013004EE67C /* MessageView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MessageView.swift; sourceTree = "<group>"; };
		893ED9D82A693013004EE67C /* MessageIndicatorView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MessageIndicatorView.swift; sourceTree = "<group>"; };
		89407EF02AA8ADD200169801 /* GalleryImageProviderFlow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GalleryImageProviderFlow.swift; sourceTree = "<group>"; };
		89407EF22AA8B0C800169801 /* GalleryImageProviderFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GalleryImageProviderFlowView.swift; sourceTree = "<group>"; };
		89407EF42AA8BDE600169801 /* CameraImageProviderFlow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CameraImageProviderFlow.swift; sourceTree = "<group>"; };
		89407EF62AA8BEC200169801 /* CameraImageProviderFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CameraImageProviderFlowView.swift; sourceTree = "<group>"; };
		89407EFB2AA8D22D00169801 /* ImageCropFlow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImageCropFlow.swift; sourceTree = "<group>"; };
		89407EFD2AA8D23B00169801 /* ImageCropFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImageCropFlowView.swift; sourceTree = "<group>"; };
		89407EFF2AA8D54800169801 /* ImageCropper.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ImageCropper.swift; sourceTree = "<group>"; };
		8940FB902A710D8D00A00D8D /* AddPasswordView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AddPasswordView.swift; sourceTree = "<group>"; };
		89429F852A9C8ECC00465420 /* PdfSignaturePickerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignaturePickerView.swift; sourceTree = "<group>"; };
		89429F872A9C8EFC00465420 /* PdfSignaturePickerViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignaturePickerViewModel.swift; sourceTree = "<group>"; };
		89429F892A9C937300465420 /* Signature.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Signature.swift; sourceTree = "<group>"; };
		89429F8B2A9C937C00465420 /* CDSignature.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CDSignature.swift; sourceTree = "<group>"; };
		89429F902A9CFFDC00465420 /* Persistable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Persistable.swift; sourceTree = "<group>"; };
		89429F922A9CFFF100465420 /* Pdf+Persistable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Pdf+Persistable.swift"; sourceTree = "<group>"; };
		89429F942A9D001A00465420 /* Signature+Persistable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Signature+Persistable.swift"; sourceTree = "<group>"; };
		89431FC52A9900740042A636 /* MathUtils.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MathUtils.swift; sourceTree = "<group>"; };
		89436AB729E5556600060605 /* PdfCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfCoordinator.swift; sourceTree = "<group>"; };
		89436ABA29E557D500060605 /* PdfFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfFlowView.swift; sourceTree = "<group>"; };
		89436ABC29E5586600060605 /* PdfEditView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfEditView.swift; sourceTree = "<group>"; };
		89436ABE29E55EA000060605 /* Pdf.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Pdf.swift; sourceTree = "<group>"; };
		89436AC229E59C0E00060605 /* PdfEditViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfEditViewModel.swift; sourceTree = "<group>"; };
		89436AC629E5B99100060605 /* PdfKitView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfKitView.swift; sourceTree = "<group>"; };
		89436D182A936C9F000868B5 /* PdfReadView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfReadView.swift; sourceTree = "<group>"; };
		89436D1A2A939CBB000868B5 /* PdfReadViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfReadViewModel.swift; sourceTree = "<group>"; };
		89436D1C2A93AE76000868B5 /* PdfReaderView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfReaderView.swift; sourceTree = "<group>"; };
		89436D1E2A93AEB4000868B5 /* PdfReaderViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfReaderViewModel.swift; sourceTree = "<group>"; };
		89436D202A93B97E000868B5 /* NSAttributedString+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "NSAttributedString+Extensions.swift"; sourceTree = "<group>"; };
		89436D222A93C1CE000868B5 /* PdfPageSelectionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfPageSelectionView.swift; sourceTree = "<group>"; };
		8945D2BB2A03C41000AFF51A /* PdfScanUtility.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfScanUtility.swift; sourceTree = "<group>"; };
		89460C5F29DAC36600E39BAC /* SubscriptionErrorView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionErrorView.swift; sourceTree = "<group>"; };
		89467AD62A9E4C6B00FC01FC /* Deeplink.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Deeplink.swift; sourceTree = "<group>"; };
		894827B12AA5D68D00030C4E /* AttributionManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AttributionManager.swift; sourceTree = "<group>"; };
		894827B32AA5D6FF00030C4E /* AttibutionManagerImpl.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AttibutionManagerImpl.swift; sourceTree = "<group>"; };
		894827B82AA5DCE400030C4E /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		894AC3632A02952A00BA5553 /* Foundation+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Foundation+Extensions.swift"; sourceTree = "<group>"; };
		894B019E2A0902BC00FF6198 /* ImportTutorialView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImportTutorialView.swift; sourceTree = "<group>"; };
		894B01A02A09030000FF6198 /* ImportTutorialPageView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImportTutorialPageView.swift; sourceTree = "<group>"; };
		894C4A682AA0C04B0001F51E /* PopupView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PopupView.swift; sourceTree = "<group>"; };
		894C4A6A2AA0C23F0001F51E /* PreReviewPopupView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PreReviewPopupView.swift; sourceTree = "<group>"; };
		894C4A6D2AA0CB470001F51E /* ReviewFlow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ReviewFlow.swift; sourceTree = "<group>"; };
		894C4A6F2AA0CCFC0001F51E /* ReviewFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ReviewFlowView.swift; sourceTree = "<group>"; };
		894C4A712AA0DB9A0001F51E /* PreReviewPopupLowRateView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PreReviewPopupLowRateView.swift; sourceTree = "<group>"; };
		894CB09D2A851FE50008008A /* ChatPdfSetupData.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfSetupData.swift; sourceTree = "<group>"; };
		894CB09F2A8520AD0008008A /* ChatPdfSetupData+Decodable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ChatPdfSetupData+Decodable.swift"; sourceTree = "<group>"; };
		894D485729D42C9D002B0230 /* OptionItemView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OptionItemView.swift; sourceTree = "<group>"; };
		894D485929D42CC5002B0230 /* OptionListView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OptionListView.swift; sourceTree = "<group>"; };
		894D485B29D42FE1002B0230 /* RoundedCorner.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RoundedCorner.swift; sourceTree = "<group>"; };
		89504A452A448252000BCACD /* PdfFillWidgetView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfFillWidgetView.swift; sourceTree = "<group>"; };
		89504A472A44829C000BCACD /* PdfFillWidgetViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfFillWidgetViewModel.swift; sourceTree = "<group>"; };
		8955ED912A1F61A9009985EE /* OnboardingView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OnboardingView.swift; sourceTree = "<group>"; };
		8955ED932A1F61BD009985EE /* OnboardingPageView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OnboardingPageView.swift; sourceTree = "<group>"; };
		8955ED952A1F73DC009985EE /* OnboardingViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OnboardingViewModel.swift; sourceTree = "<group>"; };
		8957FBA72A77C646008B31ED /* PdfShareCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfShareCoordinator.swift; sourceTree = "<group>"; };
		8957FBA92A77E6F7008B31ED /* PdfShareView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfShareView.swift; sourceTree = "<group>"; };
		8957FBAB2A7801BA008B31ED /* PdfCompressionPickerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfCompressionPickerView.swift; sourceTree = "<group>"; };
		895C1BAD2A04FA53005EA190 /* ShareFileExtension.appex */ = {isa = PBXFileReference; explicitFileType = "wrapper.app-extension"; includeInIndex = 0; path = ShareFileExtension.appex; sourceTree = BUILT_PRODUCTS_DIR; };
		895C1BAF2A04FA53005EA190 /* ShareViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ShareViewController.swift; sourceTree = "<group>"; };
		895C1BB22A04FA53005EA190 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/MainInterface.storyboard; sourceTree = "<group>"; };
		895C1BB42A04FA53005EA190 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		895C1BBC2A04FD67005EA190 /* ShareFileExtension.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = ShareFileExtension.entitlements; sourceTree = "<group>"; };
		895C1BBF2A051261005EA190 /* SharedStorage.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SharedStorage.swift; sourceTree = "<group>"; };
		895FE2C329D6D7E500A99D5B /* ScannerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ScannerView.swift; sourceTree = "<group>"; };
		895FE2C529D6E17600A99D5B /* AnimationPalette.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AnimationPalette.swift; sourceTree = "<group>"; };
		895FE2C729D6E7D900A99D5B /* ProductionProducts.storekit */ = {isa = PBXFileReference; lastKnownFileType = text; path = ProductionProducts.storekit; sourceTree = "<group>"; };
		895FE2CA29D6E9B800A99D5B /* SubscriptionPairsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPairsView.swift; sourceTree = "<group>"; };
		895FE2CC29D724B900A99D5B /* SubscriptionPairsItemView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPairsItemView.swift; sourceTree = "<group>"; };
		8962D6052A9E28FB008426A2 /* PdfSignaturePrioviderFlow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignaturePrioviderFlow.swift; sourceTree = "<group>"; };
		8962D6072A9E2A57008426A2 /* PdfSignatureProviderFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignatureProviderFlowView.swift; sourceTree = "<group>"; };
		8966B6F12AA9FCE0005E6DED /* SuggestedFields.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SuggestedFields.swift; sourceTree = "<group>"; };
		896876192A7CE87A0014A320 /* PdfSplitViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSplitViewModel.swift; sourceTree = "<group>"; };
		8968761B2A7CEB650014A320 /* PdfImportViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfImportViewModel.swift; sourceTree = "<group>"; };
		8968761D2A7CEE320014A320 /* PdfImportView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfImportView.swift; sourceTree = "<group>"; };
		8968761F2A7CF1E00014A320 /* PdfImportMultipleViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfImportMultipleViewModel.swift; sourceTree = "<group>"; };
		896876212A7CF3220014A320 /* PdfImportMultipleView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfImportMultipleView.swift; sourceTree = "<group>"; };
		896876232A7D05040014A320 /* PdfSplitView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSplitView.swift; sourceTree = "<group>"; };
		896876252A7D2EB80014A320 /* PdfPageRangeEditorViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfPageRangeEditorViewModel.swift; sourceTree = "<group>"; };
		896876272A7D2EC20014A320 /* PdfPageRangeEditorView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfPageRangeEditorView.swift; sourceTree = "<group>"; };
		896CCF6C2A28910B008F268E /* SizePrinter.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SizePrinter.swift; sourceTree = "<group>"; };
		896CCF6E2A28AEAC008F268E /* UIFont+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "UIFont+Extensions.swift"; sourceTree = "<group>"; };
		897911EC29E70541008B7088 /* SubscriptionVerticalView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionVerticalView.swift; sourceTree = "<group>"; };
		897911EE29E70558008B7088 /* SubscriptionVerticalItemView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionVerticalItemView.swift; sourceTree = "<group>"; };
		897967852A73E59B00E91F8E /* URL+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "URL+Extensions.swift"; sourceTree = "<group>"; };
		89847AE02A1BA947000EC14B /* GoogleService-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = "GoogleService-Info.plist"; sourceTree = "<group>"; };
		89851B5D2A13DB1A00ABF58F /* ImageResizableView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImageResizableView.swift; sourceTree = "<group>"; };
		89883B012A45CB9800E684B6 /* InfoTemplate.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = InfoTemplate.plist; sourceTree = "<group>"; };
		8991485029E851B500DD01F2 /* ConfigService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ConfigService.swift; sourceTree = "<group>"; };
		8991485229E851BD00DD01F2 /* RemoteConfigManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RemoteConfigManager.swift; sourceTree = "<group>"; };
		89923E5D29D4350F00E246FC /* AppTrackingTransparencyImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppTrackingTransparencyImpl.swift; sourceTree = "<group>"; };
		89923E5E29D4350F00E246FC /* AppTrackingTransparency.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppTrackingTransparency.swift; sourceTree = "<group>"; };
		89923E6829D46A9900E246FC /* FilePicker.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FilePicker.swift; sourceTree = "<group>"; };
		89923E6A29D47B9E00E246FC /* pdf-scanning.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = "pdf-scanning.json"; sourceTree = "<group>"; };
		8995694129D33B1300566EF4 /* HomeItemView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HomeItemView.swift; sourceTree = "<group>"; };
		8995694329D3450300566EF4 /* HomeViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HomeViewModel.swift; sourceTree = "<group>"; };
		899F484329DF128200E7E1E4 /* MainTabView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainTabView.swift; sourceTree = "<group>"; };
		89AA36082A1BC5FD0077A70A /* StagingProducts.storekit */ = {isa = PBXFileReference; lastKnownFileType = text; path = StagingProducts.storekit; sourceTree = "<group>"; };
		89AA360A2A1BC8560077A70A /* LocalStagingProducts.storekit */ = {isa = PBXFileReference; lastKnownFileType = text; path = LocalStagingProducts.storekit; sourceTree = "<group>"; };
		89AAFE9F29DB2672002D348E /* CacheManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CacheManager.swift; sourceTree = "<group>"; };
		89AAFEA029DB2672002D348E /* CacheManagerImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CacheManagerImpl.swift; sourceTree = "<group>"; };
		89AAFEA629DB2AC4002D348E /* WelcomeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WelcomeView.swift; sourceTree = "<group>"; };
		89ABAA582A97B29C00721045 /* PdfDocument+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "PdfDocument+Extensions.swift"; sourceTree = "<group>"; };
		89B72A2D29DACBBF0076884F /* EmptyProducts.storekit */ = {isa = PBXFileReference; lastKnownFileType = text; path = EmptyProducts.storekit; sourceTree = "<group>"; };
		89B72A3229DADC790076884F /* SettingsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsView.swift; sourceTree = "<group>"; };
		89BB2DB62A7A5EFC009E6738 /* PdfMergeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfMergeView.swift; sourceTree = "<group>"; };
		89BB2DB82A7A6050009E6738 /* PdfMergeViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfMergeViewModel.swift; sourceTree = "<group>"; };
		89BB2DBA2A7A7DD7009E6738 /* PdfUnlockViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfUnlockViewModel.swift; sourceTree = "<group>"; };
		89BB2DBC2A7A80A8009E6738 /* PdfUnlockView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfUnlockView.swift; sourceTree = "<group>"; };
		89BB2DBE2A7AB0CE009E6738 /* PdfSortViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSortViewModel.swift; sourceTree = "<group>"; };
		89BB2DC02A7AB4A8009E6738 /* PdfSortView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSortView.swift; sourceTree = "<group>"; };
		89C2500E2A72B2BC00184C45 /* CDPdf.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CDPdf.swift; sourceTree = "<group>"; };
		89CD7A9629D32855003F1C3A /* PdfExpert.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = PdfExpert.app; sourceTree = BUILT_PRODUCTS_DIR; };
		89CD7A9929D32855003F1C3A /* PdfExpertApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfExpertApp.swift; sourceTree = "<group>"; };
		89CD7AA029D32856003F1C3A /* Preview Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = "Preview Assets.xcassets"; sourceTree = "<group>"; };
		89CD7AA729D32856003F1C3A /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		89CD7AAE29D329B1003F1C3A /* Colors.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Colors.xcassets; sourceTree = "<group>"; };
		89CD7AB229D329B1003F1C3A /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		89CD7AB429D329B1003F1C3A /* Products.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Products.plist; sourceTree = "<group>"; };
		89CD7ACC29D329B1003F1C3A /* loading.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = loading.json; sourceTree = "<group>"; };
		89CD7ACF29D329B1003F1C3A /* AsyncView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AsyncView.swift; sourceTree = "<group>"; };
		89CD7AD029D329B1003F1C3A /* CircularProgressView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CircularProgressView.swift; sourceTree = "<group>"; };
		89CD7AD129D329B1003F1C3A /* UnderlyingError.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = UnderlyingError.swift; sourceTree = "<group>"; };
		89CD7AD229D329B1003F1C3A /* LottieView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = LottieView.swift; sourceTree = "<group>"; };
		89CD7AD329D329B1003F1C3A /* ParentalCheck.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ParentalCheck.swift; sourceTree = "<group>"; };
		89CD7AD529D329B1003F1C3A /* String+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "String+Extensions.swift"; sourceTree = "<group>"; };
		89CD7AD629D329B1003F1C3A /* UIApplication+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "UIApplication+Extensions.swift"; sourceTree = "<group>"; };
		89CD7AD729D329B1003F1C3A /* View+Alert.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "View+Alert.swift"; sourceTree = "<group>"; };
		89CD7AD829D329B1003F1C3A /* View+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "View+Extensions.swift"; sourceTree = "<group>"; };
		89CD7AD929D329B1003F1C3A /* Color+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "Color+Extensions.swift"; sourceTree = "<group>"; };
		89CD7ADA29D329B1003F1C3A /* Enum+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "Enum+Extensions.swift"; sourceTree = "<group>"; };
		89CD7ADB29D329B1003F1C3A /* Async.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Async.swift; sourceTree = "<group>"; };
		89CD7ADC29D329B1003F1C3A /* DebugUtils.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = DebugUtils.swift; sourceTree = "<group>"; };
		89CD7AE529D329B1003F1C3A /* StoreImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = StoreImpl.swift; sourceTree = "<group>"; };
		89CD7AEB29D329B1003F1C3A /* Store.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Store.swift; sourceTree = "<group>"; };
		89CD7AF629D329B1003F1C3A /* Constants.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Constants.swift; sourceTree = "<group>"; };
		89CD7AF929D329B1003F1C3A /* FontPalette.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = FontPalette.swift; sourceTree = "<group>"; };
		89CD7AFA29D329B1003F1C3A /* ColorPalette.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ColorPalette.swift; sourceTree = "<group>"; };
		89CD7AFD29D329B1003F1C3A /* SubscribeViewModel.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SubscribeViewModel.swift; sourceTree = "<group>"; };
		89CD7B2629D329B1003F1C3A /* ContentView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
		89CD7B2C29D329B1003F1C3A /* SharedErrors.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SharedErrors.swift; sourceTree = "<group>"; };
		89CD7B2D29D329B1003F1C3A /* SubscriptionViewUtility.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SubscriptionViewUtility.swift; sourceTree = "<group>"; };
		89CD7B2E29D329B1003F1C3A /* View+Preview.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "View+Preview.swift"; sourceTree = "<group>"; };
		89CD7B2F29D329B1003F1C3A /* View+Internal.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "View+Internal.swift"; sourceTree = "<group>"; };
		89CD7BB429D32E69003F1C3A /* MainCoordinator.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MainCoordinator.swift; sourceTree = "<group>"; };
		89CD7BBA29D330FB003F1C3A /* HomeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HomeView.swift; sourceTree = "<group>"; };
		89CD7BBC29D331AA003F1C3A /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		89D1FE7D2A84D428009AC57C /* SubscriptionPickerPlanListView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPickerPlanListView.swift; sourceTree = "<group>"; };
		89D1FE7F2A84D76B009AC57C /* FullScreenClearBackground.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FullScreenClearBackground.swift; sourceTree = "<group>"; };
		89D79DE62A654DC70086A8E5 /* Poppins-ExtraLightItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-ExtraLightItalic.ttf"; sourceTree = "<group>"; };
		89D79DE72A654DC70086A8E5 /* Poppins-SemiBold.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-SemiBold.ttf"; sourceTree = "<group>"; };
		89D79DE82A654DC80086A8E5 /* Poppins-Black.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Black.ttf"; sourceTree = "<group>"; };
		89D79DE92A654DC80086A8E5 /* Poppins-ThinItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-ThinItalic.ttf"; sourceTree = "<group>"; };
		89D79DEA2A654DC80086A8E5 /* Poppins-Light.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Light.ttf"; sourceTree = "<group>"; };
		89D79DEB2A654DC80086A8E5 /* Poppins-BlackItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-BlackItalic.ttf"; sourceTree = "<group>"; };
		89D79DEC2A654DC80086A8E5 /* Poppins-Medium.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Medium.ttf"; sourceTree = "<group>"; };
		89D79DED2A654DC80086A8E5 /* Poppins-Italic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Italic.ttf"; sourceTree = "<group>"; };
		89D79DEE2A654DC80086A8E5 /* Poppins-ExtraBold.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-ExtraBold.ttf"; sourceTree = "<group>"; };
		89D79DEF2A654DC80086A8E5 /* Poppins-Thin.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Thin.ttf"; sourceTree = "<group>"; };
		89D79DF02A654DC80086A8E5 /* Poppins-ExtraLight.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-ExtraLight.ttf"; sourceTree = "<group>"; };
		89D79DF12A654DC80086A8E5 /* Poppins-ExtraBoldItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-ExtraBoldItalic.ttf"; sourceTree = "<group>"; };
		89D79DF22A654DC80086A8E5 /* Poppins-LightItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-LightItalic.ttf"; sourceTree = "<group>"; };
		89D79DF32A654DC80086A8E5 /* Poppins-Regular.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Regular.ttf"; sourceTree = "<group>"; };
		89D79DF42A654DC80086A8E5 /* Poppins-MediumItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-MediumItalic.ttf"; sourceTree = "<group>"; };
		89D79DF52A654DC80086A8E5 /* Poppins-BoldItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-BoldItalic.ttf"; sourceTree = "<group>"; };
		89D79DF62A654DC80086A8E5 /* Poppins-Bold.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Bold.ttf"; sourceTree = "<group>"; };
		89D79DF72A654DC80086A8E5 /* Poppins-SemiBoldItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-SemiBoldItalic.ttf"; sourceTree = "<group>"; };
		89E55BD829DC64840073F268 /* AnalyticsManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AnalyticsManager.swift; sourceTree = "<group>"; };
		89E55BDA29DC64840073F268 /* FirebaseAnalyticsPlatform.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = FirebaseAnalyticsPlatform.swift; sourceTree = "<group>"; };
		89E55BDB29DC64840073F268 /* AnalyticsManagerImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AnalyticsManagerImpl.swift; sourceTree = "<group>"; };
		89E55BE129DC66240073F268 /* AnalyticsPlatform.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AnalyticsPlatform.swift; sourceTree = "<group>"; };
		89E601612A829556009492DA /* SubscriptionPickerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPickerView.swift; sourceTree = "<group>"; };
		89E601632A8295A2009492DA /* SubscriptionPickerViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPickerViewModel.swift; sourceTree = "<group>"; };
		89EBC9042A83CC3000BDBBD4 /* SubscriptionFreeTrialToggleView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionFreeTrialToggleView.swift; sourceTree = "<group>"; };
		89EBC9062A83D0DB00BDBBD4 /* SubscriptionPickerPlanView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPickerPlanView.swift; sourceTree = "<group>"; };
		89ED72B82A9F69E5004F541F /* AdSupport.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AdSupport.framework; path = System/Library/Frameworks/AdSupport.framework; sourceTree = SDKROOT; };
		89F9E4F82A95FEED0001D48B /* PDFImageExtractor.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PDFImageExtractor.swift; sourceTree = "<group>"; };
		89F9E4FA2A9606ED0001D48B /* PdfImageViewerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfImageViewerView.swift; sourceTree = "<group>"; };
		89F9E4FC2A9635EC0001D48B /* ZoomImageModifier.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ZoomImageModifier.swift; sourceTree = "<group>"; };
		C99992892DAF4C86003C3643 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		C999928C2DAF4C9B003C3643 /* GoogleService-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "GoogleService-Info.plist"; sourceTree = "<group>"; };
		C9CEF5DC2DAF973100980C8A /* Montserrat-ExtraBold.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Montserrat-ExtraBold.ttf"; sourceTree = "<group>"; };
		C9CEF5DE2DAF974500980C8A /* Montserrat-Medium.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Montserrat-Medium.ttf"; sourceTree = "<group>"; };
		C9CEF5E02DAF975200980C8A /* Montserrat-Regular.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Montserrat-Regular.ttf"; sourceTree = "<group>"; };
		C9CEF5E22DAF975A00980C8A /* Montserrat-Bold.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Montserrat-Bold.ttf"; sourceTree = "<group>"; };
		C9CEF5EB2DB03CCB00980C8A /* SceneDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SceneDelegate.swift; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		895C1BAA2A04FA53005EA190 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		89CD7A9329D32855003F1C3A /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				894827B02AA5D65600030C4E /* BranchSDK in Frameworks */,
				893EB5012AA717B80066914E /* FacebookCore in Frameworks */,
				89407EFA2AA8C4C400169801 /* Mantis in Frameworks */,
				8942034529DC12BC004D610B /* PagerTabStripView in Frameworks */,
				895FE2D229D7392F00A99D5B /* OrderedCollections in Frameworks */,
				89CD7BAB29D32CE5003F1C3A /* FirebaseAnalyticsSwift in Frameworks */,
				893E84A429D5BFBB00F6B99A /* PSPDFKit in Frameworks */,
				8991485629E85DE500DD01F2 /* CombineExt in Frameworks */,
				89CD7BAD29D32CE5003F1C3A /* FirebaseCrashlytics in Frameworks */,
				891A07E929E028EE0002FA3A /* CloudKitSyncMonitor in Frameworks */,
				89923E6729D437F500E246FC /* FirebasePerformance in Frameworks */,
				89CD7BA529D32C52003F1C3A /* Lottie in Frameworks */,
				893BE52B2A6A7864004B05B9 /* CombineMoya in Frameworks */,
				895FE2D029D7392F00A99D5B /* Collections in Frameworks */,
				89CD7BA829D32C72003F1C3A /* Factory in Frameworks */,
				89ED72BB2A9F6B3A004F541F /* AdSupport.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		8936AA292A67F922005F6C73 /* ci_scripts */ = {
			isa = PBXGroup;
			children = (
				8936AA2A2A67F975005F6C73 /* ci_post_clone.sh */,
			);
			path = ci_scripts;
			sourceTree = "<group>";
		};
		8936AA3A2A682C71005F6C73 /* ChatPdf */ = {
			isa = PBXGroup;
			children = (
				8936AA3B2A682CDA005F6C73 /* ChatPdfSelectionView.swift */,
				8936AA412A6840D1005F6C73 /* ChatPdfView.swift */,
				893ED9D82A693013004EE67C /* MessageIndicatorView.swift */,
				893ED9D72A693013004EE67C /* MessageView.swift */,
			);
			path = ChatPdf;
			sourceTree = "<group>";
		};
		893BE5312A6A96BE004B05B9 /* Network */ = {
			isa = PBXGroup;
			children = (
				893BE5322A6A96D0004B05B9 /* ChatPdf */,
				893BE52E2A6A7C0C004B05B9 /* NetworkUtility.swift */,
			);
			path = Network;
			sourceTree = "<group>";
		};
		893BE5322A6A96D0004B05B9 /* ChatPdf */ = {
			isa = PBXGroup;
			children = (
				893BE5332A6A96E1004B05B9 /* Mapping */,
				8936AA352A68299B005F6C73 /* ChatPdfManager.swift */,
				8936AA362A68299B005F6C73 /* ChatPdfManagerMock.swift */,
				893BE52C2A6A78BB004B05B9 /* ChatPdfManagerImpl.swift */,
			);
			path = ChatPdf;
			sourceTree = "<group>";
		};
		893BE5332A6A96E1004B05B9 /* Mapping */ = {
			isa = PBXGroup;
			children = (
				893BE5342A6A96F5004B05B9 /* ChatPdfRef+Decodable.swift */,
				893BE5362A6A9708004B05B9 /* ChatPdfMessage+Decodable.swift */,
				894CB09F2A8520AD0008008A /* ChatPdfSetupData+Decodable.swift */,
			);
			path = Mapping;
			sourceTree = "<group>";
		};
		893C8FC729DED15B000E35BD /* Archive */ = {
			isa = PBXGroup;
			children = (
				893C8FC829DED190000E35BD /* ArchiveView.swift */,
			);
			path = Archive;
			sourceTree = "<group>";
		};
		893C8FDF29DEDAE8000E35BD /* Test */ = {
			isa = PBXGroup;
			children = (
				893C8FE029DEDAF4000E35BD /* test.pdf */,
			);
			path = Test;
			sourceTree = "<group>";
		};
		893E849229D5877800F6B99A /* Camera */ = {
			isa = PBXGroup;
			children = (
				893E849029D5874D00F6B99A /* CameraView.swift */,
			);
			path = Camera;
			sourceTree = "<group>";
		};
		893E849529D5943D00F6B99A /* Camera */ = {
			isa = PBXGroup;
			children = (
				893E849829D5944E00F6B99A /* CameraPreviewView.swift */,
				893E849A29D5944E00F6B99A /* CameraService.swift */,
				893E849729D5944E00F6B99A /* CameraService+Enums.swift */,
				893E849B29D5944E00F6B99A /* CameraService+Extensions.swift */,
				893E849929D5944E00F6B99A /* ImageResizer.swift */,
				893E849629D5944E00F6B99A /* PhotoCaptureProcessor.swift */,
			);
			path = Camera;
			sourceTree = "<group>";
		};
		89429F8D2A9C94A300465420 /* Persistence */ = {
			isa = PBXGroup;
			children = (
				89429F8E2A9C94BD00465420 /* CoreData */,
				89AAFE9F29DB2672002D348E /* CacheManager.swift */,
				89AAFEA029DB2672002D348E /* CacheManagerImpl.swift */,
				893C8FD129DED2E9000E35BD /* Repository.swift */,
				893C8FD229DED2E9000E35BD /* RepositoryImpl.swift */,
			);
			path = Persistence;
			sourceTree = "<group>";
		};
		89429F8E2A9C94BD00465420 /* CoreData */ = {
			isa = PBXGroup;
			children = (
				89429F8F2A9CFFC500465420 /* Persistable */,
				89C2500E2A72B2BC00184C45 /* CDPdf.swift */,
				89429F8B2A9C937C00465420 /* CDSignature.swift */,
				892CC6912AAA23AE000DEC21 /* CDSuggestedFields.swift */,
				893C8FCF29DED278000E35BD /* Persistence.swift */,
			);
			path = CoreData;
			sourceTree = "<group>";
		};
		89429F8F2A9CFFC500465420 /* Persistable */ = {
			isa = PBXGroup;
			children = (
				89429F902A9CFFDC00465420 /* Persistable.swift */,
				89429F922A9CFFF100465420 /* Pdf+Persistable.swift */,
				89429F942A9D001A00465420 /* Signature+Persistable.swift */,
				892CC6932AAA243E000DEC21 /* SuggestedFields+Persistable.swift */,
			);
			path = Persistable;
			sourceTree = "<group>";
		};
		89436AB929E5578300060605 /* Pdf */ = {
			isa = PBXGroup;
			children = (
				89436ABA29E557D500060605 /* PdfFlowView.swift */,
				89436ABC29E5586600060605 /* PdfEditView.swift */,
				892201DB2A0BA70300832CF2 /* PdfSignatureView.swift */,
				89429F852A9C8ECC00465420 /* PdfSignaturePickerView.swift */,
				89127AA22A177F170059005F /* PdfSignatureCanvasView.swift */,
				8962D6072A9E2A57008426A2 /* PdfSignatureProviderFlowView.swift */,
				8932ECE42A20DC7700CBCD7A /* PdfFillFormView.swift */,
				89504A452A448252000BCACD /* PdfFillWidgetView.swift */,
				8957FBAB2A7801BA008B31ED /* PdfCompressionPickerView.swift */,
			);
			path = Pdf;
			sourceTree = "<group>";
		};
		894827B52AA5DCA900030C4E /* Resources */ = {
			isa = PBXGroup;
			children = (
				894827B72AA5DCB800030C4E /* Production */,
				894827B62AA5DCB200030C4E /* Staging */,
			);
			path = Resources;
			sourceTree = "<group>";
		};
		894827B62AA5DCB200030C4E /* Staging */ = {
			isa = PBXGroup;
			children = (
				894827B82AA5DCE400030C4E /* Info.plist */,
			);
			path = Staging;
			sourceTree = "<group>";
		};
		894827B72AA5DCB800030C4E /* Production */ = {
			isa = PBXGroup;
			children = (
				895C1BB42A04FA53005EA190 /* Info.plist */,
			);
			path = Production;
			sourceTree = "<group>";
		};
		894B019D2A0902A000FF6198 /* ImportTutorial */ = {
			isa = PBXGroup;
			children = (
				894B019E2A0902BC00FF6198 /* ImportTutorialView.swift */,
				894B01A02A09030000FF6198 /* ImportTutorialPageView.swift */,
			);
			path = ImportTutorial;
			sourceTree = "<group>";
		};
		894C4A6C2AA0C2F40001F51E /* Review */ = {
			isa = PBXGroup;
			children = (
				894C4A6A2AA0C23F0001F51E /* PreReviewPopupView.swift */,
				894C4A712AA0DB9A0001F51E /* PreReviewPopupLowRateView.swift */,
				894C4A6F2AA0CCFC0001F51E /* ReviewFlowView.swift */,
			);
			path = Review;
			sourceTree = "<group>";
		};
		895C1BAE2A04FA53005EA190 /* ShareFileExtension */ = {
			isa = PBXGroup;
			children = (
				895C1BBC2A04FD67005EA190 /* ShareFileExtension.entitlements */,
				895C1BAF2A04FA53005EA190 /* ShareViewController.swift */,
				895C1BB12A04FA53005EA190 /* MainInterface.storyboard */,
				894827B52AA5DCA900030C4E /* Resources */,
			);
			path = ShareFileExtension;
			sourceTree = "<group>";
		};
		895FE2C229D6D7D800A99D5B /* Scan */ = {
			isa = PBXGroup;
			children = (
				895FE2C329D6D7E500A99D5B /* ScannerView.swift */,
			);
			path = Scan;
			sourceTree = "<group>";
		};
		895FE2C929D6E98100A99D5B /* Subscription */ = {
			isa = PBXGroup;
			children = (
				895FE2CA29D6E9B800A99D5B /* SubscriptionPairsView.swift */,
				895FE2CC29D724B900A99D5B /* SubscriptionPairsItemView.swift */,
				89460C5F29DAC36600E39BAC /* SubscriptionErrorView.swift */,
				897911EC29E70541008B7088 /* SubscriptionVerticalView.swift */,
				897911EE29E70558008B7088 /* SubscriptionVerticalItemView.swift */,
				89E601612A829556009492DA /* SubscriptionPickerView.swift */,
				89EBC9062A83D0DB00BDBBD4 /* SubscriptionPickerPlanView.swift */,
				89D1FE7D2A84D428009AC57C /* SubscriptionPickerPlanListView.swift */,
				89EBC9042A83CC3000BDBBD4 /* SubscriptionFreeTrialToggleView.swift */,
			);
			path = Subscription;
			sourceTree = "<group>";
		};
		89847ADE2A1BA8CC000EC14B /* Production */ = {
			isa = PBXGroup;
			children = (
				89CD7AA729D32856003F1C3A /* Info.plist */,
				C999928C2DAF4C9B003C3643 /* GoogleService-Info.plist */,
			);
			path = Production;
			sourceTree = "<group>";
		};
		89847ADF2A1BA8CC000EC14B /* Staging */ = {
			isa = PBXGroup;
			children = (
				C99992892DAF4C86003C3643 /* Info.plist */,
				89847AE02A1BA947000EC14B /* GoogleService-Info.plist */,
			);
			path = Staging;
			sourceTree = "<group>";
		};
		89923E6529D437F500E246FC /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				89ED72B82A9F69E5004F541F /* AdSupport.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		8995694829D3473E00566EF4 /* Common */ = {
			isa = PBXGroup;
			children = (
				894D485729D42C9D002B0230 /* OptionItemView.swift */,
				894D485929D42CC5002B0230 /* OptionListView.swift */,
				8936AA3F2A683FB5005F6C73 /* ImportOption.swift */,
				8940FB902A710D8D00A00D8D /* AddPasswordView.swift */,
				89BB2DBC2A7A80A8009E6738 /* PdfUnlockView.swift */,
				8957FBA92A77E6F7008B31ED /* PdfShareView.swift */,
				89BB2DB62A7A5EFC009E6738 /* PdfMergeView.swift */,
				896876232A7D05040014A320 /* PdfSplitView.swift */,
				89BB2DC02A7AB4A8009E6738 /* PdfSortView.swift */,
				8968761D2A7CEE320014A320 /* PdfImportView.swift */,
				896876212A7CF3220014A320 /* PdfImportMultipleView.swift */,
				896876272A7D2EC20014A320 /* PdfPageRangeEditorView.swift */,
				89436D182A936C9F000868B5 /* PdfReadView.swift */,
				89436D1C2A93AE76000868B5 /* PdfReaderView.swift */,
				89436D222A93C1CE000868B5 /* PdfPageSelectionView.swift */,
				89F9E4FA2A9606ED0001D48B /* PdfImageViewerView.swift */,
				89407EF22AA8B0C800169801 /* GalleryImageProviderFlowView.swift */,
				89407EF62AA8BEC200169801 /* CameraImageProviderFlowView.swift */,
				89407EFD2AA8D23B00169801 /* ImageCropFlowView.swift */,
				892CC6952AAA2641000DEC21 /* SuggestedFieldsFormView.swift */,
			);
			path = Common;
			sourceTree = "<group>";
		};
		899F484229DF123B00E7E1E4 /* Main */ = {
			isa = PBXGroup;
			children = (
				899F484329DF128200E7E1E4 /* MainTabView.swift */,
			);
			path = Main;
			sourceTree = "<group>";
		};
		89AAFE9A29DB1823002D348E /* Onboarding */ = {
			isa = PBXGroup;
			children = (
				8955ED912A1F61A9009985EE /* OnboardingView.swift */,
				8955ED932A1F61BD009985EE /* OnboardingPageView.swift */,
			);
			path = Onboarding;
			sourceTree = "<group>";
		};
		89AAFEA829DB3098002D348E /* Welcome */ = {
			isa = PBXGroup;
			children = (
				89AAFEA629DB2AC4002D348E /* WelcomeView.swift */,
			);
			path = Welcome;
			sourceTree = "<group>";
		};
		89B72A3129DADC6E0076884F /* Settings */ = {
			isa = PBXGroup;
			children = (
				89B72A3229DADC790076884F /* SettingsView.swift */,
			);
			path = Settings;
			sourceTree = "<group>";
		};
		89CD7A8D29D32855003F1C3A = {
			isa = PBXGroup;
			children = (
				8936AA292A67F922005F6C73 /* ci_scripts */,
				89CD7A9829D32855003F1C3A /* PdfExpert */,
				895C1BAE2A04FA53005EA190 /* ShareFileExtension */,
				89CD7A9729D32855003F1C3A /* Products */,
				89923E6529D437F500E246FC /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		89CD7A9729D32855003F1C3A /* Products */ = {
			isa = PBXGroup;
			children = (
				89CD7A9629D32855003F1C3A /* PdfExpert.app */,
				895C1BAD2A04FA53005EA190 /* ShareFileExtension.appex */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		89CD7A9829D32855003F1C3A /* PdfExpert */ = {
			isa = PBXGroup;
			children = (
				893C8FE229DF0145000E35BD /* PdfExpert.entitlements */,
				89CD7AF529D329B1003F1C3A /* Applicaction */,
				89CD7ADD29D329B1003F1C3A /* Models */,
				89CD7AFB29D329B1003F1C3A /* ViewModels */,
				89CD7B0329D329B1003F1C3A /* Views */,
				89CD7AF829D329B1003F1C3A /* Style */,
				89CD7B2B29D329B1003F1C3A /* InternalUtils */,
				89CD7ACD29D329B1003F1C3A /* Utils */,
				89CD7AAD29D329B1003F1C3A /* Resources */,
				89CD7A9F29D32856003F1C3A /* Preview Content */,
				C9CEF5DC2DAF973100980C8A /* Montserrat-ExtraBold.ttf */,
				C9CEF5DE2DAF974500980C8A /* Montserrat-Medium.ttf */,
				C9CEF5E02DAF975200980C8A /* Montserrat-Regular.ttf */,
				C9CEF5E22DAF975A00980C8A /* Montserrat-Bold.ttf */,
			);
			path = PdfExpert;
			sourceTree = "<group>";
		};
		89CD7A9F29D32856003F1C3A /* Preview Content */ = {
			isa = PBXGroup;
			children = (
				89CD7AA029D32856003F1C3A /* Preview Assets.xcassets */,
			);
			path = "Preview Content";
			sourceTree = "<group>";
		};
		89CD7AAD29D329B1003F1C3A /* Resources */ = {
			isa = PBXGroup;
			children = (
				8936AA302A682812005F6C73 /* ProjectInfo.plist */,
				89883B012A45CB9800E684B6 /* InfoTemplate.plist */,
				89847ADE2A1BA8CC000EC14B /* Production */,
				89847ADF2A1BA8CC000EC14B /* Staging */,
				893C8FDF29DEDAE8000E35BD /* Test */,
				893C8FCC29DED254000E35BD /* AppCoreData.xcdatamodeld */,
				89CD7AAE29D329B1003F1C3A /* Colors.xcassets */,
				89CD7AB229D329B1003F1C3A /* Assets.xcassets */,
				89CD7AB329D329B1003F1C3A /* IAP */,
				89CD7AB729D329B1003F1C3A /* Fonts */,
				89CD7ACB29D329B1003F1C3A /* Animations */,
			);
			path = Resources;
			sourceTree = "<group>";
		};
		89CD7AB329D329B1003F1C3A /* IAP */ = {
			isa = PBXGroup;
			children = (
				89CD7AB429D329B1003F1C3A /* Products.plist */,
				895FE2C729D6E7D900A99D5B /* ProductionProducts.storekit */,
				89AA36082A1BC5FD0077A70A /* StagingProducts.storekit */,
				893DE8DD29E832B90043C02C /* LocalProductionProducts.storekit */,
				89AA360A2A1BC8560077A70A /* LocalStagingProducts.storekit */,
				89B72A2D29DACBBF0076884F /* EmptyProducts.storekit */,
			);
			path = IAP;
			sourceTree = "<group>";
		};
		89CD7AB729D329B1003F1C3A /* Fonts */ = {
			isa = PBXGroup;
			children = (
				89D79DE82A654DC80086A8E5 /* Poppins-Black.ttf */,
				89D79DEB2A654DC80086A8E5 /* Poppins-BlackItalic.ttf */,
				89D79DF62A654DC80086A8E5 /* Poppins-Bold.ttf */,
				89D79DF52A654DC80086A8E5 /* Poppins-BoldItalic.ttf */,
				89D79DEE2A654DC80086A8E5 /* Poppins-ExtraBold.ttf */,
				89D79DF12A654DC80086A8E5 /* Poppins-ExtraBoldItalic.ttf */,
				89D79DF02A654DC80086A8E5 /* Poppins-ExtraLight.ttf */,
				89D79DE62A654DC70086A8E5 /* Poppins-ExtraLightItalic.ttf */,
				89D79DED2A654DC80086A8E5 /* Poppins-Italic.ttf */,
				89D79DEA2A654DC80086A8E5 /* Poppins-Light.ttf */,
				89D79DF22A654DC80086A8E5 /* Poppins-LightItalic.ttf */,
				89D79DEC2A654DC80086A8E5 /* Poppins-Medium.ttf */,
				89D79DF42A654DC80086A8E5 /* Poppins-MediumItalic.ttf */,
				89D79DF32A654DC80086A8E5 /* Poppins-Regular.ttf */,
				89D79DE72A654DC70086A8E5 /* Poppins-SemiBold.ttf */,
				89D79DF72A654DC80086A8E5 /* Poppins-SemiBoldItalic.ttf */,
				89D79DEF2A654DC80086A8E5 /* Poppins-Thin.ttf */,
				89D79DE92A654DC80086A8E5 /* Poppins-ThinItalic.ttf */,
			);
			path = Fonts;
			sourceTree = "<group>";
		};
		89CD7ACB29D329B1003F1C3A /* Animations */ = {
			isa = PBXGroup;
			children = (
				89923E6A29D47B9E00E246FC /* pdf-scanning.json */,
				89CD7ACC29D329B1003F1C3A /* loading.json */,
			);
			path = Animations;
			sourceTree = "<group>";
		};
		89CD7ACD29D329B1003F1C3A /* Utils */ = {
			isa = PBXGroup;
			children = (
				C9CEF5ED2DB0679B00980C8A /* Protocols */,
				893E849529D5943D00F6B99A /* Camera */,
				89CD7ACE29D329B1003F1C3A /* UI */,
				89CD7AD329D329B1003F1C3A /* ParentalCheck.swift */,
				89CD7AD429D329B1003F1C3A /* Extensions */,
				89CD7ADB29D329B1003F1C3A /* Async.swift */,
				89CD7ADC29D329B1003F1C3A /* DebugUtils.swift */,
				893ED9D32A692805004EE67C /* CombineUtils.swift */,
				89F9E4F82A95FEED0001D48B /* PDFImageExtractor.swift */,
				89431FC52A9900740042A636 /* MathUtils.swift */,
			);
			path = Utils;
			sourceTree = "<group>";
		};
		89CD7ACE29D329B1003F1C3A /* UI */ = {
			isa = PBXGroup;
			children = (
				89CD7ACF29D329B1003F1C3A /* AsyncView.swift */,
				893875002A7BDD3B00267AFD /* LoadingView.swift */,
				89CD7AD029D329B1003F1C3A /* CircularProgressView.swift */,
				89CD7AD129D329B1003F1C3A /* UnderlyingError.swift */,
				89CD7AD229D329B1003F1C3A /* LottieView.swift */,
				894D485B29D42FE1002B0230 /* RoundedCorner.swift */,
				89923E6829D46A9900E246FC /* FilePicker.swift */,
				893E84A529D5C5E200F6B99A /* ActivityViewController.swift */,
				8902898C29DC1F10007E6372 /* PageControl.swift */,
				89436AC629E5B99100060605 /* PdfKitView.swift */,
				8933490B2A24AE880005D484 /* PdfKitViewBinder.swift */,
				89127AA02A177E370059005F /* PencilKitView.swift */,
				892201D82A0BA64600832CF2 /* ImageAnnotationStamp.swift */,
				89851B5D2A13DB1A00ABF58F /* ImageResizableView.swift */,
				8932ECE82A20F10500CBCD7A /* TextResizableView.swift */,
				896CCF6C2A28910B008F268E /* SizePrinter.swift */,
				893AAFCA2A39B2AF00EF9B00 /* FormSheet.swift */,
				89D1FE7F2A84D76B009AC57C /* FullScreenClearBackground.swift */,
				89F9E4FC2A9635EC0001D48B /* ZoomImageModifier.swift */,
				894C4A682AA0C04B0001F51E /* PopupView.swift */,
			);
			path = UI;
			sourceTree = "<group>";
		};
		89CD7AD429D329B1003F1C3A /* Extensions */ = {
			isa = PBXGroup;
			children = (
				89CD7AD529D329B1003F1C3A /* String+Extensions.swift */,
				89CD7AD629D329B1003F1C3A /* UIApplication+Extensions.swift */,
				89CD7AD729D329B1003F1C3A /* View+Alert.swift */,
				89CD7AD829D329B1003F1C3A /* View+Extensions.swift */,
				89CD7AD929D329B1003F1C3A /* Color+Extensions.swift */,
				89CD7ADA29D329B1003F1C3A /* Enum+Extensions.swift */,
				894AC3632A02952A00BA5553 /* Foundation+Extensions.swift */,
				893B04BC2AA9C2C100F86813 /* CoreGraphics+Extensions.swift */,
				891AE58A2A03E80300DBC246 /* ObservableObject+Extensions.swift */,
				89127AA62A17C1980059005F /* PencilKit+Extensions.swift */,
				896CCF6E2A28AEAC008F268E /* UIFont+Extensions.swift */,
				892E404E2A25E5D9000EEE23 /* PDFAnnotation+Extensions.swift */,
				897967852A73E59B00E91F8E /* URL+Extensions.swift */,
				89436D202A93B97E000868B5 /* NSAttributedString+Extensions.swift */,
				89ABAA582A97B29C00721045 /* PdfDocument+Extensions.swift */,
				893EB5042AA722EF0066914E /* StoreKit+Extensions.swift */,
			);
			path = Extensions;
			sourceTree = "<group>";
		};
		89CD7ADD29D329B1003F1C3A /* Models */ = {
			isa = PBXGroup;
			children = (
				89CD7AEF29D329B1003F1C3A /* Entities */,
				89E55BE029DC66170073F268 /* Analytics */,
				89429F8D2A9C94A300465420 /* Persistence */,
				89CD7AEB29D329B1003F1C3A /* Store.swift */,
				89CD7AE529D329B1003F1C3A /* StoreImpl.swift */,
				89923E5E29D4350F00E246FC /* AppTrackingTransparency.swift */,
				89923E5D29D4350F00E246FC /* AppTrackingTransparencyImpl.swift */,
				894827B12AA5D68D00030C4E /* AttributionManager.swift */,
				894827B32AA5D6FF00030C4E /* AttibutionManagerImpl.swift */,
				8991485029E851B500DD01F2 /* ConfigService.swift */,
				8991485229E851BD00DD01F2 /* RemoteConfigManager.swift */,
				893BE5312A6A96BE004B05B9 /* Network */,
			);
			path = Models;
			sourceTree = "<group>";
		};
		89CD7AEF29D329B1003F1C3A /* Entities */ = {
			isa = PBXGroup;
			children = (
				89436ABE29E55EA000060605 /* Pdf.swift */,
				89429F892A9C937300465420 /* Signature.swift */,
				8928F3D02A30BAFB001C1853 /* PickedImage.swift */,
				8936AA322A6828C9005F6C73 /* ProjectInfo.swift */,
				893ED9CF2A6920F2004EE67C /* ChatPdfRef.swift */,
				893ED9D12A6926E8004EE67C /* ChatPdfMessage.swift */,
				894CB09D2A851FE50008008A /* ChatPdfSetupData.swift */,
				8934ACC62A6AE96700F6CDA8 /* ChatPdfInitParams.swift */,
				8966B6F12AA9FCE0005E6DED /* SuggestedFields.swift */,
			);
			path = Entities;
			sourceTree = "<group>";
		};
		89CD7AF529D329B1003F1C3A /* Applicaction */ = {
			isa = PBXGroup;
			children = (
				C9CEF5EB2DB03CCB00980C8A /* SceneDelegate.swift */,
				89CD7BBC29D331AA003F1C3A /* AppDelegate.swift */,
				89CD7AF629D329B1003F1C3A /* Constants.swift */,
				89CD7A9929D32855003F1C3A /* PdfExpertApp.swift */,
			);
			path = Applicaction;
			sourceTree = "<group>";
		};
		89CD7AF829D329B1003F1C3A /* Style */ = {
			isa = PBXGroup;
			children = (
				89CD7AF929D329B1003F1C3A /* FontPalette.swift */,
				89CD7AFA29D329B1003F1C3A /* ColorPalette.swift */,
				895FE2C529D6E17600A99D5B /* AnimationPalette.swift */,
			);
			path = Style;
			sourceTree = "<group>";
		};
		89CD7AFB29D329B1003F1C3A /* ViewModels */ = {
			isa = PBXGroup;
			children = (
				8995694329D3450300566EF4 /* HomeViewModel.swift */,
				89CD7AFD29D329B1003F1C3A /* SubscribeViewModel.swift */,
				893DE8D929E7F85C0043C02C /* SubscriptionPairsViewModel.swift */,
				893DE8DB29E7F9A10043C02C /* SubscriptionVerticalViewModel.swift */,
				89E601632A8295A2009492DA /* SubscriptionPickerViewModel.swift */,
				893E849329D5878E00F6B99A /* CameraViewModel.swift */,
				8955ED952A1F73DC009985EE /* OnboardingViewModel.swift */,
				893C8FCA29DED1AF000E35BD /* ArchiveViewModel.swift */,
				8936AA3D2A682F8E005F6C73 /* ChatPdfSelectionViewModel.swift */,
				8936AA432A684128005F6C73 /* ChatPdfViewModel.swift */,
				89436AC229E59C0E00060605 /* PdfEditViewModel.swift */,
				892201DD2A0BA72D00832CF2 /* PdfSignatureViewModel.swift */,
				8932ECE62A20DCB900CBCD7A /* PdfFillFormViewModel.swift */,
				89127AA42A17A3600059005F /* PdfSignatureCanvasViewModel.swift */,
				89429F872A9C8EFC00465420 /* PdfSignaturePickerViewModel.swift */,
				89504A472A44829C000BCACD /* PdfFillWidgetViewModel.swift */,
				89BB2DB82A7A6050009E6738 /* PdfMergeViewModel.swift */,
				89BB2DBA2A7A7DD7009E6738 /* PdfUnlockViewModel.swift */,
				89BB2DBE2A7AB0CE009E6738 /* PdfSortViewModel.swift */,
				896876192A7CE87A0014A320 /* PdfSplitViewModel.swift */,
				8968761B2A7CEB650014A320 /* PdfImportViewModel.swift */,
				8968761F2A7CF1E00014A320 /* PdfImportMultipleViewModel.swift */,
				896876252A7D2EB80014A320 /* PdfPageRangeEditorViewModel.swift */,
				89436D1A2A939CBB000868B5 /* PdfReadViewModel.swift */,
				89436D1E2A93AEB4000868B5 /* PdfReaderViewModel.swift */,
				892CC6972AAA2660000DEC21 /* SuggestedFieldsFormViewModel.swift */,
				8962D6052A9E28FB008426A2 /* PdfSignaturePrioviderFlow.swift */,
				89407EF02AA8ADD200169801 /* GalleryImageProviderFlow.swift */,
				89407EF42AA8BDE600169801 /* CameraImageProviderFlow.swift */,
				89407EFB2AA8D22D00169801 /* ImageCropFlow.swift */,
				894C4A6D2AA0CB470001F51E /* ReviewFlow.swift */,
			);
			path = ViewModels;
			sourceTree = "<group>";
		};
		89CD7B0329D329B1003F1C3A /* Views */ = {
			isa = PBXGroup;
			children = (
				89CD7BB229D32E69003F1C3A /* Navigation */,
				8995694829D3473E00566EF4 /* Common */,
				89AAFEA829DB3098002D348E /* Welcome */,
				89AAFE9A29DB1823002D348E /* Onboarding */,
				895FE2C929D6E98100A99D5B /* Subscription */,
				89436AB929E5578300060605 /* Pdf */,
				899F484229DF123B00E7E1E4 /* Main */,
				893C8FC729DED15B000E35BD /* Archive */,
				8936AA3A2A682C71005F6C73 /* ChatPdf */,
				89CD7BB729D330B2003F1C3A /* Home */,
				89B72A3129DADC6E0076884F /* Settings */,
				895FE2C229D6D7D800A99D5B /* Scan */,
				893E849229D5877800F6B99A /* Camera */,
				894B019D2A0902A000FF6198 /* ImportTutorial */,
				894C4A6C2AA0C2F40001F51E /* Review */,
				89CD7B2629D329B1003F1C3A /* ContentView.swift */,
			);
			path = Views;
			sourceTree = "<group>";
		};
		89CD7B2B29D329B1003F1C3A /* InternalUtils */ = {
			isa = PBXGroup;
			children = (
				89CD7B2C29D329B1003F1C3A /* SharedErrors.swift */,
				89CD7B2D29D329B1003F1C3A /* SubscriptionViewUtility.swift */,
				89CD7B2E29D329B1003F1C3A /* View+Preview.swift */,
				89CD7B2F29D329B1003F1C3A /* View+Internal.swift */,
				893C8FDD29DED7F4000E35BD /* PdfUtility.swift */,
				8945D2BB2A03C41000AFF51A /* PdfScanUtility.swift */,
				895C1BBF2A051261005EA190 /* SharedStorage.swift */,
				89407EFF2AA8D54800169801 /* ImageCropper.swift */,
			);
			path = InternalUtils;
			sourceTree = "<group>";
		};
		89CD7BB229D32E69003F1C3A /* Navigation */ = {
			isa = PBXGroup;
			children = (
				89CD7BB429D32E69003F1C3A /* MainCoordinator.swift */,
				89436AB729E5556600060605 /* PdfCoordinator.swift */,
				8957FBA72A77C646008B31ED /* PdfShareCoordinator.swift */,
				89467AD62A9E4C6B00FC01FC /* Deeplink.swift */,
			);
			path = Navigation;
			sourceTree = "<group>";
		};
		89CD7BB729D330B2003F1C3A /* Home */ = {
			isa = PBXGroup;
			children = (
				89CD7BBA29D330FB003F1C3A /* HomeView.swift */,
				8995694129D33B1300566EF4 /* HomeItemView.swift */,
			);
			path = Home;
			sourceTree = "<group>";
		};
		89E55BE029DC66170073F268 /* Analytics */ = {
			isa = PBXGroup;
			children = (
				89E55BDB29DC64840073F268 /* AnalyticsManagerImpl.swift */,
				89E55BD829DC64840073F268 /* AnalyticsManager.swift */,
				89E55BDA29DC64840073F268 /* FirebaseAnalyticsPlatform.swift */,
				893EB5022AA71FFD0066914E /* BranchAnalyticsPlatform.swift */,
				89E55BE129DC66240073F268 /* AnalyticsPlatform.swift */,
				893EB5062AA723C80066914E /* AnalyticsDefaultParameters.swift */,
			);
			path = Analytics;
			sourceTree = "<group>";
		};
		C9CEF5ED2DB0679B00980C8A /* Protocols */ = {
			isa = PBXGroup;
			children = (
			);
			path = Protocols;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		895C1BAC2A04FA53005EA190 /* ShareFileExtension */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 895C1BBB2A04FA54005EA190 /* Build configuration list for PBXNativeTarget "ShareFileExtension" */;
			buildPhases = (
				895C1BA92A04FA53005EA190 /* Sources */,
				895C1BAA2A04FA53005EA190 /* Frameworks */,
				895C1BAB2A04FA53005EA190 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = ShareFileExtension;
			productName = ShareFileExtension;
			productReference = 895C1BAD2A04FA53005EA190 /* ShareFileExtension.appex */;
			productType = "com.apple.product-type.app-extension";
		};
		89CD7A9529D32855003F1C3A /* PdfExpert */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 89CD7AAA29D32856003F1C3A /* Build configuration list for PBXNativeTarget "PdfExpert" */;
			buildPhases = (
				89CD7A9229D32855003F1C3A /* Sources */,
				89CD7A9329D32855003F1C3A /* Frameworks */,
				89AA36072A1BB0280077A70A /* Setup Firebase Environment GoogleService-Info.plist */,
				89CD7A9429D32855003F1C3A /* Resources */,
				89923E6429D437B400E246FC /* ShellScript */,
				C9CEF5EA2DB02DBB00980C8A /* Embed Foundation Extensions */,
			);
			buildRules = (
			);
			dependencies = (
				C9CEF5E92DB02DBA00980C8A /* PBXTargetDependency */,
			);
			name = PdfExpert;
			packageProductDependencies = (
				89CD7BA429D32C52003F1C3A /* Lottie */,
				89CD7BA729D32C72003F1C3A /* Factory */,
				89CD7BAA29D32CE5003F1C3A /* FirebaseAnalyticsSwift */,
				89CD7BAC29D32CE5003F1C3A /* FirebaseCrashlytics */,
				89923E6629D437F500E246FC /* FirebasePerformance */,
				893E84A329D5BFBB00F6B99A /* PSPDFKit */,
				895FE2CF29D7392F00A99D5B /* Collections */,
				895FE2D129D7392F00A99D5B /* OrderedCollections */,
				8942034429DC12BC004D610B /* PagerTabStripView */,
				891A07E829E028EE0002FA3A /* CloudKitSyncMonitor */,
				8991485529E85DE500DD01F2 /* CombineExt */,
				893BE52A2A6A7864004B05B9 /* CombineMoya */,
				894827AF2AA5D65600030C4E /* BranchSDK */,
				893EB5002AA717B80066914E /* FacebookCore */,
				89407EF92AA8C4C400169801 /* Mantis */,
			);
			productName = PdfExpert;
			productReference = 89CD7A9629D32855003F1C3A /* PdfExpert.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		89CD7A8E29D32855003F1C3A /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1430;
				LastUpgradeCheck = 1620;
				TargetAttributes = {
					895C1BAC2A04FA53005EA190 = {
						CreatedOnToolsVersion = 14.3;
					};
					89CD7A9529D32855003F1C3A = {
						CreatedOnToolsVersion = 14.2;
					};
				};
			};
			buildConfigurationList = 89CD7A9129D32855003F1C3A /* Build configuration list for PBXProject "pdfexpert" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 89CD7A8D29D32855003F1C3A;
			packageReferences = (
				89CD7BA329D32C52003F1C3A /* XCRemoteSwiftPackageReference "lottie-spm" */,
				89CD7BA629D32C72003F1C3A /* XCRemoteSwiftPackageReference "Factory" */,
				89CD7BA929D32CE5003F1C3A /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */,
				893E84A229D5BFBB00F6B99A /* XCRemoteSwiftPackageReference "PSPDFKit-SP" */,
				895FE2CE29D7392E00A99D5B /* XCRemoteSwiftPackageReference "swift-collections" */,
				8942034329DC12BC004D610B /* XCRemoteSwiftPackageReference "PagerTabStripView" */,
				891A07E729E028EE0002FA3A /* XCRemoteSwiftPackageReference "CloudKitSyncMonitor" */,
				8991485429E85DE500DD01F2 /* XCRemoteSwiftPackageReference "CombineExt" */,
				893BE5292A6A7864004B05B9 /* XCRemoteSwiftPackageReference "Moya" */,
				894827AE2AA5D65600030C4E /* XCRemoteSwiftPackageReference "ios-branch-sdk-spm" */,
				893EB4FF2AA717B80066914E /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */,
				89407EF82AA8C4C400169801 /* XCRemoteSwiftPackageReference "Mantis" */,
			);
			productRefGroup = 89CD7A9729D32855003F1C3A /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				89CD7A9529D32855003F1C3A /* PdfExpert */,
				895C1BAC2A04FA53005EA190 /* ShareFileExtension */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		895C1BAB2A04FA53005EA190 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				895C1BB32A04FA53005EA190 /* MainInterface.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		89CD7A9429D32855003F1C3A /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				89CD7B3029D329B1003F1C3A /* Colors.xcassets in Resources */,
				89D79DFC2A654DC80086A8E5 /* Poppins-Light.ttf in Resources */,
				89CD7AA129D32856003F1C3A /* Preview Assets.xcassets in Resources */,
				89D79E092A654DC80086A8E5 /* Poppins-SemiBoldItalic.ttf in Resources */,
				C999928D2DAF4C9B003C3643 /* GoogleService-Info.plist in Resources */,
				C9CEF5DD2DAF973100980C8A /* Montserrat-ExtraBold.ttf in Resources */,
				89D79E012A654DC80086A8E5 /* Poppins-Thin.ttf in Resources */,
				89D79E032A654DC80086A8E5 /* Poppins-ExtraBoldItalic.ttf in Resources */,
				C9CEF5DF2DAF974500980C8A /* Montserrat-Medium.ttf in Resources */,
				89CD7B3429D329B1003F1C3A /* Products.plist in Resources */,
				8936AA312A682812005F6C73 /* ProjectInfo.plist in Resources */,
				89D79DF82A654DC80086A8E5 /* Poppins-ExtraLightItalic.ttf in Resources */,
				89D79E082A654DC80086A8E5 /* Poppins-Bold.ttf in Resources */,
				89923E6B29D47B9E00E246FC /* pdf-scanning.json in Resources */,
				89D79DF92A654DC80086A8E5 /* Poppins-SemiBold.ttf in Resources */,
				89CD7B4A29D329B1003F1C3A /* loading.json in Resources */,
				89D79DFD2A654DC80086A8E5 /* Poppins-BlackItalic.ttf in Resources */,
				89D79DFE2A654DC80086A8E5 /* Poppins-Medium.ttf in Resources */,
				C9CEF5E12DAF975200980C8A /* Montserrat-Regular.ttf in Resources */,
				89D79DFF2A654DC80086A8E5 /* Poppins-Italic.ttf in Resources */,
				C9CEF5E32DAF975A00980C8A /* Montserrat-Bold.ttf in Resources */,
				893C8FE129DEDAF4000E35BD /* test.pdf in Resources */,
				89D79DFA2A654DC80086A8E5 /* Poppins-Black.ttf in Resources */,
				89D79E072A654DC80086A8E5 /* Poppins-BoldItalic.ttf in Resources */,
				89D79E022A654DC80086A8E5 /* Poppins-ExtraLight.ttf in Resources */,
				89D79E042A654DC80086A8E5 /* Poppins-LightItalic.ttf in Resources */,
				89D79DFB2A654DC80086A8E5 /* Poppins-ThinItalic.ttf in Resources */,
				89D79E002A654DC80086A8E5 /* Poppins-ExtraBold.ttf in Resources */,
				89D79E052A654DC80086A8E5 /* Poppins-Regular.ttf in Resources */,
				89D79E062A654DC80086A8E5 /* Poppins-MediumItalic.ttf in Resources */,
				89CD7B3329D329B1003F1C3A /* Assets.xcassets in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		89923E6429D437B400E246FC /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${DWARF_DSYM_FOLDER_PATH}/${DWARF_DSYM_FILE_NAME}/Contents/Resources/DWARF/${TARGET_NAME}",
			);
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "# Type a script or drag a script file from your workspace to insert its path.\n\"${BUILD_DIR%/Build/*}/SourcePackages/checkouts/firebase-ios-sdk/Crashlytics/run\"\n";
		};
		89AA36072A1BB0280077A70A /* Setup Firebase Environment GoogleService-Info.plist */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			name = "Setup Firebase Environment GoogleService-Info.plist";
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "# Name of the resource we're selectively copying\nGOOGLESERVICE_INFO_PLIST=GoogleService-Info.plist\n\n# Get references to dev and prod versions of the GoogleService-Info.plist\n# NOTE: These should only live on the file system and should NOT be part of the target (since we'll be adding them to the target manually)\nGOOGLESERVICE_INFO_STAGING=${PROJECT_DIR}/${TARGET_NAME}/Resources/Staging/${GOOGLESERVICE_INFO_PLIST}\nGOOGLESERVICE_INFO_PROD=${PROJECT_DIR}/${TARGET_NAME}/Resources/Production/${GOOGLESERVICE_INFO_PLIST}\n\n# Make sure the staging version of GoogleService-Info.plist exists\necho \"Looking for ${GOOGLESERVICE_INFO_PLIST} in ${GOOGLESERVICE_INFO_STAGING}\"\nif [ ! -f $GOOGLESERVICE_INFO_STAGING ]\nthen\n    echo \"No Staging GoogleService-Info.plist found. Please ensure it's in the proper directory.\"\n    exit 1\nfi\n\n# Make sure the prod version of GoogleService-Info.plist exists\necho \"Looking for ${GOOGLESERVICE_INFO_PLIST} in ${GOOGLESERVICE_INFO_PROD}\"\nif [ ! -f $GOOGLESERVICE_INFO_PROD ]\nthen\n    echo \"No Production GoogleService-Info.plist found. Please ensure it's in the proper directory.\"\n    exit 1\nfi\n\n# Get a reference to the destination location for the GoogleService-Info.plist\nPLIST_DESTINATION=${BUILT_PRODUCTS_DIR}/${PRODUCT_NAME}.app\necho \"Will copy ${GOOGLESERVICE_INFO_PLIST} to final destination: ${PLIST_DESTINATION}\"\n\n# Copy over the prod GoogleService-Info.plist for Production builds\nif [ \"${CONFIGURATION}\" == \"Production Release\" ] || [ \"${CONFIGURATION}\" == \"Production Debug\" ]\nthen\n    echo \"Using ${GOOGLESERVICE_INFO_PROD}\"\n    cp \"${GOOGLESERVICE_INFO_PROD}\" \"${PLIST_DESTINATION}\"\nelse\n    echo \"Using ${GOOGLESERVICE_INFO_STAGING}\"\n    cp \"${GOOGLESERVICE_INFO_STAGING}\" \"${PLIST_DESTINATION}\"\nfi\n";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		895C1BA92A04FA53005EA190 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				895C1BC12A051261005EA190 /* SharedStorage.swift in Sources */,
				895C1BB02A04FA53005EA190 /* ShareViewController.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		89CD7A9229D32855003F1C3A /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				893EB5072AA723C80066914E /* AnalyticsDefaultParameters.swift in Sources */,
				8932ECE92A20F10500CBCD7A /* TextResizableView.swift in Sources */,
				89AAFEA129DB2672002D348E /* CacheManager.swift in Sources */,
				89CD7B5529D329B1003F1C3A /* Enum+Extensions.swift in Sources */,
				8932ECE72A20DCB900CBCD7A /* PdfFillFormViewModel.swift in Sources */,
				892CC6942AAA243E000DEC21 /* SuggestedFields+Persistable.swift in Sources */,
				89429F8C2A9C937C00465420 /* CDSignature.swift in Sources */,
				89436ABF29E55EA000060605 /* Pdf.swift in Sources */,
				8955ED962A1F73DC009985EE /* OnboardingViewModel.swift in Sources */,
				8936AA422A6840D1005F6C73 /* ChatPdfView.swift in Sources */,
				89436D1B2A939CBB000868B5 /* PdfReadViewModel.swift in Sources */,
				89AAFEA229DB2672002D348E /* CacheManagerImpl.swift in Sources */,
				89431FC62A9900740042A636 /* MathUtils.swift in Sources */,
				89436AC329E59C0E00060605 /* PdfEditViewModel.swift in Sources */,
				89407EF32AA8B0C800169801 /* GalleryImageProviderFlowView.swift in Sources */,
				893ED9D42A692805004EE67C /* CombineUtils.swift in Sources */,
				89CD7B9A29D329B1003F1C3A /* View+Internal.swift in Sources */,
				89BB2DB72A7A5EFC009E6738 /* PdfMergeView.swift in Sources */,
				89407EF72AA8BEC200169801 /* CameraImageProviderFlowView.swift in Sources */,
				89436D232A93C1CE000868B5 /* PdfPageSelectionView.swift in Sources */,
				89BB2DBF2A7AB0CE009E6738 /* PdfSortViewModel.swift in Sources */,
				89C2500F2A72B2BC00184C45 /* CDPdf.swift in Sources */,
				8928F3D12A30BAFB001C1853 /* PickedImage.swift in Sources */,
				894AC3642A02952A00BA5553 /* Foundation+Extensions.swift in Sources */,
				891AE58B2A03E80300DBC246 /* ObservableObject+Extensions.swift in Sources */,
				89429F952A9D001A00465420 /* Signature+Persistable.swift in Sources */,
				89CD7B5029D329B1003F1C3A /* String+Extensions.swift in Sources */,
				8968761E2A7CEE320014A320 /* PdfImportView.swift in Sources */,
				89429F932A9CFFF100465420 /* Pdf+Persistable.swift in Sources */,
				893B04BD2AA9C2C100F86813 /* CoreGraphics+Extensions.swift in Sources */,
				8936AA402A683FB5005F6C73 /* ImportOption.swift in Sources */,
				89429F912A9CFFDC00465420 /* Persistable.swift in Sources */,
				89CD7B5729D329B1003F1C3A /* DebugUtils.swift in Sources */,
				892E404F2A25E5D9000EEE23 /* PDFAnnotation+Extensions.swift in Sources */,
				893E849D29D5944E00F6B99A /* CameraService+Enums.swift in Sources */,
				89CD7BBB29D330FB003F1C3A /* HomeView.swift in Sources */,
				895C1BC02A051261005EA190 /* SharedStorage.swift in Sources */,
				89CD7B7329D329B1003F1C3A /* SubscribeViewModel.swift in Sources */,
				893E849129D5874D00F6B99A /* CameraView.swift in Sources */,
				89504A482A44829C000BCACD /* PdfFillWidgetViewModel.swift in Sources */,
				894B019F2A0902BC00FF6198 /* ImportTutorialView.swift in Sources */,
				893E849F29D5944E00F6B99A /* ImageResizer.swift in Sources */,
				893E849E29D5944E00F6B99A /* CameraPreviewView.swift in Sources */,
				893DE8DC29E7F9A10043C02C /* SubscriptionVerticalViewModel.swift in Sources */,
				893AAFCB2A39B2AF00EF9B00 /* FormSheet.swift in Sources */,
				89436D1F2A93AEB4000868B5 /* PdfReaderViewModel.swift in Sources */,
				895FE2CD29D724B900A99D5B /* SubscriptionPairsItemView.swift in Sources */,
				892201D92A0BA64600832CF2 /* ImageAnnotationStamp.swift in Sources */,
				894C4A6E2AA0CB470001F51E /* ReviewFlow.swift in Sources */,
				896876262A7D2EB80014A320 /* PdfPageRangeEditorViewModel.swift in Sources */,
				89EBC9072A83D0DB00BDBBD4 /* SubscriptionPickerPlanView.swift in Sources */,
				8962D6082A9E2A57008426A2 /* PdfSignatureProviderFlowView.swift in Sources */,
				897911EF29E70558008B7088 /* SubscriptionVerticalItemView.swift in Sources */,
				896876282A7D2EC20014A320 /* PdfPageRangeEditorView.swift in Sources */,
				89CD7B5629D329B1003F1C3A /* Async.swift in Sources */,
				89CD7B5129D329B1003F1C3A /* UIApplication+Extensions.swift in Sources */,
				89BB2DBB2A7A7DD7009E6738 /* PdfUnlockViewModel.swift in Sources */,
				8995694429D3450300566EF4 /* HomeViewModel.swift in Sources */,
				89CD7B9829D329B1003F1C3A /* SubscriptionViewUtility.swift in Sources */,
				89BB2DB92A7A6050009E6738 /* PdfMergeViewModel.swift in Sources */,
				89127AA32A177F170059005F /* PdfSignatureCanvasView.swift in Sources */,
				8933490C2A24AE880005D484 /* PdfKitViewBinder.swift in Sources */,
				893C8FD329DED2E9000E35BD /* Repository.swift in Sources */,
				89923E6929D46A9900E246FC /* FilePicker.swift in Sources */,
				893ED9D22A6926E8004EE67C /* ChatPdfMessage.swift in Sources */,
				894D485829D42C9E002B0230 /* OptionItemView.swift in Sources */,
				896876202A7CF1E10014A320 /* PdfImportMultipleViewModel.swift in Sources */,
				8936AA392A68299B005F6C73 /* ChatPdfManagerMock.swift in Sources */,
				89CD7B4B29D329B1003F1C3A /* AsyncView.swift in Sources */,
				C9CEF5EC2DB03CCE00980C8A /* SceneDelegate.swift in Sources */,
				89407EFC2AA8D22D00169801 /* ImageCropFlow.swift in Sources */,
				8991485129E851B500DD01F2 /* ConfigService.swift in Sources */,
				89E55BDF29DC64840073F268 /* AnalyticsManagerImpl.swift in Sources */,
				89407EF12AA8ADD200169801 /* GalleryImageProviderFlow.swift in Sources */,
				892CC6922AAA23AE000DEC21 /* CDSuggestedFields.swift in Sources */,
				896876222A7CF3220014A320 /* PdfImportMultipleView.swift in Sources */,
				895FE2C629D6E17600A99D5B /* AnimationPalette.swift in Sources */,
				8957FBAA2A77E6F7008B31ED /* PdfShareView.swift in Sources */,
				89436AB829E5556600060605 /* PdfCoordinator.swift in Sources */,
				89CD7B7029D329B1003F1C3A /* FontPalette.swift in Sources */,
				893BE52D2A6A78BB004B05B9 /* ChatPdfManagerImpl.swift in Sources */,
				895FE2CB29D6E9B800A99D5B /* SubscriptionPairsView.swift in Sources */,
				894C4A702AA0CCFC0001F51E /* ReviewFlowView.swift in Sources */,
				89923E5F29D4350F00E246FC /* AppTrackingTransparencyImpl.swift in Sources */,
				893C8FCB29DED1AF000E35BD /* ArchiveViewModel.swift in Sources */,
				89407EF52AA8BDE600169801 /* CameraImageProviderFlow.swift in Sources */,
				89E55BDE29DC64840073F268 /* FirebaseAnalyticsPlatform.swift in Sources */,
				895FE2C429D6D7E500A99D5B /* ScannerView.swift in Sources */,
				89CD7B4E29D329B1003F1C3A /* LottieView.swift in Sources */,
				8991485329E851BD00DD01F2 /* RemoteConfigManager.swift in Sources */,
				893875012A7BDD3B00267AFD /* LoadingView.swift in Sources */,
				89436D1D2A93AE76000868B5 /* PdfReaderView.swift in Sources */,
				89436D192A936C9F000868B5 /* PdfReadView.swift in Sources */,
				89CD7B5F29D329B1003F1C3A /* StoreImpl.swift in Sources */,
				893C8FD429DED2E9000E35BD /* RepositoryImpl.swift in Sources */,
				893E84A129D5944E00F6B99A /* CameraService+Extensions.swift in Sources */,
				897967862A73E59B00E91F8E /* URL+Extensions.swift in Sources */,
				89127AA52A17A3600059005F /* PdfSignatureCanvasViewModel.swift in Sources */,
				89CD7B9729D329B1003F1C3A /* SharedErrors.swift in Sources */,
				893E849429D5878E00F6B99A /* CameraViewModel.swift in Sources */,
				892201DE2A0BA72D00832CF2 /* PdfSignatureViewModel.swift in Sources */,
				8968761C2A7CEB650014A320 /* PdfImportViewModel.swift in Sources */,
				89460C6029DAC36600E39BAC /* SubscriptionErrorView.swift in Sources */,
				89BB2DBD2A7A80A8009E6738 /* PdfUnlockView.swift in Sources */,
				896CCF6D2A28910B008F268E /* SizePrinter.swift in Sources */,
				89127AA12A177E370059005F /* PencilKitView.swift in Sources */,
				894827B42AA5D6FF00030C4E /* AttibutionManagerImpl.swift in Sources */,
				89CD7BBD29D331AA003F1C3A /* AppDelegate.swift in Sources */,
				8968761A2A7CE87A0014A320 /* PdfSplitViewModel.swift in Sources */,
				893ED9D02A6920F2004EE67C /* ChatPdfRef.swift in Sources */,
				89CD7BB629D32E69003F1C3A /* MainCoordinator.swift in Sources */,
				89407F002AA8D54800169801 /* ImageCropper.swift in Sources */,
				899F484429DF128200E7E1E4 /* MainTabView.swift in Sources */,
				894D485A29D42CC5002B0230 /* OptionListView.swift in Sources */,
				89923E6029D4350F00E246FC /* AppTrackingTransparency.swift in Sources */,
				89CD7B9929D329B1003F1C3A /* View+Preview.swift in Sources */,
				8957FBA82A77C646008B31ED /* PdfShareCoordinator.swift in Sources */,
				894CB09E2A851FE50008008A /* ChatPdfSetupData.swift in Sources */,
				893DE8DA29E7F85C0043C02C /* SubscriptionPairsViewModel.swift in Sources */,
				89436AC729E5B99100060605 /* PdfKitView.swift in Sources */,
				894C4A722AA0DB9A0001F51E /* PreReviewPopupLowRateView.swift in Sources */,
				89CD7B5429D329B1003F1C3A /* Color+Extensions.swift in Sources */,
				897911ED29E70541008B7088 /* SubscriptionVerticalView.swift in Sources */,
				8936AA442A684128005F6C73 /* ChatPdfViewModel.swift in Sources */,
				89CD7B4D29D329B1003F1C3A /* UnderlyingError.swift in Sources */,
				89436D212A93B97E000868B5 /* NSAttributedString+Extensions.swift in Sources */,
				89B72A3329DADC790076884F /* SettingsView.swift in Sources */,
				896CCF6F2A28AEAC008F268E /* UIFont+Extensions.swift in Sources */,
				89D1FE802A84D76B009AC57C /* FullScreenClearBackground.swift in Sources */,
				8945D2BC2A03C41000AFF51A /* PdfScanUtility.swift in Sources */,
				89429F882A9C8EFC00465420 /* PdfSignaturePickerViewModel.swift in Sources */,
				89CD7B6E29D329B1003F1C3A /* Constants.swift in Sources */,
				8962D6062A9E28FB008426A2 /* PdfSignaturePrioviderFlow.swift in Sources */,
				893EB5032AA71FFD0066914E /* BranchAnalyticsPlatform.swift in Sources */,
				89436ABB29E557D500060605 /* PdfFlowView.swift in Sources */,
				89CD7B6529D329B1003F1C3A /* Store.swift in Sources */,
				893E849C29D5944E00F6B99A /* PhotoCaptureProcessor.swift in Sources */,
				894C4A692AA0C04B0001F51E /* PopupView.swift in Sources */,
				89407EFE2AA8D23B00169801 /* ImageCropFlowView.swift in Sources */,
				89F9E4FB2A9606ED0001D48B /* PdfImageViewerView.swift in Sources */,
				894B01A12A09030000FF6198 /* ImportTutorialPageView.swift in Sources */,
				892201DC2A0BA70300832CF2 /* PdfSignatureView.swift in Sources */,
				893E84A029D5944E00F6B99A /* CameraService.swift in Sources */,
				893C8FDE29DED7F4000E35BD /* PdfUtility.swift in Sources */,
				8995694229D33B1300566EF4 /* HomeItemView.swift in Sources */,
				894D485C29D42FE1002B0230 /* RoundedCorner.swift in Sources */,
				89EBC9052A83CC3000BDBBD4 /* SubscriptionFreeTrialToggleView.swift in Sources */,
				89E601622A829556009492DA /* SubscriptionPickerView.swift in Sources */,
				8934ACC72A6AE96700F6CDA8 /* ChatPdfInitParams.swift in Sources */,
				8966B6F22AA9FCE0005E6DED /* SuggestedFields.swift in Sources */,
				89CD7B4C29D329B1003F1C3A /* CircularProgressView.swift in Sources */,
				89E55BE229DC66240073F268 /* AnalyticsPlatform.swift in Sources */,
				893ED9D92A693013004EE67C /* MessageView.swift in Sources */,
				893C8FC929DED190000E35BD /* ArchiveView.swift in Sources */,
				89467AD72A9E4C6B00FC01FC /* Deeplink.swift in Sources */,
				89F9E4FD2A9635EC0001D48B /* ZoomImageModifier.swift in Sources */,
				89AAFEA729DB2AC4002D348E /* WelcomeView.swift in Sources */,
				8955ED922A1F61A9009985EE /* OnboardingView.swift in Sources */,
				89851B5E2A13DB1A00ABF58F /* ImageResizableView.swift in Sources */,
				89ABAA592A97B29C00721045 /* PdfDocument+Extensions.swift in Sources */,
				89BB2DC12A7AB4A8009E6738 /* PdfSortView.swift in Sources */,
				89429F862A9C8ECC00465420 /* PdfSignaturePickerView.swift in Sources */,
				8936AA3C2A682CDA005F6C73 /* ChatPdfSelectionView.swift in Sources */,
				8936AA332A6828C9005F6C73 /* ProjectInfo.swift in Sources */,
				893C8FD029DED278000E35BD /* Persistence.swift in Sources */,
				893BE5352A6A96F5004B05B9 /* ChatPdfRef+Decodable.swift in Sources */,
				89CD7B5229D329B1003F1C3A /* View+Alert.swift in Sources */,
				89E601642A8295A2009492DA /* SubscriptionPickerViewModel.swift in Sources */,
				893C8FCE29DED254000E35BD /* AppCoreData.xcdatamodeld in Sources */,
				89436ABD29E5586600060605 /* PdfEditView.swift in Sources */,
				89CD7B9329D329B1003F1C3A /* ContentView.swift in Sources */,
				89127AA72A17C1980059005F /* PencilKit+Extensions.swift in Sources */,
				89F9E4F92A95FEEE0001D48B /* PDFImageExtractor.swift in Sources */,
				893E84A629D5C5E200F6B99A /* ActivityViewController.swift in Sources */,
				8940FB912A710D8D00A00D8D /* AddPasswordView.swift in Sources */,
				8936AA3E2A682F8E005F6C73 /* ChatPdfSelectionViewModel.swift in Sources */,
				8932ECE52A20DC7700CBCD7A /* PdfFillFormView.swift in Sources */,
				893BE52F2A6A7C0C004B05B9 /* NetworkUtility.swift in Sources */,
				89D1FE7E2A84D428009AC57C /* SubscriptionPickerPlanListView.swift in Sources */,
				89CD7B5329D329B1003F1C3A /* View+Extensions.swift in Sources */,
				892CC6962AAA2641000DEC21 /* SuggestedFieldsFormView.swift in Sources */,
				8957FBAC2A7801BA008B31ED /* PdfCompressionPickerView.swift in Sources */,
				893BE5372A6A9708004B05B9 /* ChatPdfMessage+Decodable.swift in Sources */,
				89429F8A2A9C937300465420 /* Signature.swift in Sources */,
				892CC6982AAA2660000DEC21 /* SuggestedFieldsFormViewModel.swift in Sources */,
				8902898D29DC1F10007E6372 /* PageControl.swift in Sources */,
				894CB0A02A8520AD0008008A /* ChatPdfSetupData+Decodable.swift in Sources */,
				89E55BDC29DC64840073F268 /* AnalyticsManager.swift in Sources */,
				89CD7B4F29D329B1003F1C3A /* ParentalCheck.swift in Sources */,
				893ED9DA2A693013004EE67C /* MessageIndicatorView.swift in Sources */,
				8936AA382A68299B005F6C73 /* ChatPdfManager.swift in Sources */,
				89CD7A9A29D32855003F1C3A /* PdfExpertApp.swift in Sources */,
				89CD7B7129D329B1003F1C3A /* ColorPalette.swift in Sources */,
				89504A462A448252000BCACD /* PdfFillWidgetView.swift in Sources */,
				894C4A6B2AA0C23F0001F51E /* PreReviewPopupView.swift in Sources */,
				893EB5052AA722EF0066914E /* StoreKit+Extensions.swift in Sources */,
				896876242A7D05040014A320 /* PdfSplitView.swift in Sources */,
				8955ED942A1F61BD009985EE /* OnboardingPageView.swift in Sources */,
				894827B22AA5D68D00030C4E /* AttributionManager.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		C9CEF5E92DB02DBA00980C8A /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 895C1BAC2A04FA53005EA190 /* ShareFileExtension */;
			targetProxy = C9CEF5E82DB02DBA00980C8A /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		895C1BB12A04FA53005EA190 /* MainInterface.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				895C1BB22A04FA53005EA190 /* Base */,
			);
			name = MainInterface.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		895C1BB92A04FA53005EA190 /* Production Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_ENTITLEMENTS = ShareFileExtension/ShareFileExtension.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = KQM6GWHKY3;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = ShareFileExtension/Resources/Production/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = ShareFileExtension;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				IPHONEOS_DEPLOYMENT_TARGET = 16.4;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@executable_path/../../Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert.ShareFileExtension;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = "Production Debug";
		};
		895C1BBA2A04FA53005EA190 /* Production Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_ENTITLEMENTS = ShareFileExtension/ShareFileExtension.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = KQM6GWHKY3;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = ShareFileExtension/Resources/Production/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = ShareFileExtension;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				IPHONEOS_DEPLOYMENT_TARGET = 16.4;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@executable_path/../../Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert.ShareFileExtension;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = "Production Release";
		};
		89AA35FE2A1BAC100077A70A /* Staging Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 16.2;
				MARKETING_VERSION = 1.26;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				OTHER_LDFLAGS = "-ObjC";
				OTHER_SWIFT_FLAGS = " \"-D\" \"FACEBOOK\" \"-D\" \"STAGING\"";
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = "Staging Debug";
		};
		89AA35FF2A1BAC100077A70A /* Staging Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIconStaging;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
				CODE_SIGN_ENTITLEMENTS = PdfExpert/PdfExpert.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"PdfExpert/Preview Content\"";
				DEVELOPMENT_TEAM = KQM6GWHKY3;
				DISPLAY_NAME = "PDF Pro Staging";
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = AtlasPDF;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.productivity";
				INFOPLIST_KEY_NSCameraUsageDescription = "The app need to access your camera in order to scan documents or to take pictures to convert to pdf";
				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Recording sound annotations requires the microphone.";
				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "The app need to access your photo library in order to convert your pictures to pdf";
				INFOPLIST_KEY_NSUserTrackingUsageDescription = "Your data will be used to facilitate access and show you content that is more relevant to you.";
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UIRequiresFullScreen = YES;
				INFOPLIST_KEY_UIStatusBarStyle = UIStatusBarStyleLightContent;
				INFOPLIST_KEY_UISupportedInterfaceOrientations = UIInterfaceOrientationPortrait;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UIInterfaceOrientationPortrait";
				INFOPLIST_KEY_UIUserInterfaceStyle = Dark;
				IPHONEOS_DEPLOYMENT_TARGET = 16.6;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert;
				PRODUCT_NAME = "$(TARGET_NAME)";
				STRIP_INSTALLED_PRODUCT = NO;
				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = "Staging Debug";
		};
		89AA36002A1BAC100077A70A /* Staging Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_ENTITLEMENTS = ShareFileExtension/ShareFileExtension.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = KQM6GWHKY3;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = ShareFileExtension/Resources/Production/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = ShareFileExtension;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				IPHONEOS_DEPLOYMENT_TARGET = 16.4;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@executable_path/../../Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert.ShareFileExtension;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = "Staging Debug";
		};
		89AA36022A1BAC1A0077A70A /* Staging Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 16.2;
				MARKETING_VERSION = 1.26;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				OTHER_LDFLAGS = "-ObjC";
				OTHER_SWIFT_FLAGS = " \"-D\" \"FACEBOOK\" \"-D\" \"STAGING\"";
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				VALIDATE_PRODUCT = YES;
			};
			name = "Staging Release";
		};
		89AA36032A1BAC1A0077A70A /* Staging Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIconStaging;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
				CODE_SIGN_ENTITLEMENTS = PdfExpert/PdfExpert.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"PdfExpert/Preview Content\"";
				DEVELOPMENT_TEAM = KQM6GWHKY3;
				DISPLAY_NAME = "PDF Pro Staging";
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = AtlasPDF;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.productivity";
				INFOPLIST_KEY_NSCameraUsageDescription = "The app need to access your camera in order to scan documents or to take pictures to convert to pdf";
				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Recording sound annotations requires the microphone.";
				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "The app need to access your photo library in order to convert your pictures to pdf";
				INFOPLIST_KEY_NSUserTrackingUsageDescription = "Your data will be used to facilitate access and show you content that is more relevant to you.";
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UIRequiresFullScreen = YES;
				INFOPLIST_KEY_UIStatusBarStyle = UIStatusBarStyleLightContent;
				INFOPLIST_KEY_UISupportedInterfaceOrientations = UIInterfaceOrientationPortrait;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UIInterfaceOrientationPortrait";
				INFOPLIST_KEY_UIUserInterfaceStyle = Dark;
				IPHONEOS_DEPLOYMENT_TARGET = 16.6;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert;
				PRODUCT_NAME = "$(TARGET_NAME)";
				STRIP_INSTALLED_PRODUCT = NO;
				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = "Staging Release";
		};
		89AA36042A1BAC1A0077A70A /* Staging Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_ENTITLEMENTS = ShareFileExtension/ShareFileExtension.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = KQM6GWHKY3;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = ShareFileExtension/Resources/Production/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = ShareFileExtension;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				IPHONEOS_DEPLOYMENT_TARGET = 16.4;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@executable_path/../../Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert.ShareFileExtension;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = "Staging Release";
		};
		89CD7AA829D32856003F1C3A /* Production Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 16.2;
				MARKETING_VERSION = 1.26;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				OTHER_LDFLAGS = "-ObjC";
				OTHER_SWIFT_FLAGS = " \"-D\" \"FACEBOOK\" \"-D\" \"PRODUCTION\"";
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = "Production Debug";
		};
		89CD7AA929D32856003F1C3A /* Production Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 16.2;
				MARKETING_VERSION = 1.26;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				OTHER_LDFLAGS = "-ObjC";
				OTHER_SWIFT_FLAGS = " \"-D\" \"FACEBOOK\" \"-D\" \"PRODUCTION\"";
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				VALIDATE_PRODUCT = YES;
			};
			name = "Production Release";
		};
		89CD7AAB29D32856003F1C3A /* Production Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
				CODE_SIGN_ENTITLEMENTS = PdfExpert/PdfExpert.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"PdfExpert/Preview Content\"";
				DEVELOPMENT_TEAM = KQM6GWHKY3;
				DISPLAY_NAME = "PDF Pro";
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = AtlasPDF;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.productivity";
				INFOPLIST_KEY_NSCameraUsageDescription = "The app need to access your camera in order to scan documents or to take pictures to convert to pdf";
				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Recording sound annotations requires the microphone.";
				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "The app need to access your photo library in order to convert your pictures to pdf";
				INFOPLIST_KEY_NSUserTrackingUsageDescription = "Your data will be used to facilitate access and show you content that is more relevant to you.";
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UIRequiresFullScreen = YES;
				INFOPLIST_KEY_UIStatusBarStyle = UIStatusBarStyleLightContent;
				INFOPLIST_KEY_UISupportedInterfaceOrientations = UIInterfaceOrientationPortrait;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UIInterfaceOrientationPortrait";
				INFOPLIST_KEY_UIUserInterfaceStyle = Dark;
				IPHONEOS_DEPLOYMENT_TARGET = 16.6;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert;
				PRODUCT_NAME = "$(TARGET_NAME)";
				STRIP_INSTALLED_PRODUCT = NO;
				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = "Production Debug";
		};
		89CD7AAC29D32856003F1C3A /* Production Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
				CODE_SIGN_ENTITLEMENTS = PdfExpert/PdfExpert.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"PdfExpert/Preview Content\"";
				DEVELOPMENT_TEAM = KQM6GWHKY3;
				DISPLAY_NAME = "PDF Pro";
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = AtlasPDF;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.productivity";
				INFOPLIST_KEY_NSCameraUsageDescription = "The app need to access your camera in order to scan documents or to take pictures to convert to pdf";
				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Recording sound annotations requires the microphone.";
				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "The app need to access your photo library in order to convert your pictures to pdf";
				INFOPLIST_KEY_NSUserTrackingUsageDescription = "Your data will be used to facilitate access and show you content that is more relevant to you.";
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UIRequiresFullScreen = YES;
				INFOPLIST_KEY_UIStatusBarStyle = UIStatusBarStyleLightContent;
				INFOPLIST_KEY_UISupportedInterfaceOrientations = UIInterfaceOrientationPortrait;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UIInterfaceOrientationPortrait";
				INFOPLIST_KEY_UIUserInterfaceStyle = Dark;
				IPHONEOS_DEPLOYMENT_TARGET = 16.6;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert;
				PRODUCT_NAME = "$(TARGET_NAME)";
				STRIP_INSTALLED_PRODUCT = NO;
				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = "Production Release";
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		895C1BBB2A04FA54005EA190 /* Build configuration list for PBXNativeTarget "ShareFileExtension" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				895C1BB92A04FA53005EA190 /* Production Debug */,
				89AA36002A1BAC100077A70A /* Staging Debug */,
				895C1BBA2A04FA53005EA190 /* Production Release */,
				89AA36042A1BAC1A0077A70A /* Staging Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = "Production Release";
		};
		89CD7A9129D32855003F1C3A /* Build configuration list for PBXProject "pdfexpert" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				89CD7AA829D32856003F1C3A /* Production Debug */,
				89AA35FE2A1BAC100077A70A /* Staging Debug */,
				89CD7AA929D32856003F1C3A /* Production Release */,
				89AA36022A1BAC1A0077A70A /* Staging Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = "Production Release";
		};
		89CD7AAA29D32856003F1C3A /* Build configuration list for PBXNativeTarget "PdfExpert" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				89CD7AAB29D32856003F1C3A /* Production Debug */,
				89AA35FF2A1BAC100077A70A /* Staging Debug */,
				89CD7AAC29D32856003F1C3A /* Production Release */,
				89AA36032A1BAC1A0077A70A /* Staging Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = "Production Release";
		};
/* End XCConfigurationList section */

/* Begin XCRemoteSwiftPackageReference section */
		891A07E729E028EE0002FA3A /* XCRemoteSwiftPackageReference "CloudKitSyncMonitor" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/ggruen/CloudKitSyncMonitor.git";
			requirement = {
				branch = main;
				kind = branch;
			};
		};
		893BE5292A6A7864004B05B9 /* XCRemoteSwiftPackageReference "Moya" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/Moya/Moya";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 15.0.0;
			};
		};
		893E84A229D5BFBB00F6B99A /* XCRemoteSwiftPackageReference "PSPDFKit-SP" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/PSPDFKit/PSPDFKit-SP";
			requirement = {
				branch = master;
				kind = branch;
			};
		};
		893EB4FF2AA717B80066914E /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/facebook/facebook-ios-sdk";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 16.0.0;
			};
		};
		89407EF82AA8C4C400169801 /* XCRemoteSwiftPackageReference "Mantis" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/guoyingtao/Mantis.git";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 2.0.0;
			};
		};
		8942034329DC12BC004D610B /* XCRemoteSwiftPackageReference "PagerTabStripView" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/xmartlabs/PagerTabStripView";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 4.0.0;
			};
		};
		894827AE2AA5D65600030C4E /* XCRemoteSwiftPackageReference "ios-branch-sdk-spm" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/BranchMetrics/ios-branch-sdk-spm";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 2.0.0;
			};
		};
		895FE2CE29D7392E00A99D5B /* XCRemoteSwiftPackageReference "swift-collections" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/apple/swift-collections.git";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 1.0.0;
			};
		};
		8991485429E85DE500DD01F2 /* XCRemoteSwiftPackageReference "CombineExt" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/CombineCommunity/CombineExt.git";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 1.0.0;
			};
		};
		89CD7BA329D32C52003F1C3A /* XCRemoteSwiftPackageReference "lottie-spm" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/airbnb/lottie-spm.git";
			requirement = {
				branch = main;
				kind = branch;
			};
		};
		89CD7BA629D32C72003F1C3A /* XCRemoteSwiftPackageReference "Factory" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/hmlongco/Factory";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 2.0.0;
			};
		};
		89CD7BA929D32CE5003F1C3A /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/firebase/firebase-ios-sdk";
			requirement = {
				branch = master;
				kind = branch;
			};
		};
/* End XCRemoteSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		891A07E829E028EE0002FA3A /* CloudKitSyncMonitor */ = {
			isa = XCSwiftPackageProductDependency;
			package = 891A07E729E028EE0002FA3A /* XCRemoteSwiftPackageReference "CloudKitSyncMonitor" */;
			productName = CloudKitSyncMonitor;
		};
		893BE52A2A6A7864004B05B9 /* CombineMoya */ = {
			isa = XCSwiftPackageProductDependency;
			package = 893BE5292A6A7864004B05B9 /* XCRemoteSwiftPackageReference "Moya" */;
			productName = CombineMoya;
		};
		893E84A329D5BFBB00F6B99A /* PSPDFKit */ = {
			isa = XCSwiftPackageProductDependency;
			package = 893E84A229D5BFBB00F6B99A /* XCRemoteSwiftPackageReference "PSPDFKit-SP" */;
			productName = PSPDFKit;
		};
		893EB5002AA717B80066914E /* FacebookCore */ = {
			isa = XCSwiftPackageProductDependency;
			package = 893EB4FF2AA717B80066914E /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */;
			productName = FacebookCore;
		};
		89407EF92AA8C4C400169801 /* Mantis */ = {
			isa = XCSwiftPackageProductDependency;
			package = 89407EF82AA8C4C400169801 /* XCRemoteSwiftPackageReference "Mantis" */;
			productName = Mantis;
		};
		8942034429DC12BC004D610B /* PagerTabStripView */ = {
			isa = XCSwiftPackageProductDependency;
			package = 8942034329DC12BC004D610B /* XCRemoteSwiftPackageReference "PagerTabStripView" */;
			productName = PagerTabStripView;
		};
		894827AF2AA5D65600030C4E /* BranchSDK */ = {
			isa = XCSwiftPackageProductDependency;
			package = 894827AE2AA5D65600030C4E /* XCRemoteSwiftPackageReference "ios-branch-sdk-spm" */;
			productName = BranchSDK;
		};
		895FE2CF29D7392F00A99D5B /* Collections */ = {
			isa = XCSwiftPackageProductDependency;
			package = 895FE2CE29D7392E00A99D5B /* XCRemoteSwiftPackageReference "swift-collections" */;
			productName = Collections;
		};
		895FE2D129D7392F00A99D5B /* OrderedCollections */ = {
			isa = XCSwiftPackageProductDependency;
			package = 895FE2CE29D7392E00A99D5B /* XCRemoteSwiftPackageReference "swift-collections" */;
			productName = OrderedCollections;
		};
		8991485529E85DE500DD01F2 /* CombineExt */ = {
			isa = XCSwiftPackageProductDependency;
			package = 8991485429E85DE500DD01F2 /* XCRemoteSwiftPackageReference "CombineExt" */;
			productName = CombineExt;
		};
		89923E6629D437F500E246FC /* FirebasePerformance */ = {
			isa = XCSwiftPackageProductDependency;
			package = 89CD7BA929D32CE5003F1C3A /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
			productName = FirebasePerformance;
		};
		89CD7BA429D32C52003F1C3A /* Lottie */ = {
			isa = XCSwiftPackageProductDependency;
			package = 89CD7BA329D32C52003F1C3A /* XCRemoteSwiftPackageReference "lottie-spm" */;
			productName = Lottie;
		};
		89CD7BA729D32C72003F1C3A /* Factory */ = {
			isa = XCSwiftPackageProductDependency;
			package = 89CD7BA629D32C72003F1C3A /* XCRemoteSwiftPackageReference "Factory" */;
			productName = Factory;
		};
		89CD7BAA29D32CE5003F1C3A /* FirebaseAnalyticsSwift */ = {
			isa = XCSwiftPackageProductDependency;
			package = 89CD7BA929D32CE5003F1C3A /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
			productName = FirebaseAnalyticsSwift;
		};
		89CD7BAC29D32CE5003F1C3A /* FirebaseCrashlytics */ = {
			isa = XCSwiftPackageProductDependency;
			package = 89CD7BA929D32CE5003F1C3A /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
			productName = FirebaseCrashlytics;
		};
/* End XCSwiftPackageProductDependency section */

/* Begin XCVersionGroup section */
		893C8FCC29DED254000E35BD /* AppCoreData.xcdatamodeld */ = {
			isa = XCVersionGroup;
			children = (
				893C8FCD29DED254000E35BD /* PdfExpert.xcdatamodel */,
			);
			currentVersion = 893C8FCD29DED254000E35BD /* PdfExpert.xcdatamodel */;
			path = AppCoreData.xcdatamodeld;
			sourceTree = "<group>";
			versionGroupType = wrapper.xcdatamodel;
		};
/* End XCVersionGroup section */
	};
	rootObject = 89CD7A8E29D32855003F1C3A /* Project object */;
}



================================================
FILE: pdfexpert.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>



================================================
FILE: pdfexpert.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



================================================
FILE: pdfexpert.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict/>
</plist>



================================================
FILE: pdfexpert.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
================================================
{
  "pins" : [
    {
      "identity" : "abseil-cpp-binary",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/google/abseil-cpp-binary.git",
      "state" : {
        "revision" : "bfc0b6f81adc06ce5121eb23f628473638d67c5c",
        "version" : "1.2022062300.0"
      }
    },
    {
      "identity" : "alamofire",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/Alamofire/Alamofire.git",
      "state" : {
        "revision" : "bc268c28fb170f494de9e9927c371b8342979ece",
        "version" : "5.7.1"
      }
    },
    {
      "identity" : "cloudkitsyncmonitor",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/ggruen/CloudKitSyncMonitor.git",
      "state" : {
        "branch" : "main",
        "revision" : "8f8de8e71928df27bf023cc6ed808a8b6270a0d3"
      }
    },
    {
      "identity" : "combineext",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/CombineCommunity/CombineExt.git",
      "state" : {
        "revision" : "d7b896fa9ca8b47fa7bcde6b43ef9b70bf8c1f56",
        "version" : "1.8.1"
      }
    },
    {
      "identity" : "facebook-ios-sdk",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/facebook/facebook-ios-sdk",
      "state" : {
        "revision" : "5ed7a05695b2830fcfd97b62225272fad2f61043",
        "version" : "16.1.3"
      }
    },
    {
      "identity" : "factory",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/hmlongco/Factory",
      "state" : {
        "revision" : "061b3afe0358a0da7ce568f8272c847910be3dd7",
        "version" : "2.2.0"
      }
    },
    {
      "identity" : "firebase-ios-sdk",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/firebase/firebase-ios-sdk",
      "state" : {
        "branch" : "master",
        "revision" : "d7173ec3c7850ebe0304e940d68a999b229ad37f"
      }
    },
    {
      "identity" : "googleappmeasurement",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/google/GoogleAppMeasurement.git",
      "state" : {
        "revision" : "0a226a8c50494c4cb877fbde27ab6374520a3354",
        "version" : "10.12.0"
      }
    },
    {
      "identity" : "googledatatransport",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/google/GoogleDataTransport.git",
      "state" : {
        "revision" : "98a00258d4518b7521253a70b7f70bb76d2120fe",
        "version" : "9.2.4"
      }
    },
    {
      "identity" : "googleutilities",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/google/GoogleUtilities.git",
      "state" : {
        "revision" : "4446686bc3714d49ce043d0f68318f42ed718cb6",
        "version" : "7.11.4"
      }
    },
    {
      "identity" : "grpc-binary",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/google/grpc-binary.git",
      "state" : {
        "revision" : "f1b366129d1125be7db83247e003fc333104b569",
        "version" : "1.50.2"
      }
    },
    {
      "identity" : "gtm-session-fetcher",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/google/gtm-session-fetcher.git",
      "state" : {
        "revision" : "d415594121c9e8a4f9d79cecee0965cf35e74dbd",
        "version" : "3.1.1"
      }
    },
    {
      "identity" : "ios-branch-sdk-spm",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/BranchMetrics/ios-branch-sdk-spm",
      "state" : {
        "revision" : "7fbe3085821c8e60241a2037098c6eed76fd2798",
        "version" : "2.2.0"
      }
    },
    {
      "identity" : "leveldb",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/firebase/leveldb.git",
      "state" : {
        "revision" : "0706abcc6b0bd9cedfbb015ba840e4a780b5159b",
        "version" : "1.22.2"
      }
    },
    {
      "identity" : "lottie-spm",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/airbnb/lottie-spm.git",
      "state" : {
        "branch" : "main",
        "revision" : "60ea4f82fba8b4cb21a75665a889e86ed4d81c6e"
      }
    },
    {
      "identity" : "mantis",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/guoyingtao/Mantis.git",
      "state" : {
        "revision" : "29783a4a73625acb42e58438fb1f9451fdcb0094",
        "version" : "2.14.1"
      }
    },
    {
      "identity" : "moya",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/Moya/Moya",
      "state" : {
        "revision" : "c263811c1f3dbf002be9bd83107f7cdc38992b26",
        "version" : "15.0.3"
      }
    },
    {
      "identity" : "nanopb",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/firebase/nanopb.git",
      "state" : {
        "revision" : "819d0a2173aff699fb8c364b6fb906f7cdb1a692",
        "version" : "2.30909.0"
      }
    },
    {
      "identity" : "pagertabstripview",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/xmartlabs/PagerTabStripView",
      "state" : {
        "revision" : "39ec00d2577adf75d82d1c7023c56950b96d2298",
        "version" : "4.0.0"
      }
    },
    {
      "identity" : "promises",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/google/promises.git",
      "state" : {
        "revision" : "c22f76b709dc4bb6d274398259e75c191e50998a",
        "version" : "2.3.0"
      }
    },
    {
      "identity" : "pspdfkit-sp",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/PSPDFKit/PSPDFKit-SP",
      "state" : {
        "branch" : "master",
        "revision" : "33f91d1c5cac1a68876582bf05b561a9155a410c"
      }
    },
    {
      "identity" : "reactiveswift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/ReactiveCocoa/ReactiveSwift.git",
      "state" : {
        "revision" : "c43bae3dac73fdd3cb906bd5a1914686ca71ed3c",
        "version" : "6.7.0"
      }
    },
    {
      "identity" : "rxswift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/ReactiveX/RxSwift.git",
      "state" : {
        "revision" : "9dcaa4b333db437b0fbfaf453fad29069044a8b4",
        "version" : "6.6.0"
      }
    },
    {
      "identity" : "swift-collections",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-collections.git",
      "state" : {
        "revision" : "937e904258d22af6e447a0b72c0bc67583ef64a2",
        "version" : "1.0.4"
      }
    },
    {
      "identity" : "swift-protobuf",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-protobuf.git",
      "state" : {
        "revision" : "f25867a208f459d3c5a06935dceb9083b11cd539",
        "version" : "1.22.0"
      }
    }
  ],
  "version" : 2
}



================================================
FILE: pdfexpert.xcodeproj/xcshareddata/xcschemes/PdfExpert Staging.xcscheme
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1620"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
               BuildableName = "PdfExpert.app"
               BlueprintName = "PdfExpert"
               ReferencedContainer = "container:pdfexpert.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Staging Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Staging Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
            BuildableName = "PdfExpert.app"
            BlueprintName = "PdfExpert"
            ReferencedContainer = "container:pdfexpert.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <CommandLineArguments>
         <CommandLineArgument
            argument = "-com.apple.CoreData.Logging.stderr 0"
            isEnabled = "YES">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "-com.apple.CoreData.CloudKitDebug 0"
            isEnabled = "YES">
         </CommandLineArgument>
      </CommandLineArguments>
      <StoreKitConfigurationFileReference
         identifier = "../../PdfExpert/Resources/IAP/LocalStagingProducts.storekit">
      </StoreKitConfigurationFileReference>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Staging Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
            BuildableName = "PdfExpert.app"
            BlueprintName = "PdfExpert"
            ReferencedContainer = "container:pdfexpert.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Staging Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Staging Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>



================================================
FILE: pdfexpert.xcodeproj/xcshareddata/xcschemes/PdfExpert.xcscheme
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1620"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
               BuildableName = "PdfExpert.app"
               BlueprintName = "PdfExpert"
               ReferencedContainer = "container:pdfexpert.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Production Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <Testables>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Production Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
            BuildableName = "PdfExpert.app"
            BlueprintName = "PdfExpert"
            ReferencedContainer = "container:pdfexpert.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <CommandLineArguments>
         <CommandLineArgument
            argument = "-com.apple.CoreData.CloudKitDebug 0"
            isEnabled = "YES">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "-FIRAnalyticsVerboseLoggingEnabled"
            isEnabled = "YES">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "-FIRAnalyticsDebugEnabled"
            isEnabled = "YES">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "-com.apple.CoreData.Logging.stderr 0"
            isEnabled = "YES">
         </CommandLineArgument>
      </CommandLineArguments>
      <StoreKitConfigurationFileReference
         identifier = "../../PdfExpert/Resources/IAP/LocalProductionProducts.storekit">
      </StoreKitConfigurationFileReference>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Production Debug"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
            BuildableName = "PdfExpert.app"
            BlueprintName = "PdfExpert"
            ReferencedContainer = "container:pdfexpert.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Production Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Production Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>



================================================
FILE: pdfexpert.xcodeproj/xcshareddata/xcschemes/ShareFileExtension.xcscheme
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1620"
   version = "2.0">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "895C1BAC2A04FA53005EA190"
               BuildableName = "ShareFileExtension.appex"
               BlueprintName = "ShareFileExtension"
               ReferencedContainer = "container:pdfexpert.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "89847A382A1BA875000EC14B"
               BuildableName = "PdfExpert Staging.app"
               BlueprintName = "PdfExpert Staging"
               ReferencedContainer = "container:pdfexpert.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
               BuildableName = "PdfExpert.app"
               BlueprintName = "PdfExpert"
               ReferencedContainer = "container:pdfexpert.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = ""
      selectedLauncherIdentifier = "Xcode.IDEFoundation.Launcher.PosixSpawn"
      launchStyle = "0"
      askForAppToLaunch = "Yes"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES"
      launchAutomaticallySubstyle = "2">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
            BuildableName = "PdfExpert.app"
            BlueprintName = "PdfExpert"
            ReferencedContainer = "container:pdfexpert.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES"
      askForAppToLaunch = "Yes"
      launchAutomaticallySubstyle = "2">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
            BuildableName = "PdfExpert.app"
            BlueprintName = "PdfExpert"
            ReferencedContainer = "container:pdfexpert.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>



================================================
FILE: ShareFileExtension/ShareFileExtension.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>aps-environment</key>
	<string>development</string>
	<key>com.apple.developer.icloud-container-identifiers</key>
	<array>
		<string>iCloud.pdfexpert</string>
	</array>
	<key>com.apple.developer.icloud-services</key>
	<array>
		<string>CloudKit</string>
		<string>CloudDocuments</string>
	</array>
	<key>com.apple.developer.ubiquity-container-identifiers</key>
	<array>
		<string>iCloud.pdfexpert</string>
	</array>
	<key>com.apple.security.application-groups</key>
	<array>
		<string>group.pcnaid.pdfexpert</string>
	</array>
</dict>
</plist>



================================================
FILE: ShareFileExtension/ShareViewController.swift
================================================
//
//  ShareViewController.swift
//  ShareFileExtension
//
//  Created by Pcnaid Inc on 05/05/23.
//

import UIKit
import UniformTypeIdentifiers
import PDFKit

class ShareViewController: UIViewController {

    @IBOutlet weak var pdfContainerView: UIView!
    @IBOutlet weak var activityIndicatorView: UIActivityIndicatorView!
    @IBOutlet weak var button: UIButton!
    @IBOutlet weak var passwordView: UIStackView!
    @IBOutlet weak var passwordTextField: UITextField!
    
    private let pdfView = PDFView()
    
    private var confirmedPassword: String?
    private var buttonOriginalText: String = ""
    
    override func viewDidLoad() {
        super.viewDidLoad()

        self.activityIndicatorView.startAnimating()
        
        self.button.addTarget(self, action: #selector(self.onButtonPressed), for: .touchUpInside)
        
        self.buttonOriginalText = self.button.title(for: .normal) ?? ""
        
        self.pdfContainerView.addSubview(self.pdfView)
        self.pdfView.translatesAutoresizingMaskIntoConstraints = false
        self.pdfContainerView.addConstraint(NSLayoutConstraint(item: self.pdfView,
                                                               attribute: .top,
                                                               relatedBy: .equal,
                                                               toItem: self.pdfContainerView,
                                                               attribute: .top,
                                                               multiplier: 1,
                                                               constant: 0))
        self.pdfContainerView.addConstraint(NSLayoutConstraint(item: self.pdfView,
                                                               attribute: .bottom,
                                                               relatedBy: .equal,
                                                               toItem: self.pdfContainerView,
                                                               attribute:.bottom,
                                                               multiplier: 1,
                                                               constant: 0))
        self.pdfContainerView.addConstraint(NSLayoutConstraint(item: self.pdfView,
                                                               attribute: .leading,
                                                               relatedBy: .equal,
                                                               toItem: self.pdfContainerView,
                                                               attribute: .leading,
                                                               multiplier: 1, constant: 0))
        self.pdfContainerView.addConstraint(NSLayoutConstraint(item: self.pdfView, attribute: .trailing,
                                                               relatedBy: .equal,
                                                               toItem: self.pdfContainerView,
                                                               attribute: .trailing,
                                                               multiplier: 1,
                                                               constant: 0))
        
        self.passwordTextField.delegate = self
        
        self.updateUI()
        self.loadFile()
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
    }
    
    // MARK: - Private Methods
    
    private func loadFile() {
        
        if let extensionContext = self.extensionContext {
            debugPrint("ShareViewController - Extension Context exist...")
            if let item = extensionContext.inputItems.first as? NSExtensionItem, let itemProvider = item.attachments?.first {
                
                if itemProvider.hasItemConformingToTypeIdentifier(UTType.pdf.identifier) {
                    itemProvider.loadItem(
                        forTypeIdentifier: UTType.pdf.identifier,
                        options: nil,
                        completionHandler: { [weak self](result, error) in
                            
                            guard let result = result else {
                                debugPrint("ShareViewController - Missing results")
                                return
                            }
                            
                            if let error = error {
                                debugPrint("ShareViewController - Coulnd't load file. Error: \(error.localizedDescription)")
                                return
                            }
                            
                            var pdfDocument: PDFDocument?
                            
                            if let url = result as? URL {
                                pdfDocument = PDFDocument(url: url)
                            }
                            
                            if let data = result as? Data {
                                pdfDocument = PDFDocument(data: data)
                            }
                            
                            if let pdfDocument = pdfDocument {
                                debugPrint("ShareViewController - Successfully retreived pdf through action extension!")
                                DispatchQueue.main.async {
                                    self?.pdfView.document = pdfDocument
                                    self?.pdfView.autoScales = true
                                    self?.updateUI()
                                }
                            } else {
                                debugPrint("ShareViewController - Failed to convert file to pdf!")
                            }
                        })
                }
            }
        }
    }
    
    private func updateUI() {
        if let pdfDocument = self.pdfView.document {
            if pdfDocument.isLocked {
                self.pdfContainerView.isHidden = true
                self.activityIndicatorView.isHidden = true
                self.button.isHidden = false
                self.passwordView.isHidden = false
                self.button.setTitle("Unlock", for: .normal)
            } else {
                self.pdfContainerView.isHidden = false
                self.activityIndicatorView.isHidden = true
                self.button.isHidden = false
                self.passwordView.isHidden = true
                self.button.setTitle(self.buttonOriginalText, for: .normal)
            }
        } else {
            self.pdfContainerView.isHidden = true
            self.activityIndicatorView.isHidden = false
            self.button.isHidden = true
            self.passwordView.isHidden = true
        }
    }
    
    private func unlockPdf(pdfDocument: PDFDocument) {
        let password = self.passwordTextField.text ?? ""
        if pdfDocument.unlock(withPassword: password) {
            debugPrint("Share Extension - Pdf Unlocked!")
            self.confirmedPassword = password
            self.updateUI()
        } else {
            self.passwordTextField.text = nil
            let alert = UIAlertController(title: "Error", message: "Wrong Password", preferredStyle: .alert)
            alert.addAction(UIAlertAction(title: "OK", style: .default))
            self.present(alert, animated: true, completion: nil)
        }
    }
    
    private func sharePdf(pdfDocument: PDFDocument) {
        guard let extensionContext = self.extensionContext else {
            assertionFailure("Missing expected extensionContext")
            return
        }
        
        guard let url = URL(string: SharedStorage.schema) else {
            assertionFailure("Cannot create url to app")
            return
        }
        
        guard let pdfData = pdfDocument.dataRepresentation() else {
            assertionFailure("Missing expected pdf document data")
            self.showGenericErrorAlert()
            return
        }
        
        SharedStorage.pdfDataShareExtensionExistanceFlag = true
        SharedStorage.pdfDataShareExtension = pdfData
        if let confirmedPassword = self.confirmedPassword {
            SharedStorage.pdfDataShareExtensionPassword = confirmedPassword
        }
        let fileSizeWithUnit = ByteCountFormatter.string(fromByteCount: Int64(pdfData.count), countStyle: .file)
        debugPrint("Share Extension - Saved pdf data with size: \(fileSizeWithUnit)")
        if self.openURL(url) {
            extensionContext.completeRequest(returningItems: [], completionHandler: nil)
        } else {
            assertionFailure("Failed to open containing app")
        }
    }
    
    private func showGenericErrorAlert() {
        let alert = UIAlertController(title: "Ooops!", message: "Something went wrong! Please try again later.", preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "Ok", style: .default))
        self.present(alert, animated: true, completion: nil)
    }
    
    // MARK: - Actions
    
    @objc fileprivate func onButtonPressed() {
        guard let pdfDocument = self.pdfView.document else {
            assertionFailure("Missing expected pdf document")
            return
        }
        
        if pdfDocument.isLocked {
            self.unlockPdf(pdfDocument: pdfDocument)
        } else {
            self.sharePdf(pdfDocument: pdfDocument)
        }
    }
    
    //  Function must be named exactly like this so a selector can be found by the compiler!
    //  Anyway - it's another selector in another instance that would be "performed" instead.
    @objc func openURL(_ url: URL) -> Bool {
        var responder: UIResponder? = self
        while responder != nil {
            if let application = responder as? UIApplication {
                return application.perform(#selector(openURL(_:)), with: url) != nil
            }
            responder = responder?.next
        }
        return false
    }
}

extension ShareViewController: UITextFieldDelegate {
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        self.onButtonPressed()
        return true
    }
}



================================================
FILE: ShareFileExtension/.DS_Store
================================================
[Non-text file]


================================================
FILE: ShareFileExtension/Base.lproj/MainInterface.storyboard
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="23504" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="j1y-V4-xli">
    <device id="retina6_12" orientation="portrait" appearance="dark"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="23506"/>
        <capability name="Named colors" minToolsVersion="9.0"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="System colors in document resources" minToolsVersion="11.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <customFonts key="customFonts">
        <array key="Montserrat-Bold.ttf">
            <string>Montserrat-Bold</string>
        </array>
        <array key="Montserrat-Regular.ttf">
            <string>Montserrat-Regular</string>
        </array>
    </customFonts>
    <scenes>
        <!--Share View Controller-->
        <scene sceneID="ceB-am-kn3">
            <objects>
                <viewController id="j1y-V4-xli" customClass="ShareViewController" customModule="ShareFileExtension" sceneMemberID="viewController">
                    <view key="view" opaque="NO" contentMode="scaleToFill" id="wbc-yd-nQP">
                        <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <view contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="Udp-n4-U3L" userLabel="Pdf Container View">
                                <rect key="frame" x="0.0" y="159" width="393" height="559"/>
                                <color key="backgroundColor" systemColor="systemBackgroundColor"/>
                            </view>
                            <activityIndicatorView opaque="NO" contentMode="scaleToFill" horizontalHuggingPriority="750" verticalHuggingPriority="750" style="medium" translatesAutoresizingMaskIntoConstraints="NO" id="LoB-cg-3Nl" userLabel="Activity Indicator View">
                                <rect key="frame" x="186.66666666666666" y="428.66666666666669" width="20" height="20"/>
                            </activityIndicatorView>
                            <stackView opaque="NO" contentMode="scaleToFill" axis="vertical" spacing="30" translatesAutoresizingMaskIntoConstraints="NO" id="LWe-jE-eXY" userLabel="Password View">
                                <rect key="frame" x="61.333333333333343" y="397.33333333333331" width="270.33333333333326" height="82.666666666666686"/>
                                <subviews>
                                    <label opaque="NO" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="This document is password protected" textAlignment="natural" lineBreakMode="tailTruncation" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="TEi-fC-wqT" userLabel="Password Description Label">
                                        <rect key="frame" x="0.0" y="0.0" width="270.33333333333331" height="18.666666666666668"/>
                                        <fontDescription key="fontDescription" name="Montserrat-Regular" family="Montserrat" pointSize="16"/>
                                        <color key="textColor" name="PrimaryText"/>
                                        <nil key="highlightedColor"/>
                                    </label>
                                    <textField opaque="NO" contentMode="scaleToFill" horizontalHuggingPriority="248" contentHorizontalAlignment="left" contentVerticalAlignment="center" borderStyle="roundedRect" placeholder="Password" textAlignment="natural" minimumFontSize="17" translatesAutoresizingMaskIntoConstraints="NO" id="Mhr-1M-pA1" userLabel="Password Text Field">
                                        <rect key="frame" x="0.0" y="48.666666666666686" width="270.33333333333331" height="34"/>
                                        <color key="backgroundColor" name="SecondaryBG"/>
                                        <color key="textColor" name="PrimaryText"/>
                                        <fontDescription key="fontDescription" type="system" pointSize="14"/>
                                        <textInputTraits key="textInputTraits" autocorrectionType="no" secureTextEntry="YES" textContentType="password"/>
                                    </textField>
                                </subviews>
                            </stackView>
                            <button opaque="NO" contentMode="scaleToFill" contentHorizontalAlignment="center" contentVerticalAlignment="center" lineBreakMode="middleTruncation" translatesAutoresizingMaskIntoConstraints="NO" id="md1-kw-C6s" userLabel="Button">
                                <rect key="frame" x="133" y="740" width="127" height="48"/>
                                <color key="backgroundColor" name="ButtonGradientEnd"/>
                                <constraints>
                                    <constraint firstAttribute="height" constant="48" id="jhC-lL-wjN"/>
                                </constraints>
                                <fontDescription key="fontDescription" name="Montserrat-Bold" family="Montserrat" pointSize="16"/>
                                <inset key="imageEdgeInsets" minX="0.0" minY="0.0" maxX="2.2250738585072014e-308" maxY="0.0"/>
                                <state key="normal" title="Open in AtlasPDF"/>
                                <userDefinedRuntimeAttributes>
                                    <userDefinedRuntimeAttribute type="number" keyPath="layer.cornerRadius">
                                        <integer key="value" value="10"/>
                                    </userDefinedRuntimeAttribute>
                                </userDefinedRuntimeAttributes>
                            </button>
                        </subviews>
                        <viewLayoutGuide key="safeArea" id="1Xd-am-t49"/>
                        <color key="backgroundColor" systemColor="systemBackgroundColor"/>
                        <constraints>
                            <constraint firstItem="LWe-jE-eXY" firstAttribute="centerY" secondItem="1Xd-am-t49" secondAttribute="centerY" id="5aa-8c-GSl"/>
                            <constraint firstItem="Udp-n4-U3L" firstAttribute="leading" secondItem="1Xd-am-t49" secondAttribute="leading" id="6vG-gl-vKq"/>
                            <constraint firstItem="LoB-cg-3Nl" firstAttribute="centerY" secondItem="1Xd-am-t49" secondAttribute="centerY" id="PSB-Qe-bRS"/>
                            <constraint firstItem="Udp-n4-U3L" firstAttribute="top" secondItem="1Xd-am-t49" secondAttribute="top" constant="100" id="WE5-10-z7f"/>
                            <constraint firstItem="LoB-cg-3Nl" firstAttribute="centerX" secondItem="1Xd-am-t49" secondAttribute="centerX" id="Y6X-rb-27W"/>
                            <constraint firstItem="1Xd-am-t49" firstAttribute="bottom" secondItem="md1-kw-C6s" secondAttribute="bottom" constant="30" id="b0O-G2-bVJ"/>
                            <constraint firstItem="LWe-jE-eXY" firstAttribute="centerX" secondItem="1Xd-am-t49" secondAttribute="centerX" id="d9B-XK-8hX"/>
                            <constraint firstItem="1Xd-am-t49" firstAttribute="trailing" secondItem="Udp-n4-U3L" secondAttribute="trailing" id="jD3-5L-qBn"/>
                            <constraint firstItem="md1-kw-C6s" firstAttribute="centerX" secondItem="1Xd-am-t49" secondAttribute="centerX" id="zl2-pc-a5K"/>
                            <constraint firstItem="1Xd-am-t49" firstAttribute="bottom" secondItem="Udp-n4-U3L" secondAttribute="bottom" constant="100" id="zr2-mg-6uf"/>
                        </constraints>
                    </view>
                    <connections>
                        <outlet property="activityIndicatorView" destination="LoB-cg-3Nl" id="7Id-do-2HB"/>
                        <outlet property="button" destination="md1-kw-C6s" id="dU4-XV-0F1"/>
                        <outlet property="passwordTextField" destination="Mhr-1M-pA1" id="k55-QT-b18"/>
                        <outlet property="passwordView" destination="LWe-jE-eXY" id="Keg-cJ-2PI"/>
                        <outlet property="pdfContainerView" destination="Udp-n4-U3L" id="IKz-ab-Rq7"/>
                    </connections>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="CEy-Cv-SGf" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="140" y="-2"/>
        </scene>
    </scenes>
    <resources>
        <namedColor name="ButtonGradientEnd">
            <color red="0.24705882352941178" green="0.56862745098039214" blue="0.97254901960784312" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
        </namedColor>
        <namedColor name="PrimaryText">
            <color red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
        </namedColor>
        <namedColor name="SecondaryBG">
            <color red="0.13725490196078433" green="0.14117647058823529" blue="0.14901960784313725" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
        </namedColor>
        <systemColor name="systemBackgroundColor">
            <color white="1" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
        </systemColor>

```
