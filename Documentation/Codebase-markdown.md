
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where line numbers have been added, security check has been disabled.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

## Additional Info

# Directory Structure
```
ci_scripts/
  ci_post_clone.sh
pdfexpert/
  Applicaction/
    AppDelegate.swift
    Constants.swift
    PdfExpertApp.swift
    SceneDelegate.swift
  InternalUtils/
    ImageCropper.swift
    PdfScanUtility.swift
    PdfUtility.swift
    SharedErrors.swift
    SharedStorage.swift
    SubscriptionViewUtility.swift
    View+Internal.swift
    View+Preview.swift
  Models/
    Analytics/
      AnalyticsDefaultParameters.swift
      AnalyticsManager.swift
      AnalyticsManagerImpl.swift
      AnalyticsPlatform.swift
      BranchAnalyticsPlatform.swift
      FirebaseAnalyticsPlatform.swift
    Entities/
      ChatPdfInitParams.swift
      ChatPdfMessage.swift
      ChatPdfRef.swift
      ChatPdfSetupData.swift
      Pdf.swift
      PickedImage.swift
      ProjectInfo.swift
      Signature.swift
      SuggestedFields.swift
    Network/
      ChatPdf/
        Mapping/
          ChatPdfMessage+Decodable.swift
          ChatPdfRef+Decodable.swift
          ChatPdfSetupData+Decodable.swift
        ChatPdfManager.swift
        ChatPdfManagerImpl.swift
        ChatPdfManagerMock.swift
      NetworkUtility.swift
    Persistence/
      CoreData/
        Persistable/
          Pdf+Persistable.swift
          Persistable.swift
          Signature+Persistable.swift
          SuggestedFields+Persistable.swift
        CDPdf.swift
        CDSignature.swift
        CDSuggestedFields.swift
        Persistence.swift
      CacheManager.swift
      CacheManagerImpl.swift
      Repository.swift
      RepositoryImpl.swift
    AppTrackingTransparency.swift
    AppTrackingTransparencyImpl.swift
    AttibutionManagerImpl.swift
    AttributionManager.swift
    ConfigService.swift
    RemoteConfigManager.swift
    Store.swift
    StoreImpl.swift
  Preview Content/
    Preview Assets.xcassets/
      Contents.json
  Resources/
    Animations/
      loading.json
      pdf-scanning.json
    AppCoreData.xcdatamodeld/
      PdfExpert.xcdatamodel/
        contents
      .xccurrentversion
    Assets.xcassets/
      AccentColor.colorset/
        Contents.json
      AppIcon.appiconset/
        Contents.json
      AppIconStaging.appiconset/
        Contents.json
      archive_empty.imageset/
        Contents.json
      camera.imageset/
        Contents.json
      edit_add_file.imageset/
        Contents.json
      edit_add_text.imageset/
        Contents.json
      edit_compression.imageset/
        Contents.json
      edit_fill_form.imageset/
        Contents.json
      edit_margins.imageset/
        Contents.json
      edit_option_compress.imageset/
        Contents.json
      edit_option_password_lock.imageset/
        Contents.json
      edit_option_password_unlock.imageset/
        Contents.json
      edit_option_split.imageset/
        Contents.json
      edit_signature.imageset/
        Contents.json
      file.imageset/
        Contents.json
      gallery.imageset/
        Contents.json
      home_add_password.imageset/
        Contents.json
      home_add_text.imageset/
        Contents.json
      home_create_pdf.imageset/
        Contents.json
      home_excel_to_pdf.imageset/
        Contents.json
      home_file_source_dropbox.imageset/
        Contents.json
      home_file_source_files.imageset/
        Contents.json
      home_file_source_google.imageset/
        Contents.json
      home_file_source_icloud.imageset/
        Contents.json
      home_fill_form.imageset/
        Contents.json
      home_image_to_pdf.imageset/
        Contents.json
      home_import_pdf.imageset/
        Contents.json
      home_merge.imageset/
        Contents.json
      home_power_to_pdf.imageset/
        Contents.json
      home_read.imageset/
        Contents.json
      home_remove_password.imageset/
        Contents.json
      home_scan.imageset/
        Contents.json
      home_sign.imageset/
        Contents.json
      home_split.imageset/
        Contents.json
      home_word_to_pdf.imageset/
        Contents.json
      import_tutorial_1.imageset/
        Contents.json
      import_tutorial_2.imageset/
        Contents.json
      import_tutorial_3.imageset/
        Contents.json
      info.imageset/
        Contents.json
      logo_large.imageset/
        Contents.json
      manage_annotations.imageset/
        Contents.json
      manage_widget.imageset/
        Contents.json
      onboarding_chat_pdf.imageset/
        Contents.json
      onboarding_convert.imageset/
        Contents.json
      onboarding_password.imageset/
        Contents.json
      onboarding_signature.imageset/
        Contents.json
      page_selection.imageset/
        Contents.json
      password_entered.imageset/
        Contents.json
      password_missing.imageset/
        Contents.json
      review_low_rate.imageset/
        Contents.json
      scan.imageset/
        Contents.json
      settings.imageset/
        Contents.json
      sign_drawing.imageset/
        Contents.json
      signature.imageset/
        Contents.json
      Subscription/
        subscription_feature_chat_pdf.imageset/
          Contents.json
        subscription_feature_convert.imageset/
          Contents.json
        subscription_feature_edit.imageset/
          Contents.json
        subscription_feature_password.imageset/
          Contents.json
        subscription_feature_signature.imageset/
          Contents.json
        Contents.json
      subscription_error.imageset/
        Contents.json
      suggested_fields.imageset/
        Contents.json
      tab_archive.imageset/
        Contents.json
      tab_chat_pdf.imageset/
        Contents.json
      tab_home.imageset/
        Contents.json
      Contents.json
    Colors.xcassets/
      AppPrimary.colorset/
        Contents.json
      Extra.colorset/
        Contents.json
      FourthText.colorset/
        Contents.json
      PrimaryBG.colorset/
        Contents.json
      PrimaryText.colorset/
        Contents.json
      SecondaryBG.colorset/
        Contents.json
      SecondaryText.colorset/
        Contents.json
      Specific/
        ButtonGradientEnd.colorset/
          Contents.json
        ButtonGradientStart.colorset/
          Contents.json
        Contents.json
      ThirdText.colorset/
        Contents.json
      Contents.json
    IAP/
      EmptyProducts.storekit
      LocalProductionProducts.storekit
      LocalStagingProducts.storekit
      ProductionProducts.storekit
      Products.plist
      StagingProducts.storekit
    InfoTemplate.plist
  Style/
    AnimationPalette.swift
    ColorPalette.swift
    FontPalette.swift
  Utils/
    Camera/
      CameraPreviewView.swift
      CameraService.swift
      CameraService+Enums.swift
      CameraService+Extensions.swift
      ImageResizer.swift
      PhotoCaptureProcessor.swift
    Extensions/
      Color+Extensions.swift
      CoreGraphics+Extensions.swift
      Enum+Extensions.swift
      Foundation+Extensions.swift
      NSAttributedString+Extensions.swift
      ObservableObject+Extensions.swift
      PDFAnnotation+Extensions.swift
      PdfDocument+Extensions.swift
      PencilKit+Extensions.swift
      StoreKit+Extensions.swift
      String+Extensions.swift
      UIApplication+Extensions.swift
      UIFont+Extensions.swift
      URL+Extensions.swift
      View+Alert.swift
      View+Extensions.swift
    UI/
      ActivityViewController.swift
      AsyncView.swift
      CircularProgressView.swift
      FilePicker.swift
      FormSheet.swift
      FullScreenClearBackground.swift
      ImageAnnotationStamp.swift
      ImageResizableView.swift
      LoadingView.swift
      LottieView.swift
      PageControl.swift
      PdfKitView.swift
      PdfKitViewBinder.swift
      PencilKitView.swift
      PopupView.swift
      RoundedCorner.swift
      SizePrinter.swift
      TextResizableView.swift
      UnderlyingError.swift
      ZoomImageModifier.swift
    Async.swift
    CombineUtils.swift
    DebugUtils.swift
    MathUtils.swift
    ParentalCheck.swift
    PDFImageExtractor.swift
  ViewModels/
    ArchiveViewModel.swift
    CameraImageProviderFlow.swift
    CameraViewModel.swift
    ChatPdfSelectionViewModel.swift
    ChatPdfViewModel.swift
    GalleryImageProviderFlow.swift
    HomeViewModel.swift
    ImageCropFlow.swift
    OnboardingViewModel.swift
    PdfEditViewModel.swift
    PdfFillFormViewModel.swift
    PdfFillWidgetViewModel.swift
    PdfImportMultipleViewModel.swift
    PdfImportViewModel.swift
    PdfMergeViewModel.swift
    PdfPageRangeEditorViewModel.swift
    PdfReaderViewModel.swift
    PdfReadViewModel.swift
    PdfSignatureCanvasViewModel.swift
    PdfSignaturePickerViewModel.swift
    PdfSignaturePrioviderFlow.swift
    PdfSignatureViewModel.swift
    PdfSortViewModel.swift
    PdfSplitViewModel.swift
    PdfUnlockViewModel.swift
    ReviewFlow.swift
    SubscribeViewModel.swift
    SubscriptionPairsViewModel.swift
    SubscriptionPickerViewModel.swift
    SubscriptionVerticalViewModel.swift
    SuggestedFieldsFormViewModel.swift
  Views/
    Archive/
      ArchiveView.swift
    Camera/
      CameraView.swift
    ChatPdf/
      ChatPdfSelectionView.swift
      ChatPdfView.swift
      MessageIndicatorView.swift
      MessageView.swift
    Common/
      AddPasswordView.swift
      CameraImageProviderFlowView.swift
      GalleryImageProviderFlowView.swift
      ImageCropFlowView.swift
      ImportOption.swift
      OptionItemView.swift
      OptionListView.swift
      PdfImageViewerView.swift
      PdfImportMultipleView.swift
      PdfImportView.swift
      PdfMergeView.swift
      PdfPageRangeEditorView.swift
      PdfPageSelectionView.swift
      PdfReaderView.swift
      PdfReadView.swift
      PdfShareView.swift
      PdfSortView.swift
      PdfSplitView.swift
      PdfUnlockView.swift
      SuggestedFieldsFormView.swift
    Home/
      HomeItemView.swift
      HomeView.swift
    ImportTutorial/
      ImportTutorialPageView.swift
      ImportTutorialView.swift
    Main/
      MainTabView.swift
    Navigation/
      Deeplink.swift
      MainCoordinator.swift
      PdfCoordinator.swift
      PdfShareCoordinator.swift
    Onboarding/
      OnboardingPageView.swift
      OnboardingView.swift
    Pdf/
      PdfCompressionPickerView.swift
      PdfEditView.swift
      PdfFillFormView.swift
      PdfFillWidgetView.swift
      PdfFlowView.swift
      PdfSignatureCanvasView.swift
      PdfSignaturePickerView.swift
      PdfSignatureProviderFlowView.swift
      PdfSignatureView.swift
    Review/
      PreReviewPopupLowRateView.swift
      PreReviewPopupView.swift
      ReviewFlowView.swift
    Scan/
      ScannerView.swift
    Settings/
      SettingsView.swift
    Subscription/
      SubscriptionErrorView.swift
      SubscriptionFreeTrialToggleView.swift
      SubscriptionPairsItemView.swift
      SubscriptionPairsView.swift
      SubscriptionPickerPlanListView.swift
      SubscriptionPickerPlanView.swift
      SubscriptionPickerView.swift
      SubscriptionVerticalItemView.swift
      SubscriptionVerticalView.swift
    Welcome/
      WelcomeView.swift
    ContentView.swift
  PdfExpert.entitlements
pdfexpert.xcodeproj/
  project.xcworkspace/
    xcshareddata/
      swiftpm/
        Package.resolved
      IDEWorkspaceChecks.plist
      WorkspaceSettings.xcsettings
    contents.xcworkspacedata
  xcshareddata/
    xcschemes/
      PdfExpert Staging.xcscheme
      PdfExpert.xcscheme
      ShareFileExtension.xcscheme
  project.pbxproj
ShareFileExtension/
  Base.lproj/
    MainInterface.storyboard
  Resources/
    Production/
      Info.plist
    Staging/
      Info.plist
  ShareFileExtension.entitlements
  ShareViewController.swift
.gitignore
README.md
```

# Files

## File: ci_scripts/ci_post_clone.sh
```bash
 1: #!/bin/sh
 2: 
 3: #  ci_post_clone.sh
 4: #  PdfExpert
 5: #
 6: #  Created by Pcnaid Inc on 19/07/23.
 7: #  
 8: 
 9: echo "POST CLONE-Xcode Build started"
10: 
11: BasePath=${CI_WORKSPACE}/PdfExpert
12: 
13: # GoogleService-Info.plist
14: 
15: CurrentFilePath=${BasePath}/Resources/Staging/GoogleService-Info.plist
16: touch "${CurrentFilePath}"
17: echo $CUSTOM_GOOGLE_SERVICE_INFO >"${CurrentFilePath}"
18: 
19: CurrentFilePath=${BasePath}/Resources/Production/GoogleService-Info.plist
20: touch "${CurrentFilePath}"
21: echo $CUSTOM_GOOGLE_SERVICE_INFO >"${CurrentFilePath}"
22: 
23: # Info.plist
24: 
25: CurrentFilePath=${BasePath}/Resources/Staging/Info.plist
26: touch "${CurrentFilePath}"
27: echo $CUSTOM_GOOGLE_SERVICE_INFO >"${CurrentFilePath}"
28: 
29: CurrentFilePath=${BasePath}/Resources/Production/Info.plist
30: touch "${CurrentFilePath}"
31: echo $CUSTOM_GOOGLE_SERVICE_INFO >"${CurrentFilePath}"
32: 
33: # ProjectInfo.plist
34: 
35: CurrentFilePath=${BasePath}/Resources/ProjectInfo.plist
36: touch "${CurrentFilePath}"
37: echo $CUSTOM_PROJECT_INFO >"${CurrentFilePath}"
38: 
39: echo "POST CLONE-Xcode Build finished"
40: 
41: exit 0
```

## File: pdfexpert/Applicaction/AppDelegate.swift
```swift
 1: //
 2: //  AppDelegate.swift
 3: //  pdfexpert
 4: //
 5: //  Created by Pcnaid Inc on 28/03/23.
 6: //
 7: 
 8: import UIKit
 9: import FirebaseCore
10: import FacebookCore
11: import Factory
12: 
13: class AppDelegate: UIResponder, UIApplicationDelegate {
14: 
15:     @Injected(\.attibutionManager) var attibutionManager
16: 
17:     func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
18:         // App-level initializations belong here
19:         FirebaseApp.configure()
20:         ApplicationDelegate.shared.application(application, didFinishLaunchingWithOptions: launchOptions)
21:         self.attibutionManager.onAppDidFinishLaunching(withLaunchOptions: launchOptions)
22:         ProjectInfo.validate()
23: 
24:         // Appearance setup is moved to SceneDelegate
25: 
26:         return true
27:     }
28: 
29:     // MARK: UISceneSession Lifecycle
30: 
31:     func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
32:         // Called when a new scene session is being created.
33:         // Use this method to select a configuration to create the new scene with.
34:         return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
35:     }
36: 
37:     func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
38:         // Called when the user discards a scene session.
39:         // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
40:         // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
41:     }
42: 
43:     // setupAppearance() method is removed from here
44: }
```

## File: pdfexpert/Applicaction/Constants.swift
```swift
  1: //
  2: //  Constants.swift
  3: //  ChatAI
  4: //
  5: //  Created by Pcnaid Inc on 23/02/23.
  6: //
  7: 
  8: import Foundation
  9: import CoreData
 10: import UniformTypeIdentifiers
 11: import PDFKit
 12: import Factory
 13: 
 14: enum SubscriptionViewType: CaseIterable {
 15:     case pairs
 16:     case verticalHighlightLongPeriod
 17:     case verticalHighlightShortPeriod
 18:     case picker
 19: }
 20: 
 21: struct K {
 22:     struct Test {
 23:         static let UseMockDB = false
 24:         static let NumberOfPdfs = 5
 25:         
 26:         static var DebugPdfDocumentUrl: URL? {
 27:             return Bundle.main.url(forResource: "test", withExtension: "pdf")
 28:         }
 29:         
 30:         static var DebugPdfDocumentData: Data? {
 31:             guard let testFileUrl = DebugPdfDocumentUrl, (try? testFileUrl.checkResourceIsReachable()) ?? false else { return nil }
 32:             return try? Data(contentsOf: testFileUrl)
 33:         }
 34:         
 35:         static var DebugPdfDocument: PDFDocument? {
 36:             guard let testFileDataUrl = DebugPdfDocumentData else { return nil }
 37:             return PDFDocument(data: testFileDataUrl)
 38:         }
 39:         
 40:         static func GetDebugCoreDataPdf(context: NSManagedObjectContext) -> CDPdf? {
 41:             guard let testPdf = DebugPdf, let pdfData = testPdf.rawData else { return nil }
 42:             let coreDataPdf = CDPdf(context: context)
 43:             coreDataPdf.update(withPdf: testPdf, pdfData: pdfData)
 44:             return coreDataPdf
 45:         }
 46:         
 47:         static var DebugPdf: Pdf? {
 48:             guard let testPdfDocument = DebugPdfDocument else { return nil }
 49:             return Pdf(pdfDocument: testPdfDocument)
 50:         }
 51:         
 52:         struct ChatPdf {
 53:             static let UseMock = false
 54:             static let NetworkStubsDelay = 1.0
 55:             static let NetworkLogVerbose = false
 56:         }
 57:         
 58:         struct Review {
 59:             // If set to true, the review flow starts every time the current logic would trigger it,
 60:             // even if it has already been shown in the past.
 61:             static let ShowAlways = false
 62:         }
 63:     }
 64:     
 65:     struct MonetizationK {
 66:         static let defaultSubscriptionViewType: SubscriptionViewType = .verticalHighlightLongPeriod
 67:     }
 68:     
 69:     struct RemoteConfigK {
 70:         static let DebugRemoteConfigExpirationDuration: TimeInterval = 30.0
 71:         static let DefaultRemoteConfigExpirationDuration: TimeInterval = 60.0 * 60.0
 72:     }
 73:     
 74:     struct ChatPdf {
 75:         static let MaxBytes: UInt64 = 32 * 1_048_576 // 32 MB
 76:         static let MaxPages: Int = 2000
 77:         static let SetupMessageFallbackResponse: String = "Ask me something about your pdf!"
 78:         static let SetupMessageRequest: String = """
 79: Make a summary and suggest three questions. Format your response as a json with the following structure:
 80: {
 81:     "\(ChatPdfSetupData.CodingKeys.summary.rawValue)": "content of the summary",
 82:     "\(ChatPdfSetupData.CodingKeys.suggestedQuestions.rawValue)": [
 83:         "suggested question number 1",
 84:         "suggested question number 2",
 85:         "suggested question number 3"
 86:     ]
 87: }
 88: """
 89:     }
 90:     
 91:     struct Review {
 92:         static let MinimumRateForNativePopup: Int = 5
 93:         static let FeedbackMaxCharacters: Int = 100
 94:     }
 95:     
 96:     struct Misc {
 97:         static let AppTitle = "AtlasPDF"
 98:         
 99:         static let PrivacyPolicyUrlString = "https://pcnaid.com/policy-viewer/privacy"
100:         static let TermsAndConditionsUrlString = "https://pcnaid.com/policy-viewer/terms"
101:         
102:         static let ImportFileTypesForAddPage: [UTType] = {
103:             [
104:                 UTType.image,
105:                 UTType.pdf,
106:                 .presentation,
107:                 .spreadsheet,
108:                 UTType("com.microsoft.word.doc"),
109:                 UTType("com.apple.iwork.pages.sffpages")
110:             ].compactMap { $0 }
111:         }()
112:         static let ImportFileTypesForMerge: [UTType] = { [UTType.pdf].compactMap { $0 } }()
113:         static let ImportFileTypesForSplit: [UTType] = { [UTType.pdf].compactMap { $0 } }()
114:         static let ImportFileTypesForRead: [UTType] = { [UTType.pdf].compactMap { $0 } }()
115:         
116:         static let ThumbnailSize: CGSize = CGSize(width: 256, height: 256)
117:         static let ThumbnailEditSize: CGSize = CGSize(width: 80, height: 80)
118:         static let PdfPageSize: CGSize = CGSize(width: 595, height: 842)
119:         static let PdfPageDefaultMargin: CGFloat = 0
120:         static let DefaultAnnotationTextFontSize: CGFloat = 10.0
121:         static let DefaultAnnotationTextFontName: String = "Arial"
122:         static let PdfMarginsColor: UIColor = .white
123:         static let PdfDefaultMarginsOption: MarginsOption = .noMargins
124:         static let PdfDefaultCompression: CompressionOption = .noCompression
125:         static let PdfReaderDefaultFontScale: CGFloat = 1.5
126:         static let SignatureDrawScaleFactor: CGFloat = 3.0
127:     }
128: }
129: 
130: extension MarginsOption {
131:     var horizontalMargin: CGFloat {
132:         switch self {
133:         case .noMargins: return 0.0
134:         case .mediumMargins: return 20.0
135:         case .heavyMargins: return 40.0
136:         }
137:     }
138: }
139: 
140: extension CompressionOption {
141:     var quality: CGFloat {
142:         switch self {
143:         case .noCompression: return 1.0
144:         case .low: return 0.66
145:         case .medium: return 0.33
146:         case .high: return 0
147:         }
148:     }
149: }
150: 
151: extension ImportFileOption: FilePickerTypeProvider {
152:      
153:     var fileTypes: [UTType] {
154:         switch self {
155:         case .image: return [UTType.image]
156:         case .word: return [UTType("com.microsoft.word.doc")].compactMap { $0 }
157:         case .excel: return [.spreadsheet]
158:         case .powerpoint: return [.presentation]
159:         case .pdf: return [UTType.pdf]
160:         case .allDocs: return [
161:             UTType.pdf,
162:             .presentation,
163:             .spreadsheet,
164:             UTType("com.microsoft.word.doc"),
165:             UTType("com.apple.iwork.pages.sffpages")
166:         ].compactMap { $0 }
167:         }
168:     }
169:  }
```

## File: pdfexpert/Applicaction/PdfExpertApp.swift
```swift
 1: //
 2: //  PdfExpertApp.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 28/03/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: @main
11: struct PdfExpertApp: App {
12:     @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
13: 
14:     var body: some Scene {
15:         WindowGroup {
16:             ContentView()
17:         }
18:     }
19: }
```

## File: pdfexpert/Applicaction/SceneDelegate.swift
```swift
 1: //
 2: //  SceneDelegate.swift
 3: //  pdfexpert
 4: //
 5: //  Created by AbdulBadran on 4/16/25.
 6: //
 7: 
 8: import UIKit
 9: import SwiftUI // Import SwiftUI if ColorPalette/FontPalette are defined there or rely on it
10: 
11: class SceneDelegate: UIResponder, UIWindowSceneDelegate {
12: 
13:     var window: UIWindow?
14: 
15:     func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
16:         // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
17: 
18:         // Setup global appearance just before the scene's window appears
19:         self.setupAppearance()
20: 
21:         // If using SwiftUI App lifecycle (@main struct ... : App),
22:         // the system handles window creation and root view controller setup.
23:         // No manual window setup needed here if PdfExpertApp.swift has WindowGroup.
24: 
25:         guard let _ = (scene as? UIWindowScene) else { return }
26: 
27:         // Example if you needed to inject environment objects into ContentView
28:         // (assuming ContentView is your root view from PdfExpertApp)
29:         // if let windowScene = scene as? UIWindowScene {
30:         //     let window = UIWindow(windowScene: windowScene)
31:         //     let contentView = ContentView().environmentObject(YourObservableObject()) // Example
32:         //     window.rootViewController = UIHostingController(rootView: contentView)
33:         //     self.window = window
34:         //     window.makeKeyAndVisible()
35:         // }
36: 
37:         // If your PdfExpertApp.swift correctly defines the WindowGroup with ContentView,
38:         // the standard template code above is often sufficient, and SwiftUI handles the rest.
39:     }
40: 
41:     private func setupAppearance() {
42:         // Copied from AppDelegate
43:         UINavigationBar.appearance().isTranslucent = false
44:         // Make sure ColorPalette and FontPalette are accessible here
45:         // You might need to ensure they are defined globally or imported correctly
46:         // If they are SwiftUI types (e.g., Color, Font), use them directly.
47:         // If they return UIColors/UIFonts, the existing code is fine.
48: 
49:         // Assuming ColorPalette.primaryText returns a type initializable by UIColor
50:         // and FontPalette.uiFontMedium returns a UIFont
51:         // If not, adjust the initializers accordingly.
52:         UINavigationBar.appearance().tintColor = UIColor(ColorPalette.primaryText) // Example if using Asset Catalog Color
53:         // Or if ColorPalette.primaryText IS a UIColor:
54:         // UINavigationBar.appearance().tintColor = ColorPalette.primaryText
55: 
56:         UINavigationBar.appearance().largeTitleTextAttributes = [.font : UIFont.systemFont(ofSize: 24, weight: .medium)] // Example using system font
57:         // Or if FontPalette.uiFontMedium returns a UIFont:
58:         // UINavigationBar.appearance().largeTitleTextAttributes = [.font : FontPalette.uiFontMedium(withSize: 24)]
59: 
60:         let tabBarAppearance = UITabBarAppearance()
61:         tabBarAppearance.configureWithOpaqueBackground()
62:         // Similar adjustments might be needed for ColorPalette usage:
63:         tabBarAppearance.backgroundColor = UIColor(ColorPalette.secondaryBG) // Example
64:         tabBarAppearance.selectionIndicatorTintColor = UIColor(ColorPalette.buttonGradientStart) // Example
65: 
66:         UITabBar.appearance().scrollEdgeAppearance = tabBarAppearance
67:         UITabBar.appearance().standardAppearance = tabBarAppearance
68:     }
69: 
70: 
71:     func sceneDidDisconnect(_ scene: UIScene) {
72:         // Called as the scene is being released by the system.
73:         // This occurs shortly after the scene enters the background, or when its session is discarded.
74:         // Release any resources associated with this scene that can be re-created the next time the scene connects.
75:         // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
76:     }
77: 
78:     func sceneDidBecomeActive(_ scene: UIScene) {
79:         // Called when the scene has moved from an inactive state to an active state.
80:         // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
81:     }
82: 
83:     func sceneWillResignActive(_ scene: UIScene) {
84:         // Called when the scene will move from an active state to an inactive state.
85:         // This may occur due to temporary interruptions (ex. an incoming phone call).
86:     }
87: 
88:     func sceneWillEnterForeground(_ scene: UIScene) {
89:         // Called as the scene transitions from the background to the foreground.
90:         // Use this method to undo the changes made on entering the background.
91:     }
92: 
93:     func sceneDidEnterBackground(_ scene: UIScene) {
94:         // Called as the scene transitions from the foreground to the background.
95:         // Use this method to save data, release shared resources, and store enough scene-specific state information
96:         // to restore the scene back to its current state.
97:     }
98: }
```

## File: pdfexpert/InternalUtils/ImageCropper.swift
```swift
 1: //
 2: //  ImageCropper.swift
 3: //  MantisSwiftUIExample
 4: //
 5: //  Created by Yingtao Guo on 2/16/23.
 6: //
 7: 
 8: import Mantis
 9: import SwiftUI
10: 
11: enum ImageCropperType {
12:     case normal
13:     case noRotaionDial
14: }
15: 
16: struct ImageCropper: UIViewControllerRepresentable {
17:     @Binding var image: UIImage?
18:     @Binding var cropShapeType: Mantis.CropShapeType
19:     @Binding var presetFixedRatioType: Mantis.PresetFixedRatioType
20:     @Binding var type: ImageCropperType
21:     
22:     @Environment(\.presentationMode) var presentationMode
23:     
24:     class Coordinator: CropViewControllerDelegate {
25:         var parent: ImageCropper
26:         
27:         init(_ parent: ImageCropper) {
28:             self.parent = parent
29:         }
30:         
31:         func cropViewControllerDidCrop(_ cropViewController: Mantis.CropViewController, cropped: UIImage, transformation: Transformation, cropInfo: CropInfo) {
32:             parent.image = cropped
33:             print("transformation is \(transformation)")
34:             parent.presentationMode.wrappedValue.dismiss()
35:         }
36:         
37:         func cropViewControllerDidCancel(_ cropViewController: Mantis.CropViewController, original: UIImage) {
38:             parent.presentationMode.wrappedValue.dismiss()
39:         }
40:     }
41:     
42:     func makeCoordinator() -> Coordinator {
43:         Coordinator(self)
44:     }
45:     
46:     func makeUIViewController(context: Context) -> UIViewController {
47:         switch type {
48:         case .normal:
49:             return makeNormalImageCropper(context: context)
50:         case .noRotaionDial:
51:             return makeImageCropperHiddingRotationDial(context: context)
52:         }
53:     }
54:     
55:     func updateUIViewController(_ uiViewController: UIViewController, context: Context) {
56:         
57:     }
58: }
59: 
60: extension ImageCropper {
61:     func makeNormalImageCropper(context: Context) -> UIViewController {
62:         var config = Mantis.Config()
63:         config.cropViewConfig.cropShapeType = cropShapeType
64:         config.presetFixedRatioType = presetFixedRatioType
65:         let cropViewController = Mantis.cropViewController(image: image!,
66:                                                            config: config)
67:         cropViewController.delegate = context.coordinator
68:         return cropViewController
69:     }
70:     
71:     func makeImageCropperHiddingRotationDial(context: Context) -> UIViewController {
72:         var config = Mantis.Config()
73:         config.cropViewConfig.showAttachedRotationControlView = false
74:         let cropViewController = Mantis.cropViewController(image: image!, config: config)
75:         cropViewController.delegate = context.coordinator
76: 
77:         return cropViewController
78:     }
79: }
```

## File: pdfexpert/InternalUtils/PdfScanUtility.swift
```swift
 1: //
 2: //  PdfScanUtility.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/05/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: import PDFKit
11: 
12: class PdfScanUtility {
13:     
14:     static func convertScan(scannerResult: ScannerResult, asyncOperation: Binding<AsyncOperation<Pdf, PdfError>>) {
15:         
16:         let progress = Progress(totalUnitCount: Int64(scannerResult.scan.pageCount))
17:         asyncOperation.wrappedValue = AsyncOperation(status: .loading(progress))
18:         
19:         DispatchQueue.global(qos: .userInitiated).async {
20: 
21:             let pdfDocument = PDFDocument()
22:             for pageIndex in 0..<scannerResult.scan.pageCount {
23:                 let pageImage = scannerResult.scan.imageOfPage(at: pageIndex)
24:                 if let page = pageImage.pdfPage() {
25:                     pdfDocument.insert(page, at: pdfDocument.pageCount)
26:                 }
27:                 
28:                 DispatchQueue.main.async {
29:                     progress.completedUnitCount = Int64(pageIndex)
30:                     asyncOperation.wrappedValue = AsyncOperation(status: .loading(progress))
31:                 }
32:             }
33:             
34:             DispatchQueue.main.async {
35:                 asyncOperation.wrappedValue = AsyncOperation(status: .data(Pdf(pdfDocument: pdfDocument)))
36:             }
37:         }
38:     }
39: }
```

## File: pdfexpert/InternalUtils/PdfUtility.swift
```swift
  1: //
  2: //  PdfUtility.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 06/04/23.
  6: //
  7: 
  8: import Foundation
  9: import PDFKit
 10: import CoreData
 11: 
 12: class PDFUtility {
 13:     
 14:     static func convertUiImageToPdf(uiImage: UIImage) -> PDFDocument {
 15:         let pdfDocument = PDFDocument()
 16:         appendImageToPdfDocument(pdfDocument: pdfDocument, uiImage: uiImage)
 17:         return pdfDocument
 18:     }
 19:     
 20:     static func appendImageToPdfDocument(pdfDocument: PDFDocument, uiImage: UIImage) {
 21:         
 22:         if let pdfPage = uiImage.pdfPage() {
 23:             pdfDocument.insert(pdfPage, at: pdfDocument.pageCount)
 24:         } else {
 25:             assertionFailure("Couldn't create pdf page from given UIImage")
 26:         }
 27:     }
 28:     
 29:     static func appendPdfDocument(_ pdfDocument: PDFDocument, toPdfDocument: PDFDocument) {
 30:         for pageIndex in 0..<pdfDocument.pageCount {
 31:             if let page = pdfDocument.page(at: pageIndex) {
 32:                 toPdfDocument.insert(page, at: toPdfDocument.pageCount)
 33:             } else {
 34:                 assertionFailure("Missing expected page at index: \(pageIndex)")
 35:             }
 36:         }
 37:     }
 38:     
 39:     static func generatePdfThumbnails(pdfDocument: PDFDocument, size: CGSize?) -> [UIImage?] {
 40:         var thumbnails: [UIImage?] = []
 41:         for index in 0..<pdfDocument.pageCount {
 42:             let image = Self.generatePdfThumbnail(pdfDocument: pdfDocument,
 43:                                                   size: size,
 44:                                                   forPageIndex: index)
 45:             thumbnails.append(image)
 46:         }
 47:         return thumbnails
 48:     }
 49:     
 50:     static func generatePdfThumbnail(documentData: Data,
 51:                                      size: CGSize?,
 52:                                      forPageIndex pageIndex: Int = 0) -> UIImage? {
 53:         guard let pdfDocument = PDFDocument(data: documentData) else { return nil }
 54:         return self.generatePdfThumbnail(pdfDocument: pdfDocument,
 55:                                          size: size,
 56:                                          forPageIndex: pageIndex)
 57:     }
 58:     
 59:     static func generatePdfThumbnail(pdfDocument: PDFDocument,
 60:                                      size: CGSize?,
 61:                                      forPageIndex pageIndex: Int = 0) -> UIImage? {
 62:         guard pageIndex >= 0, pageIndex < pdfDocument.pageCount else { return nil }
 63:         guard let pdfDocumentPage = pdfDocument.page(at: pageIndex) else { return nil }
 64:         if let size = size {
 65:             let nativeScale = UIScreen.main.nativeScale
 66:             let nativeSize = CGSize(width: size.width * nativeScale, height: size.height * nativeScale)
 67:             return pdfDocumentPage.thumbnail(of: nativeSize, for: PDFDisplayBox.trimBox)
 68:         } else {
 69:             return pdfDocumentPage.thumbnail(of: pdfDocumentPage.bounds(for: .mediaBox).size, for: .mediaBox)
 70:         }
 71:     }
 72:     
 73:     static func applyPostProcess(toPdfDocument pdfDocument: PDFDocument, margins: MarginsOption, compression: CompressionOption) -> PDFDocument {
 74:         
 75:         guard pdfDocument.pageCount > 0 else { return PDFDocument(data: pdfDocument.dataRepresentation()!)! }
 76:         guard margins != .noMargins, compression != .noCompression else { return PDFDocument(data: pdfDocument.dataRepresentation()!)! }
 77:         
 78:         let newPdfDocument = PDFDocument()
 79:         for pageIndex in 0..<pdfDocument.pageCount {
 80:             guard let page = pdfDocument.page(at: pageIndex) else {
 81:                 continue
 82:             }
 83:             
 84:             // Fetch the page rect for the page we want to render.
 85:             let pageRect = page.bounds(for: .mediaBox)
 86:             
 87:             let originalSize = pageRect.size
 88:             
 89:             let newWidth = originalSize.width - margins.horizontalMargin * 2
 90:             let newHeight = (originalSize.height / originalSize.width) * newWidth
 91:             
 92:             let renderer = UIGraphicsImageRenderer(size: originalSize)
 93:             var newImage = renderer.image { ctx in
 94:                 
 95:                 // Set and fill the background color.
 96:                 K.Misc.PdfMarginsColor.set()
 97:                 ctx.fill(pageRect)
 98:                 
 99:                 // Translate the context so that we only draw the `cropRect`.
100:                 ctx.cgContext.translateBy(x: -pageRect.origin.x + margins.horizontalMargin,
101:                                           y: originalSize.height - pageRect.origin.y - (originalSize.height - newHeight)/2)
102: 
103:                 // Flip the context vertically because the Core Graphics coordinate system starts from the bottom.
104:                 ctx.cgContext.scaleBy(x: newWidth / originalSize.width, y: -newHeight / originalSize.height)
105:                 
106:                 // Draw the PDF page.
107:                 page.draw(with: .mediaBox, to: ctx.cgContext)
108:             }
109:             
110:             if compression.quality < 1.0, let jpegData = newImage.jpegData(compressionQuality: compression.quality) {
111:                 let nsJpegData = NSData(data: jpegData)
112:                 let unsafePointer = UnsafePointer<UInt8>(nsJpegData.bytes.bindMemory(to: UInt8.self, capacity: nsJpegData.length))
113:                 if let dataPtr = CFDataCreate(kCFAllocatorDefault, unsafePointer, nsJpegData.length),
114:                    let dataProvider = CGDataProvider(data: dataPtr),
115:                    let cgImage = CGImage(jpegDataProviderSource: dataProvider, decode: nil, shouldInterpolate: true, intent: .defaultIntent) {
116:                     newImage = UIImage(cgImage: cgImage)
117:                 }
118:             }
119:             
120:             if let pdfPage = PDFPage(image: newImage) {
121:                 newPdfDocument.insert(pdfPage, at: newPdfDocument.pageCount)
122:             }
123:         }
124:         return newPdfDocument
125:     }
126:     
127:     static func getSharePdfUrl(pdf: Pdf) -> URL {
128:         let documentDirectory = FileManager.default.temporaryDirectory
129:         return documentDirectory.appendingPathComponent(pdf.filename).appendingPathExtension(for: .pdf)
130:     }
131:     
132:     static func processToShare(pdf: Pdf, applyPostProcess: Bool) -> URL {
133:         
134:         var pdfDocument = pdf.pdfDocument
135:         if applyPostProcess {
136:             pdfDocument = Self.applyPostProcess(toPdfDocument: pdfDocument,
137:                                                 margins: pdf.margins,
138:                                                 compression: pdf.compression)
139:         }
140:         
141:         let fileURL = Self.getSharePdfUrl(pdf: pdf)
142:         
143:         let options: [PDFDocumentWriteOption: Any] = {
144:             if let password = pdf.password {
145:                 return [
146:                     PDFDocumentWriteOption.userPasswordOption : password,
147:                     PDFDocumentWriteOption.ownerPasswordOption : password
148:                 ]
149:             } else {
150:                 return [:]
151:             }
152:         }()
153:         
154:         // Write with password protection
155:         pdfDocument.write(to: fileURL, withOptions: options)
156:         
157:         return fileURL
158:     }
159:     
160:     static func cleanSharedPdf(pdf: Pdf) {
161:         let fileUrl = Self.getSharePdfUrl(pdf: pdf)
162:         do {
163:             try FileManager.default.removeItem(at: fileUrl)
164:         } catch {
165:             print("PdfUtility - Failed to delete temporary file at '\(fileUrl)'. Error: \(error)")
166:         }
167:     }
168:     
169:     static func unlock(data: Data, password: String) -> CGPDFDocument? {
170:         if let pdf = CGPDFDocument(CGDataProvider(data: data as CFData)!) {
171:             guard pdf.isEncrypted == true else { return pdf }
172:             guard pdf.unlockWithPassword("") == false else { return pdf }
173:             
174:             if let cPasswordString = password.cString(using: String.Encoding.utf8) {
175:                 if pdf.unlockWithPassword(cPasswordString) {
176:                     return pdf
177:                 }
178:             }
179:         }
180:         return nil
181:     }
182:     
183:     static func removePassword(data: Data, existingPDFPassword: String) throws -> Data? {
184:         
185:         if let pdf = unlock(data: data, password: existingPDFPassword) {
186:             let data = NSMutableData()
187:             
188:             autoreleasepool {
189:                 let pageCount = pdf.numberOfPages
190:                 UIGraphicsBeginPDFContextToData(data, .zero, nil)
191:                 
192:                 for index in 1...pageCount {
193:                     
194:                     let page = pdf.page(at: index)
195:                     let pageRect = page?.getBoxRect(CGPDFBox.mediaBox)
196:                     
197:                     
198:                     UIGraphicsBeginPDFPageWithInfo(pageRect!, nil)
199:                     let ctx = UIGraphicsGetCurrentContext()
200:                     ctx?.interpolationQuality = .high
201:                     // Draw existing page
202:                     ctx!.saveGState()
203:                     ctx!.scaleBy(x: 1, y: -1)
204:                     ctx!.translateBy(x: 0, y: -(pageRect?.size.height)!)
205:                     ctx!.drawPDFPage(page!)
206:                     ctx!.restoreGState()
207:                     
208:                 }
209:                 
210:                 UIGraphicsEndPDFContext()
211:             }
212:             return data as Data
213:         }
214:         return nil
215:     }
216:     
217:     static func decryptFile(pdf: Pdf, password: String = "") -> AsyncOperation<Pdf, PdfError> {
218:         guard pdf.pdfDocument.isEncrypted else {
219:             return AsyncOperation(status: .data(pdf))
220:         }
221:         
222:         guard pdf.pdfDocument.unlock(withPassword: password) else {
223:             return AsyncOperation(status: .error(.wrongPassword))
224:         }
225:         
226:         guard let pdfEncryptedData = pdf.pdfDocument.dataRepresentation() else {
227:             assertionFailure("Missing expected encrypted data")
228:             return AsyncOperation(status: .error(.unknownError))
229:         }
230:         
231:         guard let pdfDecryptedData = try? PDFUtility.removePassword(data: pdfEncryptedData, existingPDFPassword: password) else {
232:             assertionFailure("Missing expected decrypted data")
233:             return AsyncOperation(status: .error(.unknownError))
234:         }
235:         
236:         guard let pdfDecryptedDocument = PDFDocument(data: pdfDecryptedData) else {
237:             assertionFailure("Cannot decode pdf from decrypted data")
238:             return AsyncOperation(status: .error(.unknownError))
239:         }
240:         var pdf = pdf
241:         pdf.updateDocument(pdfDecryptedDocument)
242:         pdf.updatePassword(password)
243:         return AsyncOperation(status: .data(pdf))
244:     }
245:     
246:     static func hasPdfWidget(pdf: Pdf) -> Bool {
247:         for pageIndex in 0..<pdf.pdfDocument.pageCount {
248:             if let page = pdf.pdfDocument.page(at: pageIndex) {
249:                 if page.annotations.contains(where: { $0.isWidgetAnnotation }) {
250:                     return true
251:                 }
252:             }
253:         }
254:         return false
255:     }
256: }
257: 
258: extension UIImage {
259:     
260:     func pdfPage() -> PDFPage? {
261:         guard let fixedOrientationImage = self.fixedOrientation() else {
262:             return nil
263:         }
264:         // Typical Letter PDF page size and margins
265:         let pageBounds = CGRect(origin: .zero, size: K.Misc.PdfPageSize)
266:         let margin: CGFloat = K.Misc.PdfPageDefaultMargin
267: 
268:         let imageMaxWidth = pageBounds.width - (margin * 2)
269:         let imageMaxHeight = pageBounds.height - (margin * 2)
270: 
271:         let image = fixedOrientationImage.scaledImage(scaleFactor: size.scaleFactor(forMaxWidth: imageMaxWidth,
272:                                                                                     maxHeight: imageMaxHeight)) ?? fixedOrientationImage
273:         let renderer = UIGraphicsPDFRenderer(bounds: pageBounds)
274:         
275:         // This procedure for rendering pdf pages (copied from WeScan) is the only one that seems
276:         // to make the applyPostProcess method to work. Creating PDFPage instances with PDFPage.init(_ image: UIImage)
277:         // causes the PDFPage.draw method to draw a black page.
278:         let data = renderer.pdfData { ctx in
279:             ctx.beginPage()
280:             
281:             ctx.cgContext.interpolationQuality = .high
282:             
283:             image.draw(at: CGPoint(x: (pageBounds.width - image.size.width) / 2,
284:                                    y: (pageBounds.height - image.size.height) / 2))
285:         }
286:         return PDFDocument(data: data)?.page(at: 0)
287:     }
288:     
289:     /// Scales the image to the specified size in the RGB color space.
290:     ///
291:     /// - Parameters:
292:     ///   - scaleFactor: Factor by which the image should be scaled.
293:     /// - Returns: The scaled image.
294:     func scaledImage(scaleFactor: CGFloat) -> UIImage? {
295:         guard let cgImage = self.cgImage else { return nil }
296: 
297:         let customColorSpace = CGColorSpaceCreateDeviceRGB()
298: 
299:         let width = CGFloat(cgImage.width) * scaleFactor
300:         let height = CGFloat(cgImage.height) * scaleFactor
301:         let bitsPerComponent = cgImage.bitsPerComponent
302:         let bytesPerRow = cgImage.bytesPerRow
303:         let bitmapInfo = cgImage.bitmapInfo.rawValue
304: 
305:         guard let context = CGContext(
306:             data: nil,
307:             width: Int(width),
308:             height: Int(height),
309:             bitsPerComponent: bitsPerComponent,
310:             bytesPerRow: bytesPerRow,
311:             space: customColorSpace,
312:             bitmapInfo: bitmapInfo
313:         ) else { return nil }
314: 
315:         context.interpolationQuality = .high
316:         context.draw(cgImage, in: CGRect(origin: .zero, size: CGSize(width: width, height: height)))
317: 
318:         return context.makeImage().flatMap { UIImage(cgImage: $0) }
319:     }
320:     
321:     /// Fix image orientaton to protrait up
322:     func fixedOrientation() -> UIImage? {
323:         guard imageOrientation != UIImage.Orientation.up else {
324:             // This is default orientation, don't need to do anything
325:             return self.copy() as? UIImage
326:         }
327:         
328:         guard let cgImage = self.cgImage else {
329:             // CGImage is not available
330:             return nil
331:         }
332:         
333:         guard let colorSpace = cgImage.colorSpace, let ctx = CGContext(data: nil, width: Int(size.width), height: Int(size.height), bitsPerComponent: cgImage.bitsPerComponent, bytesPerRow: 0, space: colorSpace, bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue) else {
334:             return nil // Not able to create CGContext
335:         }
336:         
337:         var transform: CGAffineTransform = CGAffineTransform.identity
338:         
339:         switch imageOrientation {
340:         case .down, .downMirrored:
341:             transform = transform.translatedBy(x: size.width, y: size.height)
342:             transform = transform.rotated(by: CGFloat.pi)
343:         case .left, .leftMirrored:
344:             transform = transform.translatedBy(x: size.width, y: 0)
345:             transform = transform.rotated(by: CGFloat.pi / 2.0)
346:         case .right, .rightMirrored:
347:             transform = transform.translatedBy(x: 0, y: size.height)
348:             transform = transform.rotated(by: CGFloat.pi / -2.0)
349:         case .up, .upMirrored:
350:             break
351:         @unknown default:
352:             fatalError("Missing...")
353:             break
354:         }
355:         
356:         // Flip image one more time if needed to, this is to prevent flipped image
357:         switch imageOrientation {
358:         case .upMirrored, .downMirrored:
359:             transform = transform.translatedBy(x: size.width, y: 0)
360:             transform = transform.scaledBy(x: -1, y: 1)
361:         case .leftMirrored, .rightMirrored:
362:             transform = transform.translatedBy(x: size.height, y: 0)
363:             transform = transform.scaledBy(x: -1, y: 1)
364:         case .up, .down, .left, .right:
365:             break
366:         @unknown default:
367:             fatalError("Missing...")
368:             break
369:         }
370:         
371:         ctx.concatenate(transform)
372:         
373:         switch imageOrientation {
374:         case .left, .leftMirrored, .right, .rightMirrored:
375:             ctx.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.height, height: size.width))
376:         default:
377:             ctx.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.width, height: size.height))
378:             break
379:         }
380:         
381:         guard let newCGImage = ctx.makeImage() else { return nil }
382:         return UIImage.init(cgImage: newCGImage, scale: 1, orientation: .up)
383:     }
384: }
385: 
386: extension CGSize {
387:     /// Calculates an appropriate scale factor which makes the size fit inside both the `maxWidth` and `maxHeight`.
388:     /// - Parameters:
389:     ///   - maxWidth: The maximum width that the size should have after applying the scale factor.
390:     ///   - maxHeight: The maximum height that the size should have after applying the scale factor.
391:     /// - Returns: A scale factor that makes the size fit within the `maxWidth` and `maxHeight`.
392:     func scaleFactor(forMaxWidth maxWidth: CGFloat, maxHeight: CGFloat) -> CGFloat {
393:         if width < maxWidth && height < maxHeight { return 1 }
394: 
395:         let widthScaleFactor = 1 / (width / maxWidth)
396:         let heightScaleFactor = 1 / (height / maxHeight)
397: 
398:         // Use the smaller scale factor to ensure both the width and height are below the max
399:         return min(widthScaleFactor, heightScaleFactor)
400:     }
401: }
402: 
403: extension PDFView {
404:     var currentPageIndex: Int? {
405:         guard let document = self.document, let currentPage = self.currentPage else {
406:             return nil
407:         }
408:         for pageIndex in 0..<document.pageCount {
409:             if document.page(at: pageIndex) == currentPage {
410:                 return pageIndex
411:             }
412:         }
413:         return nil
414:     }
415: }
```

## File: pdfexpert/InternalUtils/SharedErrors.swift
```swift
  1: //
  2: //  SharedLocalizedError.swift
  3: //  StoryKidsAI
  4: //
  5: //  Created by Pcnaid Inc on 07/03/23.
  6: //
  7: 
  8: import Foundation
  9: 
 10: enum SharedLocalizedError: LocalizedError {
 11:     case unknownError
 12:     
 13:     var errorDescription: String? {
 14:         switch self {
 15:         case .unknownError: return "Internal Error. Please try again later"
 16:         }
 17:     }
 18: }
 19: 
 20: enum SharedUnderlyingError: LocalizedError, UnderlyingError {
 21:     case unknownError
 22:     case underlyingError(errorDescription: String)
 23:     
 24:     static func getUnknownError() -> Self { Self.unknownError }
 25:     
 26:     static func getUnderlyingError(errorDescription: String) -> Self {
 27:         return .underlyingError(errorDescription: errorDescription)
 28:     }
 29:     
 30:     var errorDescription: String? {
 31:         switch self {
 32:         case .unknownError: return "Internal Error. Please try again later"
 33:         case .underlyingError(let errorMessage): return errorMessage
 34:         }
 35:     }
 36: }
 37: 
 38: enum PdfError: LocalizedError, UnderlyingError {
 39:     case unknownError
 40:     case urlToPdfConversionError
 41:     case underlyingError(errorDescription: String)
 42:     case wrongPassword
 43:     
 44:     static func getUnknownError() -> Self { Self.unknownError }
 45:     
 46:     static func getUnderlyingError(errorDescription: String) -> Self {
 47:         return .underlyingError(errorDescription: errorDescription)
 48:     }
 49:     
 50:     var errorDescription: String? {
 51:         switch self {
 52:         case .unknownError, .urlToPdfConversionError:
 53:             return "Internal Error. Please try again later"
 54:         case .underlyingError(let errorMessage): return errorMessage
 55:         case .wrongPassword: return "Wrong Password"
 56:         }
 57:     }
 58: }
 59: 
 60: enum AddPasswordError: LocalizedError {
 61:     case unknownError
 62:     case pdfHasPassword
 63:     
 64:     var errorDescription: String? {
 65:         switch self {
 66:         case .unknownError: return "Internal Error. Please try again later"
 67:         case .pdfHasPassword: return "Your pdf is already protected"
 68:         }
 69:     }
 70: }
 71: 
 72: enum RemovePasswordError: LocalizedError {
 73:     case unknownError
 74:     case pdfNoPassword
 75:     
 76:     var errorDescription: String? {
 77:         switch self {
 78:         case .unknownError: return "Internal Error. Please try again later"
 79:         case .pdfNoPassword: return "Your pdf is already unlocked"
 80:         }
 81:     }
 82: }
 83: 
 84: enum PdfSplitError: LocalizedError, UnderlyingError {
 85:     case unknownError
 86:     case pdfNoPage
 87:     case pdfSinglePage
 88:     case incompatibleRange
 89:     case underlyingError(errorDescription: String)
 90:     
 91:     static func getUnknownError() -> Self { Self.unknownError }
 92:     
 93:     static func getUnderlyingError(errorDescription: String) -> Self {
 94:         return .underlyingError(errorDescription: errorDescription)
 95:     }
 96:     
 97:     var errorDescription: String? {
 98:         switch self {
 99:         case .unknownError, .incompatibleRange: return "Internal Error. Please try again later"
100:         case .pdfNoPage: return "Your pdf has no pages."
101:         case .pdfSinglePage: return "Your pdf has only one page, so you cannot split it into multiple pdfs."
102:         case .underlyingError(let errorMessage): return errorMessage
103:         }
104:     }
105: }
```

## File: pdfexpert/InternalUtils/SharedStorage.swift
```swift
 1: //
 2: //  SharedStorage.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 05/05/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: class SharedStorage {
11:     
12:     enum UserDefaultsKey: String {
13:         case pdfDataShareExtensionExistanceFlag
14:         case pdfDataShareExtensionPassword
15:     }
16:     
17:     enum FileName: String {
18:         case pdfDataShareExtension
19:     }
20:     
21:     #if STAGING
22:     static let schema = "pdfprostaging://"
23:     #else
24:     static let schema = "pdfpro://"
25:     #endif
26:     
27:     private static let appGroup = "group.pcnaid.pdfexpert"
28:     private static let userDefaults = UserDefaults(suiteName: appGroup)
29:     
30:     static var cacheDirectory: URL? {
31:         FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: Self.appGroup)?.appending(path: "Library/Caches",
32:                                                                                                           directoryHint: .isDirectory)
33:     }
34:     
35:     static var pdfDataShareExtensionExistanceFlag: Bool {
36:         get { Self.userDefaults?.bool(forKey: UserDefaultsKey.pdfDataShareExtensionExistanceFlag.rawValue) ?? false }
37:         set {
38:             Self.userDefaults?.set(newValue, forKey: UserDefaultsKey.pdfDataShareExtensionExistanceFlag.rawValue)
39:             Self.userDefaults?.synchronize()
40:         }
41:     }
42:     
43:     static var pdfDataShareExtensionPassword: String? {
44:         get { Self.userDefaults?.string(forKey: UserDefaultsKey.pdfDataShareExtensionPassword.rawValue) }
45:         set {
46:             Self.userDefaults?.set(newValue, forKey: UserDefaultsKey.pdfDataShareExtensionPassword.rawValue)
47:             Self.userDefaults?.synchronize()
48:         }
49:     }
50:     
51:     private static var pdfDataShareExtensionFilePath: URL? {
52:         Self.cacheDirectory?.appending(component: FileName.pdfDataShareExtension.rawValue).appendingPathExtension(for: .pdf)
53:     }
54:     
55:     static var pdfDataShareExtension: Data? {
56:         get {
57:             guard let url = Self.pdfDataShareExtensionFilePath else { return nil }
58:             return try? Data(contentsOf: url)
59:         }
60:         set {
61:             guard let url = Self.pdfDataShareExtensionFilePath else { return }
62:             if let newValue = newValue {
63:                 try? newValue.write(to: url)
64:             } else {
65:                 try? FileManager.default.removeItem(at: url)
66:             }
67:         }
68:     }
69: }
```

## File: pdfexpert/InternalUtils/SubscriptionViewUtility.swift
```swift
  1: //
  2: //  SubscriptionViewUtility.swift
  3: //  ChatAI
  4: //
  5: //  Created by Pcnaid Inc on 24/02/23.
  6: //
  7: 
  8: import Foundation
  9: import StoreKit
 10: import Collections
 11: 
 12: fileprivate struct InternalSubscriptionPeriod {
 13:     let unit: Product.SubscriptionPeriod.Unit
 14:     let value: Int
 15: }
 16: 
 17: extension Product.SubscriptionPeriod.Unit {
 18:     var displayUnitSingle: String {
 19:         switch self {
 20:         case .day: return "day"
 21:         case .week: return "week"
 22:         case .month: return "month"
 23:         case .year: return "year"
 24:         default: return ""
 25:         }
 26:     }
 27:     
 28:     var displayUnitPeriod: String {
 29:         switch self {
 30:         case .day: return "daily"
 31:         case .week: return "weekly"
 32:         case .month: return "monthly"
 33:         case .year: return "yearly"
 34:         default: return ""
 35:         }
 36:     }
 37:     
 38:     var displayUnitMultiple: String {
 39:         switch self {
 40:         case .day: return "days"
 41:         case .week: return "weeks"
 42:         case .month: return "months"
 43:         case .year: return "years"
 44:         default: return ""
 45:         }
 46:     }
 47:     
 48:     var displayUnitSingleWithArticle: String {
 49:         switch self {
 50:         case .day: return "a day"
 51:         case .week: return "a week"
 52:         case .month: return "a month"
 53:         case .year: return "an year"
 54:         default: return ""
 55:         }
 56:     }
 57:     
 58:     var days: Int {
 59:         switch self {
 60:         case .day: return 1
 61:         case .week: return 7
 62:         case .month: return 30
 63:         case .year: return 365
 64:         default: return 0
 65:         }
 66:     }
 67:     
 68:     var previousUnit: Self? {
 69:         switch self {
 70:         case .day: return nil
 71:         case .week: return .day
 72:         case .month: return .week
 73:         case .year: return .month
 74:         default: return nil
 75:         }
 76:     }
 77: }
 78: 
 79: fileprivate extension InternalSubscriptionPeriod {
 80:     
 81:     var days: Int {
 82:         return self.unit.days * self.value
 83:     }
 84:     
 85:     // period == 1 ? "a day" : "5 days"
 86:     var displayPeriodStartStatement: String {
 87:         if self.value > 1 {
 88:             return "\(self.value) \(self.unit.displayUnitMultiple)"
 89:         } else {
 90:             return self.unit.displayUnitSingleWithArticle
 91:         }
 92:     }
 93:     
 94:     // period == 1 ? "day" : "5 days"
 95:     var displayPeriod: String {
 96:         if self.value > 1 {
 97:             return "\(self.value) \(self.unit.displayUnitMultiple)"
 98:         } else {
 99:             return self.unit.displayUnitSingle
100:         }
101:     }
102:     
103:     // period == 1 ? "daily" : "5 days"
104:     var displayFrequency: String {
105:         if self.value > 1 {
106:             return "\(self.value) \(self.unit.displayUnitMultiple)"
107:         } else {
108:             return self.unit.displayUnitPeriod
109:         }
110:     }
111:     
112:     // period == 1 ? "1 day" : "5 days"
113:     var displayPeriodWithNumber: String {
114:         "\(self.value) \(self.value > 1 ? self.unit.displayUnitMultiple : self.unit.displayUnitSingle)"
115:     }
116:     
117:     func convert(toUnit unit: Product.SubscriptionPeriod.Unit) -> Self {
118:         return InternalSubscriptionPeriod(unit: unit, value: self.days/unit.days)
119:     }
120: }
121: 
122: extension Product.SubscriptionPeriod {
123:     
124:     // 3 days => 3, 3 weeks => 21, 2 months => 60, ...
125:     // Not reliable for legal information or date calculations,
126:     // since months and years are fixed on 30 and 365 respectively
127:     var days: Int {
128:         return InternalSubscriptionPeriod(unit: self.unit, value: self.value).days
129:     }
130:     
131:     fileprivate func getInternalPeriod(weekFrom7days: Bool) -> InternalSubscriptionPeriod {
132:         if weekFrom7days, self.value == 7, self.unit == .day {
133:             return InternalSubscriptionPeriod(unit: .week, value: 1)
134:         } else {
135:             return InternalSubscriptionPeriod(unit: self.unit, value: self.value)
136:         }
137:     }
138: }
139: 
140: extension Product {
141:     
142:     var title: String {
143:         var text = "Premium"
144:         if let subscription = self.subscription {
145:             text += " \(subscription.subscriptionPeriod.getInternalPeriod(weekFrom7days: true).displayPeriodWithNumber)"
146:         }
147:         return text
148:     }
149:     
150:     var titleShort: String {
151:         var text = ""
152:         if let subscription = self.subscription {
153:             text += "\(subscription.subscriptionPeriod.getInternalPeriod(weekFrom7days: true).displayFrequency)"
154:         }
155:         text += " \(self.displayPrice)"
156:         text = text.capitalizingFirstLetter()
157:         return text
158:     }
159:     
160:     var period: String {
161:         var text = ""
162:         if let subscription = self.subscription {
163:             text += "\(subscription.subscriptionPeriod.getInternalPeriod(weekFrom7days: true).displayFrequency)"
164:         }
165:         text = text.capitalizingFirstLetter()
166:         return text
167:     }
168:     
169:     var priceText: String {
170:         return self.displayPrice
171:     }
172:     
173:     var weeklyPriceAndPeriod: String {
174:         var text = self.getPriceText(weekFrom7days: false, customUnitPeriod: .week)
175:         text = text.capitalizingFirstLetter()
176:         return text
177:     }
178:     
179:     var fullDescriptionText: String {
180:         var text = ""
181:         if let introductortOffer = self.subscription?.introductoryOffer {
182:             text += "\(introductortOffer.period.getInternalPeriod(weekFrom7days: false).displayPeriodStartStatement) free, then "
183:         }
184:         text += self.getPriceText(weekFrom7days: true)
185:         text = text.capitalizingFirstLetter()
186:         return text
187:     }
188:     
189:     var freeTrialText: String? {
190:         if let introductoryOffer = self.subscription?.introductoryOffer, introductoryOffer.paymentMode == .freeTrial {
191:             let freeTrialDuration = introductoryOffer.period.getInternalPeriod(weekFrom7days: false).displayPeriodWithNumber
192:             return "FREE TRIAL for \(freeTrialDuration)"
193:         } else {
194:             return nil
195:         }
196:     }
197:     
198:     // Returned only if:
199:     // - The current product is a subscription
200:     // - The current product is the most convenient one
201:     // - There is another product which is a subscription and is less convenient
202:     func getBestDiscount(forProducts products: [Product]) -> String? {
203:         // Compare subscription periods instead of the products themselves to handle cases of identical
204:         // subscriptions that varies only for introductory offers (e.g.: yearly with free trial, yearly without free trial)
205:         let mostConvenientSubscriptionPeriod = Self.getMostConvenientSubscription(fromProducts: products)?.subscription?.subscriptionPeriod
206:         guard let mostConvenientSubscriptionPeriod, self.subscription?.subscriptionPeriod == mostConvenientSubscriptionPeriod else {
207:             return nil
208:         }
209:         guard let discountPercentage = self.getDiscountPercentage(forProducts: products) else {
210:             return nil
211:         }
212:         return "\(discountPercentage) OFF"
213:     }
214:     
215:     // Returned only if:
216:     // - The current product is a subscription
217:     // - There is another product which is a subscription and is less convenient
218:     func getDiscount(forProducts products: [Product]) -> String? {
219:         guard let subscription = self.subscription else {
220:             return nil
221:         }
222:         guard let discountPercentage = self.getDiscountPercentage(forProducts: products) else {
223:             return nil
224:         }
225:         guard let previousUnit = subscription.subscriptionPeriod.unit.previousUnit else {
226:             return nil
227:         }
228:         let periodInPreviousUnit = subscription.subscriptionPeriod.getInternalPeriod(weekFrom7days: false).convert(toUnit: previousUnit)
229:         var text = periodInPreviousUnit.displayPeriodWithNumber
230:         text += " at "
231:         text += self.getPriceText(weekFrom7days: false, customUnitPeriod: previousUnit, showTrailing: false)
232:         text = text.capitalizingFirstLetter()
233:         text += ", save \(discountPercentage)"
234:         return text
235:     }
236:     
237:     private func getDiscountPercentage(forProducts products: [Product]) -> String? {
238:         let nextMostConvenientProduct = Self.getMostConvenientSubscription(fromProducts: products, worseThan: self)
239:         
240:         guard let nextMostConvenientProduct = nextMostConvenientProduct else {
241:             return nil
242:         }
243:         guard let priceYearly = self.priceYearly,
244:               let nextMostConvenientProductPriceYearly = nextMostConvenientProduct.priceYearly else {
245:             return nil
246:         }
247:         
248:         let discount = Decimal(1) - priceYearly / nextMostConvenientProductPriceYearly
249:         let discountPercentage = discount.formatted(.percent
250:             .precision(.integerAndFractionLength(integerLimits: ..<3, fractionLimits: 0...0)))
251:         return discountPercentage
252:     }
253:     
254:     private static func sortedSubscriptionsBasedOnConvenience(fromProducts products: [Product]) -> [Product] {
255:         return products.filter { $0.priceYearly != nil }.sorted { $0.priceYearly ?? 0 < $1.priceYearly ?? 0 }
256:     }
257:     
258:     private static func getMostConvenientSubscription(fromProducts products: [Product], worseThan referenceProduct: Product? = nil) -> Product? {
259:         let sortedProducts = Self.sortedSubscriptionsBasedOnConvenience(fromProducts: products)
260:         if let referenceProduct = referenceProduct, let index = sortedProducts.firstIndex(of: referenceProduct) {
261:             let nextProductIndex = index + 1
262:             if nextProductIndex < sortedProducts.count {
263:                 return sortedProducts[nextProductIndex]
264:             } else {
265:                 return nil
266:             }
267:         } else {
268:             return sortedProducts.first
269:         }
270:     }
271:     
272:     private var priceYearly: Decimal? {
273:         if let subscription = self.subscription {
274:             return (self.price / Decimal(subscription.subscriptionPeriod.days)) * Decimal(SubscriptionPeriod.Unit.year.days)
275:         } else {
276:             return nil
277:         }
278:     }
279:     
280:     // if customUnitPeriod == nil
281:     // <price>/<displayPeriod>. E.g.: 99.99/year, 19.99/2 months
282:     // otherwise
283:     // <price in custom unit period>(= (price / period days) * custom unit period days)/<display period of custom unit period>
284:     // E.g.: custom unit period == week => 89.99/year => 1.73/week
285:     private func getPriceText(weekFrom7days: Bool, customUnitPeriod: SubscriptionPeriod.Unit? = nil, showTrailing: Bool = true) -> String {
286:         if let subscription = self.subscription {
287:             var text = ""
288:             if let customUnitPeriod = customUnitPeriod {
289:                 let pricePerUnit = (self.price / Decimal(subscription.subscriptionPeriod.days)) * Decimal(customUnitPeriod.days)
290:                 text += self.priceFormatStyle
291:                     .precision(.integerAndFractionLength(integerLimits: 1..<3, fractionLimits: 2...2))
292:                     .format(pricePerUnit)
293:                 if showTrailing {
294:                     text += "/\(customUnitPeriod.displayUnitSingle)"
295:                 }
296:             } else {
297:                 text += self.displayPrice
298:                 if showTrailing {
299:                     text += "/\(subscription.subscriptionPeriod.getInternalPeriod(weekFrom7days: weekFrom7days).displayPeriod)"
300:                 }
301:             }
302:             return text
303:         } else {
304:             return self.displayPrice
305:         }
306:     }
307: }
308: 
309: let productMetaViewsKey: String = "views"
310: 
311: func getSubscriptionsForView(products: [Product], store: Store, viewKey: String) -> [Product] {
312:     return products.filter {
313:         if $0.subscription != nil,
314:            let metaDictionary = store.getProductData(forProductId: $0.id) as? [String: Any],
315:            let views = metaDictionary[productMetaViewsKey] as? [String],
316:            views.contains(viewKey) {
317:             return true
318:         } else {
319:             return false
320:         }
321:     }
322: }
323: 
324: extension Array where Element == Product {
325:     func subscriptionPairs<T: SubscriptionPlan>(periodOrderDesc: Bool, conversion: ((Product?) -> T?)) async throws -> [SubscriptionPlanCombo<T>] {
326:         var groupedSubscriptions: OrderedDictionary<Int, [Product]> = self.reduce([:]) { partialResult, subscription in
327:             var partialResult = partialResult
328:             if let subscriptionInfo = subscription.subscription {
329:                 let key = subscriptionInfo.subscriptionPeriod.days
330:                 var subscriptions = partialResult[key] ?? []
331:                 subscriptions.append(subscription)
332:                 partialResult[key] = subscriptions
333:             }
334:             return partialResult
335:         }
336:         
337:         groupedSubscriptions.sort { pair1, pair2 in
338:             periodOrderDesc ? pair1.key > pair2.key : pair1.key < pair2.key
339:         }
340:         
341:         let subscriptionPlanPairs: [SubscriptionPlanCombo<T>] = groupedSubscriptions.reduce([]) { partialResult, rawPair in
342:             var partialResult = partialResult
343:             let freeTrialSubscriptionPlan = conversion(rawPair.value.first (where: { $0.subscription?.introductoryOffer?.paymentMode == .freeTrial }))
344:             let standardSubscriptionPlan = conversion(rawPair.value.first (where: { $0.subscription?.introductoryOffer == nil }))
345:             if standardSubscriptionPlan != nil || freeTrialSubscriptionPlan != nil {
346:                 partialResult.append(SubscriptionPlanCombo<T>(standardSubscriptionPlan: standardSubscriptionPlan,
347:                                                               freeTrialSubscriptionPlan: freeTrialSubscriptionPlan))
348:             }
349:             return partialResult
350:         }
351:         return subscriptionPlanPairs
352:     }
353: }
```

## File: pdfexpert/InternalUtils/View+Internal.swift
```swift
  1: //
  2: //  View+Internal.swift
  3: //  StoryKidsAI
  4: //
  5: //  Created by Pcnaid Inc on 13/03/23.
  6: //
  7: 
  8: import Foundation
  9: import SwiftUI
 10: import Factory
 11: 
 12: enum DisclamerType: Hashable, Identifiable {
 13:     case privacyPolicy, termsAndConditions
 14:     
 15:     var id: Self { self }
 16: }
 17: 
 18: extension View {
 19:     
 20:     var defaultGradientBackground: some View {
 21:         LinearGradient(colors: [ColorPalette.buttonGradientStart, ColorPalette.buttonGradientEnd],
 22:                        startPoint: UnitPoint(x: 0.25, y: 0.5), endPoint: UnitPoint(x: 0.75, y: 0.5))
 23:     }
 24:     
 25:     @ViewBuilder func getDefaultButton(text: String, enabled: Bool = true, onButtonPressed: @escaping () -> ()) -> some View {
 26:         Button(action: onButtonPressed) {
 27:             Text(text)
 28:                 .frame(maxWidth: .infinity, maxHeight: .infinity)
 29:                 .font(forCategory: .button)
 30:                 .foregroundColor(ColorPalette.primaryText)
 31:                 .contentShape(Capsule())
 32:         }
 33:         .frame(maxWidth: .infinity)
 34:         .frame(height: 48)
 35:         .background(self.getDefaultButtonBackground(enabled: enabled))
 36:         .cornerRadius(10)
 37:         .disabled(!enabled)
 38:     }
 39:     
 40:     @ViewBuilder private func getDefaultButtonBackground(enabled: Bool) -> some View {
 41:         if enabled {
 42:             self.defaultGradientBackground
 43:         } else {
 44:             ColorPalette.thirdText
 45:         }
 46:     }
 47:     
 48:     func getDisclamer(color: Color, onSelection: @escaping (DisclamerType) -> ()) -> some View {
 49:         var attributedString = AttributedString("By continuing you accept our ")
 50:         attributedString += Self.getAttributedText(forUrlString: K.Misc.TermsAndConditionsUrlString, text: "Terms and Conditions")
 51:         attributedString += AttributedString(" and confirm that you have received our ")
 52:         attributedString += Self.getAttributedText(forUrlString: K.Misc.PrivacyPolicyUrlString, text: "Privacy Policy")
 53:         attributedString += AttributedString(".")
 54:         return Text(attributedString)
 55:             .multilineTextAlignment(.center)
 56:             .font(forCategory: .caption1)
 57:             .foregroundColor(color)
 58:             .tint(color)
 59:     }
 60:     
 61:     func alertCameraPermission(isPresented: Binding<Bool>) -> some View {
 62:         self.alert("Unable to access camera",
 63:                    isPresented: isPresented) {
 64:             Button("Settings", role: .none) {
 65:                 if let appSettingsUrl = URL(string: UIApplication.openSettingsURLString) {
 66:                 UIApplication.shared.open(appSettingsUrl,
 67:                                               options: [:],
 68:                                               completionHandler: nil)
 69:                                           }
 70:             }
 71:             Button("Cancel", role: .cancel) {}
 72:         } message: {
 73:             Text("You have denied permission to access the camera of your device. Please go to your phone Settings to change your camera permission to be able to scan and convert your documents.")
 74:         }
 75:     }
 76:     
 77:     @ViewBuilder func getSubscriptionView(onComplete: @escaping () -> ()) -> some View {
 78:         switch Container.shared.configService().remoteConfigData.value.subcriptionViewType {
 79:         case .pairs: SubscriptionPairsView(onComplete: onComplete)
 80:         case .verticalHighlightLongPeriod:
 81:             let viewModel = Container.shared.subscriptionVerticalViewModel(.highlightLongPeriod)
 82:             SubscriptionVerticalView(viewModel: viewModel, onComplete: onComplete)
 83:         case .verticalHighlightShortPeriod:
 84:             let viewModel = Container.shared.subscriptionVerticalViewModel(.highlightShortPeriod)
 85:             SubscriptionVerticalView(viewModel: viewModel, onComplete: onComplete)
 86:         case .picker: SubscriptionPickerView(onComplete: onComplete)
 87:         }
 88:     }
 89:     
 90:     func showSubscriptionView(_ show: Binding<Bool>, onComplete: @escaping () -> ()) -> some View {
 91:         self.fullScreenCover(isPresented: show) {
 92:             getSubscriptionView(onComplete: {
 93:                 show.wrappedValue = false
 94:                 onComplete()
 95:             })
 96:         }
 97:     }
 98:     
 99:     func sharePdf(_ pdf: Binding<Pdf?>, applyPostProcess: Bool, onDismiss: @escaping () -> ()) -> some View {
100:         self.sheet(item: pdf, onDismiss: {
101:             if let pdf = pdf.wrappedValue {
102:                 PDFUtility.cleanSharedPdf(pdf: pdf)
103:             }
104:             onDismiss()
105:         }) { pdf in
106:             ActivityViewController(activityItems: [PDFUtility.processToShare(pdf: pdf, applyPostProcess: applyPostProcess)],
107:                                    thumbnail: pdf.thumbnail,
108:                                    title: pdf.filename)
109:         }
110:     }
111:     
112:     func pageCounter(currentPageIndex: Int, totalPages: Int) -> some View {
113:         Text("\(currentPageIndex + 1) of \(totalPages)")
114:             .font(forCategory: .body1)
115:             .foregroundColor(ColorPalette.primaryText)
116:     }
117:     
118:     func removePasswordView(show: Binding<Bool>,
119:                             removePasswordCallback: @escaping () -> ()) -> some View {
120:         self.alert("Would you like to remove your password?", isPresented: show, actions: {
121:             Button("Delete", role: .destructive, action: removePasswordCallback)
122:             Button("Cancel", role: .cancel, action: {})
123:         }, message: {
124:             Text("If you decide to remove the password, your PDF will no longer be protected.")
125:         })
126:     }
127:     
128:     func showError<T: LocalizedError>(_ errorBinding: Binding<T?>) -> some View {
129:         self.alert("Error",
130:                    isPresented: .constant(errorBinding.wrappedValue != nil),
131:                    presenting: errorBinding.wrappedValue,
132:                    actions: { pdfSaveError in
133:             Button("Ok") { errorBinding.wrappedValue = nil }
134:         }, message: { error in
135:             Text(error.errorDescription ?? "")
136:         })
137:     }
138: }
```

## File: pdfexpert/InternalUtils/View+Preview.swift
```swift
 1: //
 2: //  View+Preview.swift
 3: //  StoryKidsAI
 4: //
 5: //  Created by Pcnaid Inc on 07/03/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: extension View {
12:     func previewOrientation() -> some View {
13:         self.previewInterfaceOrientation(.landscapeLeft)
14:     }
15: }
```

## File: pdfexpert/Models/Analytics/AnalyticsDefaultParameters.swift
```swift
  1: //
  2: //  AnalyticsDefaultParameters.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 05/09/23.
  6: //
  7: 
  8: import Foundation
  9: 
 10: enum AnalyticsEventCustomParameters: String {
 11:     case compressionOption = "compression_option"
 12:     case marginOption = "margin_option"
 13:     case homeActionType = "home_action_type"
 14:     case importOption = "import_option"
 15:     case pdfInputType = "pdf_input_type"
 16:     case pdfInputTypeExtension = "pdf_input_type_extension"
 17:     case productId = "product_identifier"
 18:     case productPrice = "product_price"
 19:     case subscriptionPlanIsFreeTrial = "subscription_is_free_trial"
 20:     case reviewLowRateFeedbackContent = "review_low_rate_feedback_content"
 21:     case screenName = "screen_name"
 22: }
 23: 
 24: extension MarginsOption {
 25:     var trackingParameterValue: String {
 26:         switch self {
 27:         case .noMargins: return "no_margins"
 28:         case .mediumMargins: return "medium_margins"
 29:         case .heavyMargins: return "heavy_margins"
 30:         }
 31:     }
 32: }
 33: 
 34: extension FileSource {
 35:     var trackingParameterValue: String {
 36:         switch self {
 37:         case .google: return "google_drive"
 38:         case .dropbox: return "dropbox"
 39:         case .icloud: return "iCloud"
 40:         case .files: return "files"
 41:         }
 42:     }
 43: }
 44: 
 45: extension AnalyticsScreen {
 46:     var name: String {
 47:         switch self {
 48:         case .onboarding: return "Onboarding"
 49:         case .home: return "Home"
 50:         case .files: return "File"
 51:         case .chatPdfSelection: return "ChatPdfSelection"
 52:         case .settings: return "Settings"
 53:         case .subscription: return "Subscription"
 54:         case .importTutorial: return "ImportTutorial"
 55:         case .signature: return "Signature"
 56:         case .signaturePicker: return "SignaturePicker"
 57:         case .fillForm: return "FillForm"
 58:         case .fillWidget: return "FillWidget"
 59:         case .chatPdf: return "ChatPdf"
 60:         case .compressionPicker: return "CompressionPicker"
 61:         case .sortPdf: return "SortPdf"
 62:         case .pageRangeEditor: return "PageRangeEditor"
 63:         case .reader: return "Reader"
 64:         case .pageSelection: return "PageSelection"
 65:         case .suggestedFields: return "SuggestedFields"
 66:         }
 67:     }
 68: }
 69: 
 70: extension AnalyticsEvent {
 71:     var customEventName: String {
 72:         switch self {
 73:         case .appTrackingTransparancyAuthorized: return "tracking_authorized"
 74:         case .checkoutCompleted: return "checkout_completed"
 75:         case .onboardingCompleted: return "onboarding_completed"
 76:         case .onboardingSkipped: return "onboarding_skipped"
 77:         case .homeActionChosen: return "home_action_chosen"
 78:         case .homeFullActionChosen: return "home_full_action_chosen"
 79:         case .homeFullActionCompleted: return "home_full_action_completed"
 80:         case .pageAdded: return "page_added"
 81:         case .pageRemoved: return "page_remove"
 82:         case .pdfRenamed: return "pdf_renamed"
 83:         case .passwordAdded: return "password_added"
 84:         case .passwordRemoved: return "password_remove"
 85:         case .compressionOptionChanged: return "compression_option_changed"
 86:         case .pdfMerge: return "pdf_merge"
 87:         case .pdfSplit: return "pdf_split"
 88:         case .existingPdfOpened: return "existing_pdf_opened"
 89:         case .existingPdfRemoved: return "existing_pdf_removed"
 90:         case .importTutorialCompleted: return "import_tutorial_completed"
 91:         case .pdfSaved: return "pdf_saved"
 92:         case .pdfShared: return "pdf_shared"
 93:         case .signatureCreated: return "signature_created"
 94:         case .signatureAdded: return "signature_added"
 95:         case .signatureRemoved: return "signature_removed"
 96:         case .signaturesConfirmed: return "signatures_confirmed"
 97:         case .signatureFileSaved: return "signatures_file_saved"
 98:         case .signatureFileDeleted: return "signatures_file_deleted"
 99:         case .textAnnotationAdded: return "text_annotation_added"
100:         case .textAnnotationRemoved: return "text_annotation_removed"
101:         case .annotationsConfirmed: return "annotations_confirmed"
102:         case .fillWidgetCancelled: return "fill_widget_cancelled"
103:         case .fillWidgetConfirmed: return "fill_widget_confirmed"
104:         case .chatPdfSelectionActionChosen: return "chat_pdf_selection_action_chosen"
105:         case .chatPdfSelectionFullActionChosen: return "chat_pdf_selection_full_action_chosen"
106:         case .chatPdfSelectionFullActionCompleted: return "chat_pdf_selection_full_action_completed"
107:         case .chatPdfMessageSent: return "chat_pdf_message_sent"
108:         case .subscriptionShown: return "subscription_shown"
109:         case .reviewLowRateFeedback: return "review_low_rate_feedback"
110:         case .suggestedFieldsSaved: return "suggested_fields_saved"
111:         case .reportScreen: return "report_screen"
112:         case .reportNonFatalError: return ""
113:         }
114:     }
115:     
116:     var parameters: [String: Any]? {
117:         switch self {
118:         case .appTrackingTransparancyAuthorized: return nil
119:         case .checkoutCompleted(let subscriptionPlanProduct):
120:             return [
121:                 AnalyticsEventCustomParameters.productId.rawValue: subscriptionPlanProduct.id,
122:                 AnalyticsEventCustomParameters.productPrice.rawValue: subscriptionPlanProduct.displayPrice,
123:                 AnalyticsEventCustomParameters.subscriptionPlanIsFreeTrial.rawValue: subscriptionPlanProduct.subscription?.introductoryOffer?.paymentMode == .freeTrial
124:             ]
125:         case .homeActionChosen(let homeAction):
126:             return [AnalyticsEventCustomParameters.homeActionType.rawValue: homeAction.trackingParameterValue]
127:         case .homeFullActionChosen(let homeAction, let importOption):
128:             var parameters = [AnalyticsEventCustomParameters.homeActionType.rawValue: homeAction.trackingParameterValue]
129:             if let importOption = importOption {
130:                 parameters[AnalyticsEventCustomParameters.importOption.rawValue] = importOption.trackingParameterValue
131:             }
132:             return parameters
133:         case .homeFullActionCompleted(let homeAction, let importOption, let fileExtension):
134:             var parameters = [AnalyticsEventCustomParameters.homeActionType.rawValue: homeAction.trackingParameterValue]
135:             if let fileExtension = fileExtension {
136:                 parameters[AnalyticsEventCustomParameters.pdfInputTypeExtension.rawValue] = fileExtension
137:             }
138:             if let importOption = importOption {
139:                 parameters[AnalyticsEventCustomParameters.importOption.rawValue] = importOption.trackingParameterValue
140:             }
141:             return parameters
142:         case .pageAdded(let pdfInputType, let fileExtension):
143:             var parameters = [AnalyticsEventCustomParameters.pdfInputType.rawValue: pdfInputType.trackingParameterValue]
144:             if let fileExtension = fileExtension {
145:                 parameters[AnalyticsEventCustomParameters.pdfInputTypeExtension.rawValue] = fileExtension
146:             }
147:             return parameters
148:         case .onboardingCompleted: return nil
149:         case .onboardingSkipped: return nil
150:         case .pageRemoved: return nil
151:         case .pdfRenamed: return nil
152:         case .passwordAdded: return nil
153:         case .passwordRemoved: return nil
154:         case .compressionOptionChanged(let compressionOption):
155:             return [AnalyticsEventCustomParameters.compressionOption.rawValue: compressionOption.trackingParameterValue]
156:         case .pdfMerge: return nil
157:         case .pdfSplit: return nil
158:         case .existingPdfOpened: return nil
159:         case .existingPdfRemoved: return nil
160:         case .importTutorialCompleted: return nil
161:         case .textAnnotationAdded: return nil
162:         case .textAnnotationRemoved: return nil
163:         case .annotationsConfirmed: return nil
164:         case .signatureCreated: return nil
165:         case .signatureAdded: return nil
166:         case .signatureRemoved: return nil
167:         case .signaturesConfirmed: return nil
168:         case .signatureFileSaved: return nil
169:         case .signatureFileDeleted: return nil
170:         case .fillWidgetCancelled: return nil
171:         case .fillWidgetConfirmed: return nil
172:         case .pdfSaved: return nil
173:         case .pdfShared: return nil
174:         case .chatPdfSelectionActionChosen: return nil
175:         case .chatPdfSelectionFullActionChosen(let importOption):
176:             var parameters: [String: Any] = [:]
177:             if let importOption = importOption {
178:                 parameters[AnalyticsEventCustomParameters.importOption.rawValue] = importOption.trackingParameterValue
179:             }
180:             return parameters
181:         case .chatPdfSelectionFullActionCompleted(let importOption, let fileExtension):
182:             var parameters: [String: Any] = [:]
183:             if let fileExtension = fileExtension {
184:                 parameters[AnalyticsEventCustomParameters.pdfInputTypeExtension.rawValue] = fileExtension
185:             }
186:             if let importOption = importOption {
187:                 parameters[AnalyticsEventCustomParameters.importOption.rawValue] = importOption.trackingParameterValue
188:             }
189:             return parameters
190:         case .chatPdfMessageSent: return nil
191:         case .subscriptionShown: return nil
192:         case .reviewLowRateFeedback(let feedback):
193:             return [AnalyticsEventCustomParameters.reviewLowRateFeedbackContent.rawValue: feedback]
194:         case .suggestedFieldsSaved: return nil
195:         case .reportScreen(let screen):
196:             return [AnalyticsEventCustomParameters.screenName.rawValue: screen.name]
197:         case .reportNonFatalError: return nil
198:         }
199:     }
200: }
201: 
202: extension AnalyticsError {
203:     
204:     var errorDescription: String {
205:         switch self {
206:         case .shareExtensionPdfMissingRawData: return "Share Extension Pdf raw data missing while existance flag was true"
207:         case .shareExtensionPdfExistingUnexpectedRawData: return "Share Extension Pdf raw data but the existance flag was false"
208:         case .shareExtensionPdfCannotDecode: return "Share Extension Pdf raw data existed but could not be converted to PdfDocument"
209:         case .shareExtensionPdfInvalidPasswordForLockedFile: return "Share Extension Pdf cannot be unlocked with the stored password"
210:         case .shareExtensionPdfMissingDataForUnlockedFile: return "Share Extension Pdf was unlocked but failed to provide data"
211:         case .shareExtensionPdfDecryptionFailed: return "Share Extension Pdf was unlocked but could not be decrypted"
212:         case .shareExtensionPdfCannotDecodeDecryptedData: return "Share Extension Pdf was decrypted but could not be converted to PdfDocument"
213:         case .chatPdfDeletionFailed: return "Pdf uploaded to Chat Pdf has not be deleted"
214:         }
215:     }
216:     
217:     var nsError: NSError {
218:         let userInfo: [String: Any] = [
219:             "error_description": self.errorDescription
220:         ]
221:         return NSError(domain: "AnalyticsError", code: 0, userInfo: userInfo)
222:     }
223: }
224: 
225: fileprivate extension AnalyticsPdfInputType {
226:     
227:     var trackingParameterValue: String {
228:         switch self {
229:         case .camera: return "camera"
230:         case .gallery: return "gallery"
231:         case .fileImage: return "file_image"
232:         case .file: return "file"
233:         case .scan: return "scan"
234:         case .appExtension: return "app_extension"
235:         case .scanPdf: return "scan_pdf"
236:         case .filePdf: return "file_pdf"
237:         case .scanFillForm: return "scan_fill_form"
238:         case .fileFillForm: return "file_fill_form"
239:         case .scanSign: return "scan_sign"
240:         case .fileSign: return "file_sign"
241:         case .fileFillWidget: return "file_fill_widget"
242:         }
243:     }
244: }
245: 
246: fileprivate extension HomeAction {
247:     
248:     var trackingParameterValue: String {
249:         switch self {
250:         case .appExtension: return "app_extension"
251:         case .imageToPdf: return "image_to_pdf"
252:         case .wordToPdf: return "word_to_pdf"
253:         case .excelToPdf: return "excel_to_pdf"
254:         case .powerpointToPdf: return "powerpoint_to_pdf"
255:         case .scan: return "scan"
256:         case .merge: return "merge"
257:         case .split: return "split"
258:         case .sign: return "sign"
259:         case .formFill: return "form_fill"
260:         case .addText: return "add_text"
261:         case .createPdf: return "create_pdf"
262:         case .importPdf: return "import_pdf"
263:         case .readPdf: return "read_pdf"
264:         case .removePassword: return "remove_password"
265:         case .addPassword: return "add_password"
266:         }
267:     }
268: }
269: 
270: fileprivate extension ImportOption {
271:     
272:     var trackingParameterValue: String {
273:         switch self {
274:         case .camera: return "camera"
275:         case .gallery: return "gallery"
276:         case .scan: return "scan"
277:         case .file(let fileSource):
278:             switch fileSource {
279:             case .google: return "google_drive"
280:             case .dropbox: return "dropbox"
281:             case .icloud: return "icloud"
282:             case .files: return "files"
283:             }
284:         }
285:     }
286: }
287: 
288: fileprivate extension CompressionOption {
289:     
290:     var trackingParameterValue: String {
291:         switch self {
292:         case .noCompression: return "no_compression"
293:         case .low: return "low"
294:         case .medium: return "medium"
295:         case .high: return "high"
296:         }
297:     }
298: }
```

## File: pdfexpert/Models/Analytics/AnalyticsManager.swift
```swift
 1: //
 2: //  AnalyticsManager.swift
 3: //  ForYouAndMe
 4: //
 5: //  Created by Pcnaid Inc on 10/07/2020.
 6: //
 7: 
 8: import Foundation
 9: import StoreKit
10: 
11: enum AnalyticsError {
12:     case shareExtensionPdfMissingRawData
13:     case shareExtensionPdfExistingUnexpectedRawData
14:     case shareExtensionPdfCannotDecode
15:     case shareExtensionPdfInvalidPasswordForLockedFile
16:     case shareExtensionPdfMissingDataForUnlockedFile
17:     case shareExtensionPdfDecryptionFailed
18:     case shareExtensionPdfCannotDecodeDecryptedData
19:     case chatPdfDeletionFailed
20: }
21: 
22: enum AnalyticsPdfInputType {
23:     case camera, gallery, fileImage, file, scan, appExtension, scanPdf, filePdf, scanFillForm, fileFillForm, scanSign, fileSign, fileFillWidget
24: }
25: 
26: enum AnalyticsScreen {
27:     case onboarding
28:     case home
29:     case files
30:     case chatPdfSelection
31:     case settings
32:     case subscription
33:     case importTutorial
34:     case signature
35:     case signaturePicker
36:     case fillForm
37:     case fillWidget
38:     case chatPdf
39:     case compressionPicker
40:     case sortPdf
41:     case pageRangeEditor
42:     case reader
43:     case pageSelection
44:     case suggestedFields
45: }
46: 
47: enum AnalyticsEvent {
48:     case appTrackingTransparancyAuthorized
49:     case checkoutCompleted(subscriptionPlanProduct: Product)
50:     case onboardingCompleted
51:     case onboardingSkipped
52:     case homeActionChosen(homeAction: HomeAction)
53:     case homeFullActionChosen(homeAction: HomeAction, importOption: ImportOption?)
54:     case homeFullActionCompleted(homeAction: HomeAction, importOption: ImportOption?, fileExtension: String?)
55:     case pageAdded(pdfInputType: AnalyticsPdfInputType, fileExtension: String?)
56:     case pageRemoved
57:     case pdfRenamed
58:     case passwordAdded
59:     case passwordRemoved
60:     case pdfMerge
61:     case pdfSplit
62:     case compressionOptionChanged(compressionOption: CompressionOption)
63:     case existingPdfOpened
64:     case existingPdfRemoved
65:     case importTutorialCompleted
66:     case signatureCreated
67:     case signatureAdded
68:     case signatureRemoved
69:     case signaturesConfirmed
70:     case signatureFileSaved
71:     case signatureFileDeleted
72:     case textAnnotationAdded
73:     case textAnnotationRemoved
74:     case annotationsConfirmed
75:     case fillWidgetCancelled
76:     case fillWidgetConfirmed
77:     case pdfSaved
78:     case pdfShared
79:     case chatPdfSelectionActionChosen
80:     case chatPdfSelectionFullActionChosen(importOption: ImportOption?)
81:     case chatPdfSelectionFullActionCompleted(importOption: ImportOption?, fileExtension: String?)
82:     case chatPdfMessageSent
83:     case subscriptionShown
84:     case reviewLowRateFeedback(feedback: String)
85:     case suggestedFieldsSaved
86:     case reportScreen(_ screen: AnalyticsScreen)
87:     case reportNonFatalError(_ error: AnalyticsError)
88: }
89: 
90: protocol AnalyticsManager {
91:     func track(event: AnalyticsEvent)
92: }
```

## File: pdfexpert/Models/Analytics/AnalyticsManagerImpl.swift
```swift
 1: //
 2: //  AnalyticsManagerImpl.swift
 3: //  ForYouAndMe
 4: //
 5: //  Created by Pcnaid Inc on 10/07/2020.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: 
11: extension Container {
12:     var analyticsManager: Factory<AnalyticsManager> {
13:         self { AnalyticsManagerImpl() }.singleton
14:     }
15: }
16: 
17: class AnalyticsManagerImpl: AnalyticsManager {
18:     
19:     private let platforms: [AnalyticsPlatform]
20:     
21:     init() {
22:         self.platforms = [FirebaseAnalyticsPlatform(), BranchAnalyticsPlatform()]
23:     }
24:     
25:     func track(event: AnalyticsEvent) {
26:         print("Analytics - Tracked event: \(event)")
27:         #if PRODUCTION && DEBUG
28:         #else
29:         self.platforms.forEach({ $0.track(event: event) })
30:         #endif
31:     }
32: }
```

## File: pdfexpert/Models/Analytics/AnalyticsPlatform.swift
```swift
 1: //
 2: //  AnalyticsPlatform.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/04/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: protocol AnalyticsPlatform {
11:     func track(event: AnalyticsEvent)
12: }
```

## File: pdfexpert/Models/Analytics/BranchAnalyticsPlatform.swift
```swift
 1: //
 2: //  BranchAnalyticsPlatform.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 05/09/23.
 6: //
 7: 
 8: import Foundation
 9: import BranchSDK
10: 
11: class BranchAnalyticsPlatform: AnalyticsPlatform {
12:     
13:     func track(event: AnalyticsEvent) {
14:         switch event {
15:         case .checkoutCompleted(let subscriptionPlanProduct):
16:             let branchUniversalObject = BranchUniversalObject()
17:             branchUniversalObject.canonicalIdentifier = subscriptionPlanProduct.id
18:             branchUniversalObject.contentMetadata.price = NSDecimalNumber(decimal: subscriptionPlanProduct.price)
19:             branchUniversalObject.title = subscriptionPlanProduct.displayName
20:             branchUniversalObject.contentMetadata.quantity = 1
21:             branchUniversalObject.contentMetadata.productName = subscriptionPlanProduct.displayName
22:             branchUniversalObject.contentMetadata.currency = BNCCurrency(rawValue: subscriptionPlanProduct.priceFormatStyle.currencyCode)
23:             if subscriptionPlanProduct.isFreeTrial {
24:                 BranchEvent.standardEvent(.startTrial, withContentItem: branchUniversalObject).logEvent()
25:             } else {
26:                 BranchEvent.standardEvent(.subscribe, withContentItem: branchUniversalObject).logEvent()
27:             }
28:         case .reportNonFatalError:
29:             break
30:         default:
31:             self.sendEvent(withEventName: event.customEventName, parameters: event.parameters)
32:         }
33:     }
34:     
35:     // MARK: - Private Methods
36:     
37:     private func sendEvent(withEventName eventName: String, parameters: [String: Any]? = nil) {
38:         if let parameters {
39:             let branchUniversalObject = BranchUniversalObject(dictionary: parameters)
40:             BranchEvent.customEvent(withName: eventName, contentItem: branchUniversalObject).logEvent()
41:         } else {
42:             BranchEvent.customEvent(withName: eventName).logEvent()
43:         }
44:     }
45: }
```

## File: pdfexpert/Models/Analytics/FirebaseAnalyticsPlatform.swift
```swift
 1: //
 2: //  FirebaseAnalyticsPlatform.swift
 3: //  ForYouAndMe
 4: //
 5: //  Created by Pcnaid Inc on 23/09/2020.
 6: //
 7: 
 8: import Foundation
 9: import FirebaseAnalytics
10: import FirebaseCrashlytics
11: 
12: class FirebaseAnalyticsPlatform: AnalyticsPlatform {
13:     
14:     func track(event: AnalyticsEvent) {
15:         switch event {
16:         case .reportScreen(let screen):
17:             self.sendEvent(withEventName: AnalyticsEventScreenView, parameters: [AnalyticsParameterScreenName: screen.name])
18:         case .reportNonFatalError(let error):
19:             Crashlytics.crashlytics().record(error: error.nsError)
20:         default:
21:             self.sendEvent(withEventName: event.customEventName, parameters: event.parameters)
22:         }
23:     }
24:     
25:     // MARK: - Private Methods
26:     
27:     private func sendEvent(withEventName eventName: String, parameters: [String: Any]? = nil) {
28:         Analytics.logEvent(eventName, parameters: parameters)
29:     }
30: }
```

## File: pdfexpert/Models/Entities/ChatPdfInitParams.swift
```swift
 1: //
 2: //  ChatPdfInitParams.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 21/07/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: struct ChatPdfInitParams: Hashable, Identifiable {
11:     
12:     var id: Self { return self }
13:     
14:     let chatPdfRef: ChatPdfRef
15:     let setupData: ChatPdfSetupData
16: }
```

## File: pdfexpert/Models/Entities/ChatPdfMessage.swift
```swift
 1: //
 2: //  ChatPdfMessage.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 20/07/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: enum ChatPdfMessageRole {
11:     case user
12:     case assistant
13: }
14: 
15: enum ChatPdfMessageType {
16:     case text
17:     case indicator
18: }
19: 
20: struct ChatPdfMessage: Hashable {
21:     let role: ChatPdfMessageRole
22:     let type: ChatPdfMessageType
23:     let content: String
24:     let suggestedQuestions: [String]
25: }
26: 
27: extension ChatPdfMessage {
28:     init(role: ChatPdfMessageRole, type: ChatPdfMessageType, content: String) {
29:         self.role = role
30:         self.type = type
31:         self.content = content
32:         self.suggestedQuestions = []
33:     }
34: }
```

## File: pdfexpert/Models/Entities/ChatPdfRef.swift
```swift
 1: //
 2: //  ChatPdfRef.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 20/07/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: struct ChatPdfRef: Hashable, Identifiable {
11:     
12:     var id: Self { return self }
13:     
14:     let sourceId: String
15: }
```

## File: pdfexpert/Models/Entities/ChatPdfSetupData.swift
```swift
 1: //
 2: //  ChatPdfSetupData.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 10/08/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: struct ChatPdfSetupData: Hashable {
11:     let summary: String
12:     let suggestedQuestions: [String]
13: }
```

## File: pdfexpert/Models/Entities/Pdf.swift
```swift
  1: //
  2: //  Pdf.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 11/04/23.
  6: //
  7: 
  8: import Foundation
  9: import PDFKit
 10: import CoreData
 11: 
 12: enum MarginsOption: Int32, CaseIterable {
 13:     case noMargins, mediumMargins, heavyMargins
 14: }
 15: 
 16: enum CompressionOption: Int32, CaseIterable {
 17:     case noCompression, low, medium, high
 18: }
 19: 
 20: struct Pdf {
 21:     private(set) var storeId: NSManagedObjectID? = nil
 22:     private(set) var pdfDocument: PDFDocument
 23:     private(set) var password: String? = nil
 24:     private(set) var creationDate: Date = Date()
 25:     private(set) var filename: String
 26:     private(set) var compression: CompressionOption = K.Misc.PdfDefaultCompression
 27:     private(set) var margins: MarginsOption = K.Misc.PdfDefaultMarginsOption
 28:     
 29:     var rawData: Data? {
 30:         return self.pdfDocument.dataRepresentation()
 31:     }
 32:     
 33:     init(storeId: NSManagedObjectID,
 34:          pdfDocument: PDFDocument,
 35:          password: String?,
 36:          creationDate: Date?,
 37:          fileName: String?,
 38:          compression: CompressionOption,
 39:          margins: MarginsOption) {
 40:         self.storeId = storeId
 41:         self.pdfDocument = pdfDocument
 42:         self.password = password
 43:         self.creationDate = creationDate ?? Date()
 44:         self.filename = fileName ?? self.creationDate.creationDateText
 45:         self.compression = compression
 46:         self.margins = margins
 47:     }
 48:     
 49:     init?(data: Data) {
 50:         guard let pdfDocument = PDFDocument(data: data) else { return nil }
 51:         self.pdfDocument = pdfDocument
 52:         self.filename = self.creationDate.creationDateText
 53:     }
 54:     
 55:     init?(pdfUrl: URL) {
 56:         guard let pdfDocument = PDFDocument(url: pdfUrl) else { return nil }
 57:         self.pdfDocument = pdfDocument
 58:         self.filename = pdfUrl.filename
 59:     }
 60:     
 61:     init(pdfDocument: PDFDocument) {
 62:         self.pdfDocument = pdfDocument
 63:         self.filename = self.creationDate.creationDateText
 64:     }
 65:     
 66:     init() {
 67:         self.pdfDocument = PDFDocument()
 68:         self.filename = self.creationDate.creationDateText
 69:     }
 70:     
 71:     mutating func updateStoreId(_ storeId: NSManagedObjectID?) {
 72:         self.storeId = storeId
 73:     }
 74:     
 75:     mutating func updateDocument(_ pdfDocument: PDFDocument) {
 76:         self.pdfDocument = pdfDocument
 77:     }
 78:     
 79:     mutating func updatePassword(_ newPassword: String?) {
 80:         self.password = newPassword
 81:     }
 82:     
 83:     mutating func updateCompression(_ newCompression: CompressionOption) {
 84:         self.compression = newCompression
 85:     }
 86:     
 87:     mutating func updateMargins(_ newMargins: MarginsOption) {
 88:         self.margins = newMargins
 89:     }
 90:     
 91:     mutating func updateFilename(_ filename: String) {
 92:         self.filename = filename
 93:     }
 94:     
 95:     var thumbnail: UIImage? {
 96:         PDFUtility.generatePdfThumbnail(pdfDocument: self.pdfDocument, size: K.Misc.ThumbnailSize)
 97:     }
 98:     
 99:     var pageCount: Int {
100:         return self.pdfDocument.pageCount
101:     }
102: }
103: 
104: fileprivate extension Date {
105:     
106:     var creationDateText: String {
107:         let dateFormatter = DateFormatter()
108:         dateFormatter.dateFormat = "MM-dd-YYYY"
109:         return "File-\(dateFormatter.string(from: self))"
110:     }
111: }
112: 
113: extension Pdf: Hashable, Identifiable {
114:     var id: Self { return self }
115: }
116: 
117: extension Pdf: Collection {
118:     
119:     typealias Index = Int
120:     typealias Element = PDFPage
121:     
122:     var startIndex: Index { return 0 }
123:     var endIndex: Index { return self.pageCount }
124:     
125:     subscript(index: Index) -> Element {
126:         get { return self.pdfDocument.page(at: index)! }
127:     }
128:     
129:     func index(after i: Index) -> Index {
130:         return i + 1
131:     }
132: }
```

## File: pdfexpert/Models/Entities/PickedImage.swift
```swift
 1: //
 2: //  PickedImage.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 07/06/23.
 6: //
 7: 
 8: import Foundation
 9: import PhotosUI
10: import SwiftUI
11: 
12: struct PickedImage: Transferable {
13:     let uiImage: UIImage
14:     
15:     static var transferRepresentation: some TransferRepresentation {
16:         DataRepresentation(importedContentType: .image) { data in
17:         #if canImport(UIKit)
18:             guard let uiImage = UIImage(data: data) else {
19:                 throw ImageTransferError.importFailed
20:             }
21:             return PickedImage(uiImage: uiImage)
22:         #else
23:             throw ImageTransferError.importFailed
24:         #endif
25:         }
26:     }
27: }
28: 
29: enum ImageTransferError: LocalizedError {
30:     case importFailed
31:     
32:     var errorDescription: String? {
33:         switch self {
34:         case .importFailed: return "Couldn't import the selected photo."
35:         }
36:     }
37: }
```

## File: pdfexpert/Models/Entities/ProjectInfo.swift
```swift
 1: //
 2: //  ProjectInfo.swift
 3: //  FastCheckIn
 4: //
 5: //  Created by Pcnaid Inc on 03/07/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: class ProjectInfo {
11:     
12:     private enum ProjectInfoKey: String, CaseIterable {
13:         
14:         case chatPdfApiKey = "CHAT_PDF_API_KEY"
15:     }
16:     
17:     static var chatPdfApiKey: String { Self.getValue(forKey: .chatPdfApiKey, defaultValue: "") }
18:     
19:     static func validate() {
20:         ProjectInfoKey.allCases.forEach { key in
21:             switch key {
22:             case .chatPdfApiKey: _ = Self.getValue(forKey: key, defaultValue: "")
23:             }
24:         }
25:     }
26:     
27:     static private var projectInfoDictionary: [String: Any] = {
28:         guard let url = Bundle.main.url(forResource: "ProjectInfo", withExtension: "plist") else {
29:             assertionFailure("Couldn't find ProjectInfo.plist")
30:             return [:]
31:         }
32:         guard let data = try? Data(contentsOf: url) else {
33:             assertionFailure("Couldn't open ProjectInfo.plist")
34:             return [:]
35:         }
36:         guard let studyConfig = try? PropertyListSerialization.propertyList(from: data, format: nil) as? [String: Any] else {
37:             assertionFailure("ProjectInfo.plist is not a dictionary of [String: Any]")
38:             return [:]
39:         }
40:         return studyConfig
41:     }()
42:     
43:     static private func getValue<T>(forKey key: ProjectInfoKey, defaultValue: T) -> T {
44:         guard let object = Self.projectInfoDictionary[key.rawValue], let value = object as? T  else {
45:             assertionFailure("Couldn't find \(key.rawValue) in ProjectInfo")
46:             return defaultValue
47:         }
48:         return value
49:     }
50:     
51:     static private func getOptionalValue<T>(forKey key: ProjectInfoKey) -> T? {
52:         guard let object = Self.projectInfoDictionary[key.rawValue], let value = object as? T  else {
53:             return nil
54:         }
55:         return value
56:     }
57: }
```

## File: pdfexpert/Models/Entities/Signature.swift
```swift
 1: //
 2: //  Signature.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 28/08/23.
 6: //
 7: 
 8: import Foundation
 9: import CoreData
10: import PencilKit
11: 
12: struct Signature {
13:     let id: UUID = UUID()
14:     private(set) var storeId: NSManagedObjectID? = nil
15:     let image: UIImage
16:     let creationDate: Date
17:     
18:     var rawData: Data? {
19:         return self.image.pngData()
20:     }
21:     
22:     init?(storeId: NSManagedObjectID,
23:          creationDate: Date?,
24:          data: Data) {
25:         guard let image = UIImage(data: data) else {
26:             return nil
27:         }
28:         print("Signature - On Load Image Size: \(image.size). Scale: \(image.scale)")
29:         self.storeId = storeId
30:         self.image = image
31:         self.creationDate = creationDate ?? Date()
32:     }
33:     
34:     init(image: UIImage) {
35:         print("Signature - On Save Image Size: \(image.size). Scale: \(image.scale)")
36:         self.image = image
37:         self.creationDate = Date()
38:     }
39:     
40:     mutating func updateStoreId(_ storeId: NSManagedObjectID?) {
41:         self.storeId = storeId
42:     }
43: }
44: 
45: extension Signature: Identifiable {}
46: 
47: extension PKDrawing {
48:     var signatureImage: UIImage {
49:         self.image(from: self.bounds, scale: K.Misc.SignatureDrawScaleFactor, userInterfaceStyle: .light)
50:     }
51: }
```

## File: pdfexpert/Models/Entities/SuggestedFields.swift
```swift
 1: //
 2: //  SuggestedFields.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 07/09/23.
 6: //
 7: 
 8: import Foundation
 9: import CoreData
10: 
11: struct SuggestedFields {
12:     private(set) var storeId: NSManagedObjectID? = nil
13:     var firstName: String?
14:     var lastName: String?
15:     var address: String?
16:     var city: String?
17:     var country: String?
18:     var email: String?
19:     var phone: String?
20:     
21:     var fields: [String] {
22:         let fields: [String?] = [
23:             self.firstName,
24:             self.lastName,
25:             self.address,
26:             self.city,
27:             self.country,
28:             self.email,
29:             self.phone
30:         ]
31:         return fields.compactMap { $0 }
32:     }
33: 
34:     mutating func updateStoreId(_ storeId: NSManagedObjectID?) {
35:         self.storeId = storeId
36:     }
37: }
```

## File: pdfexpert/Models/Network/ChatPdf/Mapping/ChatPdfMessage+Decodable.swift
```swift
 1: //
 2: //  ChatPdfMessage+Decodable.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 21/07/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: extension ChatPdfMessage: Decodable {
11:     private enum CodingKeys: CodingKey {
12:         case content
13:     }
14:     
15:     init(from decoder: Decoder) throws {
16:         let container = try decoder.container(keyedBy: CodingKeys.self)
17:         self.content = try container.decode(String.self, forKey: .content)
18:         self.type = .text
19:         self.role = .assistant
20:         self.suggestedQuestions = []
21:     }
22: }
```

## File: pdfexpert/Models/Network/ChatPdf/Mapping/ChatPdfRef+Decodable.swift
```swift
 1: //
 2: //  ChatPdfRef+Decodable.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 21/07/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: extension ChatPdfRef: Decodable {
11:     private enum CodingKeys: CodingKey {
12:         case sourceId
13:     }
14:     
15:     init(from decoder: Decoder) throws {
16:         let container = try decoder.container(keyedBy: CodingKeys.self)
17:         self.sourceId = try container.decode(String.self, forKey: .sourceId)
18:     }
19: }
```

## File: pdfexpert/Models/Network/ChatPdf/Mapping/ChatPdfSetupData+Decodable.swift
```swift
 1: //
 2: //  ChatPdfSetupData+Decodable.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 10/08/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: extension ChatPdfSetupData: Decodable {
11:     enum CodingKeys: String, CodingKey {
12:         case summary
13:         case suggestedQuestions = "suggested_questions"
14:     }
15:     
16:     init(from decoder: Decoder) throws {
17:         let container = try decoder.container(keyedBy: CodingKeys.self)
18:         self.summary = try container.decode(String.self, forKey: .summary)
19:         self.suggestedQuestions = (try? container.decode([String].self, forKey: .suggestedQuestions)) ?? []
20:         if self.summary.isEmpty {
21:             throw DecodingError.dataCorruptedError(forKey: .summary, in: container, debugDescription: "Summary cannot be empty")
22:         }
23:     }
24: }
```

## File: pdfexpert/Models/Network/ChatPdf/ChatPdfManager.swift
```swift
 1: //
 2: //  ChatPdfManager.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 02/03/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import Combine
11: 
12: enum ChatPdfError: LocalizedError, UnderlyingError {
13:     case unknownError
14:     case parse
15:     case pdfTooLarge
16:     case pdfTooManyPages
17:     case underlyingError(errorDescription: String)
18:     
19:     static func getUnknownError() -> Self { Self.unknownError }
20:     
21:     static func getUnderlyingError(errorDescription: String) -> Self {
22:         return .underlyingError(errorDescription: errorDescription)
23:     }
24:     
25:     var errorDescription: String? {
26:         switch self {
27:         case .unknownError, .parse: return "Internal Error. Please try again later"
28:         case .underlyingError(let errorMessage): return errorMessage
29:         case .pdfTooLarge: return "Your pdf is too large"
30:         case .pdfTooManyPages: return "Your pdf has too many pages"
31:         }
32:     }
33: }
34: 
35: 
36: protocol ChatPdfManager {
37:     func sendPdf(pdf: Data) -> AnyPublisher<ChatPdfRef, ChatPdfError>
38:     func generateText(ref: ChatPdfRef, prompt: String) -> AnyPublisher<ChatPdfMessage, ChatPdfError>
39:     func getSetupData(ref: ChatPdfRef) -> AnyPublisher<ChatPdfSetupData, ChatPdfError>
40:     func deletePdf(ref: ChatPdfRef)
41: }
42: 
43: extension Container {
44:     var chatPdfManager: Factory<ChatPdfManager> {
45:         self {
46:             #if DEBUG
47:             K.Test.ChatPdf.UseMock ? (ChatPdfManagerMock() as ChatPdfManager) : (ChatPdfManagerImpl() as ChatPdfManager)
48:             #else
49:             ChatPdfManagerImpl()
50:             #endif
51:         }.singleton
52:     }
53: }
```

## File: pdfexpert/Models/Network/ChatPdf/ChatPdfManagerImpl.swift
```swift
  1: //
  2: //  ChatPdfManagerImpl.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 21/07/23.
  6: //
  7: 
  8: import Foundation
  9: import Moya
 10: import CombineMoya
 11: import Combine
 12: import Factory
 13: 
 14: fileprivate struct ChatPdfApiError: Decodable, CustomStringConvertible {
 15:     let code: String
 16:     let message: String
 17:     
 18:     var description: String { self.message }
 19: }
 20: 
 21: class ChatPdfManagerImpl: ChatPdfManager {
 22:     
 23:     fileprivate static let baseUrl: String = "https://api.chatpdf.com"
 24:     
 25:     fileprivate static let apiKey: String = { ProjectInfo.chatPdfApiKey }()
 26:     
 27:     lazy var provider: MoyaProvider<ChatPdfService> = { self.createProvider() }()
 28:     
 29:     lazy var loggerPlugin: PluginType = {
 30:         let formatter = NetworkLoggerPlugin.Configuration.Formatter(requestData: Data.JSONRequestDataFormatter,
 31:                                                                     responseData: Data.JSONRequestDataFormatter)
 32:         let logOptions: NetworkLoggerPlugin.Configuration.LogOptions = K.Test.ChatPdf.NetworkLogVerbose
 33:             ? .verbose
 34:             : .default
 35:         let config = NetworkLoggerPlugin.Configuration(formatter: formatter, logOptions: logOptions)
 36:         return NetworkLoggerPlugin(configuration: config)
 37:     }()
 38:     
 39:     @Injected(\.analyticsManager) private var analyticsManager
 40:     
 41:     private var cancelBag = Set<AnyCancellable>()
 42:     
 43:     func createProvider() -> MoyaProvider<ChatPdfService> {
 44:         MoyaProvider<ChatPdfService>(plugins: [self.loggerPlugin])
 45:     }
 46:     
 47:     func sendPdf(pdf: Data) -> AnyPublisher<ChatPdfRef, ChatPdfError> {
 48:         self.send(request: .sendPdf(pdf: pdf))
 49:     }
 50:     
 51:     func generateText(ref: ChatPdfRef, prompt: String) -> AnyPublisher<ChatPdfMessage, ChatPdfError> {
 52:         self.send(request: .generateText(ref: ref, prompt: prompt))
 53:     }
 54:     
 55:     func getSetupData(ref: ChatPdfRef) -> AnyPublisher<ChatPdfSetupData, ChatPdfError> {
 56:         self.generateText(ref: ref, prompt: K.ChatPdf.SetupMessageRequest)
 57:             .map { (message: ChatPdfMessage) in
 58:                 let decoder = JSONDecoder()
 59:                 if let setupData = try? decoder.decode(ChatPdfSetupData.self, from: Data(message.content.utf8)) {
 60:                     return setupData
 61:                 } else {
 62:                     return ChatPdfSetupData(summary: K.ChatPdf.SetupMessageFallbackResponse, suggestedQuestions: [])
 63:                 }
 64:             }.eraseToAnyPublisher()
 65:     }
 66:     
 67:     func deletePdf(ref: ChatPdfRef) {
 68:         // Must be fire and forget by design, to avoid blocking the user and show unfriendly errors
 69:         // TODO: Improve with a queue of to-be-deleted pdfs that periodically get flushed
 70:         self.send(request: .deletePdf(ref: ref))
 71:             .sink(receiveCompletion: { subscriptionCompletion in
 72:                 if let error = subscriptionCompletion.error {
 73:                     print("ChatPdfManagerImpl - deleting Pdf from Chat PDF. Error: \(error.localizedDescription)")
 74:                     self.analyticsManager.track(event: .reportNonFatalError(.chatPdfDeletionFailed))
 75:                 }
 76:             }, receiveValue: {
 77:                 print("ChatPdfManagerImpl - successfully deleted from Chat PDF")
 78:             }).store(in: &self.cancelBag)
 79:     }
 80:     
 81:     private func send<T: Decodable>(request: ChatPdfService) -> AnyPublisher<T, ChatPdfError> {
 82:         self.provider.requestPublisher(request)
 83:             .tryMap() { response -> Data in
 84:                 guard 200 ... 299 ~= response.statusCode else {
 85:                     let decoder = JSONDecoder()
 86:                     if let apiError =  try? decoder.decode(ChatPdfApiError.self, from: response.data) {
 87:                         throw ChatPdfError.underlyingError(errorDescription: apiError.description)
 88:                     } else {
 89:                         throw ChatPdfError.underlyingError(errorDescription: String(data: response.data, encoding: .utf8) ?? "")
 90:                     }
 91:                 }
 92:                 return response.data
 93:             }
 94:             .decode(type: T.self, decoder: JSONDecoder())
 95:             .mapError { error in
 96:                 if let error = error as? ChatPdfError {
 97:                     return error
 98:                 } else if error is DecodingError {
 99:                     return ChatPdfError.parse
100:                 } else {
101:                     return ChatPdfError.underlyingError(errorDescription: error.localizedDescription)
102:                 }
103:             }
104:             .eraseToAnyPublisher()
105:     }
106:     
107:     private func send(request: ChatPdfService) -> AnyPublisher<(), ChatPdfError> {
108:         self.provider.requestPublisher(request)
109:             .tryMap() { response -> () in
110:                 guard 200 ... 299 ~= response.statusCode else {
111:                     let decoder = JSONDecoder()
112:                     if let apiError =  try? decoder.decode(ChatPdfApiError.self, from: response.data) {
113:                         throw ChatPdfError.underlyingError(errorDescription: apiError.description)
114:                     } else {
115:                         throw ChatPdfError.underlyingError(errorDescription: String(data: response.data, encoding: .utf8) ?? "")
116:                     }
117:                 }
118:                 return ()
119:             }
120:             .mapError { error in
121:                 if let error = error as? ChatPdfError {
122:                     return error
123:                 } else {
124:                     return ChatPdfError.underlyingError(errorDescription: error.localizedDescription)
125:                 }
126:             }
127:             .eraseToAnyPublisher()
128:     }
129: }
130: 
131: enum ChatPdfService {
132:     case sendPdf(pdf: Data)
133:     case generateText(ref: ChatPdfRef, prompt: String)
134:     case deletePdf(ref: ChatPdfRef)
135: }
136: 
137: extension ChatPdfService: TargetType {
138:     
139:     var baseURL: URL { return URL(string: ChatPdfManagerImpl.baseUrl)! }
140:     
141:     var path: String {
142:         switch self {
143:         case .sendPdf: return "/v1/sources/add-file"
144:         case .generateText: return "/v1/chats/message"
145:         case .deletePdf: return "/v1/sources/delete"
146:         }
147:     }
148:     
149:     var method: Moya.Method {
150:         switch self {
151:         case .sendPdf, .generateText, .deletePdf:
152:             return .post
153:         }
154:     }
155:     
156:     var sampleData: Data {
157:         switch self {
158:         // Misc
159:         case .sendPdf: return "{\"sourceId\": \"TestSourceId\"}".utf8Encoded
160:         case .generateText:
161:             return "{\"content\": \"Test Message\"}".utf8Encoded
162: //            return "{\"content\": \"{\\\"summary\\\": \\\"content of the summary\\\",\\\"suggested_questions\\\": [\\\"suggested question number 1\\\",\\\"suggested question number 2\\\",\\\"suggested question number 3\\\"]}\"}".utf8Encoded
163: //            return "{\"content\": \"{\\\"summary\\\": \\\"content of the summary\\\",\\\"suggested_questions\\\": \\\"suggested question number 1\\\"}\"}".utf8Encoded
164: //            return "{\"content\": \"invalid text\"}".utf8Encoded
165:         case .deletePdf: return "".utf8Encoded
166:         }
167:     }
168:     
169:     var task: Task {
170:         switch self {
171:         case .sendPdf:
172:             return .uploadMultipart(self.multipartBody)
173:         case .generateText(let ref, let prompt):
174:             let message: [String: Any] = [
175:                 "role": "user",
176:                 "content": prompt
177:             ]
178:             let parameters: [String: Any] = [
179:                 "sourceId": ref.sourceId,
180:                 "messages": [message]
181:             ]
182:             return .requestParameters(parameters: parameters, encoding: JSONEncoding.default)
183:         case .deletePdf(let ref):
184:             return .requestParameters(parameters: ["sources": [ref.sourceId]], encoding: JSONEncoding.default)
185:         }
186:     }
187:     
188:     var multipartBody: [MultipartFormData] {
189:         switch self {
190:         case .sendPdf(let pdfFile):
191:             let imageDataProvider = MultipartFormData(provider: MultipartFormData.FormDataProvider.data(pdfFile),
192:                                                       name: "pdf_expert_file",
193:                                                       fileName: "pdf_expert_file.pdf",
194:                                                       mimeType: "application/pdf")
195:             return [imageDataProvider]
196:         default:
197:             return []
198:         }
199:     }
200:     
201:     var headers: [String: String]? {
202:         return [
203:             "Content-type": "application/json",
204:             "x-api-key": ChatPdfManagerImpl.apiKey
205:         ]
206:     }
207: }
```

## File: pdfexpert/Models/Network/ChatPdf/ChatPdfManagerMock.swift
```swift
 1: //
 2: //  ChatPdfManagerMock.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 02/03/23.
 6: //
 7: 
 8: import Foundation
 9: import Combine
10: import Moya
11: 
12: class ChatPdfManagerMock: ChatPdfManagerImpl {
13:     
14:     override func createProvider() -> MoyaProvider<ChatPdfService> {
15:         if K.Test.ChatPdf.NetworkStubsDelay > 0.0 {
16:             // Delayed responses (to test progress HUD, for example, or other UI tests)
17:             return MoyaProvider<ChatPdfService>(stubClosure: MoyaProvider.delayedStub(K.Test.ChatPdf.NetworkStubsDelay),
18:                                                 plugins: [self.loggerPlugin])
19:         } else {
20:             // Immediate stubs for unit tests
21:             return MoyaProvider<ChatPdfService>(stubClosure: MoyaProvider.immediatelyStub,
22:                                                 plugins: [self.loggerPlugin])
23:         }
24:     }
25: }
```

## File: pdfexpert/Models/Network/NetworkUtility.swift
```swift
 1: //
 2: //  NetworkUtility.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 21/07/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: internal extension String {
11:     var urlEscaped: String {
12:         return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
13:     }
14:     
15:     var utf8Encoded: Data {
16:         return self.data(using: .utf8)!
17:     }
18: }
19: 
20: internal extension Optional where Wrapped == Int {
21:     var toString:String {
22:         return self != nil ? String(describing: self) : ""
23:     }
24: }
25: 
26: internal extension Int {
27:     var toString:String {
28:         return String(describing: self)
29:     }
30: }
31: 
32: internal extension Date {
33:     var toString:String {
34:         let dateFormatter = ISO8601DateFormatter()
35:         return dateFormatter.string(from: self)
36:     }
37:     
38:     var toDateString: String {
39:         let dateFormatter = DateFormatter()
40:         dateFormatter.dateFormat = "yyyy-MM-dd"
41:         return dateFormatter.string(from: self)
42:     }
43: }
44: 
45: internal extension Bundle {
46:     static func getTestData(from fileName:String) -> Data {
47:         guard let url = Bundle.main.url(forResource: fileName, withExtension: "json"),
48:             let data = try? Data(contentsOf: url) else {
49:                 return Data()
50:         }
51:         return data
52:     }
53: }
54: 
55: internal extension Data {
56:     static func JSONResponseDataFormatter(_ data: Data) -> String {
57:         return JSONPrettyDataFormatter(data)
58:     }
59:     
60:     static func JSONRequestDataFormatter(_ data: Data) -> String {
61:         return JSONPrettyDataFormatter(data)
62:     }
63:     
64:     private static func JSONPrettyDataFormatter(_ data: Data) -> String {
65:         do {
66:             let dataAsJSON = try JSONSerialization.jsonObject(with: data)
67:             let prettyData =  try JSONSerialization.data(withJSONObject: dataAsJSON, options: .prettyPrinted)
68:             return String(data: prettyData, encoding: .utf8) ?? ""
69:         } catch {
70:             return String(data: data, encoding: .utf8) ?? ""
71:         }
72:     }
73: }
```

## File: pdfexpert/Models/Persistence/CoreData/Persistable/Pdf+Persistable.swift
```swift
 1: //
 2: //  Pdf+Persistable.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 28/08/23.
 6: //
 7: 
 8: import Foundation
 9: import CoreData
10: import PDFKit
11: 
12: extension Pdf: Persistable {
13:     
14:     typealias CDEntity = CDPdf
15:     
16:     func getSavedOrNewCoreDataEntity(context: NSManagedObjectContext) -> CDEntity? {
17:         
18:         guard let pdfData = self.rawData else {
19:             debugPrint(for: self, message: "Cannot get pdf raw data for given Pdf instance")
20:             return nil
21:         }
22:         
23:         let result: CDPdf = self.getSavedCoreDataEntity(context: context) ?? CDPdf(context: context)
24:         result.update(withPdf: self, pdfData: pdfData)
25:         return result
26:     }
27:     
28:     static func create(withCoreDataEntity coreDataEntity: some CDEntity) -> Self? {
29:         
30:         guard let pdfData = coreDataEntity.data, let pdfDocument = PDFDocument(data: pdfData) else {
31:             debugPrint(for: self, message: "Cannot get pdf document for given CDPdf instance")
32:             return nil
33:         }
34:         return Pdf(storeId: coreDataEntity.objectID,
35:                    pdfDocument: pdfDocument,
36:                    password: coreDataEntity.password,
37:                    creationDate: coreDataEntity.creationDate,
38:                    fileName: coreDataEntity.filename,
39:                    compression: CompressionOption(rawValue: coreDataEntity.compression) ?? K.Misc.PdfDefaultCompression,
40:                    margins: MarginsOption(rawValue: coreDataEntity.margins) ?? K.Misc.PdfDefaultMarginsOption)
41:     }
42:     
43:     static func fetchRequest() -> NSFetchRequest<CDPdf> {
44:         return NSFetchRequest<CDPdf>(entityName: "Pdf")
45:     }
46: }
```

## File: pdfexpert/Models/Persistence/CoreData/Persistable/Persistable.swift
```swift
 1: //
 2: //  Persistable.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 28/08/23.
 6: //
 7: 
 8: import Foundation
 9: import CoreData
10: 
11: protocol Persistable {
12:     
13:     associatedtype CDEntity: NSManagedObject
14:     
15:     var storeId: NSManagedObjectID? { get }
16:     
17:     static func create(withCoreDataEntity coreDataEntity: CDEntity) -> Self?
18:     static func fetchRequest() -> NSFetchRequest<CDEntity>
19:     
20:     func getSavedOrNewCoreDataEntity(context: NSManagedObjectContext) -> CDEntity?
21: }
22: 
23: extension Persistable {
24:     func getSavedCoreDataEntity(context: NSManagedObjectContext) -> CDEntity? {
25:         if let objectId = self.storeId {
26:             return (try? context.existingObject(with: objectId)) as? CDEntity
27:         } else {
28:             return nil
29:         }
30:     }
31: }
```

## File: pdfexpert/Models/Persistence/CoreData/Persistable/Signature+Persistable.swift
```swift
 1: //
 2: //  Signature+Persistable.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 28/08/23.
 6: //
 7: 
 8: import Foundation
 9: import CoreData
10: 
11: extension Signature: Persistable {
12:     
13:     typealias CDEntity = CDSignature
14:     
15:     func getSavedOrNewCoreDataEntity(context: NSManagedObjectContext) -> CDEntity? {
16:         
17:         guard let signatureData = self.rawData else {
18:             debugPrint(for: self, message: "Cannot get signature raw data for given Signature instance")
19:             return nil
20:         }
21:         
22:         let result: CDSignature = self.getSavedCoreDataEntity(context: context) ?? CDSignature(context: context)
23:         result.update(withSignature: self, imageData: signatureData)
24:         return result
25:     }
26:     
27:     static func create(withCoreDataEntity coreDataEntity: some CDEntity) -> Self? {
28:         
29:         guard let signatureData = coreDataEntity.data else {
30:             debugPrint(for: self, message: "Cannot get signature data for given CDSignature instance")
31:             return nil
32:         }
33:         let signature = Signature(storeId: coreDataEntity.objectID,
34:                                   creationDate: coreDataEntity.creationDate,
35:                                   data: signatureData
36:         )
37:         guard let signature else {
38:             debugPrint(for: self, message: "Cannot get signature drawing for given signature data")
39:             return nil
40:         }
41:         return signature
42:     }
43:     
44:     static func fetchRequest() -> NSFetchRequest<CDSignature> {
45:         return NSFetchRequest<CDSignature>(entityName: "Signature")
46:     }
47: }
```

## File: pdfexpert/Models/Persistence/CoreData/Persistable/SuggestedFields+Persistable.swift
```swift
 1: //
 2: //  SuggestedFields+Persistable.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 07/09/23.
 6: //
 7: 
 8: import Foundation
 9: import CoreData
10: 
11: extension SuggestedFields: Persistable {
12:     
13:     typealias CDEntity = CDSuggestedFields
14:     
15:     func getSavedOrNewCoreDataEntity(context: NSManagedObjectContext) -> CDEntity? {
16:         let result: CDEntity = self.getSavedCoreDataEntity(context: context) ?? CDEntity(context: context)
17:         result.update(withSuggestedFields: self)
18:         return result
19:     }
20:     
21:     static func create(withCoreDataEntity coreDataEntity: some CDEntity) -> Self? {
22:         
23:         return SuggestedFields(
24:             storeId: coreDataEntity.objectID,
25:             firstName: coreDataEntity.firstName,
26:             lastName: coreDataEntity.lastName,
27:             address: coreDataEntity.address,
28:             city: coreDataEntity.city,
29:             country: coreDataEntity.country,
30:             email: coreDataEntity.email,
31:             phone: coreDataEntity.phone
32:         )
33:     }
34:     
35:     static func fetchRequest() -> NSFetchRequest<CDEntity> {
36:         return NSFetchRequest<CDEntity>(entityName: "SuggestedFields")
37:     }
38: }
```

## File: pdfexpert/Models/Persistence/CoreData/CDPdf.swift
```swift
 1: //
 2: //  CDPdf.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 06/04/23.
 6: //
 7: //
 8: 
 9: import Foundation
10: import CoreData
11: 
12: @objc(CDPdf)
13: public class CDPdf: NSManagedObject {
14:     
15:     func update(withPdf pdf: Pdf, pdfData: Data) {
16:         self.data = pdfData
17:         self.creationDate = pdf.creationDate
18:         self.password = pdf.password
19:         self.filename = pdf.filename
20:         self.compression = pdf.compression.rawValue
21:         self.margins = pdf.margins.rawValue
22:     }
23: }
24: 
25: extension CDPdf {
26:     @NSManaged public var data: Data?
27:     @NSManaged public var creationDate: Date?
28:     @NSManaged public var password: String?
29:     @NSManaged public var filename: String?
30:     @NSManaged public var compression: Int32
31:     @NSManaged public var margins: Int32
32: }
```

## File: pdfexpert/Models/Persistence/CoreData/CDSignature.swift
```swift
 1: //
 2: //  CDSignature.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 28/08/23.
 6: //
 7: 
 8: import Foundation
 9: import CoreData
10: 
11: @objc(CDSignature)
12: public class CDSignature: NSManagedObject {
13:     
14:     func update(withSignature signature: Signature, imageData: Data) {
15:         self.data = imageData
16:         self.creationDate = signature.creationDate
17:     }
18: }
19: 
20: extension CDSignature {
21:     @NSManaged public var data: Data?
22:     @NSManaged public var creationDate: Date?
23: }
```

## File: pdfexpert/Models/Persistence/CoreData/CDSuggestedFields.swift
```swift
 1: //
 2: //  CDSuggestedFields.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 07/09/23.
 6: //
 7: 
 8: import Foundation
 9: import CoreData
10: 
11: @objc(CDSuggestedFields)
12: public class CDSuggestedFields: NSManagedObject {
13:     
14:     func update(withSuggestedFields suggestedFields: SuggestedFields) {
15:         self.firstName = suggestedFields.firstName
16:         self.lastName = suggestedFields.lastName
17:         self.address = suggestedFields.address
18:         self.city = suggestedFields.city
19:         self.country = suggestedFields.country
20:         self.email = suggestedFields.email
21:         self.phone = suggestedFields.phone
22:     }
23: }
24: 
25: extension CDSuggestedFields {
26:     @NSManaged public var firstName: String?
27:     @NSManaged public var lastName: String?
28:     @NSManaged public var address: String?
29:     @NSManaged public var city: String?
30:     @NSManaged public var country: String?
31:     @NSManaged public var email: String?
32:     @NSManaged public var phone: String?
33: }
```

## File: pdfexpert/Models/Persistence/CoreData/Persistence.swift
```swift
  1: //
  2: //  Persistence.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 06/04/23.
  6: //
  7: 
  8: import CoreData
  9: import Factory
 10: import CloudKit
 11: 
 12: private var CloudKitContainerIdentifier: String = "iCloud.pdfexpert"
 13: private var InitializeCloudKitSchema: Bool = false
 14: 
 15: extension Container {
 16:     var persistence: Factory<PersistenceController> {
 17:         self {
 18:             #if DEBUG
 19:             if K.Test.UseMockDB || isPreview() {
 20:                 return PersistenceController.preview
 21:             } else {
 22:                 return PersistenceController()
 23:             }
 24:             #else
 25:             PersistenceController()
 26:             #endif
 27:         }.singleton
 28:     }
 29: }
 30: 
 31: struct TransactionAuthor {
 32:     static let app = "app"
 33: }
 34: 
 35: class PersistenceController {
 36: 
 37:     static var preview: PersistenceController = {
 38:         let result = PersistenceController(inMemory: true)
 39:         let viewContext = result.container.viewContext
 40:         for index in 0..<K.Test.NumberOfPdfs {
 41:             _ = K.Test.GetDebugCoreDataPdf(context: viewContext)
 42:         }
 43:         do {
 44:             try viewContext.save()
 45:         } catch {
 46:             // Replace this implementation with code to handle the error appropriately.
 47:             // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
 48:             let nsError = error as NSError
 49:             fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
 50:         }
 51:         return result
 52:     }()
 53: 
 54:     let container: NSPersistentContainer
 55: 
 56:     init(inMemory: Bool = false) {
 57:         if inMemory {
 58:             self.container = NSPersistentContainer(name: "AppCoreData")
 59:             self.container.persistentStoreDescriptions.first!.url = URL(fileURLWithPath: "/dev/null")
 60:             self.container.loadPersistentStores(completionHandler: { (storeDescription, error) in
 61:                 if let error = error as NSError? {
 62:                     fatalError("Unresolved error \(error), \(error.userInfo)")
 63:                 }
 64:             })
 65:             self.container.viewContext.automaticallyMergesChangesFromParent = true
 66:         } else {
 67:             /**
 68:              Prepare the containing folder for the Core Data stores.
 69:              A Core Data store has companion files, so it's a good practice to put a store under a folder.
 70:              */
 71:             let baseURL = NSPersistentContainer.defaultDirectoryURL()
 72:             let storeFolderURL = baseURL.appendingPathComponent("CoreDataStores")
 73:             let privateStoreFolderURL = storeFolderURL.appendingPathComponent("Private")
 74:             
 75:             let fileManager = FileManager.default
 76:             for folderURL in [privateStoreFolderURL] where !fileManager.fileExists(atPath: folderURL.path) {
 77:                 do {
 78:                     try fileManager.createDirectory(at: folderURL, withIntermediateDirectories: true, attributes: nil)
 79:                 } catch {
 80:                     fatalError("#\(#function): Failed to create the store folder: \(error)")
 81:                 }
 82:             }
 83:             
 84:             let cloudKitContainer = NSPersistentCloudKitContainer(name: "AppCoreData")
 85:             self.container = cloudKitContainer
 86:             
 87:             /**
 88:              Grab the default (first) store and associate it with the CloudKit private database.
 89:              Set up the store description by:
 90:              - Specifying a filename for the store.
 91:              - Enabling history tracking and remote notifications.
 92:              - Specifying the iCloud container and database scope.
 93:              */
 94:             guard let privateStoreDescription = self.container.persistentStoreDescriptions.first else {
 95:                 fatalError("#\(#function): Failed to retrieve a persistent store description.")
 96:             }
 97:             privateStoreDescription.url = privateStoreFolderURL.appendingPathComponent("private.sqlite")
 98:             
 99:             privateStoreDescription.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
100:             privateStoreDescription.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
101:             privateStoreDescription.setOption(true as NSNumber, forKey: NSMigratePersistentStoresAutomaticallyOption)
102:             privateStoreDescription.setOption(true as NSNumber, forKey: NSInferMappingModelAutomaticallyOption)
103:             
104:             let cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: CloudKitContainerIdentifier)
105:             
106:             cloudKitContainerOptions.databaseScope = .private
107:             privateStoreDescription.cloudKitContainerOptions = cloudKitContainerOptions
108:             
109:             /**
110:              Load the persistent stores.
111:              */
112:             self.container.loadPersistentStores(completionHandler: { (loadedStoreDescription, error) in
113:                 guard error == nil else {
114:                     fatalError("#\(#function): Failed to load persistent stores:\(error!)")
115:                 }
116:                 guard let cloudKitContainerOptions = loadedStoreDescription.cloudKitContainerOptions else {
117:                     return
118:                 }
119:                 if cloudKitContainerOptions.databaseScope == .private {
120:                     self._privatePersistentStore = self.container.persistentStoreCoordinator.persistentStore(for: loadedStoreDescription.url!)
121:                 }
122:             })
123:             
124:             /**
125:              Run initializeCloudKitSchema() once to update the CloudKit schema every time you change the Core Data model.
126:              Don't call this code in the production environment.
127:              */
128:             if InitializeCloudKitSchema {
129:                 do {
130:                     try cloudKitContainer.initializeCloudKitSchema()
131:                 } catch {
132:                     print("\(#function): initializeCloudKitSchema: \(error)")
133:                 }
134:             } else {
135:                 self.container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
136:                 self.container.viewContext.transactionAuthor = TransactionAuthor.app
137:                 
138:                 /**
139:                  Automatically merge the changes from other contexts.
140:                  */
141:                 self.container.viewContext.automaticallyMergesChangesFromParent = true
142:                 
143:                 /**
144:                  Pin the viewContext to the current generation token and set it to keep itself up-to-date with local changes.
145:                  */
146:                 do {
147:                     try self.container.viewContext.setQueryGenerationFrom(.current)
148:                 } catch {
149:                     fatalError("#\(#function): Failed to pin viewContext to the current generation:\(error)")
150:                 }
151:                 
152:                 /**
153:                  Observe the following notifications:
154:                  - The remote change notifications from container.persistentStoreCoordinator.
155:                  - The .NSManagedObjectContextDidSave notifications from any context.
156:                  - The event change notifications from the container.
157:                  */
158:                 NotificationCenter.default.addObserver(self, selector: #selector(self.storeRemoteChange(_:)),
159:                                                        name: .NSPersistentStoreRemoteChange,
160:                                                        object: self.container.persistentStoreCoordinator)
161:                 NotificationCenter.default.addObserver(self, selector: #selector(self.containerEventChanged(_:)),
162:                                                        name: NSPersistentCloudKitContainer.eventChangedNotification,
163:                                                        object: self.container)
164:             }
165:         }
166:     }
167:     
168:     private var _privatePersistentStore: NSPersistentStore?
169:     var privatePersistentStore: NSPersistentStore {
170:         return _privatePersistentStore!
171:     }
172:     
173:     lazy var cloudKitContainer: CKContainer = {
174:         return CKContainer(identifier: CloudKitContainerIdentifier)
175:     }()
176:         
177:     /**
178:      An operation queue for handling history-processing tasks: watching changes, deduplicating tags, and triggering UI updates, if needed.
179:      */
180:     lazy var historyQueue: OperationQueue = {
181:         let queue = OperationQueue()
182:         queue.maxConcurrentOperationCount = 1
183:         return queue
184:     }()
185: }
186: 
187: extension PersistenceController {
188:     /**
189:      Handle .NSPersistentStoreRemoteChange notifications.
190:      Process persistent history to merge relevant changes to the context, and deduplicate the tags, if necessary.
191:      */
192:     @objc
193:     func storeRemoteChange(_ notification: Notification) {
194:         guard let storeUUID = notification.userInfo?[NSStoreUUIDKey] as? String,
195:               [privatePersistentStore.identifier].contains(storeUUID) else {
196:             print("\(#function): Ignore a store remote Change notification because of no valid storeUUID.")
197:             return
198:         }
199: //        processHistoryAsynchronously(storeUUID: storeUUID)
200:     }
201: 
202:     /**
203:      Handle the container's event change notifications (NSPersistentCloudKitContainer.eventChangedNotification).
204:      */
205:     @objc
206:     func containerEventChanged(_ notification: Notification) {
207:          guard let value = notification.userInfo?[NSPersistentCloudKitContainer.eventNotificationUserInfoKey],
208:               let event = value as? NSPersistentCloudKitContainer.Event else {
209:             print("\(#function): Failed to retrieve the container event from notification.userInfo.")
210:             return
211:         }
212:         if event.error != nil {
213:             print("\(#function): Received a persistent CloudKit container event changed notification.\n\(event)")
214:         }
215:     }
216: }
```

## File: pdfexpert/Models/Persistence/CacheManager.swift
```swift
 1: //
 2: //  CacheManager.swift
 3: //  StoryKidsAI
 4: //
 5: //  Created by Pcnaid Inc on 22/03/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: protocol CacheManager {
11:     var onboardingShown: Bool { get set }
12:     var preReviewShown: Bool { get set }
13: }
```

## File: pdfexpert/Models/Persistence/CacheManagerImpl.swift
```swift
  1: //
  2: //  CacheManagerImpl.swift
  3: //  StoryKidsAI
  4: //
  5: //  Created by Pcnaid Inc on 22/03/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: 
 11: extension Container {
 12:     var cacheManager: Factory<CacheManager> {
 13:         self { CacheManagerImpl() }.singleton
 14:     }
 15: }
 16: 
 17: class CacheManagerImpl: CacheManager {
 18:     
 19:     enum CacheManagerKey: String {
 20:         case onboardingShown
 21:         case preReviewShown
 22:     }
 23:     
 24:     private let mainUserDefaults = UserDefaults.standard
 25:     
 26:     var onboardingShown: Bool {
 27:         get { self.getBool(forKey: CacheManagerKey.onboardingShown.rawValue) ?? false }
 28:         set { self.saveBool(newValue, forKey: CacheManagerKey.onboardingShown.rawValue) }
 29:     }
 30:     
 31:     var preReviewShown: Bool {
 32:         get { self.getBool(forKey: CacheManagerKey.preReviewShown.rawValue) ?? false }
 33:         set { self.saveBool(newValue, forKey: CacheManagerKey.preReviewShown.rawValue) }
 34:     }
 35:         
 36:     // MARK: - Private methods
 37:     
 38:     private func save<T>(encodable: T?, forKey key: String) where T: Encodable {
 39:         if let encodable = encodable {
 40:             let encoder = JSONEncoder()
 41:             if let encoded = try? encoder.encode(encodable) {
 42:                 self.mainUserDefaults.set(encoded, forKey: key)
 43:             }
 44:         } else {
 45:             self.reset(forKey: key)
 46:         }
 47:     }
 48:     
 49:     private func load<T>(forKey key: String) -> T? where T: Decodable {
 50:         if let encodedData = self.mainUserDefaults.object(forKey: key) as? Data {
 51:             let decoder = JSONDecoder()
 52:             if let object = try? decoder.decode(T.self, from: encodedData) {
 53:                 return object
 54:             }
 55:         }
 56:         return nil
 57:     }
 58:     
 59:     private func saveNSSecureCoding<T>(object: T?, forKey key: String) where T: NSSecureCoding {
 60:         if let object = object {
 61:             if let encoded = try? NSKeyedArchiver.archivedData(withRootObject: object, requiringSecureCoding: true) {
 62:                 self.mainUserDefaults.set(encoded, forKey: key)
 63:             }
 64:         } else {
 65:             self.reset(forKey: key)
 66:         }
 67:     }
 68:     
 69:     private func loadNSSecureCoding<T>(forKey key: String) -> T? where T: NSSecureCoding & NSObject {
 70:         if let encodedData = self.mainUserDefaults.object(forKey: key) as? Data {
 71:             return try? NSKeyedUnarchiver.unarchivedObject(ofClass: T.self, from: encodedData)
 72:         }
 73:         return nil
 74:     }
 75:     
 76:     private func saveData(_ value: Data?, forKey key: String) {
 77:         if let value = value {
 78:             self.mainUserDefaults.set(value, forKey: key)
 79:         } else {
 80:             self.reset(forKey: key)
 81:         }
 82:     }
 83:     
 84:     private func getData(forKey key: String) -> Data? {
 85:         return self.mainUserDefaults.data(forKey: key)
 86:     }
 87:     
 88:     private func saveString(_ value: String?, forKey key: String) {
 89:         if let value = value {
 90:             self.mainUserDefaults.set(value, forKey: key)
 91:         } else {
 92:             self.reset(forKey: key)
 93:         }
 94:     }
 95:     
 96:     private func getString(forKey key: String) -> String? {
 97:         return self.mainUserDefaults.string(forKey: key)
 98:     }
 99:     
100:     private func saveInteger(_ value: Int?, forKey key: String) {
101:         if let value = value {
102:             self.mainUserDefaults.set(value, forKey: key)
103:         } else {
104:             self.reset(forKey: key)
105:         }
106:     }
107:     
108:     private func getInteger(forKey key: String) -> Int? {
109:         if self.mainUserDefaults.object(forKey: key) != nil {
110:             return self.mainUserDefaults.integer(forKey: key)
111:         } else {
112:             return nil
113:         }
114:     }
115:     
116:     private func saveBool(_ value: Bool?, forKey key: String) {
117:         if let value = value {
118:             self.mainUserDefaults.set(value, forKey: key)
119:         } else {
120:             self.reset(forKey: key)
121:         }
122:     }
123:     
124:     private func getBool(forKey key: String) -> Bool? {
125:         if self.mainUserDefaults.object(forKey: key) != nil {
126:             return self.mainUserDefaults.bool(forKey: key)
127:         } else {
128:             return nil
129:         }
130:     }
131:     
132:     private func reset(forKey key: String) {
133:         self.mainUserDefaults.removeObject(forKey: key)
134:     }
135: }
```

## File: pdfexpert/Models/Persistence/Repository.swift
```swift
 1: //
 2: //  Repository.swift
 3: //  StoryKidsAI
 4: //
 5: //  Created by Pcnaid Inc on 27/03/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: protocol Repository {
11:     func savePdf(pdf: Pdf) throws -> Pdf
12:     func getDoPdfExist() throws -> Bool
13:     func loadPdfs() throws -> [Pdf]
14:     func delete(pdf: Pdf) throws
15:     
16:     func saveSignature(signature: Signature) throws -> Signature
17:     func getDoSignatureExist() throws -> Bool
18:     func loadSignatures() throws -> [Signature]
19:     func delete(signature: Signature) throws
20:     func delete(signatures: [Signature]) throws
21:     
22:     func saveSuggestedFields(suggestedFields: SuggestedFields) throws -> SuggestedFields
23:     func loadSuggestedFields() throws -> SuggestedFields?
24: }
```

## File: pdfexpert/Models/Persistence/RepositoryImpl.swift
```swift
  1: //
  2: //  RepositoryImpl.swift
  3: //  StoryKidsAI
  4: //
  5: //  Created by Pcnaid Inc on 27/03/23.
  6: //
  7: 
  8: import Foundation
  9: import CoreData
 10: import Factory
 11: import CloudKit
 12: 
 13: private let DiskFullErrorDomain: String = NSSQLiteErrorDomain
 14: private let DiskFullErrorCode: Int = 13
 15: 
 16: extension Container {
 17:     var repository: Factory<Repository> {
 18:         self { RepositoryImpl() }.singleton
 19:     }
 20: }
 21: 
 22: class RepositoryImpl: Repository {
 23:     
 24:     @Injected(\.persistence) var persistence
 25:     @Injected(\.analyticsManager) var analyticsMananger
 26:     
 27:     private var sharedManagedContext: NSManagedObjectContext {
 28:         return self.persistence.container.viewContext
 29:     }
 30:     
 31:     // MARK: - PDF
 32:     
 33:     func savePdf(pdf: Pdf) throws -> Pdf {
 34:         let pdf = try self.save(pdf)
 35:         self.analyticsMananger.track(event: .pdfSaved)
 36:         return pdf
 37:     }
 38:     
 39:     func getDoPdfExist() throws -> Bool {
 40:         return try self.getDoExist(forPersistableType: Pdf.self)
 41:     }
 42:     
 43:     func loadPdfs() throws -> [Pdf] {
 44:         return try self.loadItems()
 45:     }
 46:     
 47:     func delete(pdf: Pdf) throws {
 48:         try self.delete(pdf)
 49:         self.analyticsMananger.track(event: .existingPdfRemoved)
 50:     }
 51:     
 52:     // MARK: - Signature
 53:     
 54:     func saveSignature(signature: Signature) throws -> Signature {
 55:         let signature = try self.save(signature)
 56:         self.analyticsMananger.track(event: .signatureFileSaved)
 57:         return signature
 58:     }
 59:     
 60:     func getDoSignatureExist() throws -> Bool {
 61:         return try self.getDoExist(forPersistableType: Signature.self)
 62:     }
 63:     
 64:     func loadSignatures() throws -> [Signature] {
 65:         return try self.loadItems()
 66:     }
 67:     
 68:     func delete(signature: Signature) throws {
 69:         try self.delete(signature)
 70:         self.analyticsMananger.track(event: .signatureFileDeleted)
 71:     }
 72:     
 73:     func delete(signatures: [Signature]) throws {
 74:         for signature in signatures {
 75:             try self.delete(signature: signature)
 76:         }
 77:     }
 78:     
 79:     // MARK: - SuggestedFields
 80:     
 81:     func saveSuggestedFields(suggestedFields: SuggestedFields) throws -> SuggestedFields {
 82:         let suggestedFields = try self.save(suggestedFields)
 83:         self.analyticsMananger.track(event: .suggestedFieldsSaved)
 84:         return suggestedFields
 85:     }
 86:     
 87:     func loadSuggestedFields() throws -> SuggestedFields? {
 88:         return try self.loadItems(sortByCreationDate: false).first
 89:     }
 90:     
 91:     // MARK: - Private Methods
 92:     
 93:     private func save<T: Persistable>(_ persistable: T) throws -> T {
 94:         
 95:         guard let savedOrNewCoreDataEntity = persistable.getSavedOrNewCoreDataEntity(context: self.sharedManagedContext) else {
 96:             throw SaveError.unknownError
 97:         }
 98:         
 99:         try self.saveChanges()
100:         
101:         guard let updatedPersistable = T.create(withCoreDataEntity: savedOrNewCoreDataEntity) else {
102:             throw SaveError.unknownError
103:         }
104:         
105:         return updatedPersistable
106:     }
107:     
108:     private func getDoExist<T: Persistable>(forPersistableType type: T.Type) throws -> Bool {
109:         return try (self.loadItems() as [T]).count > 0
110:     }
111:     
112:     private func loadItems<T: Persistable>(sortByCreationDate: Bool = true) throws -> [T] {
113:         let fetchRequest = T.fetchRequest()
114:         if sortByCreationDate {
115:             fetchRequest.sortDescriptors = [NSSortDescriptor(key:"creationDate", ascending: false)]
116:         }
117:         do {
118:             return try self.persistence.container.viewContext
119:                 .fetch(fetchRequest)
120:                 .compactMap { coreDataEntity in
121:                     guard let item = T.create(withCoreDataEntity: coreDataEntity) else {
122:                         return nil
123:                     }
124:                     return item
125:                 }
126:         } catch {
127:             debugPrint(for: self, message: "Error while fetching items")
128:             throw SharedUnderlyingError.convertError(fromError: error)
129:         }
130:     }
131:     
132:     private func delete<T: Persistable>(_ persistable: T) throws {
133:         
134:         guard let storedSignature = persistable.getSavedCoreDataEntity(context: self.sharedManagedContext) else {
135:             debugPrint(for: self, message: "Current peristable instance doesn't exist in the persistent storage")
136:             return
137:         }
138:         self.persistence.container.viewContext.delete(storedSignature)
139:         try self.saveChanges()
140:     }
141:     
142:     private func saveChanges() throws {
143:         guard self.persistence.container.viewContext.hasChanges else {
144:             return
145:         }
146:         
147:         do {
148:             try self.persistence.container.viewContext.save()
149:         } catch let error as NSError {
150:             debugPrint(for: self, message: "Error while saving the story. Error: \(error.localizedDescription)")
151:             if error.domain == DiskFullErrorDomain, error.code == DiskFullErrorCode {
152:                 debugPrint(for: self, message: "Memory full error")
153:                 throw SaveError.diskFullError
154:             } else {
155:                 debugPrint(for: self, message: "Unhandled save error")
156:                 throw SaveError.convertError(fromError: error)
157:             }
158:         }
159:     }
160: }
161: 
162: enum SaveError: UnderlyingError {
163:     case unknownError
164:     case diskFullError
165:     case underlyingError(errorDescription: String)
166:     
167:     static func getUnknownError() -> Self { Self.unknownError }
168:     
169:     static func getUnderlyingError(errorDescription: String) -> Self {
170:         return .underlyingError(errorDescription: errorDescription)
171:     }
172: }
```

## File: pdfexpert/Models/AppTrackingTransparency.swift
```swift
 1: //
 2: //  AppTrackingTransparency.swift
 3: //  FourBooks
 4: //
 5: //  Created by Pcnaid Inc on 03/05/21.
 6: //  Copyright  2021 4Books. All rights reserved.
 7: //
 8: 
 9: import Foundation
10: import Factory
11: import AppTrackingTransparency
12: 
13: protocol AppTrackingTransparency : AnyObject {
14:     var serviceSupported: Bool { get }
15:     var permissionGranted: Bool? { get }
16:     func requestPermissionIfNeeded() async
17: }
18: 
19: extension Container {
20:     var appTrackingTransparancy: Factory<AppTrackingTransparency> {
21:         self { AppTrackingTransparencyImpl() }.singleton
22:     }
23: }
```

## File: pdfexpert/Models/AppTrackingTransparencyImpl.swift
```swift
 1: //
 2: //  AppTrackingTransparencyImpl.swift
 3: //  FourBooks
 4: //
 5: //  Created by Pcnaid Inc on 03/05/21.
 6: //  Copyright  2021 4Books. All rights reserved.
 7: //
 8: 
 9: import Foundation
10: import AppTrackingTransparency
11: #if FACEBOOK
12: import FacebookCore
13: #endif
14: import Factory
15: 
16: class AppTrackingTransparencyImpl: AppTrackingTransparency {
17:     
18:     var serviceSupported: Bool {
19:         if #available(iOS 14, *) {
20:             return true
21:         } else {
22:             return false
23:         }
24:     }
25:     
26:     var permissionGranted: Bool? {
27:         if #available(iOS 14, *) {
28:             return ATTrackingManager.trackingAuthorizationStatus.granted
29:         } else {
30:             return true
31:         }
32:     }
33:     
34:     @Injected(\.analyticsManager) var analyticsManager
35:     @Injected(\.attibutionManager) var attibutionManager
36:     
37:     init() {
38:         self.updateFacebookAdvertiseTrackingSettings()
39:     }
40:     
41:     func requestPermissionIfNeeded() async {
42:         if #available(iOS 14, *) {
43:             debugPrint(for: self, message: "Current Auth Status: \(ATTrackingManager.trackingAuthorizationStatus.rawValue)")
44:         }
45:         guard self.permissionGranted == nil else {
46:             return
47:         }
48:         if #available(iOS 14, *) {
49:             return await withCheckedContinuation({ continuation in
50:                 ATTrackingManager.requestTrackingAuthorization(completionHandler: { authorizationStatus in
51:                     self.updateFacebookAdvertiseTrackingSettings()
52:                     self.trackAuthorizationEvent(authorizationStatus: authorizationStatus)
53:                     continuation.resume()
54:                 })
55:             })
56:         } else {
57:             return
58:         }
59:     }
60:     
61:     private func updateFacebookAdvertiseTrackingSettings() {
62:                 let enableAdvertiserTracking = self.permissionGranted ?? false
63:                 #if FACEBOOK
64:        // Settings.shared.setAdvertiserTrackingEnabled(enableAdvertiserTracking)
65:                 debugPrint(for: self, message: "Facebook Advertiser Tracking Enabled set to: \(enableAdvertiserTracking)")
66:                 #endif
67:             }
68:     
69:     private func trackAuthorizationEvent(authorizationStatus: ATTrackingManager.AuthorizationStatus) {
70:         self.attibutionManager.onHandleATTAuthorizationStatus(authorizationStatus: authorizationStatus)
71:         switch authorizationStatus {
72:           case .authorized:
73:             debugPrint(for: self, message: "Authorization Granted")
74:             self.analyticsManager.track(event: .appTrackingTransparancyAuthorized)
75:           default:
76:             debugPrint(for: self, message: "Authorization not granted")
77:             break
78:           }
79:     }
80: }
81: 
82: @available(iOS 14.0, *)
83: extension ATTrackingManager.AuthorizationStatus {
84:     var granted: Bool? {
85:         switch self {
86:         case .authorized: return true
87:         case .notDetermined: return nil
88:         case .denied, .restricted: return false
89:         @unknown default: return false
90:         }
91:     }
92: }
```

## File: pdfexpert/Models/AttibutionManagerImpl.swift
```swift
 1: //
 2: //  AttibutionManagerImpl.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/09/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import BranchSDK
11: import UIKit
12: import AppTrackingTransparency
13: 
14: extension Container {
15:     var attibutionManager: Factory<AttributionManager> {
16:         self { AttributionManagerImpl() }.singleton
17:     }
18: }
19: 
20: class AttributionManagerImpl: AttributionManager {
21:     
22:     func onAppDidFinishLaunching(withLaunchOptions launchOptions:  [UIApplication.LaunchOptionsKey: Any]?) {
23:         #if STAGING
24:         Branch.setUseTestBranchKey(true)
25:         #endif
26: //        Branch.getInstance().enableLogging()
27: //        Branch.getInstance().validateSDKIntegration()
28:         Branch.getInstance().initSession(launchOptions: launchOptions) { (params, error) in
29:             print("AttributionManagerImpl - Deeplink detected. Parameters: \((params as? [String: AnyObject]) ?? [:])")
30:             // TODO: Implement Deeplink from here
31:         }
32:     }
33:     
34:     func onOpenUrl(url: URL) {
35:         Branch.getInstance().handleDeepLink(url)
36:     }
37:     
38:     func onHandleATTAuthorizationStatus(authorizationStatus: ATTrackingManager.AuthorizationStatus) {
39:         Branch.getInstance().handleATTAuthorizationStatus(authorizationStatus.rawValue)
40:     }
41: }
```

## File: pdfexpert/Models/AttributionManager.swift
```swift
 1: //
 2: //  AttributionManager.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/09/23.
 6: //
 7: 
 8: import Foundation
 9: import UIKit
10: import AppTrackingTransparency
11: 
12: protocol AttributionManager : AnyObject {
13:     func onAppDidFinishLaunching(withLaunchOptions launchOptions:  [UIApplication.LaunchOptionsKey: Any]?)
14:     func onOpenUrl(url: URL)
15:     func onHandleATTAuthorizationStatus(authorizationStatus: ATTrackingManager.AuthorizationStatus)
16: }
```

## File: pdfexpert/Models/ConfigService.swift
```swift
 1: //
 2: //  ConfigService.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 13/04/23.
 6: //
 7: 
 8: import Foundation
 9: import Combine
10: 
11: protocol ConfigService {
12:     func onApplicationDidBecomeActive()
13:     var remoteConfigData: CurrentValueSubject<RemoteConfigData, Never> { get }
14: }
```

## File: pdfexpert/Models/RemoteConfigManager.swift
```swift
  1: //
  2: //  RemoteConfigImpl.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 13/04/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import FirebaseRemoteConfig
 11: import Combine
 12: import CombineExt
 13: 
 14: struct RemoteConfigData {
 15:     let subcriptionViewType: SubscriptionViewType
 16:     
 17:     init(remoteConfig: RemoteConfig) {
 18:         let subscriptionViewTypeValue = remoteConfig.configValue(forKey: RemoteConfigKey.subcriptionViewType.rawValue).stringValue
 19:         self.subcriptionViewType = SubscriptionViewType.getSubscriptionViewType(forRemoteConfigValue: subscriptionViewTypeValue)
 20:     }
 21: }
 22: 
 23: extension Container {
 24:     var configService: Factory<ConfigService> {
 25:         self { RemoteConfigManager() }.singleton
 26:     }
 27: }
 28: 
 29: class RemoteConfigManager : ConfigService {
 30:     
 31:     lazy var remoteConfigData: CurrentValueSubject<RemoteConfigData, Never> = CurrentValueSubject<RemoteConfigData, Never>(RemoteConfigData(remoteConfig: self.remoteConfig))
 32:     
 33:     private var remoteConfigExpirationDuration: TimeInterval {
 34:         return self.isTestUser
 35:             ? K.RemoteConfigK.DebugRemoteConfigExpirationDuration
 36:             : K.RemoteConfigK.DefaultRemoteConfigExpirationDuration
 37:     }
 38:     
 39:     private var sharedFetchConfigRequest: AnyPublisher<RemoteConfigData, Never>?
 40:     private let remoteConfig: RemoteConfig
 41:     private var cancelBag = Set<AnyCancellable>()
 42:     private var isTestUser: Bool {
 43:         #if DEBUG
 44:         return true
 45:         #else
 46:         return false
 47:         #endif
 48:     }
 49:     
 50:     init() {
 51:         self.remoteConfig = RemoteConfig.remoteConfig()
 52:         self.remoteConfig.configSettings = RemoteConfigSettings()
 53:         self.remoteConfig.setDefaults(RemoteConfig.defaults)
 54:     }
 55:     
 56:     // MARK: - ConfigService
 57:     
 58:     func onApplicationDidBecomeActive() {
 59:         self.fetchConfig().sink(receiveValue: { _ in }).store(in: &self.cancelBag)
 60:     }
 61:     
 62:     // MARK: Private methods
 63:     
 64:     private func fetchConfig() -> AnyPublisher<RemoteConfigData, Never> {
 65:         print("RemoteConfigManager - fetchConfig started")
 66:         let sharedFetchConfigRequest: AnyPublisher<RemoteConfigData, Never> = {
 67:             if let sharedFetchConfigRequest = self.sharedFetchConfigRequest {
 68:                 print("RemoteConfigManager - returned cached instance")
 69:                 return sharedFetchConfigRequest
 70:             } else {
 71:                 print("RemoteConfigManager - returned new instance")
 72:                 return self.createFetchConfigRequest()
 73:             }
 74:         }()
 75:         self.sharedFetchConfigRequest = sharedFetchConfigRequest
 76:         return sharedFetchConfigRequest
 77:     }
 78:     
 79:     private func createFetchConfigRequest() -> AnyPublisher<RemoteConfigData, Never> {
 80:         return AnyPublisher<RemoteConfigData, Never>.create { subscriber in
 81:             let notifyRemoteConfig = {
 82:                 self.sharedFetchConfigRequest = nil
 83:                 let remoteConfigData = RemoteConfigData(remoteConfig: self.remoteConfig)
 84:                 self.remoteConfigData.send(remoteConfigData)
 85:                 subscriber.send(remoteConfigData)
 86:             }
 87:             self.remoteConfig
 88:                 .fetch(withExpirationDuration: self.remoteConfigExpirationDuration,
 89:                        completionHandler: { (status, error) in
 90:                         if status == .success {
 91:                             print("RemoteConfigManager - Config fetched!")
 92:                             self.remoteConfig.activate(completion: { (changed, error) in
 93:                                 if let error = error {
 94:                                     print("RemoteConfigManager - Config not activated. Error: '\(error.localizedDescription)'")
 95:                                 } else if changed {
 96:                                     print("RemoteConfigManager - Config activated with changes")
 97:                                 } else {
 98:                                     print("RemoteConfigManager - Config activated without changes")
 99:                                 }
100:                                 // Must run this on main thread (this completion block runs on a different thread... how cute...)
101:                                 DispatchQueue.main.async {
102:                                     notifyRemoteConfig()
103:                                 }
104:                             })
105:                         } else {
106:                             print("RemoteConfigManager - Config not fetched. Error: '\(error?.localizedDescription ?? "")'")
107:                             DispatchQueue.main.async {
108:                                 notifyRemoteConfig()
109:                             }
110:                         }
111:                 })
112:             return AnyCancellable {}
113:         }.share().eraseToAnyPublisher()
114:     }
115: }
116: 
117: fileprivate enum RemoteConfigKey : String, CaseIterable {
118:     case subcriptionViewType = "subscription_view_type"
119: }
120: 
121: fileprivate extension RemoteConfig {
122:     
123:     static var defaults: [String: NSObject] {
124:         var result: [String: NSObject] = [:]
125:         RemoteConfigKey.allCases.forEach { (key) in
126:             switch key {
127:             case .subcriptionViewType:
128:                 result[key.rawValue] = NSString(string: K.MonetizationK.defaultSubscriptionViewType.remoteConfigValue)
129:             }
130:         }
131:         return result
132:     }
133: }
134: 
135: fileprivate extension SubscriptionViewType {
136:     var remoteConfigValue: String {
137:         switch self {
138:         case .pairs: return "pairs"
139:         case .verticalHighlightLongPeriod: return "vertical"
140:         case .verticalHighlightShortPeriod: return "vertical_highlight_short_period"
141:         case .picker: return "picker"
142:         }
143:     }
144:     
145:     static func getSubscriptionViewType(forRemoteConfigValue remoteConfigValue: String?) -> Self {
146:         for type in Self.allCases {
147:             if type.remoteConfigValue == remoteConfigValue {
148:                 return type
149:             }
150:         }
151:         return K.MonetizationK.defaultSubscriptionViewType
152:     }
153: }
```

## File: pdfexpert/Models/Store.swift
```swift
 1: //
 2: //  Store.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 03/03/23.
 6: //
 7: 
 8: import Foundation
 9: import StoreKit
10: import Combine
11: 
12: protocol Store {
13:     var subscriptions: [Product] { get }
14:     var consumables: [Product] { get }
15:     var purchasedSubscriptions: [Product] { get }
16:     var subscriptionGroupStatus: RenewalState? { get }
17:     var isPremium: CurrentValueSubject<Bool, Never> { get }
18:     
19:     func refreshAll() async throws
20:     func requestProducts() async throws
21:     func purchase(_ product: Product) async throws -> Transaction?
22:     func isPurchased(_ product: Product) async throws -> Bool
23:     func checkVerified<T>(_ result: VerificationResult<T>) throws -> T
24:     func updateCustomerProductStatus() async
25:     func getProductData(forProductId productId: String) -> Any?
26:     func sortByPrice(_ products: [Product]) -> [Product]
27: }
```

## File: pdfexpert/Models/StoreImpl.swift
```swift
  1: /*
  2: See LICENSE folder for this samples licensing information.
  3: 
  4: Abstract:
  5: The store class is responsible for requesting products from the App Store and starting purchases.
  6: */
  7: 
  8: import Foundation
  9: import StoreKit
 10: import Combine
 11: import Factory
 12: 
 13: typealias Transaction = StoreKit.Transaction
 14: typealias RenewalInfo = StoreKit.Product.SubscriptionInfo.RenewalInfo
 15: typealias RenewalState = StoreKit.Product.SubscriptionInfo.RenewalState
 16: 
 17: public enum StoreError: Error {
 18:     case failedVerification
 19: }
 20: 
 21: //Define our app's subscription tiers by level of service, in ascending order.
 22: public enum SubscriptionTier: Int, Comparable {
 23:     case none = 0
 24:     case standard = 1
 25: 
 26:     public static func < (lhs: Self, rhs: Self) -> Bool {
 27:         return lhs.rawValue < rhs.rawValue
 28:     }
 29: }
 30: 
 31: extension Container {
 32:     var store: Factory<Store> {
 33:         self { StoreImpl() }.singleton
 34:     }
 35: }
 36: 
 37: class StoreImpl: Store {
 38: 
 39:     private(set) var subscriptions: [Product]
 40:     private(set) var consumables: [Product]
 41:     
 42:     private(set) var purchasedSubscriptions: [Product] = []
 43:     private(set) var subscriptionGroupStatus: RenewalState?
 44:     
 45:     var isPremium: CurrentValueSubject<Bool, Never> = CurrentValueSubject(false)
 46:     
 47:     var updateListenerTask: Task<Void, Error>? = nil
 48: 
 49:     private let productIdToProduct: [String: Any]
 50:     
 51:     @Injected(\.analyticsManager) var analyticsManager
 52: 
 53:     init() {
 54:         self.productIdToProduct = Self.loadProductIdToProductData().reduce([:], {
 55:             var result = $0
 56:             result[(Bundle.main.bundleIdentifier ?? "") + "." + $1.key] = $1.value
 57:             return result
 58:         })
 59: 
 60:         //Initialize empty products, and then do a product request asynchronously to fill them in.
 61:         self.subscriptions = []
 62:         self.consumables = []
 63: 
 64:         //Start a transaction listener as close to app launch as possible so you don't miss any transactions.
 65:         self.updateListenerTask = self.listenForTransactions()
 66: 
 67:         Task {
 68:             try await self.refreshAll()
 69: //            //During store initialization, request products from the App Store.
 70: //            try await requestProducts()
 71: //
 72: //            //Deliver products that the customer purchases.
 73: //            await updateCustomerProductStatus()
 74:         }
 75:     }
 76: 
 77:     deinit {
 78:         self.updateListenerTask?.cancel()
 79:     }
 80:     
 81:     static func loadProductIdToProductData() -> [String: Any] {
 82:         guard let path = Bundle.main.path(forResource: "Products", ofType: "plist"),
 83:               let plist = FileManager.default.contents(atPath: path),
 84:               let data = try? PropertyListSerialization.propertyList(from: plist, format: nil) as? [String: Any] else {
 85:             return [:]
 86:         }
 87:         return data
 88:     }
 89: 
 90:     func listenForTransactions() -> Task<Void, Error> {
 91:         return Task.detached {
 92:             //Iterate through any transactions that don't come from a direct call to `purchase()`.
 93:             for await result in Transaction.updates {
 94:                 do {
 95:                     let transaction = try self.checkVerified(result)
 96: 
 97:                     //Deliver products to the user.
 98:                     await self.updateCustomerProductStatus()
 99: 
100:                     //Always finish a transaction.
101:                     await transaction.finish()
102:                 } catch {
103:                     //StoreKit has a transaction that fails verification. Don't deliver content to the user.
104:                     print("Transaction failed verification")
105:                 }
106:             }
107:         }
108:     }
109:     
110:     func refreshAll() async throws {
111:         
112:         //During store initialization, request products from the App Store.
113:         try await self.requestProducts()
114: 
115:         //Deliver products that the customer purchases.
116:         await self.updateCustomerProductStatus()
117:     }
118: 
119:     @MainActor
120:     func requestProducts() async throws {
121:         do {
122:             //Request products from the App Store using the identifiers that the Products.plist file defines.
123:             let storeProducts = try await Product.products(for: self.productIdToProduct.keys)
124:             
125:             var newSubscriptions: [Product] = []
126:             var newConsumables: [Product] = []
127: 
128:             //Filter the products into categories based on their type.
129:             for product in storeProducts {
130:                 switch product.type {
131:                 case .consumable:
132:                     newConsumables.append(product)
133:                 case .nonConsumable:
134:                     debugPrint("Unexpected non consumable found")
135:                 case .autoRenewable:
136:                     newSubscriptions.append(product)
137:                 case .nonRenewable:
138:                     debugPrint("Unexpected non renewable found")
139:                 default:
140:                     //Ignore this product.
141:                     print("Unknown product")
142:                 }
143:             }
144: 
145:             //Sort each product category by price, lowest to highest, to update the store.
146:             self.consumables = self.sortByPrice(newConsumables)
147:             self.subscriptions = self.sortByPrice(newSubscriptions)
148:         } catch {
149:             print("Failed product request from the App Store server: \(error)")
150:             throw error
151:         }
152:     }
153: 
154:     @MainActor
155:     func purchase(_ product: Product) async throws -> Transaction? {
156:         //Begin purchasing the `Product` the user selects.
157:         let result = try await product.purchase()
158: 
159:         switch result {
160:         case .success(let verification):
161:             //Check whether the transaction is verified. If it isn't,
162:             //this function rethrows the verification error.
163:             let transaction = try self.checkVerified(verification)
164: 
165:             //The transaction is verified. Deliver content to the user.
166:             await self.updateCustomerProductStatus()
167: 
168:             //Always finish a transaction.
169:             await transaction.finish()
170:             
171:             // Sent custom method to analytics because free trials are not always automatically tracked
172:             // (e.g.: Firebase)
173:             self.analyticsManager.track(event: .checkoutCompleted(subscriptionPlanProduct: product))
174: 
175:             return transaction
176:         case .userCancelled, .pending:
177:             return nil
178:         default:
179:             return nil
180:         }
181:     }
182: 
183:     func isPurchased(_ product: Product) async throws -> Bool {
184:         //Determine whether the user purchases a given product.
185:         switch product.type {
186:         case .nonRenewable:
187:             debugPrint("Unexpected non renewable found")
188:             return false
189:         case .nonConsumable:
190:             debugPrint("Unexpected non consumable found")
191:             return false
192:         case .autoRenewable:
193:             return self.purchasedSubscriptions.contains(product)
194:         default:
195:             return false
196:         }
197:     }
198: 
199:     func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
200:         //Check whether the JWS passes StoreKit verification.
201:         switch result {
202:         case .unverified:
203:             //StoreKit parses the JWS, but it fails verification.
204:             throw StoreError.failedVerification
205:         case .verified(let safe):
206:             //The result is verified. Return the unwrapped value.
207:             return safe
208:         }
209:     }
210: 
211:     @MainActor
212:     func updateCustomerProductStatus() async {
213:         var purchasedSubscriptions: [Product] = []
214: 
215:         //Iterate through all of the user's purchased products.
216:         for await result in Transaction.currentEntitlements {
217:             do {
218:                 //Check whether the transaction is verified. If it isnt, catch `failedVerification` error.
219:                 let transaction = try self.checkVerified(result)
220: 
221:                 //Check the `productType` of the transaction and get the corresponding product from the store.
222:                 switch transaction.productType {
223:                 case .nonConsumable:
224:                     debugPrint("Unexpected non consumable found")
225:                 case .nonRenewable:
226:                     debugPrint("Unexpected non renewable found")
227:                 case .autoRenewable:
228:                     if let subscription = self.subscriptions.first(where: { $0.id == transaction.productID }) {
229:                         purchasedSubscriptions.append(subscription)
230:                     }
231:                 default:
232:                     break
233:                 }
234:             } catch {
235:                 print()
236:             }
237:         }
238: 
239:         //Update the store information with auto-renewable subscription products.
240:         self.purchasedSubscriptions = purchasedSubscriptions
241: 
242:         //Check the `subscriptionGroupStatus` to learn the auto-renewable subscription state to determine whether the customer
243:         //is new (never subscribed), active, or inactive (expired subscription). This app has only one subscription
244:         //group, so products in the subscriptions array all belong to the same group. The statuses that
245:         //`product.subscription.status` returns apply to the entire subscription group.
246:         self.subscriptionGroupStatus = try? await self.subscriptions.first?.subscription?.status.first?.state
247:         
248:         self.isPremium.send(Self.subscriptionStatusToIsPremium(subscriptionStatus: self.subscriptionGroupStatus))
249:     }
250: 
251:     func getProductData(forProductId productId: String) -> Any? {
252:         return self.productIdToProduct[productId]
253:     }
254: 
255:     func sortByPrice(_ products: [Product]) -> [Product] {
256:         products.sorted(by: { return $0.price < $1.price })
257:     }
258:     
259:     private static func subscriptionStatusToIsPremium(subscriptionStatus: RenewalState?) -> Bool {
260:         guard let state = subscriptionStatus else {
261:             return false
262:         }
263:         
264:         switch state {
265:         case .subscribed: return true
266:         case .expired: return false
267:         case .inBillingRetryPeriod: return true
268:         case .inGracePeriod: return true
269:         case .revoked: return false
270:         default:
271:             debugPrint("Unhandled RenewalState")
272:             return false
273:         }
274:     }
275: }
276: 
277: //fileprivate extension String {
278: //    func removeEnvironmentSuffix() -> String {
279: //        #if STAGING
280: //        self.replacingOccurrences(of: ".staging", with: "")
281: //        #else
282: //        self
283: //        #endif
284: //    }
285: //}
```

## File: pdfexpert/Preview Content/Preview Assets.xcassets/Contents.json
```json
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
```

## File: pdfexpert/Resources/Animations/loading.json
```json
1: {"v":"5.7.8","fr":29.9700012207031,"ip":0,"op":30.0000012219251,"w":500,"h":500,"nm":"Loading","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Shape Layer 4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":13,"s":[546,266,0],"to":[0,-11,0],"ti":[0,0,0]},{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":17,"s":[546,200,0],"to":[0,0,0],"ti":[0,-11,0]},{"t":21.0000008553475,"s":[546,266,0]}],"ix":2,"l":2,"x":"var $bm_rt;\nvar $bm_rt;\nvar n, n, t, t, v, amp, freq, decay;\n$bm_rt = $bm_rt = n = 0;\nif (numKeys > 0) {\n    $bm_rt = $bm_rt = n = nearestKey(time).index;\n    if (key(n).time > time) {\n        n--;\n    }\n}\nif (n == 0) {\n    $bm_rt = $bm_rt = t = 0;\n} else {\n    $bm_rt = $bm_rt = t = sub(time, key(n).time);\n}\nif (n > 0 && t < 1) {\n    v = velocityAtTime(sub(key(n).time, div(thisComp.frameDuration, 10)));\n    amp = 0.05;\n    freq = 4;\n    decay = 8;\n    $bm_rt = $bm_rt = add(value, div(mul(mul(v, amp), Math.sin(mul(mul(mul(freq, t), 2), Math.PI))), Math.exp(mul(decay, t))));\n} else {\n    $bm_rt = $bm_rt = value;\n}"},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[45.137,45.137],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[1,0.7490196078431373,0.24705882352941178,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":8,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.7490196078431373,0.24705882352941178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-167.432,-17.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":30.0000012219251,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"Shape Layer 3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":9,"s":[454,266,0],"to":[0,-11,0],"ti":[0,0,0]},{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":13,"s":[454,200,0],"to":[0,0,0],"ti":[0,-11,0]},{"t":17.0000006924242,"s":[454,266,0]}],"ix":2,"l":2,"x":"var $bm_rt;\nvar $bm_rt;\nvar n, n, t, t, v, amp, freq, decay;\n$bm_rt = $bm_rt = n = 0;\nif (numKeys > 0) {\n    $bm_rt = $bm_rt = n = nearestKey(time).index;\n    if (key(n).time > time) {\n        n--;\n    }\n}\nif (n == 0) {\n    $bm_rt = $bm_rt = t = 0;\n} else {\n    $bm_rt = $bm_rt = t = sub(time, key(n).time);\n}\nif (n > 0 && t < 1) {\n    v = velocityAtTime(sub(key(n).time, div(thisComp.frameDuration, 10)));\n    amp = 0.05;\n    freq = 4;\n    decay = 8;\n    $bm_rt = $bm_rt = add(value, div(mul(mul(v, amp), Math.sin(mul(mul(mul(freq, t), 2), Math.PI))), Math.exp(mul(decay, t))));\n} else {\n    $bm_rt = $bm_rt = value;\n}"},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[45.137,45.137],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[0.3568627450980392,0.7607843137254902,0.9058823529411765,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":8,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.3568627450980392,0.7607843137254902,0.9058823529411765,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-167.432,-17.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":30.0000012219251,"st":-359.00001462237,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"Shape Layer 2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":4,"s":[365,266,0],"to":[0,-11,0],"ti":[0,0,0]},{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":9,"s":[365,200,0],"to":[0,0,0],"ti":[0,-11,0]},{"t":13.0000005295009,"s":[365,266,0]}],"ix":2,"l":2,"x":"var $bm_rt;\nvar $bm_rt;\nvar n, n, t, t, v, amp, freq, decay;\n$bm_rt = $bm_rt = n = 0;\nif (numKeys > 0) {\n    $bm_rt = $bm_rt = n = nearestKey(time).index;\n    if (key(n).time > time) {\n        n--;\n    }\n}\nif (n == 0) {\n    $bm_rt = $bm_rt = t = 0;\n} else {\n    $bm_rt = $bm_rt = t = sub(time, key(n).time);\n}\nif (n > 0 && t < 1) {\n    v = velocityAtTime(sub(key(n).time, div(thisComp.frameDuration, 10)));\n    amp = 0.05;\n    freq = 4;\n    decay = 8;\n    $bm_rt = $bm_rt = add(value, div(mul(mul(v, amp), Math.sin(mul(mul(mul(freq, t), 2), Math.PI))), Math.exp(mul(decay, t))));\n} else {\n    $bm_rt = $bm_rt = value;\n}"},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[45.137,45.137],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[0,0.7019607843137254,0.5333333333333333,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":8,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.7019607843137254,0.5333333333333333,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-167.432,-17.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":30.0000012219251,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":4,"nm":"Shape Layer 1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":0,"s":[277,266,0],"to":[0,-11,0],"ti":[0,0,0]},{"i":{"x":0.833,"y":1},"o":{"x":0.167,"y":0},"t":4,"s":[277,200,0],"to":[0,0,0],"ti":[0,-11,0]},{"t":9.00000036657752,"s":[277,266,0]}],"ix":2,"l":2,"x":"var $bm_rt;\nvar $bm_rt;\nvar n, n, t, t, v, amp, freq, decay;\n$bm_rt = $bm_rt = n = 0;\nif (numKeys > 0) {\n    $bm_rt = $bm_rt = n = nearestKey(time).index;\n    if (key(n).time > time) {\n        n--;\n    }\n}\nif (n == 0) {\n    $bm_rt = $bm_rt = t = 0;\n} else {\n    $bm_rt = $bm_rt = t = sub(time, key(n).time);\n}\nif (n > 0 && t < 1) {\n    v = velocityAtTime(sub(key(n).time, div(thisComp.frameDuration, 10)));\n    amp = 0.05;\n    freq = 4;\n    decay = 8;\n    $bm_rt = $bm_rt = add(value, div(mul(mul(v, amp), Math.sin(mul(mul(mul(freq, t), 2), Math.PI))), Math.exp(mul(decay, t))));\n} else {\n    $bm_rt = $bm_rt = value;\n}"},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[45.137,45.137],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[0.06274509803921569,0.023529411764705882,0.6235294117647059,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":8,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.06274509803921569,0.023529411764705882,0.6235294117647059,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-167.432,-17.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":30.0000012219251,"st":0,"bm":0}],"markers":[]}
```

## File: pdfexpert/Resources/Animations/pdf-scanning.json
```json
1: {"nm":"pdf_scanning","mn":"","layers":[{"ty":4,"nm":"scanning","mn":"","sr":1,"st":-793.000032299552,"op":107.000004358199,"ip":-793.000032299552,"hd":false,"cl":"","ln":"","ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[93,93,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":1,"k":[{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[180.282,513.787,0],"t":0},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[180.282,93.787,0],"t":46},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[180.282,513.787,0],"t":99.0000040323527}],"ix":2},"sa":{"a":0,"k":0},"o":{"a":0,"k":38,"ix":11},"r":{"a":0,"k":0,"ix":10}},"ef":[],"shapes":[{"ty":"gr","bm":0,"cl":"","ln":"","hd":false,"mn":"ADBE Vector Group","nm":"Rectangle 1","ix":1,"cix":2,"np":3,"it":[{"ty":"rc","bm":0,"cl":"","ln":"","hd":false,"mn":"ADBE Vector Shape - Rect","nm":"Rectangle Path 1","d":1,"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"s":{"a":0,"k":[292,60],"ix":2}},{"ty":"st","bm":0,"cl":"","ln":"","hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":1,"lj":1,"ml":4,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"d":[],"c":{"a":0,"k":[0.2157,0.2627,0.6078],"ix":3}},{"ty":"fl","bm":0,"cl":"","ln":"","hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[1,0.7647,0.7647],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[122.837,53.333],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,-143],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]}],"ind":1},{"ty":2,"nm":"pdf_corner","mn":"","sr":1,"st":-781.000031810782,"op":106.000004317469,"ip":-781.000031810782,"hd":false,"cl":"","ln":"","ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[51.25,51.25,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":0,"k":[269.731,73.454,0],"ix":2},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10}},"ef":[],"refId":"image_0","ind":2},{"ty":2,"nm":"pdf_text","mn":"","sr":1,"st":-781.000031810782,"op":106.000004317469,"ip":-781.000031810782,"hd":false,"cl":"","ln":"","ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[80.824,28.018,0],"ix":1},"s":{"a":1,"k":[{"o":{"x":0.167,"y":0.167},"i":{"x":0.667,"y":1},"s":[25,25,100],"t":-20},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[117,117,100],"t":34.0000013848484}],"ix":6},"sk":{"a":0,"k":0},"p":{"a":0,"k":[187.968,212.08,0],"ix":2},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10}},"ef":[],"refId":"image_1","ind":3},{"ty":2,"nm":"pdf_line","mn":"","sr":1,"st":-781.000031810782,"op":106.000004317469,"ip":-781.000031810782,"hd":false,"cl":"","ln":"","ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[63,66,0],"ix":1},"s":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[25,25,100],"t":0},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[117,117,100],"t":54.0000021994651}],"ix":6},"sk":{"a":0,"k":0},"p":{"a":0,"k":[184.731,215.454,0],"ix":2},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10}},"ef":[],"refId":"image_2","ind":4},{"ty":2,"nm":"pdf_bg","mn":"","sr":1,"st":-781.000031810782,"op":106.000004317469,"ip":-781.000031810782,"hd":false,"cl":"","ln":"","ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[136.25,154.25,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":0,"k":[184.73,176.454,0],"ix":2},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10}},"ef":[],"refId":"image_3","ind":5}],"ddd":0,"h":360,"w":360,"meta":{"a":"akhtarzaman","k":"pdf scan scannning docs documents","d":"pdf_scanning_lottie_animation_create_by_akhtarzaman","g":"LottieFiles AE 3.1.1","tc":"#000000"},"v":"4.8.0","fr":29.9700012207031,"op":102.000004154545,"ip":0,"assets":[{"id":"image_0","u":"","e":1,"w":103,"h":103,"p":"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGcAAABnCAYAAAAdQVz5AAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAAEdUlEQVR4nO2bW2rkRhSG\/1Mkb4HMDjKPA77EZvBgP8QtEyZMCAkOSZ6rF5A9xEsYyAbUO0hW0Hbb2IwxHpswzOtkB5NnY5082Jq+6dKSSqpS1fnMb9xNI5f0ceocCRo3e7\/9DsFJFMB\/3u79GtteiLCMAgAGtAhyDwUwAAaD9e3eL7HtBQlTFDOQJmHot7siyBVUxnsiyBGy5AAiyAk+9ZyM6Le7P8cW1xY8eZXzCIkgi5TIAUSQPVTupjYX0tciqHMUZmfpwkAEdcwK29oMIqhTqskBRFCHVJcDiKCOqCcHEEEdUHQTWh5mfb17GFtYdxCsOEoXhCGCWkI1M\/MQTqCvX4gg09TvOQswRJBpmvWchTBYBBnEWOWkiCBzGJcDiCBTNJ\/WcpKA9ZUIaoTRnpOhSF+9+Cnu7nT8wsgoXRJ9tSOC6tBKz8lABNWgKzmACKpMl3IAEVQJxej8R1\/u\/BjbPvE+0HXlAAAIEEEr0MW0lhliEVSGlcpJEUHFtHwTWh5i6UF5WK2cFBGUjRNyABGURWsPPusEImgO6z1nKZzoy50f4nZPux9YG6ULk0BfPhdBzvScDIIX5LIcIHBB7vWc5ejL59\/HrV0Bh3FqWssP6TcBCnJ9W5shPEE9kgOEJqjCN9tcCfSb7TAE9axyHqEwBPVTDhCEoP7KAbwX1JNRuiAEfeGpoD7chJaGiPXF9qvY+NWxTL+3tRmI4J0gN59K1wzBL0HeVE6KT4K86DlLPQh+9KD+T2s5gQeCvNvW5um3IM\/lAH0W5GXPWU6iL7a\/i01dtK7wapQuib7Y6pegALa1OXolyNtprSD6vCeCQquclF4ICmQgyIw+33oZN7+E7RFq5aQ4LSikaS0v+nzzZdz0QrZB6JXzALkpKOSeMx9i5wSFOErnxzFBsq0t4JIgkZOBK4Kk5+SEKdHnm9\/GTS5uU2SULggDVgXJtlaCTUEyra2QBNBnFgRJz1k9+mzzIK55nWsh21olqFNBIqcy3QkSObXoRlAPv9nmSqDPNtoVpED4t81\/4DmtClLM+GB9Dup39KQlQdJzDEAtCVIEfDR90BBpQ5Bi4hvrG4MnIbCebERxVQl5KCQ4NnUwIa0gM4IIAE7XIzZxMGEKE0b7\/xwPmxxDAQAz\/ra\/KfgVcPMKUo+\/\/7J\/Oh6Gm\/UgSv+YrA8+APiq7oGEAohqbXHT+xyiI4PLEWapWUE0+0Kqp2UqVtDcEwICDa3v0z6HEz3Z2I\/LpEx9LHCyvn8Exh+rHkCoxWjwbjIs+9CSHAA4Wds\/BjAwvCBhnlJBmQ8+k8\/VIYNuW1mSkKJP1oq3uMzKAYDxVvSE7viYwF8bX5YwS24F5coBHgSpu\/vXAHQbqxI+MRq8Ox0uvlkoJ2Wy9s2QgdcAvjS8KGHKkqCV5ADA+Fn0VNH9EUiqqDUYo8H702H6cmU5KeNn0VPQ\/REpHIKlkkzDjNHBo6DKclLGW9ET3N0fIkFExBHkyYIxmGl08P50WFvOIuMo+gwf8YWp44VOdHP83\/8408U0NPbpmQAAAABJRU5ErkJggg=="},{"id":"image_1","u":"","e":1,"w":162,"h":57,"p":"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKIAAAA5CAYAAAC1U\/CbAAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAAFJ0lEQVR4nO2d7XHjNhCGn\/Xkv92BdRXYHRxdgZUKzFRwTgWn60DpQKogUgd0BSdXELmCSBVsfgCylRsJoG3hQwSeGc1YQ4hYmi+BxWIBCoCqjoApcEU41vbTASsR2QSs6yiqOgYeA5x6A6ww17gSkVWAOk6Cvd8TYJTQjA0wFZEOMEap6kbjs1LVif2nRMHWF4uNqs5UtY11fX2wNuXEDEDsHw9J\/zuwBCYhWxFVvQL+DXV+D1tghmkB1olsQFVvgZ+p6nfw5QK4TW0FcA\/8VNWpFUwIUl7nJfAN+EdNqxzSBXLRJKrXx\/gCuEltxR7fgJV9cofKd8w1jhPUneoB8NFdpLbgANdAN3AxXgN\/B+4BzoUnEVnlKEQwXdnQxQimB+gKFeMW+AtoAX7zFJ5jnOzPcIXxz0YYH+W65+92YhxFCvXcvYYSemDFs3tQ9q\/vva7ODbarTh3yERFJVrlnaD0JUN\/IOux9Q0azE9XbeOppTlTPlaq2qtr1vL4dGw0cylJP+Cpk3T6id80ishaRCaYFmff4yUPoG3RKRGQjIjMRaYAvmNBUHy6BhZbZTccX4g57w1rgjx7FJ2GtCYN96MbAHfDc4yc3fN4VOkuSD1ZEZIZxWl2Mz7mlsL5nQ78e4F5VQ0xBZk1yIQKIyCPw4ihySb7B2F68twc4J3fkFGQhRMvEc7yJYENwbA\/gE+MlZ+qOfJRshGhv0NZRZDAxxZ7uyFkN0j5LNkK0dI5jgxEivLojT55ikwimZEFuQnQFdC+jWRGP1nO8mFYxNyEWhU0J++EpliI5IjpViOmZ4vaN20h2JKUKMTF2Hn3hKHJTQvecmxAbxzFXnPHcmXqOD757zkaI9qn\/6iiyjmNJfGzWjetBG1TE4BDZCBG\/L9RFsCElneNYFWIM1CTAfvcUc\/lRQ2DtOJbTco4g+BJjg2OTGWaeYi+pk0Yj0OF4GNUkCK9DGqCqXcjzYx626aF7mVSIVoQd\/ife58yXwIjwfrLLRz\/V+R9UdWnT415J1jWrWXi+xi\/C3ZrgQfOeZQoD4P7XjPhoLaK+rfEYYwYmfafs2lTbk1SC0rI3QPMJsdGPr1sZ8ba3yoj+i6b2mYvI0AcppbLe\/+IT4lfC+w3HeCbMZklZcs4Z6B9ktv8li\/DNAZZAU1iXPPhYoeUZ+P3XCEDy8M0BfthVfqXhaxFjhK\/uAp9\/cywMl5MQn4DHAuKFx3C2iDF6h5Qj9xyEuGR\/w8ZyaRzHfJncZ08KIb5ghu0dsCjMD3ThGhQOvpfwCfGJzycbrO2ntKBtb9S\/RV0Xw46U+ITYFTpwiI0vTNXFMCIluYZviqFHHuayBPelCjE9voSOImaWqhATYn3De0eRrV2MP3iqEBPRMw+zmPS3KsR0dLgzkLZUIVZComYXXG8ycAmDlB05zKwUg+2OF\/gzmp5LC5vVFjESdoHYin5pdW1Ya\/KjCjEwdnP3CebVY32Sg\/8sMfGjds2BsN3wo\/30XRYxF5FiBij7VCGeEDtL0mDW5bjig4eY262Ni6QK8Y32g+9aGdnPLR\/fw7FoEUIV4j6pXhVcakb6\/6hCTMcWs1S2iLlkH3XUnIYlMKoifOOCfm9EqpyGJ8zLJ8clzZr04QL3fiquY2eFzQ53bREckjlGgE3iLHVXC5x2I1RVvdXDbwodXFDVca2nZqXmpeDZvbpNVRdHbE66K61Y424x7\/RogN2ezpMhdh9qYn1j\/OuI38MGM313dN1uTqgJU7WYSEFdRVmp7PgPOGNrjeW0wuYAAAAASUVORK5CYII="},{"id":"image_2","u":"","e":1,"w":126,"h":132,"p":"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH4AAACECAYAAABWKp\/3AAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAAA3klEQVR4nO3bsQ2AQAwEQZ6ILui\/SlPDRy+0MxVY2vS8Zua9yLlPH8AZwkcJHyV8lPBRwkcJHyV8lPBRwkcJDwAAAAAAAAAAsG35lm2yuYsSPkr4KOGjhI8SPkr4KOGjhI8SPkp4AAAAAAAAAACAbb5lo2zuooSPEj5K+Cjho4SPEj5K+Cjho4SPEh4AAAAAAAAAAGCbb9kom7so4aOEjxI+Svgo4aOEjxI+Svgo4aOEj1oz85w+AgAAAAAAAAAAfsu3bJTNXZTwUcJHCR8lfJTwUcJHCR8lfJTwUcJHfTZ1Ewb25QZeAAAAAElFTkSuQmCC"},{"id":"image_3","u":"","e":1,"w":273,"h":309,"p":"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAREAAAE1CAYAAADAqdSuAAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAAJN0lEQVR4nO3dPY9c5RXA8fNc32ArQsJpLKhwQeqhTBfnG2yTKB1LRxc3SBbVTZq0rhBSClwiuXG+wfobsHWKhAo6jORi1569T4pdv6zZ13tm5s6d+f2kI7BlL4+E9NeZt2dKJNUvuw\/jRnwa0XwSpf999ufBOZ7Hzfhn6brnYx+E08qQv1QfdHcjyv0osRMRHy\/2SHCu\/bhZ75Wuezb2QXjjWhGpD7q7UUoXEZ8t5zhwKSFZM1eKSO2623FQuijxt2UfCK5ASNbIpRGpX3WfRi2PImK2\/OPAlQnJmrgwIvXBP3Yj6sOI+GA1x4Fr2Y9bQjK2cyNSH3S7EfHt6o4Cg+zHrRCSEZ0Zkfqg260CwnTsFyEZza8iUr\/qPq197IWHMEyLkIzkVERq192uB\/F9eO8H0yQkI2je\/kV\/EF0ICNM1qwexV7vu9tgH2SavN5H6oLtbI\/475mFgQWwkK\/R6E+kjuhHPAYtkI1mhEnGyhVRbCBtnvxzGvfLQRrJMTUREH7E78jlgGWb1ZuzV+zaSZWoiIoqIsLmEZMlK\/bL7sDbx49gHgSXz0GZJmuMLhWDj2UiWpIk+PomoYcwWjJAsQdM31ZWGbBEhWbTm8j8Cm0ZIFqmJWIMl05iVT531QrIQTfQx9v9NY0aaOuvfE5IsD2fYckKSJSIgJCkiAhEhJMOJCLwmJEOICJwiJNclIvArQnIdIgJnEpKraiMiotaRjwHrqM76Nvbq\/c6nfy9gE4GLlJj1bW8juYCIwGWE5EIiAlchJOdqfHTGmCuOkJzJJgLXICS\/JiJwTUJymojAAELyhojAQEJyzKVExiSmhpDYRCBp20MiIrAA2xySJjyeMWYhU6PO+vZo60JiE4EFqhFbFxIRgQXbtpCICCzBNoVERGBJtiUkbfQRtYx9DNhMNWLW3zja6IuNbCKwfLP5jc3dSEQEVmNjQyIisDobGRIRgdXauJCICKzeRoVERGAcGxOSk4iM\/7kDY7ZwZvMb88mHxCYC45p8SEQExjfpkBxHZPStzpitn9m8mWZIbCKwPiYZEhGB9TK5kIgIrJ9JhaQZ\/6GgMeaMmb2cSEhsIrC+JhESEYH1tvYhERFYf2sdkjZqP\/YZgMvNXpaXa3lDmk0EpuNVSNZqIxERmJa1C4mIwPSsVUhEBKZpbUIiIjBdaxESEYFpGz0kIgLTN2pIRAQ2w2ghaSMial31fxZYgtmLWP0b0mwisFlehWRlG4mIwOZZaUiaiD5GvznBGLPoWVlIbCKwsVYTEhGBjbb8kIgIbLzlhkREYCssLySN51WN2ZZZTkhsIrBNlhASEYFts+CQiAhsowWGRERgWy0oJCIC22wBIWm8OGPMlk+ts8NESGwiQEQiJCcRGb2Fxpixp\/azwzi8dkiOI7IG5zfGrMH0MTvsrxcSD2eAd10rJCICnOXKIRER4DxXComIABe5NCQiAlzmwpCICHAV54ZERICrOjMkLiUyxlxnZodHp0NiEwGu61RIRAQY4jgku92tto8aZezjAFM0O3j\/4A82ESBFRIAUEQFSRARIEREgpY0+wsszwFA2ESBFRIAUEQFSRARIEREgpT3+Rx33FMBEleOISAgwRIlXm4iKAEMUz4kASSICpIgIkCIiQIqIACkiAqSICJAiIkBKG7Uf+wzAVJViEwFyRARIaV2xCgx1FDYRIElEgBQRAVJEBEhxKREw3NwmAiSJCJAiIkCKr4wAEuY2ESBHRIAUEQFS2ug9IwIMZxMBUkQESBERIEVEgBQRAVJEBEgRESCljfC9M8BwLiUChisezgBJIgKkiAiQIiJASus5VSDDJgKkiAiQIiJAiogAKa13vQODldefnSljHwWYpOLhDJAjIkCKiAApIgKkiAiQIiJAyvHXaHqFFxigzG0iQJKIACkiAqSICJBy\/JURvjMCGMRnZ4AkEQFSfAMekGITAVJEBEgRESBFRICU1j3NwFBHYRMBkkQESBERIKWNvvraGWCYMreJADkiAqSICJAiIkCKiAApIgKkiAiQ4lIiYLhiEwGS2j68YRUYzldGACkezgApIgKkiAiQIiJAiogAKa0XZoDB5jYRIElEgBQRAVJEBEgRESCljei9QAMMVGwiQI5LiYAUmwiQIiJAiogAKSICpIgIkCIiQIqIACkiAqS00Y99BGCyiu+dAVKKb8ADhivhOREgSUSAFBEBUkQESBERIOX4fSJengGGKDYRIElEgBQRAVJEBEhpwyfwgMHmNhEgR0SAFBEBUtqIiOo6EWCAo7lNBEgSESBFRIAUEQFSRARIEREgRUSAlDb6PqK4lQgYxiYCpIgIkCIiQIqIACmtz94BGTYRIEVEgBQRAVLaiIjwxAgwhG\/AA7KONxGrCDBIsYkAOSICpIgIkCIiQIqIACkiAqS0Ub3ACwzkzWZAlogAKSICpIgIkNJ6WhUYzmdngCQRAVJEBEhxsxkw3NwmAiSJCJAiIkCKiAApbT\/2CYDJKmETAZJEBEhpo4\/wRhFgmLlNBMgRESBFRIAUEQFSRARIEREgRUSAwWrTPBMRYLCjvn92\/GazMvZRgEkqx7e9P\/d+VWCIG0fNQRNN+c\/YBwGm6c7jr39q4yi+j8YuAlxPLfE0IqK58\/jr78c+DDA9JWIv4s1LvP8e7yjAFJWj5knESURKiSfjHgeYmP1Xj2KaiIg7333zKCJ+GPNEwHSUEg9f\/Xv7+jf76GqJb8c5EjAZJX44WTwi4q23vd95\/M2jKLYR4GKlj+7tX59623tfYneVhwGmpUY8vfP4zRYS8U5EPvrum72I+PsKzwRMxy83X9zaefc3z\/zUzE9\/+WKvRPxx+WcCpqJv4k8ni8YpZ36K96Q2+8s+FDANpcbnZwUk4oLP7\/68c\/\/24XsHexExW9K5gAmoNT7\/6J3nQd524SUAP+\/s3n7x3q2HNepnCz8ZsO5+qU3ZOW8DeeVKN4n8+OcvdkupDyPig0WcDFh35enNFwc7v3vy6Nmlf\/KqP\/LHv35xt5lHV4utBDZX\/aFG01308OVd177T7K2Y7ITNBDbFfo3y8DrxeGXwxYg\/7+zePvjNrZ2mxr1a+nsR5eOhPwsYQ3laS+zdqEdP7jz+1+ArQRZ2u2q917XPbv\/v\/UX9PGA5Xv7mt\/M7j79+vqif93\/qH3DNcSPSsgAAAABJRU5ErkJggg=="}]}
```

## File: pdfexpert/Resources/AppCoreData.xcdatamodeld/PdfExpert.xcdatamodel/contents
```
 1: <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
 2: <model type="com.apple.IDECoreDataModeler.DataModel" documentVersion="1.0" lastSavedToolsVersion="21754" systemVersion="22A380" minimumToolsVersion="Automatic" sourceLanguage="Swift" usedWithCloudKit="YES" userDefinedModelVersionIdentifier="">
 3:     <entity name="Pdf" representedClassName="CDPdf" syncable="YES">
 4:         <attribute name="compression" optional="YES" attributeType="Integer 32" defaultValueString="0" usesScalarValueType="YES"/>
 5:         <attribute name="creationDate" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
 6:         <attribute name="data" optional="YES" attributeType="Binary"/>
 7:         <attribute name="filename" optional="YES" attributeType="String"/>
 8:         <attribute name="margins" optional="YES" attributeType="Integer 32" defaultValueString="0" usesScalarValueType="YES"/>
 9:         <attribute name="password" optional="YES" attributeType="String"/>
10:     </entity>
11:     <entity name="Signature" representedClassName="CDSignature" syncable="YES">
12:         <attribute name="creationDate" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
13:         <attribute name="data" optional="YES" attributeType="Binary"/>
14:     </entity>
15:     <entity name="SuggestedFields" representedClassName="CDSuggestedFields" syncable="YES">
16:         <attribute name="address" optional="YES" attributeType="String"/>
17:         <attribute name="city" optional="YES" attributeType="String"/>
18:         <attribute name="country" optional="YES" attributeType="String"/>
19:         <attribute name="email" optional="YES" attributeType="String"/>
20:         <attribute name="firstName" optional="YES" attributeType="String"/>
21:         <attribute name="lastName" optional="YES" attributeType="String"/>
22:         <attribute name="phone" optional="YES" attributeType="String"/>
23:     </entity>
24: </model>
```

## File: pdfexpert/Resources/AppCoreData.xcdatamodeld/.xccurrentversion
```
1: <?xml version="1.0" encoding="UTF-8"?>
2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
3: <plist version="1.0">
4: <dict>
5: 	<key>_XCCurrentVersionName</key>
6: 	<string>PdfExpert.xcdatamodel</string>
7: </dict>
8: </plist>
```

## File: pdfexpert/Resources/Assets.xcassets/AccentColor.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0xF8",
 9:           "green" : "0x91",
10:           "red" : "0x3F"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Assets.xcassets/AppIcon.appiconset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "AtlasWorks - PDF App icon.png",
 5:       "idiom" : "universal",
 6:       "platform" : "ios",
 7:       "size" : "1024x1024"
 8:     }
 9:   ],
10:   "info" : {
11:     "author" : "xcode",
12:     "version" : 1
13:   }
14: }
```

## File: pdfexpert/Resources/Assets.xcassets/AppIconStaging.appiconset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "AtlasWorks - PDF App icon.png",
 5:       "idiom" : "universal",
 6:       "platform" : "ios",
 7:       "size" : "1024x1024"
 8:     }
 9:   ],
10:   "info" : {
11:     "author" : "xcode",
12:     "version" : 1
13:   }
14: }
```

## File: pdfexpert/Resources/Assets.xcassets/archive_empty.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "empty_archive.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "empty_archive@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "empty_archive@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/camera.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "camera.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "camera@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "camera@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/edit_add_file.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "edit_add_file.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "edit_add_file@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "edit_add_file@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/edit_add_text.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "edit_add_text.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "edit_add_text@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "edit_add_text@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/edit_compression.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "edit_compression.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "edit_compression@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "edit_compression@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/edit_fill_form.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "edit_fill_form.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "edit_fill_form@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "edit_fill_form@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/edit_margins.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "margins.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "margins@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "margins@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/edit_option_compress.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "edit_option_compress.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "edit_option_compress@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "edit_option_compress@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/edit_option_password_lock.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "edit_option_password_lock.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "edit_option_password_lock@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "edit_option_password_lock@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/edit_option_password_unlock.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "edit_option_password_unlock.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "edit_option_password_unlock@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "edit_option_password_unlock@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/edit_option_split.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "edit_option_split.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "edit_option_split@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "edit_option_split@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/edit_signature.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "edit_signature.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "edit_signature@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "edit_signature@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/file.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "file.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "file@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "file@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/gallery.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "gallery 1.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "gallery 1@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "gallery 1@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_add_password.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_add_password.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_add_password@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_add_password@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_add_text.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_add_text.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_add_text@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_add_text@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_create_pdf.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_create_pdf.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_create_pdf@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_create_pdf@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_excel_to_pdf.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_excel_to_pdf.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_excel_to_pdf@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_excel_to_pdf@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_file_source_dropbox.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_file_source_dropbox.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_file_source_dropbox@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_file_source_dropbox@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_file_source_files.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "file.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "file@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "file@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_file_source_google.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_file_source_google.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_file_source_google@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_file_source_google@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_file_source_icloud.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_file_source_icloud.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_file_source_icloud@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_file_source_icloud@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_fill_form.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_fill_form.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_fill_form@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_fill_form@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_image_to_pdf.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_image_to_pdf.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_image_to_pdf@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_image_to_pdf@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_import_pdf.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_import_pdf.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_import_pdf@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_import_pdf@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_merge.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_merge.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_merge@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_merge@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_power_to_pdf.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_power_to_pdf.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_power_to_pdf@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_power_to_pdf@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_read.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_read.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_read@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_read@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_remove_password.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_remove_password.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_remove_password@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_remove_password@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_scan.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_scan.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_scan@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_scan@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_sign.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_signature.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_signature@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_signature@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_split.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_split.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_split@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_split@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/home_word_to_pdf.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "home_word_to_pdf.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "home_word_to_pdf@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "home_word_to_pdf@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/import_tutorial_1.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "import_tutorial_1.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "import_tutorial_1@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "import_tutorial_1@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/import_tutorial_2.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "import_tutorial_2.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "import_tutorial_2@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "import_tutorial_2@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/import_tutorial_3.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "import_tutorial_3.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "import_tutorial_3@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "import_tutorial_3@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/info.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "info.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "info@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "info@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/logo_large.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "logo_large.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "logo_large@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "logo_large@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/manage_annotations.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "manage_annotations.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "manage_annotations@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "manage_annotations@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/manage_widget.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "manage_annotations.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "manage_annotations@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "manage_annotations@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/onboarding_chat_pdf.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "onboarding_chat_pdf.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "onboarding_chat_pdf@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "onboarding_chat_pdf@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/onboarding_convert.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "onboarding_tutorial_1.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "onboarding_tutorial_1@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "onboarding_tutorial_1@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/onboarding_password.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "onboarding_tutorial_4.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "onboarding_tutorial_4@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "onboarding_tutorial_4@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/onboarding_signature.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "onboarding_tutorial_2.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "onboarding_tutorial_2@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "onboarding_tutorial_2@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/page_selection.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "page_selection.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "page_selection@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "page_selection@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/password_entered.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "password_entered.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "password_entered@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "password_entered@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/password_missing.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "password_missing.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "password_missing@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "password_missing@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/review_low_rate.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "review_low_rate.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "review_low_rate@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "review_low_rate@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/scan.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "scan.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "scan@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "scan@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/settings.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "tab_settings.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "tab_settings@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "tab_settings@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/sign_drawing.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "sign_drawing.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "sign_drawing@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "sign_drawing@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/signature.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "signature.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "signature@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "signature@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/Subscription/subscription_feature_chat_pdf.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "subscription_feature_chat_pdf.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "subscription_feature_chat_pdf@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "subscription_feature_chat_pdf@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/Subscription/subscription_feature_convert.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "subscription_feature_convert.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "subscription_feature_convert@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "subscription_feature_convert@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/Subscription/subscription_feature_edit.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "subscription_feature_edit.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "subscription_feature_edit@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "subscription_feature_edit@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/Subscription/subscription_feature_password.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "subscription_feature_password.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "subscription_feature_password@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "subscription_feature_password@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/Subscription/subscription_feature_signature.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "subscription_feature_signature.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "subscription_feature_signature@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "subscription_feature_signature@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/Subscription/Contents.json
```json
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
```

## File: pdfexpert/Resources/Assets.xcassets/subscription_error.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "attention_icon.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "attention_icon@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "attention_icon@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   }
23: }
```

## File: pdfexpert/Resources/Assets.xcassets/suggested_fields.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "suggested_fields.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "suggested_fields@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "suggested_fields@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/tab_archive.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "tab_archive.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "tab_archive@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "tab_archive@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/tab_chat_pdf.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "tab_chat_pdf.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "tab_chat_pdf@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "tab_chat_pdf@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/tab_home.imageset/Contents.json
```json
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "tab_home.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "filename" : "tab_home@2x.png",
10:       "idiom" : "universal",
11:       "scale" : "2x"
12:     },
13:     {
14:       "filename" : "tab_home@3x.png",
15:       "idiom" : "universal",
16:       "scale" : "3x"
17:     }
18:   ],
19:   "info" : {
20:     "author" : "xcode",
21:     "version" : 1
22:   },
23:   "properties" : {
24:     "template-rendering-intent" : "template"
25:   }
26: }
```

## File: pdfexpert/Resources/Assets.xcassets/Contents.json
```json
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
```

## File: pdfexpert/Resources/Colors.xcassets/AppPrimary.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0xA3",
 9:           "green" : "0x50",
10:           "red" : "0x67"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Colors.xcassets/Extra.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0x00",
 9:           "green" : "0xC7",
10:           "red" : "0xFF"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Colors.xcassets/FourthText.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0x5A",
 9:           "green" : "0x5A",
10:           "red" : "0x5A"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Colors.xcassets/PrimaryBG.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0x15",
 9:           "green" : "0x13",
10:           "red" : "0x12"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Colors.xcassets/PrimaryText.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0xFF",
 9:           "green" : "0xFF",
10:           "red" : "0xFF"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Colors.xcassets/SecondaryBG.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0x26",
 9:           "green" : "0x24",
10:           "red" : "0x23"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Colors.xcassets/SecondaryText.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0xF8",
 9:           "green" : "0x91",
10:           "red" : "0x3F"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Colors.xcassets/Specific/ButtonGradientEnd.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0xF8",
 9:           "green" : "0x91",
10:           "red" : "0x3F"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Colors.xcassets/Specific/ButtonGradientStart.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0xE8",
 9:           "green" : "0xAB",
10:           "red" : "0x00"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Colors.xcassets/Specific/Contents.json
```json
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
```

## File: pdfexpert/Resources/Colors.xcassets/ThirdText.colorset/Contents.json
```json
 1: {
 2:   "colors" : [
 3:     {
 4:       "color" : {
 5:         "color-space" : "srgb",
 6:         "components" : {
 7:           "alpha" : "1.000",
 8:           "blue" : "0xB9",
 9:           "green" : "0xB9",
10:           "red" : "0xB9"
11:         }
12:       },
13:       "idiom" : "universal"
14:     }
15:   ],
16:   "info" : {
17:     "author" : "xcode",
18:     "version" : 1
19:   }
20: }
```

## File: pdfexpert/Resources/Colors.xcassets/Contents.json
```json
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
```

## File: pdfexpert/Resources/IAP/EmptyProducts.storekit
```
 1: {
 2:   "identifier" : "AF06D1DE",
 3:   "nonRenewingSubscriptions" : [
 4: 
 5:   ],
 6:   "products" : [
 7: 
 8:   ],
 9:   "settings" : {
10: 
11:   },
12:   "subscriptionGroups" : [
13: 
14:   ],
15:   "version" : {
16:     "major" : 2,
17:     "minor" : 0
18:   }
19: }
```

## File: pdfexpert/Resources/IAP/LocalProductionProducts.storekit
```
  1: {
  2:   "appPolicies" : {
  3:     "eula" : "",
  4:     "policies" : [
  5:       {
  6:         "locale" : "en_US",
  7:         "policyText" : "",
  8:         "policyURL" : ""
  9:       }
 10:     ]
 11:   },
 12:   "identifier" : "610606E8",
 13:   "nonRenewingSubscriptions" : [
 14: 
 15:   ],
 16:   "products" : [
 17: 
 18:   ],
 19:   "settings" : {
 20:     "_failTransactionsEnabled" : false,
 21:     "_locale" : "en_US",
 22:     "_storefront" : "USA",
 23:     "_storeKitErrors" : [
 24:       {
 25:         "current" : null,
 26:         "enabled" : false,
 27:         "name" : "Load Products"
 28:       },
 29:       {
 30:         "current" : null,
 31:         "enabled" : false,
 32:         "name" : "Purchase"
 33:       },
 34:       {
 35:         "current" : null,
 36:         "enabled" : false,
 37:         "name" : "Verification"
 38:       },
 39:       {
 40:         "current" : null,
 41:         "enabled" : false,
 42:         "name" : "App Store Sync"
 43:       },
 44:       {
 45:         "current" : null,
 46:         "enabled" : false,
 47:         "name" : "Subscription Status"
 48:       },
 49:       {
 50:         "current" : null,
 51:         "enabled" : false,
 52:         "name" : "App Transaction"
 53:       },
 54:       {
 55:         "current" : null,
 56:         "enabled" : false,
 57:         "name" : "Manage Subscriptions Sheet"
 58:       },
 59:       {
 60:         "current" : null,
 61:         "enabled" : false,
 62:         "name" : "Refund Request Sheet"
 63:       },
 64:       {
 65:         "current" : null,
 66:         "enabled" : false,
 67:         "name" : "Offer Code Redeem Sheet"
 68:       }
 69:     ]
 70:   },
 71:   "subscriptionGroups" : [
 72:     {
 73:       "id" : "21297792",
 74:       "localizations" : [
 75: 
 76:       ],
 77:       "name" : "Main",
 78:       "subscriptions" : [
 79:         {
 80:           "adHocOffers" : [
 81: 
 82:           ],
 83:           "codeOffers" : [
 84: 
 85:           ],
 86:           "displayPrice" : "4.99",
 87:           "familyShareable" : false,
 88:           "groupNumber" : 3,
 89:           "internalID" : "6447059846",
 90:           "introductoryOffer" : null,
 91:           "localizations" : [
 92:             {
 93:               "description" : "Unlimited access to all app features.",
 94:               "displayName" : "Unlimited access",
 95:               "locale" : "en_US"
 96:             }
 97:           ],
 98:           "productID" : "eu.balzo.pdfexpert.monthly",
 99:           "recurringSubscriptionPeriod" : "P1M",
100:           "referenceName" : "Monthly",
101:           "subscriptionGroupID" : "21297792",
102:           "type" : "RecurringSubscription",
103:           "winbackOffers" : [
104: 
105:           ]
106:         },
107:         {
108:           "adHocOffers" : [
109: 
110:           ],
111:           "codeOffers" : [
112: 
113:           ],
114:           "displayPrice" : "4.99",
115:           "familyShareable" : false,
116:           "groupNumber" : 4,
117:           "internalID" : "6447059881",
118:           "introductoryOffer" : {
119:             "internalID" : "5AC93103",
120:             "numberOfPeriods" : 1,
121:             "paymentMode" : "free",
122:             "subscriptionPeriod" : "P1W"
123:           },
124:           "localizations" : [
125:             {
126:               "description" : "Unlimited access to all app features.",
127:               "displayName" : "Unlimited access",
128:               "locale" : "en_US"
129:             }
130:           ],
131:           "productID" : "eu.balzo.pdfexpert.monthly.freetrial",
132:           "recurringSubscriptionPeriod" : "P1M",
133:           "referenceName" : "Monthly Free Trial",
134:           "subscriptionGroupID" : "21297792",
135:           "type" : "RecurringSubscription",
136:           "winbackOffers" : [
137: 
138:           ]
139:         },
140:         {
141:           "adHocOffers" : [
142: 
143:           ],
144:           "codeOffers" : [
145: 
146:           ],
147:           "displayPrice" : "1.99",
148:           "familyShareable" : false,
149:           "groupNumber" : 5,
150:           "internalID" : "6447692196",
151:           "introductoryOffer" : null,
152:           "localizations" : [
153:             {
154:               "description" : "Unlimited access to all app features.",
155:               "displayName" : "Unlimited access",
156:               "locale" : "en_US"
157:             }
158:           ],
159:           "productID" : "eu.balzo.pdfexpert.weekly",
160:           "recurringSubscriptionPeriod" : "P1W",
161:           "referenceName" : "Weekly",
162:           "subscriptionGroupID" : "21297792",
163:           "type" : "RecurringSubscription",
164:           "winbackOffers" : [
165: 
166:           ]
167:         },
168:         {
169:           "adHocOffers" : [
170: 
171:           ],
172:           "codeOffers" : [
173: 
174:           ],
175:           "displayPrice" : "19.99",
176:           "familyShareable" : false,
177:           "groupNumber" : 1,
178:           "internalID" : "6447059590",
179:           "introductoryOffer" : null,
180:           "localizations" : [
181:             {
182:               "description" : "Unlimited access to all app features.",
183:               "displayName" : "Unlimited access",
184:               "locale" : "en_US"
185:             }
186:           ],
187:           "productID" : "eu.balzo.pdfexpert.yearly",
188:           "recurringSubscriptionPeriod" : "P1Y",
189:           "referenceName" : "Yearly",
190:           "subscriptionGroupID" : "21297792",
191:           "type" : "RecurringSubscription",
192:           "winbackOffers" : [
193: 
194:           ]
195:         },
196:         {
197:           "adHocOffers" : [
198: 
199:           ],
200:           "codeOffers" : [
201: 
202:           ],
203:           "displayPrice" : "19.99",
204:           "familyShareable" : false,
205:           "groupNumber" : 2,
206:           "internalID" : "6447059831",
207:           "introductoryOffer" : {
208:             "internalID" : "D369907B",
209:             "numberOfPeriods" : 1,
210:             "paymentMode" : "free",
211:             "subscriptionPeriod" : "P1W"
212:           },
213:           "localizations" : [
214:             {
215:               "description" : "Unlimited access to all app features.",
216:               "displayName" : "Unlimited Access",
217:               "locale" : "en_US"
218:             }
219:           ],
220:           "productID" : "eu.balzo.pdfexpert.yearly.freetrial",
221:           "recurringSubscriptionPeriod" : "P1Y",
222:           "referenceName" : "Yearly Free Trial",
223:           "subscriptionGroupID" : "21297792",
224:           "type" : "RecurringSubscription",
225:           "winbackOffers" : [
226: 
227:           ]
228:         }
229:       ]
230:     }
231:   ],
232:   "version" : {
233:     "major" : 4,
234:     "minor" : 0
235:   }
236: }
```

## File: pdfexpert/Resources/IAP/LocalStagingProducts.storekit
```
  1: {
  2:   "appPolicies" : {
  3:     "eula" : "",
  4:     "policies" : [
  5:       {
  6:         "locale" : "en_US",
  7:         "policyText" : "",
  8:         "policyURL" : ""
  9:       }
 10:     ]
 11:   },
 12:   "identifier" : "4F24126A",
 13:   "nonRenewingSubscriptions" : [
 14: 
 15:   ],
 16:   "products" : [
 17: 
 18:   ],
 19:   "settings" : {
 20:     "_failTransactionsEnabled" : false,
 21:     "_locale" : "en_US",
 22:     "_storefront" : "USA",
 23:     "_storeKitErrors" : [
 24:       {
 25:         "current" : {
 26:           "index" : 2,
 27:           "type" : "generic"
 28:         },
 29:         "enabled" : false,
 30:         "name" : "Load Products"
 31:       },
 32:       {
 33:         "current" : null,
 34:         "enabled" : false,
 35:         "name" : "Purchase"
 36:       },
 37:       {
 38:         "current" : null,
 39:         "enabled" : false,
 40:         "name" : "Verification"
 41:       },
 42:       {
 43:         "current" : null,
 44:         "enabled" : false,
 45:         "name" : "App Store Sync"
 46:       },
 47:       {
 48:         "current" : null,
 49:         "enabled" : false,
 50:         "name" : "Subscription Status"
 51:       },
 52:       {
 53:         "current" : null,
 54:         "enabled" : false,
 55:         "name" : "App Transaction"
 56:       },
 57:       {
 58:         "current" : null,
 59:         "enabled" : false,
 60:         "name" : "Manage Subscriptions Sheet"
 61:       },
 62:       {
 63:         "current" : null,
 64:         "enabled" : false,
 65:         "name" : "Refund Request Sheet"
 66:       },
 67:       {
 68:         "current" : null,
 69:         "enabled" : false,
 70:         "name" : "Offer Code Redeem Sheet"
 71:       }
 72:     ]
 73:   },
 74:   "subscriptionGroups" : [
 75:     {
 76:       "id" : "21342828",
 77:       "localizations" : [
 78: 
 79:       ],
 80:       "name" : "Main",
 81:       "subscriptions" : [
 82:         {
 83:           "adHocOffers" : [
 84: 
 85:           ],
 86:           "codeOffers" : [
 87: 
 88:           ],
 89:           "displayPrice" : "4.99",
 90:           "familyShareable" : false,
 91:           "groupNumber" : 1,
 92:           "internalID" : "6449435879",
 93:           "introductoryOffer" : null,
 94:           "localizations" : [
 95: 
 96:           ],
 97:           "productID" : "eu.balzo.pdfexpert.staging.monthly",
 98:           "recurringSubscriptionPeriod" : "P1M",
 99:           "referenceName" : "Monthly",
100:           "subscriptionGroupID" : "21342828",
101:           "type" : "RecurringSubscription",
102:           "winbackOffers" : [
103: 
104:           ]
105:         },
106:         {
107:           "adHocOffers" : [
108: 
109:           ],
110:           "codeOffers" : [
111: 
112:           ],
113:           "displayPrice" : "4.99",
114:           "familyShareable" : false,
115:           "groupNumber" : 5,
116:           "internalID" : "6449436432",
117:           "introductoryOffer" : {
118:             "internalID" : "D91BFEE9",
119:             "numberOfPeriods" : 1,
120:             "paymentMode" : "free",
121:             "subscriptionPeriod" : "P1W"
122:           },
123:           "localizations" : [
124: 
125:           ],
126:           "productID" : "eu.balzo.pdfexpert.staging.monthly.freetrial",
127:           "recurringSubscriptionPeriod" : "P1M",
128:           "referenceName" : "Monthly Free Trial",
129:           "subscriptionGroupID" : "21342828",
130:           "type" : "RecurringSubscription",
131:           "winbackOffers" : [
132: 
133:           ]
134:         },
135:         {
136:           "adHocOffers" : [
137: 
138:           ],
139:           "codeOffers" : [
140: 
141:           ],
142:           "displayPrice" : "1.99",
143:           "familyShareable" : false,
144:           "groupNumber" : 2,
145:           "internalID" : "6449436136",
146:           "introductoryOffer" : null,
147:           "localizations" : [
148: 
149:           ],
150:           "productID" : "eu.balzo.pdfexpert.staging.weekly",
151:           "recurringSubscriptionPeriod" : "P1W",
152:           "referenceName" : "Weekly",
153:           "subscriptionGroupID" : "21342828",
154:           "type" : "RecurringSubscription",
155:           "winbackOffers" : [
156: 
157:           ]
158:         },
159:         {
160:           "adHocOffers" : [
161: 
162:           ],
163:           "codeOffers" : [
164: 
165:           ],
166:           "displayPrice" : "19.99",
167:           "familyShareable" : false,
168:           "groupNumber" : 3,
169:           "internalID" : "6449436141",
170:           "introductoryOffer" : null,
171:           "localizations" : [
172: 
173:           ],
174:           "productID" : "eu.balzo.pdfexpert.staging.yearly",
175:           "recurringSubscriptionPeriod" : "P1Y",
176:           "referenceName" : "Yearly",
177:           "subscriptionGroupID" : "21342828",
178:           "type" : "RecurringSubscription",
179:           "winbackOffers" : [
180: 
181:           ]
182:         },
183:         {
184:           "adHocOffers" : [
185: 
186:           ],
187:           "codeOffers" : [
188: 
189:           ],
190:           "displayPrice" : "19.99",
191:           "familyShareable" : false,
192:           "groupNumber" : 4,
193:           "internalID" : "6449436302",
194:           "introductoryOffer" : {
195:             "internalID" : "6D245617",
196:             "numberOfPeriods" : 1,
197:             "paymentMode" : "free",
198:             "subscriptionPeriod" : "P1W"
199:           },
200:           "localizations" : [
201: 
202:           ],
203:           "productID" : "eu.balzo.pdfexpert.staging.yearly.freetrial",
204:           "recurringSubscriptionPeriod" : "P1Y",
205:           "referenceName" : "Yearly Free Trial",
206:           "subscriptionGroupID" : "21342828",
207:           "type" : "RecurringSubscription",
208:           "winbackOffers" : [
209: 
210:           ]
211:         }
212:       ]
213:     }
214:   ],
215:   "version" : {
216:     "major" : 4,
217:     "minor" : 0
218:   }
219: }
```

## File: pdfexpert/Resources/IAP/ProductionProducts.storekit
```
  1: {
  2:   "appPolicies" : {
  3:     "eula" : "",
  4:     "policies" : [
  5:       {
  6:         "locale" : "en_US",
  7:         "policyText" : "",
  8:         "policyURL" : ""
  9:       }
 10:     ]
 11:   },
 12:   "identifier" : "4215B0B5",
 13:   "nonRenewingSubscriptions" : [
 14: 
 15:   ],
 16:   "products" : [
 17: 
 18:   ],
 19:   "settings" : {
 20:     "_applicationInternalID" : "6744288931",
 21:     "_developerTeamID" : "KQM6GWHKY3",
 22:     "_failTransactionsEnabled" : false,
 23:     "_lastSynchronizedDate" : 706463782.07062304,
 24:     "_locale" : "en_US",
 25:     "_storefront" : "USA",
 26:     "_storeKitErrors" : [
 27:       {
 28:         "current" : null,
 29:         "enabled" : false,
 30:         "name" : "Load Products"
 31:       },
 32:       {
 33:         "current" : null,
 34:         "enabled" : false,
 35:         "name" : "Purchase"
 36:       },
 37:       {
 38:         "current" : null,
 39:         "enabled" : false,
 40:         "name" : "Verification"
 41:       },
 42:       {
 43:         "current" : null,
 44:         "enabled" : false,
 45:         "name" : "App Store Sync"
 46:       },
 47:       {
 48:         "current" : {
 49:           "index" : 2,
 50:           "type" : "generic"
 51:         },
 52:         "enabled" : false,
 53:         "name" : "Subscription Status"
 54:       },
 55:       {
 56:         "current" : null,
 57:         "enabled" : false,
 58:         "name" : "App Transaction"
 59:       },
 60:       {
 61:         "current" : null,
 62:         "enabled" : false,
 63:         "name" : "Manage Subscriptions Sheet"
 64:       },
 65:       {
 66:         "current" : null,
 67:         "enabled" : false,
 68:         "name" : "Refund Request Sheet"
 69:       },
 70:       {
 71:         "current" : null,
 72:         "enabled" : false,
 73:         "name" : "Offer Code Redeem Sheet"
 74:       }
 75:     ]
 76:   },
 77:   "subscriptionGroups" : [
 78:     {
 79:       "id" : "21667229",
 80:       "localizations" : [
 81: 
 82:       ],
 83:       "name" : "Main",
 84:       "subscriptions" : [
 85:         {
 86:           "adHocOffers" : [
 87: 
 88:           ],
 89:           "codeOffers" : [
 90: 
 91:           ],
 92:           "displayPrice" : "12.99",
 93:           "familyShareable" : false,
 94:           "groupNumber" : 2,
 95:           "internalID" : "6744569812",
 96:           "introductoryOffer" : null,
 97:           "localizations" : [
 98:             {
 99:               "description" : "Unlimited access to all app features.",
100:               "displayName" : "Unlimited access",
101:               "locale" : "en_US"
102:             }
103:           ],
104:           "productID" : "com.pcnaid.pdfexpert.monthly",
105:           "recurringSubscriptionPeriod" : "P1M",
106:           "referenceName" : "Monthly",
107:           "subscriptionGroupID" : "21667229",
108:           "type" : "RecurringSubscription",
109:           "winbackOffers" : [
110: 
111:           ]
112:         },
113:         {
114:           "adHocOffers" : [
115: 
116:           ],
117:           "codeOffers" : [
118: 
119:           ],
120:           "displayPrice" : "12.99",
121:           "familyShareable" : false,
122:           "groupNumber" : 3,
123:           "internalID" : "6744569730",
124:           "introductoryOffer" : {
125:             "internalID" : "6744569730",
126:             "numberOfPeriods" : 1,
127:             "paymentMode" : "free",
128:             "subscriptionPeriod" : "P1W"
129:           },
130:           "localizations" : [
131:             {
132:               "description" : "Unlimited access to all app features.",
133:               "displayName" : "Unlimited access",
134:               "locale" : "en_US"
135:             }
136:           ],
137:           "productID" : "com.pcnaid.pdfexpert.monthly.freetrial",
138:           "recurringSubscriptionPeriod" : "P1M",
139:           "referenceName" : "Monthly Free Trial",
140:           "subscriptionGroupID" : "21667229",
141:           "type" : "RecurringSubscription",
142:           "winbackOffers" : [
143: 
144:           ]
145:         },
146:         {
147:           "adHocOffers" : [
148: 
149:           ],
150:           "codeOffers" : [
151: 
152:           ],
153:           "displayPrice" : "3.99",
154:           "familyShareable" : false,
155:           "groupNumber" : 1,
156:           "internalID" : "6744569786",
157:           "introductoryOffer" : null,
158:           "localizations" : [
159:             {
160:               "description" : "Unlimited access to all app features.",
161:               "displayName" : "Unlimited access",
162:               "locale" : "en_US"
163:             }
164:           ],
165:           "productID" : "com.pcnaid.pdfexpert.weekly",
166:           "recurringSubscriptionPeriod" : "P1W",
167:           "referenceName" : "Weekly",
168:           "subscriptionGroupID" : "21667229",
169:           "type" : "RecurringSubscription",
170:           "winbackOffers" : [
171: 
172:           ]
173:         },
174:         {
175:           "adHocOffers" : [
176: 
177:           ],
178:           "codeOffers" : [
179: 
180:           ],
181:           "displayPrice" : "89.99",
182:           "familyShareable" : false,
183:           "groupNumber" : 4,
184:           "internalID" : "6744569681",
185:           "introductoryOffer" : null,
186:           "localizations" : [
187:             {
188:               "description" : "Unlimited access to all app features.",
189:               "displayName" : "Unlimited access",
190:               "locale" : "en_US"
191:             }
192:           ],
193:           "productID" : "com.pcnaid.pdfexpert.yearly",
194:           "recurringSubscriptionPeriod" : "P1Y",
195:           "referenceName" : "Yearly",
196:           "subscriptionGroupID" : "21667229",
197:           "type" : "RecurringSubscription",
198:           "winbackOffers" : [
199: 
200:           ]
201:         },
202:         {
203:           "adHocOffers" : [
204: 
205:           ],
206:           "codeOffers" : [
207: 
208:           ],
209:           "displayPrice" : "89.99",
210:           "familyShareable" : false,
211:           "groupNumber" : 5,
212:           "internalID" : "6744569907",
213:           "introductoryOffer" : {
214:             "internalID" : "6744569907",
215:             "numberOfPeriods" : 1,
216:             "paymentMode" : "free",
217:             "subscriptionPeriod" : "P1W"
218:           },
219:           "localizations" : [
220:             {
221:               "description" : "Unlimited access to all app features.",
222:               "displayName" : "Unlimited Access",
223:               "locale" : "en_US"
224:             }
225:           ],
226:           "productID" : "com.pcnaid.pdfexpert.yearly.freetrial",
227:           "recurringSubscriptionPeriod" : "P1Y",
228:           "referenceName" : "Yearly Free Trial",
229:           "subscriptionGroupID" : "21667229",
230:           "type" : "RecurringSubscription",
231:           "winbackOffers" : [
232: 
233:           ]
234:         }
235:       ]
236:     }
237:   ],
238:   "version" : {
239:     "major" : 4,
240:     "minor" : 0
241:   }
242: }
```

## File: pdfexpert/Resources/IAP/Products.plist
```
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5: 	<key>yearly</key>
 6: 	<dict>
 7: 		<key>name</key>
 8: 		<string>standard_subscription</string>
 9: 		<key>views</key>
10: 		<array>
11: 			<string>pairs</string>
12: 			<string>picker</string>
13: 		</array>
14: 	</dict>
15: 	<key>yearly.freetrial</key>
16: 	<dict>
17: 		<key>name</key>
18: 		<string>standard_subscription</string>
19: 		<key>views</key>
20: 		<array>
21: 			<string>pairs</string>
22: 			<string>vertical</string>
23: 			<string>picker</string>
24: 		</array>
25: 	</dict>
26: 	<key>monthly</key>
27: 	<dict>
28: 		<key>name</key>
29: 		<string>standard_subscription</string>
30: 		<key>views</key>
31: 		<array>
32: 			<string>pairs</string>
33: 			<string>vertical</string>
34: 		</array>
35: 	</dict>
36: 	<key>monthly.freetrial</key>
37: 	<dict>
38: 		<key>name</key>
39: 		<string>standard_subscription</string>
40: 		<key>views</key>
41: 		<array>
42: 			<string>pairs</string>
43: 		</array>
44: 	</dict>
45: 	<key>weekly</key>
46: 	<dict>
47: 		<key>name</key>
48: 		<string>standard_subscription</string>
49: 		<key>views</key>
50: 		<array>
51: 			<string>vertical</string>
52: 			<string>picker</string>
53: 		</array>
54: 	</dict>
55: </dict>
56: </plist>
```

## File: pdfexpert/Resources/IAP/StagingProducts.storekit
```
  1: {
  2:   "appPolicies" : {
  3:     "eula" : "",
  4:     "policies" : [
  5:       {
  6:         "locale" : "en_US",
  7:         "policyText" : "",
  8:         "policyURL" : ""
  9:       }
 10:     ]
 11:   },
 12:   "identifier" : "01B5CCE1",
 13:   "nonRenewingSubscriptions" : [
 14: 
 15:   ],
 16:   "products" : [
 17: 
 18:   ],
 19:   "settings" : {
 20:     "_applicationInternalID" : "6744288931",
 21:     "_developerTeamID" : "KQM6GWHKY3",
 22:     "_failTransactionsEnabled" : false,
 23:     "_lastSynchronizedDate" : 706614288.93695605,
 24:     "_locale" : "en_US",
 25:     "_storefront" : "USA",
 26:     "_storeKitErrors" : [
 27:       {
 28:         "current" : null,
 29:         "enabled" : false,
 30:         "name" : "Load Products"
 31:       },
 32:       {
 33:         "current" : null,
 34:         "enabled" : false,
 35:         "name" : "Purchase"
 36:       },
 37:       {
 38:         "current" : null,
 39:         "enabled" : false,
 40:         "name" : "Verification"
 41:       },
 42:       {
 43:         "current" : null,
 44:         "enabled" : false,
 45:         "name" : "App Store Sync"
 46:       },
 47:       {
 48:         "current" : null,
 49:         "enabled" : false,
 50:         "name" : "Subscription Status"
 51:       },
 52:       {
 53:         "current" : null,
 54:         "enabled" : false,
 55:         "name" : "App Transaction"
 56:       },
 57:       {
 58:         "current" : null,
 59:         "enabled" : false,
 60:         "name" : "Manage Subscriptions Sheet"
 61:       },
 62:       {
 63:         "current" : null,
 64:         "enabled" : false,
 65:         "name" : "Refund Request Sheet"
 66:       },
 67:       {
 68:         "current" : null,
 69:         "enabled" : false,
 70:         "name" : "Offer Code Redeem Sheet"
 71:       }
 72:     ]
 73:   },
 74:   "subscriptionGroups" : [
 75:     {
 76:       "id" : "21342828",
 77:       "localizations" : [
 78: 
 79:       ],
 80:       "name" : "Main",
 81:       "subscriptions" : [
 82:         {
 83:           "adHocOffers" : [
 84: 
 85:           ],
 86:           "codeOffers" : [
 87: 
 88:           ],
 89:           "displayPrice" : "3.99",
 90:           "familyShareable" : false,
 91:           "groupNumber" : 1,
 92:           "internalID" : "6449435879",
 93:           "introductoryOffer" : null,
 94:           "localizations" : [
 95: 
 96:           ],
 97:           "productID" : "eu.balzo.pdfexpert.staging.monthly",
 98:           "recurringSubscriptionPeriod" : "P1M",
 99:           "referenceName" : "Monthly",
100:           "subscriptionGroupID" : "21342828",
101:           "type" : "RecurringSubscription",
102:           "winbackOffers" : [
103: 
104:           ]
105:         },
106:         {
107:           "adHocOffers" : [
108: 
109:           ],
110:           "codeOffers" : [
111: 
112:           ],
113:           "displayPrice" : "3.99",
114:           "familyShareable" : false,
115:           "groupNumber" : 6,
116:           "internalID" : "6449436432",
117:           "introductoryOffer" : {
118:             "internalID" : "1F91B9DD",
119:             "numberOfPeriods" : 1,
120:             "paymentMode" : "free",
121:             "subscriptionPeriod" : "P1W"
122:           },
123:           "localizations" : [
124: 
125:           ],
126:           "productID" : "eu.balzo.pdfexpert.staging.monthly.freetrial",
127:           "recurringSubscriptionPeriod" : "P1M",
128:           "referenceName" : "Monthly Free Trial",
129:           "subscriptionGroupID" : "21342828",
130:           "type" : "RecurringSubscription",
131:           "winbackOffers" : [
132: 
133:           ]
134:         },
135:         {
136:           "adHocOffers" : [
137: 
138:           ],
139:           "codeOffers" : [
140: 
141:           ],
142:           "displayPrice" : "1.99",
143:           "familyShareable" : false,
144:           "groupNumber" : 3,
145:           "internalID" : "6449436136",
146:           "introductoryOffer" : null,
147:           "localizations" : [
148: 
149:           ],
150:           "productID" : "eu.balzo.pdfexpert.staging.weekly",
151:           "recurringSubscriptionPeriod" : "P1W",
152:           "referenceName" : "Weekly",
153:           "subscriptionGroupID" : "21342828",
154:           "type" : "RecurringSubscription",
155:           "winbackOffers" : [
156: 
157:           ]
158:         },
159:         {
160:           "adHocOffers" : [
161: 
162:           ],
163:           "codeOffers" : [
164: 
165:           ],
166:           "displayPrice" : "17.99",
167:           "familyShareable" : false,
168:           "groupNumber" : 4,
169:           "internalID" : "6449436141",
170:           "introductoryOffer" : null,
171:           "localizations" : [
172: 
173:           ],
174:           "productID" : "eu.balzo.pdfexpert.staging.yearly",
175:           "recurringSubscriptionPeriod" : "P1Y",
176:           "referenceName" : "Yearly",
177:           "subscriptionGroupID" : "21342828",
178:           "type" : "RecurringSubscription",
179:           "winbackOffers" : [
180: 
181:           ]
182:         },
183:         {
184:           "adHocOffers" : [
185: 
186:           ],
187:           "codeOffers" : [
188: 
189:           ],
190:           "displayPrice" : "17.99",
191:           "familyShareable" : false,
192:           "groupNumber" : 5,
193:           "internalID" : "6449436302",
194:           "introductoryOffer" : {
195:             "internalID" : "178FF839",
196:             "numberOfPeriods" : 1,
197:             "paymentMode" : "free",
198:             "subscriptionPeriod" : "P1W"
199:           },
200:           "localizations" : [
201: 
202:           ],
203:           "productID" : "eu.balzo.pdfexpert.staging.yearly.freetrial",
204:           "recurringSubscriptionPeriod" : "P1Y",
205:           "referenceName" : "Yearly Free Trial",
206:           "subscriptionGroupID" : "21342828",
207:           "type" : "RecurringSubscription",
208:           "winbackOffers" : [
209: 
210:           ]
211:         }
212:       ]
213:     }
214:   ],
215:   "version" : {
216:     "major" : 4,
217:     "minor" : 0
218:   }
219: }
```

## File: pdfexpert/Resources/InfoTemplate.plist
```
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5: 	<key>CFBundleURLTypes</key>
 6: 	<array>
 7: 		<dict>
 8: 			<key>CFBundleTypeRole</key>
 9: 			<string>None</string>
10: 			<key>CFBundleURLSchemes</key>
11: 			<array>
12: 				<string>fb1171568467580217</string>
13: 			</array>
14: 		</dict>
15: 		<dict>
16: 			<key>CFBundleTypeRole</key>
17: 			<string>Editor</string>
18: 			<key>CFBundleURLName</key>
19: 			<string>com.pcnaid.pdfexpert</string>
20: 			<key>CFBundleURLSchemes</key>
21: 			<array>
22: 				<string>pdfpro</string>
23: 			</array>
24: 		</dict>
25: 	</array>
26: 	<key>FacebookAdvertiserIDCollectionEnabled</key>
27: 	<true/>
28: 	<key>FacebookAppID</key>
29: 	<string>1171568467580217</string>
30: 	<key>FacebookAutoLogAppEventsEnabled</key>
31: 	<true/>
32: 	<key>FacebookClientToken</key>
33: 	<string>5cd9d790a2afc06ff086a69e67823a55</string>
34: 	<key>FacebookDisplayName</key>
35: 	<string>AtlasPDF</string>
36: 	<key>ITSAppUsesNonExemptEncryption</key>
37: 	<false/>
38: 	<key>UIAppFonts</key>
39: 	<array>
40: 		<string>Montserrat-ExtraBold.ttf</string>
41: 		<string>Montserrat-Medium.ttf</string>
42: 		<string>Montserrat-Regular.ttf</string>
43: 		<string>Montserrat-Bold.ttf</string>
44: 	</array>
45: 	<key>UIApplicationSceneManifest</key>
46: 	<dict>
47: 		<key>UIApplicationSupportsMultipleScenes</key>
48: 		<false/>
49: 	</dict>
50: 	<key>UIBackgroundModes</key>
51: 	<array>
52: 		<string>remote-notification</string>
53: 	</array>
54: 	<key>UIViewControllerBasedStatusBarAppearance</key>
55: 	<false/>
56: </dict>
57: </plist>
```

## File: pdfexpert/Style/AnimationPalette.swift
```swift
 1: //
 2: //  AnimationPalette.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 31/03/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: enum AnimationType: String {
12:     case dots = "loading"
13:     case pdf = "pdf-scanning"
14: }
15: 
16: extension AnimationType {
17:     var view: some View {
18:         var view = LottieView(filename: self.rawValue)
19:         switch self {
20:         case .dots: view = view.loop()
21:         case .pdf: view = view.loop(autoReverse: true)
22:         }
23:         return GeometryReader { geometryReader in
24:             view.frame(width: geometryReader.size.width / 2.0)
25:                 .frame(maxHeight: .infinity)
26:                 .position(x: geometryReader.size.width / 2.0, y: geometryReader.size.height / 2.0)
27:         }
28:     }
29: }
```

## File: pdfexpert/Style/ColorPalette.swift
```swift
 1: //
 2: //  ColorPalette.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 23/02/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: class ColorPalette {
12:     static let primary = Color("Primary")
13:     static let primaryBG = Color("PrimaryBG")
14:     static let secondaryBG = Color("SecondaryBG")
15:     static let primaryText = Color("PrimaryText")
16:     static let secondaryText = Color("SecondaryText")
17:     static let thirdText = Color("ThirdText")
18:     static let fourthText = Color("FourthText")
19:     static let extra = Color("Extra")
20:     static let buttonGradientStart = Color("ButtonGradientStart")
21:     static let buttonGradientEnd = Color("ButtonGradientEnd")
22: }
```

## File: pdfexpert/Style/FontPalette.swift
```swift
  1: //
  2: //  FontPalette.swift
  3: //  ChatAI
  4: //
  5: //  Created by Pcnaid Inc on 23/02/23.
  6: //
  7: 
  8: import Foundation
  9: import SwiftUI
 10: 
 11: class FontPalette {
 12:     
 13:     private static let fontFamily: String = "Poppins"
 14:     
 15:     static func fontBlack(withSize size: CGFloat) -> Font {
 16:         return Font.custom("\(Self.fontFamily)-Black", size: size)
 17:     }
 18:     static func fontBlackItalic(withSize size: CGFloat) -> Font {
 19:         return Font.custom("\(Self.fontFamily)-BlackItalic", size: size)
 20:     }
 21:     static func fontBold(withSize size: CGFloat) -> Font {
 22:         return Font.custom("\(Self.fontFamily)-Bold", size: size)
 23:     }
 24:     static func fontBoldItalic(withSize size: CGFloat) -> Font {
 25:         return Font.custom("\(Self.fontFamily)-BoldItalic", size: size)
 26:     }
 27:     static func fontExtraBold(withSize size: CGFloat) -> Font {
 28:         return Font.custom("\(Self.fontFamily)-ExtraBold", size: size)
 29:     }
 30:     static func fontExtraBoldItalic(withSize size: CGFloat) -> Font {
 31:         return Font.custom("\(Self.fontFamily)-ExtraBoldItalic", size: size)
 32:     }
 33:     static func fontExtraLight(withSize size: CGFloat) -> Font {
 34:         return Font.custom("\(Self.fontFamily)-ExtraLight", size: size)
 35:     }
 36:     static func fontExtraLightItalic(withSize size: CGFloat) -> Font {
 37:         return Font.custom("\(Self.fontFamily)-ExtraLightItalic", size: size)
 38:     }
 39:     static func fontItalic(withSize size: CGFloat) -> Font {
 40:         return Font.custom("\(Self.fontFamily)-Italic", size: size)
 41:     }
 42:     static func fontLight(withSize size: CGFloat) -> Font {
 43:         return Font.custom("\(Self.fontFamily)-Light", size: size)
 44:     }
 45:     static func fontLightItalic(withSize size: CGFloat) -> Font {
 46:         return Font.custom("\(Self.fontFamily)-LightItalic", size: size)
 47:     }
 48:     static func fontMedium(withSize size: CGFloat) -> Font {
 49:         return Font.custom("\(Self.fontFamily)-Medium", size: size)
 50:     }
 51:     static func fontMediumItalic(withSize size: CGFloat) -> Font {
 52:         return Font.custom("\(Self.fontFamily)-MediumItalic", size: size)
 53:     }
 54:     static func fontRegular(withSize size: CGFloat) -> Font {
 55:         return Font.custom("\(Self.fontFamily)-Regular", size: size)
 56:     }
 57:     static func fontSemiBold(withSize size: CGFloat) -> Font {
 58:         return Font.custom("\(Self.fontFamily)-SemiBold", size: size)
 59:     }
 60:     static func fontSemiBoldItalic(withSize size: CGFloat) -> Font {
 61:         return Font.custom("\(Self.fontFamily)-SemiBoldItalic", size: size)
 62:     }
 63:     static func fontThin(withSize size: CGFloat) -> Font {
 64:         return Font.custom("\(Self.fontFamily)-Thin", size: size)
 65:     }
 66:     static func fontThinItalic(withSize size: CGFloat) -> Font {
 67:         return Font.custom("\(Self.fontFamily)-ThinItalic", size: size)
 68:     }
 69:     
 70:     static func uiFontBlack(withSize size: CGFloat) -> UIFont {
 71:         return UIFont(name: "\(Self.fontFamily)-Black", size: size) ?? UIFont.boldSystemFont(ofSize: size)
 72:     }
 73:     static func uiFontBlackItalic(withSize size: CGFloat) -> UIFont {
 74:         return UIFont(name: "\(Self.fontFamily)-BlackItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
 75:     }
 76:     static func uiFontBold(withSize size: CGFloat) -> UIFont {
 77:         return UIFont(name: "\(Self.fontFamily)-Bold", size: size) ?? UIFont.boldSystemFont(ofSize: size)
 78:     }
 79:     static func uiFontBoldItalic(withSize size: CGFloat) -> UIFont {
 80:         return UIFont(name: "\(Self.fontFamily)-BoldItalic", size: size) ?? UIFont.boldSystemFont(ofSize: size)
 81:     }
 82:     static func uiFontExtraBold(withSize size: CGFloat) -> UIFont {
 83:         return UIFont(name: "\(Self.fontFamily)-ExtraBold", size: size) ?? UIFont.boldSystemFont(ofSize: size)
 84:     }
 85:     static func uiFontExtraBoldItalic(withSize size: CGFloat) -> UIFont {
 86:         return UIFont(name: "\(Self.fontFamily)-ExtraBoldItalic", size: size) ?? UIFont.boldSystemFont(ofSize: size)
 87:     }
 88:     static func uiFontExtraLight(withSize size: CGFloat) -> UIFont {
 89:         return UIFont(name: "\(Self.fontFamily)-ExtraLight", size: size) ?? UIFont.systemFont(ofSize: size)
 90:     }
 91:     static func uiFontExtraLightItalic(withSize size: CGFloat) -> UIFont {
 92:         return UIFont(name: "\(Self.fontFamily)-ExtraLightItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
 93:     }
 94:     static func uiFontItalic(withSize size: CGFloat) -> UIFont {
 95:         return UIFont(name: "\(Self.fontFamily)-Italic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
 96:     }
 97:     static func uiFontLight(withSize size: CGFloat) -> UIFont {
 98:         return UIFont(name: "\(Self.fontFamily)-Light", size: size) ?? UIFont.systemFont(ofSize: size)
 99:     }
100:     static func uiFontLightItalic(withSize size: CGFloat) -> UIFont {
101:         return UIFont(name: "\(Self.fontFamily)-LightItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
102:     }
103:     static func uiFontMedium(withSize size: CGFloat) -> UIFont {
104:         return UIFont(name: "\(Self.fontFamily)-Medium", size: size) ?? UIFont.systemFont(ofSize: size)
105:     }
106:     static func uiFontMediumItalic(withSize size: CGFloat) -> UIFont {
107:         return UIFont(name: "\(Self.fontFamily)-MediumItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
108:     }
109:     static func uiFontRegular(withSize size: CGFloat) -> UIFont {
110:         return UIFont(name: "\(Self.fontFamily)-Regular", size: size) ?? UIFont.systemFont(ofSize: size)
111:     }
112:     static func uiFontSemiBold(withSize size: CGFloat) -> UIFont {
113:         return UIFont(name: "\(Self.fontFamily)-SemiBold", size: size) ?? UIFont.boldSystemFont(ofSize: size)
114:     }
115:     static func uiFontSemiBoldItalic(withSize size: CGFloat) -> UIFont {
116:         return UIFont(name: "\(Self.fontFamily)-SemiBoldItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
117:     }
118:     static func uiFontThin(withSize size: CGFloat) -> UIFont {
119:         return UIFont(name: "\(Self.fontFamily)-Thin", size: size) ?? UIFont.systemFont(ofSize: size)
120:     }
121:     static func uiFontThinItalic(withSize size: CGFloat) -> UIFont {
122:         return UIFont(name: "\(Self.fontFamily)-ThinItalic", size: size) ?? UIFont.italicSystemFont(ofSize: size)
123:     }
124: }
125: 
126: enum FontCategory {
127:     case largeTitle
128:     case title1
129:     case title2
130:     case button
131:     case headline
132:     case body1
133:     case body2
134:     case body3
135:     case linkText
136:     case callout
137:     case caption1
138:     case caption2
139:     
140:     var font: Font {
141:         switch self {
142:         case .largeTitle: return FontPalette.fontMedium(withSize: 32)
143:         case .title1: return FontPalette.fontMedium(withSize: 24)
144:         case .title2: return FontPalette.fontMedium(withSize: 22)
145:         case .button: return FontPalette.fontMedium(withSize: 18)
146:         case .headline: return FontPalette.fontMedium(withSize: 18)
147:         case .body1: return FontPalette.fontRegular(withSize: 16)
148:         case .body2: return FontPalette.fontRegular(withSize: 14)
149:         case .body3: return FontPalette.fontMedium(withSize: 16)
150:         case .linkText: return FontPalette.fontRegular(withSize: 14)
151:         case .callout: return FontPalette.fontMedium(withSize: 12)
152:         case .caption1: return FontPalette.fontRegular(withSize: 12)
153:         case .caption2: return FontPalette.fontRegular(withSize: 10)
154:         }
155:     }
156: }
157: 
158: extension View {
159:     func font(forCategory category: FontCategory) -> some View {
160:         self.font(category.font)
161:     }
162: }
```

## File: pdfexpert/Utils/Camera/CameraPreviewView.swift
```swift
 1: //
 2: //  CameraPreviewView.swift
 3: //  SwiftCamera
 4: //
 5: //  Created by Rolando Rodriguez on 10/17/20.
 6: //
 7: 
 8: import SwiftUI
 9: import AVFoundation
10: 
11: struct CameraPreviewView: UIViewRepresentable {
12:     class VideoPreviewView: UIView {
13:         override class var layerClass: AnyClass {
14:              AVCaptureVideoPreviewLayer.self
15:         }
16:         
17:         var videoPreviewLayer: AVCaptureVideoPreviewLayer {
18:             return layer as! AVCaptureVideoPreviewLayer
19:         }
20:     }
21:     
22:     let session: AVCaptureSession
23:     
24:     func makeUIView(context: Context) -> VideoPreviewView {
25:         let view = VideoPreviewView()
26:         view.backgroundColor = .black
27:         view.videoPreviewLayer.cornerRadius = 0
28:         view.videoPreviewLayer.session = session
29:         view.videoPreviewLayer.connection?.videoOrientation = .portrait
30: 
31:         return view
32:     }
33:     
34:     func updateUIView(_ uiView: VideoPreviewView, context: Context) {
35:         
36:     }
37: }
38: 
39: struct CameraPreviewView_Previews: PreviewProvider {
40:     static var previews: some View {
41:         CameraPreviewView(session: AVCaptureSession())
42:             .frame(height: 300)
43:     }
44: }
```

## File: pdfexpert/Utils/Camera/CameraService.swift
```swift
  1: //
  2: //  CameraService.swift
  3: //  SwiftCamera
  4: //
  5: //  Created by Rolando Rodriguez on 10/15/20.
  6: //
  7: 
  8: import Foundation
  9: import Combine
 10: import AVFoundation
 11: import UIKit
 12: 
 13: //  MARK: Class Camera Service, handles setup of AVFoundation needed for a basic camera app.
 14: public struct Photo: Identifiable, Equatable {
 15: //    The ID of the captured photo
 16:     public var id: String
 17: //    Data representation of the captured photo
 18:     public var originalData: Data
 19:     
 20:     public init(id: String = UUID().uuidString, originalData: Data) {
 21:         self.id = id
 22:         self.originalData = originalData
 23:     }
 24: }
 25: 
 26: public enum CameraError {
 27:     case permissionDenied
 28:     case cameraUnavailable
 29: }
 30: 
 31: extension Photo {
 32:     public var compressedData: Data? {
 33:         ImageResizer(targetWidth: 800).resize(data: originalData)?.jpegData(compressionQuality: 0.5)
 34:     }
 35:     public var thumbnailData: Data? {
 36:         ImageResizer(targetWidth: 100).resize(data: originalData)?.jpegData(compressionQuality: 0.5)
 37:     }
 38:     public var thumbnailImage: UIImage? {
 39:         guard let data = thumbnailData else { return nil }
 40:         return UIImage(data: data)
 41:     }
 42:     public var image: UIImage? {
 43:         guard let data = compressedData else { return nil }
 44:         return UIImage(data: data)
 45:     }
 46: }
 47: 
 48: public class CameraService {
 49:     typealias PhotoCaptureSessionID = String
 50:     
 51: //    MARK: Observed Properties UI must react to
 52:     
 53: //    1.
 54:     @Published public var flashMode: AVCaptureDevice.FlashMode = .off
 55: //    2.
 56:     @Published public var error: CameraError? = nil
 57: //    3.
 58:     @Published public var shouldShowSpinner = false
 59: //    4.
 60:     @Published public var willCapturePhoto = false
 61: //    5.
 62:     @Published public var isCameraButtonDisabled = true
 63: //    6.
 64:     @Published public var isCameraUnavailable = true
 65: //    8.
 66:     @Published public var photo: Photo?
 67:     
 68: // MARK: Session Management Properties
 69:     
 70: //    9
 71:     public let session = AVCaptureSession()
 72: //    10
 73:     var isSessionRunning = false
 74: //    12
 75:     var isConfigured = false
 76: //    13
 77:     var setupResult: SessionSetupResult = .success
 78: //    14
 79:     // Communicate with the session and other session objects on this queue.
 80:     private let sessionQueue = DispatchQueue(label: "session queue")
 81:     
 82:     @objc dynamic var videoDeviceInput: AVCaptureDeviceInput!
 83:     
 84:     // MARK: Device Configuration Properties
 85:     private let videoDeviceDiscoverySession = AVCaptureDevice.DiscoverySession(deviceTypes: [.builtInWideAngleCamera, .builtInDualCamera, .builtInTrueDepthCamera], mediaType: .video, position: .unspecified)
 86:     
 87:     // MARK: Capturing Photos
 88:     
 89:     private let photoOutput = AVCapturePhotoOutput()
 90:     
 91:     private var inProgressPhotoCaptureDelegates = [Int64: PhotoCaptureProcessor]()
 92:     
 93:     // MARK: KVO and Notifications Properties
 94:     
 95:     private var keyValueObservations = [NSKeyValueObservation]()
 96:     
 97:     
 98:     public func configure() {
 99:         /*
100:          Setup the capture session.
101:          In general, it's not safe to mutate an AVCaptureSession or any of its
102:          inputs, outputs, or connections from multiple threads at the same time.
103:          
104:          Don't perform these tasks on the main queue because
105:          AVCaptureSession.startRunning() is a blocking call, which can
106:          take a long time. Dispatch session setup to the sessionQueue, so
107:          that the main queue isn't blocked, which keeps the UI responsive.
108:          */
109:         sessionQueue.async {
110:             self.configureSession()
111:         }
112:     }
113:     
114:     //        MARK: Checks for user's permisions
115:     public func checkForPermissions() {
116:       
117:         switch AVCaptureDevice.authorizationStatus(for: .video) {
118:         case .authorized:
119:             // The user has previously granted access to the camera.
120:             break
121:         case .notDetermined:
122:             /*
123:              The user has not yet been presented with the option to grant
124:              video access. Suspend the session queue to delay session
125:              setup until the access request has completed.
126:              */
127:             sessionQueue.suspend()
128:             AVCaptureDevice.requestAccess(for: .video, completionHandler: { granted in
129:                 if !granted {
130:                     self.setupResult = .notAuthorized
131:                 }
132:                 self.sessionQueue.resume()
133:             })
134:             
135:         default:
136:             // The user has previously denied access.
137:             setupResult = .notAuthorized
138:             
139:             DispatchQueue.main.async {
140:                 self.error = .permissionDenied
141:                 self.isCameraUnavailable = true
142:                 self.isCameraButtonDisabled = true
143:             }
144:         }
145:     }
146:     
147:     //  MARK: Session Management
148:     
149:     // Call this on the session queue.
150:     /// - Tag: ConfigureSession
151:     private func configureSession() {
152:         if setupResult != .success {
153:             return
154:         }
155:         
156:         session.beginConfiguration()
157:         
158:         session.sessionPreset = .photo
159:         
160:         // Add video input.
161:         do {
162:             var defaultVideoDevice: AVCaptureDevice?
163:             
164:             if let backCameraDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) {
165:                 // If a rear dual camera is not available, default to the rear wide angle camera.
166:                 defaultVideoDevice = backCameraDevice
167:             } else if let frontCameraDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .front) {
168:                 // If the rear wide angle camera isn't available, default to the front wide angle camera.
169:                 defaultVideoDevice = frontCameraDevice
170:             }
171:             
172:             guard let videoDevice = defaultVideoDevice else {
173:                 print("Default video device is unavailable.")
174:                 setupResult = .configurationFailed
175:                 session.commitConfiguration()
176:                 return
177:             }
178:             
179:             let videoDeviceInput = try AVCaptureDeviceInput(device: videoDevice)
180:             
181:             if session.canAddInput(videoDeviceInput) {
182:                 session.addInput(videoDeviceInput)
183:                 self.videoDeviceInput = videoDeviceInput
184:                 
185:             } else {
186:                 print("Couldn't add video device input to the session.")
187:                 setupResult = .configurationFailed
188:                 session.commitConfiguration()
189:                 return
190:             }
191:         } catch {
192:             print("Couldn't create video device input: \(error)")
193:             setupResult = .configurationFailed
194:             session.commitConfiguration()
195:             return
196:         }
197:         
198:         // Add the photo output.
199:         if session.canAddOutput(photoOutput) {
200:             session.addOutput(photoOutput)
201:             
202:             photoOutput.maxPhotoQualityPrioritization = .quality
203:             
204:         } else {
205:             print("Could not add photo output to the session")
206:             setupResult = .configurationFailed
207:             session.commitConfiguration()
208:             return
209:         }
210:         
211:         session.commitConfiguration()
212:         
213:         self.isConfigured = true
214:         
215:         self.start()
216:     }
217:  
218:     //  MARK: Device Configuration
219:     
220:     /// - Tag: ChangeCamera
221:     public func changeCamera() {
222:         guard self.setupResult == .success else {
223:             return
224:         }
225:         //        MARK: Here disable all camera operation related buttons due to configuration is due upon and must not be interrupted
226:         DispatchQueue.main.async {
227:             self.isCameraButtonDisabled = true
228:         }
229:         //
230:         
231:         sessionQueue.async {
232:             let currentVideoDevice = self.videoDeviceInput.device
233:             let currentPosition = currentVideoDevice.position
234:             
235:             let preferredPosition: AVCaptureDevice.Position
236:             let preferredDeviceType: AVCaptureDevice.DeviceType
237:             
238:             switch currentPosition {
239:             case .unspecified, .front:
240:                 preferredPosition = .back
241:                 preferredDeviceType = .builtInWideAngleCamera
242:                 
243:             case .back:
244:                 preferredPosition = .front
245:                 preferredDeviceType = .builtInWideAngleCamera
246:                 
247:             @unknown default:
248:                 print("Unknown capture position. Defaulting to back, dual-camera.")
249:                 preferredPosition = .back
250:                 preferredDeviceType = .builtInWideAngleCamera
251:             }
252:             let devices = self.videoDeviceDiscoverySession.devices
253:             var newVideoDevice: AVCaptureDevice? = nil
254:             
255:             // First, seek a device with both the preferred position and device type. Otherwise, seek a device with only the preferred position.
256:             if let device = devices.first(where: { $0.position == preferredPosition && $0.deviceType == preferredDeviceType }) {
257:                 newVideoDevice = device
258:             } else if let device = devices.first(where: { $0.position == preferredPosition }) {
259:                 newVideoDevice = device
260:             }
261:             
262:             if let videoDevice = newVideoDevice {
263:                 do {
264:                     let videoDeviceInput = try AVCaptureDeviceInput(device: videoDevice)
265:                     
266:                     self.session.beginConfiguration()
267:                     
268:                     // Remove the existing device input first, because AVCaptureSession doesn't support
269:                     // simultaneous use of the rear and front cameras.
270:                     self.session.removeInput(self.videoDeviceInput)
271:                     
272:                     if self.session.canAddInput(videoDeviceInput) {
273:                         self.session.addInput(videoDeviceInput)
274:                         self.videoDeviceInput = videoDeviceInput
275:                     } else {
276:                         self.session.addInput(self.videoDeviceInput)
277:                     }
278:                     
279:                     if let connection = self.photoOutput.connection(with: .video) {
280:                         if connection.isVideoStabilizationSupported {
281:                             connection.preferredVideoStabilizationMode = .auto
282:                         }
283:                     }
284:                     
285:                     self.photoOutput.maxPhotoQualityPrioritization = .quality
286:                     
287:                     self.session.commitConfiguration()
288:                 } catch {
289:                     print("Error occurred while creating video device input: \(error)")
290:                 }
291:             }
292:             
293:             DispatchQueue.main.async {
294: //                MARK: Here enable capture button due to successfull setup
295:                 self.isCameraButtonDisabled = false
296:             }
297:         }
298:     }
299:     
300:     public func focus(at focusPoint: CGPoint){
301: //        let focusPoint = self.videoPreviewLayer.captureDevicePointConverted(fromLayerPoint: point)
302: 
303:         let device = self.videoDeviceInput.device
304:         do {
305:             try device.lockForConfiguration()
306:             if device.isFocusPointOfInterestSupported {
307:                 device.focusPointOfInterest = focusPoint
308:                 device.exposurePointOfInterest = focusPoint
309:                 device.exposureMode = .continuousAutoExposure
310:                 device.focusMode = .continuousAutoFocus
311:                 device.unlockForConfiguration()
312:             }
313:         }
314:         catch {
315:             print(error.localizedDescription)
316:         }
317:     }
318:     
319:     /// - Tag: Stop capture session
320:     
321:     public func stop(completion: (() -> ())? = nil) {
322:         sessionQueue.async {
323:             if self.isSessionRunning {
324:                 if self.setupResult == .success {
325:                     self.session.stopRunning()
326:                     self.isSessionRunning = self.session.isRunning
327:                     
328:                     if !self.session.isRunning {
329:                         DispatchQueue.main.async {
330:                             self.isCameraButtonDisabled = true
331:                             self.isCameraUnavailable = true
332:                             completion?()
333:                         }
334:                     }
335:                 }
336:             }
337:         }
338:     }
339:     
340:     /// - Tag: Start capture session
341:     
342:     public func start() {
343: //        We use our capture session queue to ensure our UI runs smoothly on the main thread.
344:         sessionQueue.async {
345:             if !self.isSessionRunning && self.isConfigured {
346:                 switch self.setupResult {
347:                 case .success:
348:                     self.session.startRunning()
349:                     self.isSessionRunning = self.session.isRunning
350:                     
351:                     if self.session.isRunning {
352:                         DispatchQueue.main.async {
353:                             self.isCameraButtonDisabled = false
354:                             self.isCameraUnavailable = false
355:                         }
356:                     }
357:                     
358:                 case .configurationFailed:
359:                     
360:                     print("Camera unavailable on this device")
361: 
362:                     DispatchQueue.main.async {
363:                         self.error = .cameraUnavailable
364:                         self.isCameraButtonDisabled = true
365:                         self.isCameraUnavailable = true
366:                     }
367:             case .notAuthorized:
368:                 print("Application not authorized to use camera")
369: 
370:                 DispatchQueue.main.async {
371:                     self.error = .permissionDenied
372:                     self.isCameraButtonDisabled = true
373:                     self.isCameraUnavailable = true
374:                 }
375:             }
376:             }
377:         }
378:     }
379:     
380:     public func set(zoom: CGFloat){
381:         let factor = zoom < 1 ? 1 : zoom
382:         let device = self.videoDeviceInput.device
383:         
384:         do {
385:             try device.lockForConfiguration()
386:             device.videoZoomFactor = factor
387:             device.unlockForConfiguration()
388:         }
389:         catch {
390:             print(error.localizedDescription)
391:         }
392:     }
393:     
394:     //    MARK: Capture Photo
395:     
396:     /// - Tag: CapturePhoto
397:     public func capturePhoto(saveToLibrary: Bool) {
398:         if self.setupResult == .success {
399:             self.isCameraButtonDisabled = true
400:             
401:             sessionQueue.async {
402:                 if let photoOutputConnection = self.photoOutput.connection(with: .video) {
403:                     photoOutputConnection.videoOrientation = .portrait
404:                 }
405:                 var photoSettings = AVCapturePhotoSettings()
406:                 
407:                 // Capture HEIF photos when supported. Enable according to user settings and high-resolution photos.
408:                 if  self.photoOutput.availablePhotoCodecTypes.contains(.hevc) {
409:                     photoSettings = AVCapturePhotoSettings(format: [AVVideoCodecKey: AVVideoCodecType.hevc])
410:                 }
411:                 
412:                 // Sets the flash option for this capture.
413:                 if self.videoDeviceInput.device.isFlashAvailable {
414:                     photoSettings.flashMode = self.flashMode
415:                 }
416:                 
417:                 // 
418:                 // iOS 16+ HighResolution Photos
419:                 // 
420:                 if #available(iOS 16.0, *) {
421:                     // 1) Opt in to the systems highres pipeline:
422:                     photoSettings.isHighResolutionPhotoEnabled = true
423: 
424:                     // 2) (Optional) If you want to explicitly pin to the device's largest supported
425:                     //    resolution, read it from your AVCaptureDevice:
426:                     if let deviceInput = self.videoDeviceInput {
427:                         let dims = deviceInput.device.activeFormat.supportedMaxPhotoDimensions
428:                         if let maxDim = dims.last {
429:                             photoSettings.maxPhotoDimensions = maxDim
430:                             print("iOS16+: maxPhotoDimensions set to \(maxDim.width)x\(maxDim.height)")
431:                         } else {
432:                             print("Warning: supportedMaxPhotoDimensions was empty.")
433:                         }
434:                     } else {
435:                         print("Warning: videoDeviceInput unavailable, skipping custom maxPhotoDimensions.")
436:                     }
437:                 }
438:                 // 
439:                     
440:                     // --- Using the exact 'if let' structure you provided ---
441:                     /* Alternative implementation using your exact snippet:
442:                     if let maxDimensions = self.photoOutput?.supportedMaxPhotoDimensions.last { // Use optional chaining for photoOutput
443:                          photoSettings.maxPhotoDimensions = maxDimensions
444:                          print("iOS 16+: Setting max photo dimensions to \(maxDimensions.width)x\(maxDimensions.height)") // Optional logging
445:                     } else {
446:                         print("Warning: Could not determine maximum supported photo dimensions for iOS 16+. Using default behavior.")
447:                         // Optional fallback here too
448:                     }
449:                     */
450:                      
451:                 } else {
452:                     // Fallback for earlier iOS versions
453:                     photoSettings.isHighResolutionPhotoEnabled = true
454:                 }
455:                 
456:                 
457:                 
458:                 // Sets the preview thumbnail pixel format
459:                 if !photoSettings.__availablePreviewPhotoPixelFormatTypes.isEmpty {
460:                     photoSettings.previewPhotoFormat = [kCVPixelBufferPixelFormatTypeKey as String: photoSettings.__availablePreviewPhotoPixelFormatTypes.first!]
461:                 }
462:                 
463:                 photoSettings.photoQualityPrioritization = .quality
464:                 
465:                 let photoCaptureProcessor = PhotoCaptureProcessor(withSaveToLibrary: saveToLibrary,
466:                                                                   requestedPhotoSettings: photoSettings,
467:                                                                   willCapturePhotoAnimation: { [weak self] in
468:                     // Tells the UI to flash the screen to signal that SwiftCamera took a photo.
469:                     DispatchQueue.main.async {
470:                         self?.willCapturePhoto = true
471:                     }
472:                     
473:                     DispatchQueue.main.asyncAfter(deadline: .now() + 0.25) {
474:                         self?.willCapturePhoto = false
475:                     }
476:                     
477:                 }, completionHandler: { [weak self] (photoCaptureProcessor) in
478:                     // When the capture is complete, remove a reference to the photo capture delegate so it can be deallocated.
479:                     if let data = photoCaptureProcessor.photoData {
480:                         self?.photo = Photo(originalData: data)
481:                         print("passing photo")
482:                     } else {
483:                         print("No photo data")
484:                     }
485:                     
486:                     self?.isCameraButtonDisabled = false
487:                     
488:                     self?.sessionQueue.async {
489:                         self?.inProgressPhotoCaptureDelegates[photoCaptureProcessor.requestedPhotoSettings.uniqueID] = nil
490:                     }
491:                 }, photoProcessingHandler: { [weak self] animate in
492:                     // Animates a spinner while photo is processing
493:                     if animate {
494:                         self?.shouldShowSpinner = true
495:                     } else {
496:                         self?.shouldShowSpinner = false
497:                     }
498:                 })
499:                 
500:                 // The photo output holds a weak reference to the photo capture delegate and stores it in an array to maintain a strong reference.
501:                 self.inProgressPhotoCaptureDelegates[photoCaptureProcessor.requestedPhotoSettings.uniqueID] = photoCaptureProcessor
502:                 self.photoOutput.capturePhoto(with: photoSettings, delegate: photoCaptureProcessor)
503:             }
504:         }
505:     }
```

## File: pdfexpert/Utils/Camera/CameraService+Enums.swift
```swift
 1: //
 2: //  CameraService+Enums.swift
 3: //  SwiftCamera
 4: //
 5: //  Created by Rolando Rodriguez on 10/15/20.
 6: //
 7: 
 8: import Foundation
 9: 
10: //  MARK: CameraService Enums
11: extension CameraService {
12:     enum LivePhotoMode {
13:         case on
14:         case off
15:     }
16:     
17:     enum DepthDataDeliveryMode {
18:         case on
19:         case off
20:     }
21:     
22:     enum PortraitEffectsMatteDeliveryMode {
23:         case on
24:         case off
25:     }
26:     
27:     enum SessionSetupResult {
28:         case success
29:         case notAuthorized
30:         case configurationFailed
31:     }
32:     
33:     enum CaptureMode: Int {
34:         case photo = 0
35:         case movie = 1
36:     }
37: }
```

## File: pdfexpert/Utils/Camera/CameraService+Extensions.swift
```swift
 1: //
 2: //  CameraService+Extensions.swift
 3: //  SwiftCamera
 4: //
 5: //  Created by Rolando Rodriguez on 10/15/20.
 6: //
 7: 
 8: import Foundation
 9: import UIKit
10: import AVFoundation
11: 
12: extension AVCaptureVideoOrientation {
13:     init?(deviceOrientation: UIDeviceOrientation) {
14:         switch deviceOrientation {
15:         case .portrait: self = .portrait
16:         case .portraitUpsideDown: self = .portraitUpsideDown
17:         case .landscapeLeft: self = .landscapeRight
18:         case .landscapeRight: self = .landscapeLeft
19:         default: return nil
20:         }
21:     }
22:     
23:     init?(interfaceOrientation: UIInterfaceOrientation) {
24:         switch interfaceOrientation {
25:         case .portrait: self = .portrait
26:         case .portraitUpsideDown: self = .portraitUpsideDown
27:         case .landscapeLeft: self = .landscapeLeft
28:         case .landscapeRight: self = .landscapeRight
29:         default: return nil
30:         }
31:     }
32: }
33: 
34: extension AVCaptureDevice.DiscoverySession {
35:     var uniqueDevicePositionsCount: Int {
36:         
37:         var uniqueDevicePositions = [AVCaptureDevice.Position]()
38:         
39:         for device in devices where !uniqueDevicePositions.contains(device.position) {
40:             uniqueDevicePositions.append(device.position)
41:         }
42:         
43:         return uniqueDevicePositions.count
44:     }
45: }
```

## File: pdfexpert/Utils/Camera/ImageResizer.swift
```swift
 1: //
 2: //  ImageResizer.swift
 3: //  SwiftCamera
 4: //
 5: //  Created by Rolando Rodriguez on 10/15/20.
 6: //
 7: 
 8: import Foundation
 9: import UIKit
10: 
11: enum ImageResizingError: Error {
12:     case cannotRetrieveFromURL
13:     case cannotRetrieveFromData
14: }
15: 
16: public struct ImageResizer {
17:     var targetWidth: CGFloat
18:     
19:     public func resize(at url: URL) -> UIImage? {
20:         guard let image = UIImage(contentsOfFile: url.path) else {
21:             return nil
22:         }
23:         
24:         return self.resize(image: image)
25:     }
26:     
27:     public func resize(image: UIImage) -> UIImage {
28:         let originalSize = image.size
29:         let targetSize = CGSize(width: targetWidth, height: targetWidth*originalSize.height/originalSize.width)
30:         let renderer = UIGraphicsImageRenderer(size: targetSize)
31:         return renderer.image { (context) in
32:             image.draw(in: CGRect(origin: .zero, size: targetSize))
33:         }
34:     }
35:     
36:     public func resize(data: Data) -> UIImage? {
37:         guard let image = UIImage(data: data) else {return nil}
38:         return resize(image: image )
39:     }
40: }
41: 
42: struct MemorySizer {
43:     static func size(of data: Data) -> String {
44:         let bcf = ByteCountFormatter()
45:         bcf.allowedUnits = [.useMB] // optional: restricts the units to MB only
46:         bcf.countStyle = .file
47:         let string = bcf.string(fromByteCount: Int64(data.count))
48:         return string
49:     }
50: }
```

## File: pdfexpert/Utils/Camera/PhotoCaptureProcessor.swift
```swift
  1: //
  2: //  PhotoCaptureProcessor.swift
  3: //  abseil
  4: //
  5: //  Created by Rolando Rodriguez on 10/15/20.
  6: //
  7: 
  8: import Foundation
  9: import Photos
 10: 
 11: class PhotoCaptureProcessor: NSObject {
 12:     
 13:     lazy var context = CIContext()
 14: 
 15:     private(set) var requestedPhotoSettings: AVCapturePhotoSettings
 16:     
 17:     private let saveToLibrary: Bool
 18:     
 19:     private let willCapturePhotoAnimation: () -> Void
 20:     
 21:     private let completionHandler: (PhotoCaptureProcessor) -> Void
 22:     
 23:     private let photoProcessingHandler: (Bool) -> Void
 24:     
 25: //    The actual captured photo's data
 26:     var photoData: Data?
 27:     
 28: //    The maximum time lapse before telling UI to show a spinner
 29:     private var maxPhotoProcessingTime: CMTime?
 30:         
 31: //    Init takes multiple closures to be called in each step of the photco capture process
 32:     init(withSaveToLibrary saveToLibrary: Bool,
 33:          requestedPhotoSettings: AVCapturePhotoSettings,
 34:          willCapturePhotoAnimation: @escaping () -> Void,
 35:          completionHandler: @escaping (PhotoCaptureProcessor) -> Void,
 36:          photoProcessingHandler: @escaping (Bool) -> Void) {
 37:         
 38:         self.saveToLibrary = saveToLibrary
 39:         self.requestedPhotoSettings = requestedPhotoSettings
 40:         self.willCapturePhotoAnimation = willCapturePhotoAnimation
 41:         self.completionHandler = completionHandler
 42:         self.photoProcessingHandler = photoProcessingHandler
 43:     }
 44: }
 45: 
 46: extension PhotoCaptureProcessor: AVCapturePhotoCaptureDelegate {
 47:     
 48:     // This extension adopts AVCapturePhotoCaptureDelegate protocol methods.
 49:     
 50:     /// - Tag: WillBeginCapture
 51:     func photoOutput(_ output: AVCapturePhotoOutput, willBeginCaptureFor resolvedSettings: AVCaptureResolvedPhotoSettings) {
 52:         maxPhotoProcessingTime = resolvedSettings.photoProcessingTimeRange.start + resolvedSettings.photoProcessingTimeRange.duration
 53:     }
 54:     
 55:     /// - Tag: WillCapturePhoto
 56:     func photoOutput(_ output: AVCapturePhotoOutput, willCapturePhotoFor resolvedSettings: AVCaptureResolvedPhotoSettings) {
 57:         DispatchQueue.main.async {
 58:             self.willCapturePhotoAnimation()
 59:         }
 60:         
 61:         guard let maxPhotoProcessingTime = maxPhotoProcessingTime else {
 62:             return
 63:         }
 64:         
 65:         // Show a spinner if processing time exceeds one second.
 66:         let oneSecond = CMTime(seconds: 2, preferredTimescale: 1)
 67:         if maxPhotoProcessingTime > oneSecond {
 68:             DispatchQueue.main.async {
 69:                 self.photoProcessingHandler(true)
 70:             }
 71:         }
 72:     }
 73:     
 74:     /// - Tag: DidFinishProcessingPhoto
 75:     func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
 76:         
 77:         DispatchQueue.main.async {
 78:             self.photoProcessingHandler(false)
 79:         }
 80:         
 81:         if let error = error {
 82:             print("Error capturing photo: \(error)")
 83:         } else {
 84:             photoData = photo.fileDataRepresentation()
 85:         }
 86:     }
 87:     
 88:     //        MARK: Saves capture to photo library
 89:     func saveToPhotoLibrary(_ photoData: Data) {
 90:         
 91:         PHPhotoLibrary.requestAuthorization { status in
 92:             if status == .authorized {
 93:                 PHPhotoLibrary.shared().performChanges({
 94:                     let options = PHAssetResourceCreationOptions()
 95:                     let creationRequest = PHAssetCreationRequest.forAsset()
 96:                     options.uniformTypeIdentifier = self.requestedPhotoSettings.processedFileType.map { $0.rawValue }
 97:                     creationRequest.addResource(with: .photo, data: photoData, options: options)
 98:                     
 99:                     
100:                 }, completionHandler: { _, error in
101:                     if let error = error {
102:                         print("Error occurred while saving photo to photo library: \(error)")
103:                     }
104:                     
105:                     DispatchQueue.main.async {
106:                         self.completionHandler(self)
107:                     }
108:                 }
109:                 )
110:             } else {
111:                 DispatchQueue.main.async {
112:                     self.completionHandler(self)
113:                 }
114:             }
115:         }
116:     }
117:     
118:     /// - Tag: DidFinishCapture
119:     func photoOutput(_ output: AVCapturePhotoOutput, didFinishCaptureFor resolvedSettings: AVCaptureResolvedPhotoSettings, error: Error?) {
120:         if let error = error {
121:             print("Error capturing photo: \(error)")
122:             DispatchQueue.main.async {
123:                 self.completionHandler(self)
124:             }
125:             return
126:         } else {
127:             guard let data = photoData else {
128:                 DispatchQueue.main.async {
129:                     self.completionHandler(self)
130:                 }
131:                 return
132:             }
133:             
134:             if self.saveToLibrary {
135:                 self.saveToPhotoLibrary(data)
136:             } else {
137:                 DispatchQueue.main.async {
138:                     self.completionHandler(self)
139:                 }
140:             }
141:         }
142:     }
143: }
```

## File: pdfexpert/Utils/Extensions/Color+Extensions.swift
```swift
 1: //
 2: //  Color+Extensions.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 23/02/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: extension Color {
12:     init(hex: String) {
13:         let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
14:         var int: UInt64 = 0
15:         Scanner(string: hex).scanHexInt64(&int)
16:         let a, r, g, b: UInt64
17:         switch hex.count {
18:         case 3: // RGB (12-bit)
19:             (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
20:         case 6: // RGB (24-bit)
21:             (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
22:         case 8: // RGBA (32-bit)
23:             (r, g, b, a) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
24:         default:
25:             (a, r, g, b) = (1, 1, 1, 0)
26:         }
27: 
28:         self.init(
29:             .sRGB,
30:             red: Double(r) / 255,
31:             green: Double(g) / 255,
32:             blue:  Double(b) / 255,
33:             opacity: Double(a) / 255
34:         )
35:     }
36: }
```

## File: pdfexpert/Utils/Extensions/CoreGraphics+Extensions.swift
```swift
 1: //
 2: //  CoreGraphics+Extensions.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 07/09/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: extension CGSize {
11:     var aspectRatio: CGFloat {
12:         return self.width / self.height
13:     }
14:     
15:     func clipToSize(
16:         _ clippingSize: CGSize,
17:         horizontalMargin: CGFloat = 0,
18:         verticalMargin: CGFloat = 0,
19:         keepAspectRatio: Bool = true
20:     ) -> CGSize {
21:         var clippedWidth: CGFloat = self.width
22:         var clippedHeight: CGFloat = self.height
23:         
24:         let maxHeight: CGFloat = clippingSize.height - horizontalMargin
25:         if clippedHeight > maxHeight {
26:             clippedHeight = maxHeight
27:             clippedWidth = clippedHeight * self.aspectRatio
28:         }
29:         
30:         let maxWidth: CGFloat = clippingSize.height - verticalMargin
31:         if clippedWidth > maxWidth {
32:             clippedWidth = maxWidth
33:             clippedHeight = clippedWidth / self.aspectRatio
34:         }
35:         
36:         return CGSize(width: clippedWidth, height: clippedHeight)
37:     }
38: }
```

## File: pdfexpert/Utils/Extensions/Enum+Extensions.swift
```swift
 1: //
 2: //  Enum+Extensions.swift
 3: //  StoryKidsAI
 4: //
 5: //  Created by Pcnaid Inc on 09/03/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: extension CaseIterable where Self: Equatable {
11:     
12:     static var totalCases: Int {
13:         return Self.allCases.count
14:     }
15:     
16:     var index: Int {
17:         return Array(Self.allCases).firstIndex(of: self)!
18:     }
19:     
20:     var next: Self? {
21:         let all = Self.allCases
22:         let idx = all.firstIndex(of: self)!
23:         let next = all.index(after: idx)
24:         return next != all.endIndex ? all[next] : nil
25:     }
26:     
27:     var previous: Self? {
28:         let all = Array(Self.allCases)
29:         let idx = all.firstIndex(of: self)!
30:         let previous = all.index(before: idx)
31:         return previous >= 0 ? all[previous] : nil
32:     }
33: }
```

## File: pdfexpert/Utils/Extensions/Foundation+Extensions.swift
```swift
 1: //
 2: //  Foundation+Extensions.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 03/05/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: extension URL {
11:     static func getDocumentsDirectory() -> URL {
12:         let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
13:         return paths[0]
14:     }
15: }
```

## File: pdfexpert/Utils/Extensions/NSAttributedString+Extensions.swift
```swift
 1: //
 2: //  NSAttributedString+Extensions.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 21/08/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: extension NSAttributedString {
11:      public func attributedStringByTrimmingCharacterSet(charSet: CharacterSet) -> NSAttributedString {
12:          let modifiedString = NSMutableAttributedString(attributedString: self)
13:         modifiedString.trimCharactersInSet(charSet: charSet)
14:          return NSAttributedString(attributedString: modifiedString)
15:      }
16: }
17: 
18: extension NSMutableAttributedString {
19:      public func trimCharactersInSet(charSet: CharacterSet) {
20:         var range = (string as NSString).rangeOfCharacter(from: charSet as CharacterSet)
21: 
22:          // Trim leading characters from character set.
23:          while range.length != 0 && range.location == 0 {
24:             replaceCharacters(in: range, with: "")
25:             range = (string as NSString).rangeOfCharacter(from: charSet)
26:          }
27: 
28:          // Trim trailing characters from character set.
29:         range = (string as NSString).rangeOfCharacter(from: charSet, options: .backwards)
30:          while range.length != 0 && NSMaxRange(range) == length {
31:             replaceCharacters(in: range, with: "")
32:             range = (string as NSString).rangeOfCharacter(from: charSet, options: .backwards)
33:          }
34:      }
35: }
```

## File: pdfexpert/Utils/Extensions/ObservableObject+Extensions.swift
```swift
 1: //
 2: //  ObservableObject+Extensions.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/05/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: @MainActor // <<< ADD THIS ANNOTATION
12: extension ObservableObject {
13:     func asyncSubject<T, E>(_ keyPath: WritableKeyPath<Self, AsyncOperation<T, E>>) -> Binding<AsyncOperation<T, E>> {
14:         let defaultValue = self[keyPath: keyPath]
15:         return .init(get: { [weak self] in
16:                 self?[keyPath: keyPath] ?? defaultValue
17:             }, set: { [weak self] in
18:                 self?[keyPath: keyPath] = $0
19:             })
20:         }
21:     }
```

## File: pdfexpert/Utils/Extensions/PDFAnnotation+Extensions.swift
```swift
  1: //
  2: //  PDFAnnotation+Extensions.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 30/05/23.
  6: //
  7: 
  8: import Foundation
  9: import PDFKit
 10: 
 11: private enum PDFCustomKey: String {
 12:     case annotationType = "type"
 13: }
 14: 
 15: private enum PDFAnnotationTypeValue: String {
 16:     case signature = "signature"
 17: }
 18: 
 19: extension PDFAnnotation {
 20:     
 21:     var text: String { self.contents ?? "" }
 22:     
 23:     var isTextAnnotation: Bool {
 24:         guard let subType = self.annotationKeyValues[PDFAnnotationKey.subtype] as? PDFAnnotationSubtype, subType == PDFAnnotationSubtype.freeText else {
 25:             return false
 26:         }
 27:         return true
 28:     }
 29:     
 30:     var isWidgetAnnotation: Bool {
 31:         guard let subType = self.annotationKeyValues[PDFAnnotationKey.subtype] as? PDFAnnotationSubtype, subType == PDFAnnotationSubtype.widget else {
 32:             return false
 33:         }
 34:         return true
 35:     }
 36:     
 37:     var isSignatureAnnotation: Bool {
 38:         guard let subType = self.annotationKeyValues[PDFAnnotationKey.subtype] as? PDFAnnotationSubtype,
 39:               subType == PDFAnnotationSubtype.stamp,
 40:               self.annotationKeyValues.getCustomPdfValue(forKey: PDFCustomKey.annotationType.rawValue) == PDFAnnotationTypeValue.signature.rawValue else {
 41:             return false
 42:         }
 43:         return true
 44:     }
 45:     
 46:     var image: UIImage {
 47:         let renderer = UIGraphicsImageRenderer(size: self.bounds.size)
 48:         return renderer.image { ctx in
 49:             
 50:             ctx.cgContext.translateBy(x: -self.bounds.origin.x, y: self.bounds.origin.y)
 51:             // Flip the context vertically because the Core Graphics coordinate system starts from the bottom.
 52:             ctx.cgContext.translateBy(x: 0, y: self.bounds.size.height)
 53:             ctx.cgContext.scaleBy(x: 1, y: -1)
 54:             
 55:             self.draw(with: .mediaBox, in: ctx.cgContext)
 56:         }
 57:     }
 58:     
 59:     var verticalCenteredTextBounds: CGRect {
 60:         self.bounds.decode(forText: self.contents ?? "", withFont: self.font)
 61:     }
 62:     
 63:     static func create(with text: String,
 64:          forBounds bounds: CGRect,
 65:          textColor: UIColor,
 66:          fontName: String,
 67:          withProperties properties: [AnyHashable : Any]?) -> PDFAnnotation {
 68:         let font = UIFont.font(named: fontName, fitting: text, into: bounds.size, with: [:], options: [])
 69:         let encodedBounds = bounds.encode(forText: text, withFont: font)
 70:         let annotation = PDFAnnotation(bounds: encodedBounds, forType: PDFAnnotationSubtype.freeText,  withProperties: properties)
 71:         annotation.fontColor = textColor
 72:         annotation.color = .clear
 73:         annotation.font = font
 74:         annotation.alignment = .center
 75:         annotation.contents = text
 76:         return annotation
 77:     }
 78:     
 79:     static func createSignature(with image: UIImage,
 80:          forBounds bounds: CGRect) -> PDFAnnotation {
 81:         var properties: [AnyHashable: Any] = [:]
 82:         properties.addCustomPdfValue(PDFAnnotationTypeValue.signature.rawValue, forKey: PDFCustomKey.annotationType.rawValue)
 83:         let annotation = ImageStampAnnotation(with: image, forBounds: bounds, withProperties: properties)
 84:         return annotation
 85:     }
 86: }
 87: 
 88: fileprivate extension CGRect {
 89:     
 90:     static var safetyMargin: CGFloat { 10.0 }
 91:     
 92:     func encode(forText text: String, withFont font: UIFont?) -> CGRect {
 93:         let size = text.boundingRect(font: font, with: [:], options: []).size
 94:         let center = CGPoint(x: self.origin.x + self.size.width / 2, y: self.origin.y + self.size.height / 2)
 95:         let origin = CGPoint(x: center.x - size.width / 2, y: center.y - size.height / 2)
 96:         return CGRect(origin: origin, size: size)
 97:             .inset(by: UIEdgeInsets(top: -Self.safetyMargin,
 98:                                     left: -Self.safetyMargin,
 99:                                     bottom: -Self.safetyMargin,
100:                                     right: -Self.safetyMargin))
101:     }
102:     
103:     func decode(forText text: String, withFont font: UIFont?) -> CGRect {
104:         return self
105:             .inset(by: UIEdgeInsets(top: Self.safetyMargin,
106:                                     left: Self.safetyMargin,
107:                                     bottom: Self.safetyMargin,
108:                                     right: Self.safetyMargin))
109:     }
110: }
111: 
112: fileprivate extension Dictionary where Key == AnyHashable, Value == Any {
113:     
114:     private static var keyPrefix: String { "PdfExpert" }
115:     
116:     mutating func addCustomPdfValue(_ value: Any, forKey key: AnyHashable) {
117:         self["\(Self.keyPrefix)_\(key)"] = value
118:     }
119:     
120:     func getCustomPdfValue<T>(forKey key: AnyHashable) -> T? {
121:         return self["/\(Self.keyPrefix)_\(key)"] as? T
122:     }
123: }
```

## File: pdfexpert/Utils/Extensions/PdfDocument+Extensions.swift
```swift
 1: //
 2: //  PdfDocument+Extensions.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 24/08/23.
 6: //
 7: 
 8: import Foundation
 9: import PDFKit
10: 
11: // 1. Wrapper Struct: *This struct* behaves like a Collection of PDFPages
12: public struct PDFPagesView: Collection {
13:     private let document: PDFDocument // Holds the document
14: 
15:     init(document: PDFDocument) { // Needs the document to work
16:         self.document = document
17:     }
18: 
19:     // Type Aliases: Matches original
20:     public typealias Index = Int
21:     public typealias Element = PDFPage
22: 
23:     // Required Properties: Matches original logic
24:     public var startIndex: Index { return 0 }
25:     public var endIndex: Index { return self.document.pageCount } // Accesses page count via stored document
26: 
27:     // Required Subscript: Matches original logic (safer unwrap)
28:     public subscript(index: Index) -> Element {
29:         // Calls page(at:) on the stored document. Uses guard for safety.
30:         guard let page = self.document.page(at: index) else {
31:             fatalError("Index \(index) out of bounds...") // Or handle error differently
32:         }
33:         return page
34:     }
35: 
36:     // Required Method: Matches original
37:     public func index(after i: Index) -> Index {
38:         return i + 1
39:     }
40: 
41:     // Optional but good additions (often get default implementations from Collection anyway)
42:     public var count: Int { return self.document.pageCount }
43:     public var isEmpty: Bool { return self.document.pageCount == 0 }
44: 
45:     // Implicitly Gains: All other Collection/Sequence methods
46:     // (e.g., for-in loops, .count, .isEmpty, .map, .filter, .first, .last, etc.)
47:     // These methods operate *on the PDFPagesView instance*.
48: }
49: 
50: // 2. Accessor Extension: How to *get* the wrapper from a PDFDocument
51: extension PDFDocument {
52:     public var pages: PDFPagesView {
53:         return PDFPagesView(document: self)
54:     }
55: }
```

## File: pdfexpert/Utils/Extensions/PencilKit+Extensions.swift
```swift
 1: //
 2: //  PencilKit+Extensions.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 19/05/23.
 6: //
 7: 
 8: import Foundation
 9: import PencilKit
10: 
11: extension PKDrawing {
12:     
13:     /**
14:      Same behaviour as PKDrawing.image(from:scale:), with the only difference that the provided
15:      UIUserInterfaceStyle will be the one used as reference for color conversion upon image creation.
16:      
17:      This is useful to prevent unwanted automatic color conversion of dark colors to bright colors (and vice versa)
18:      in case of dark mode.
19:      */
20:     func image(from rect: CGRect, scale: CGFloat, userInterfaceStyle: UIUserInterfaceStyle) -> UIImage {
21:         let currentTraits = UITraitCollection.current
22:         UITraitCollection.current = UITraitCollection(userInterfaceStyle: userInterfaceStyle)
23:         let image = self.image(from: rect, scale: scale)
24:         UITraitCollection.current = currentTraits
25:         return image
26:     }
27: }
```

## File: pdfexpert/Utils/Extensions/StoreKit+Extensions.swift
```swift
 1: //
 2: //  StoreKit+Extensions.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 05/09/23.
 6: //
 7: 
 8: import Foundation
 9: import StoreKit
10: 
11: public extension Product {
12:     var isFreeTrial: Bool {
13:         self.subscription?.introductoryOffer?.paymentMode == .freeTrial
14:     }
15: }
```

## File: pdfexpert/Utils/Extensions/String+Extensions.swift
```swift
 1: //
 2: //  String+Extensions.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 06/03/23.
 6: //
 7: 
 8: import Foundation
 9: import UIKit
10: 
11: extension String {
12:     
13:     public var nilIfEmpty: String? {
14:         return self.isEmpty ? nil : self
15:     }
16:     
17:     public func capitalizingFirstLetter() -> String {
18:         return prefix(1).capitalized + dropFirst()
19:     }
20: 
21:     public mutating func capitalizeFirstLetter() {
22:         self = self.capitalizingFirstLetter()
23:     }
24:     
25:     public func boundingRect(font: UIFont?,
26:                              with attributes: [NSAttributedString.Key: Any],
27:                              options: NSStringDrawingOptions) -> CGRect {
28:         var attributes = attributes
29:         attributes[.font] = font
30:         return self.boundingRect(with: CGSize(width: CGFloat.greatestFiniteMagnitude,
31:                                               height: CGFloat.greatestFiniteMagnitude),
32:                                  options: options,
33:                                  attributes: attributes,
34:                                  context: nil)
35:     }
36: }
```

## File: pdfexpert/Utils/Extensions/UIApplication+Extensions.swift
```swift
 1: //
 2: //  UIApplication+Extensions.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 02/03/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: extension UIApplication {
12:     static func dismissKeyboard() {
13:         UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
14:     }
15: }
```

## File: pdfexpert/Utils/Extensions/UIFont+Extensions.swift
```swift
 1: //
 2: //  UIFont+Extensions.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 01/06/23.
 6: //
 7: 
 8: import Foundation
 9: import UIKit
10: 
11: extension UIFont {
12:     static func font(named fontName: String,
13:                      fitting text: String,
14:                      into targetSize: CGSize,
15:                      with attributes: [NSAttributedString.Key: Any],
16:                      options: NSStringDrawingOptions) -> UIFont {
17:         var attributes = attributes
18:         let fontSize = targetSize.height
19: 
20:         attributes[.font] = UIFont(name: fontName, size: fontSize)
21:         let size = text.boundingRect(with: CGSize(width: .greatestFiniteMagnitude, height: fontSize),
22:                                      options: options,
23:                                      attributes: attributes,
24:                                      context: nil).size
25: 
26:         let heightSize = targetSize.height / (size.height / fontSize)
27:         let widthSize = targetSize.width / (size.width / fontSize)
28:         let minSize = min(heightSize, widthSize)
29:         
30:         return UIFont(name: fontName, size: minSize) ?? .systemFont(ofSize: minSize)
31:     }
32: }
```

## File: pdfexpert/Utils/Extensions/URL+Extensions.swift
```swift
 1: //
 2: //  URL+Extensions.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 28/07/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: extension URL {
11:     var filename: String {
12:         self.deletingPathExtension().lastPathComponent
13:     }
14: }
```

## File: pdfexpert/Utils/Extensions/View+Alert.swift
```swift
 1: //
 2: //  View+Alert.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 24/02/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: 
12: extension View {
13:     func errorAlert<T, E>(asyncOperation: Binding<AsyncOperation<T, E>>, buttonTitle: String = "OK") -> some View {
14:         var localizedError: E? = nil
15:         switch asyncOperation.wrappedValue.status {
16:         case .error(let error): localizedError = error
17:         default: break
18:         }
19:         return alert("Error", isPresented: .constant(localizedError != nil), presenting: localizedError) { _ in
20:             Button(buttonTitle) {
21:                 asyncOperation.wrappedValue = AsyncOperation(status: .empty)
22:             }
23:         } message: { localizedError in
24:             Text(localizedError.errorDescription ?? "")
25:         }
26:     }
27:     
28:     func errorAlert<T: AsyncFailable>(asyncFailable: Binding<T>, buttonTitle: String = "OK") -> some View {
29:         let localizedError: T.E? = asyncFailable.wrappedValue.error
30:         return alert("Error", isPresented: .constant(localizedError != nil), presenting: localizedError) { _ in
31:             Button(buttonTitle) {
32:                 asyncFailable.wrappedValue = T.resetState
33:             }
34:         } message: { localizedError in
35:             Text(localizedError.errorDescription ?? "")
36:         }
37:     }
38: }
```

## File: pdfexpert/Utils/Extensions/View+Extensions.swift
```swift
  1: //
  2: //  View+Extensions.swift
  3: //  StoryKidsAI
  4: //
  5: //  Created by Pcnaid Inc on 10/03/23.
  6: //
  7: 
  8: import Foundation
  9: import SwiftUI
 10: 
 11: #if canImport(UIKit)
 12: extension View {
 13:     func hideKeyboard() {
 14:         UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
 15:     }
 16: }
 17: #endif
 18: 
 19: extension View {
 20:     
 21:     func getCloseButton(color: Color, leftSide: Bool = true, padding: CGFloat? = nil, onClose: @escaping () -> ()) -> some View {
 22:         VStack {
 23:             HStack {
 24:                 if !leftSide {
 25:                     Spacer()
 26:                 }
 27:                 Button(action: { onClose() }) {
 28:                     Self.getSystemClose(color: color)
 29:                 }
 30:                 if leftSide {
 31:                     Spacer()
 32:                 }
 33:             }
 34:             Spacer()
 35:         }
 36:         .padding(.all, padding)
 37:     }
 38:     
 39:     func getEditButton(color: Color, font: Font, editMode: Binding<EditMode>) -> some View {
 40:         VStack {
 41:             HStack {
 42:                 Spacer()
 43:                 Button(action: {
 44:                     withAnimation {
 45:                         if editMode.wrappedValue == .active {
 46:                             editMode.wrappedValue = .inactive
 47:                         } else {
 48:                             editMode.wrappedValue = .active
 49:                         }
 50:                     }
 51:                 }) {
 52:                     Text(editMode.wrappedValue.text)
 53:                         .font(font)
 54:                         .foregroundColor(color)
 55:                 }
 56:             }
 57:             .padding(.trailing)
 58:             Spacer()
 59:         }
 60:         .padding(.top)
 61:     }
 62:     
 63:     @ViewBuilder func addCustomBackButton(color: Color, onPress: @escaping () -> ()) -> some View {
 64:         self.navigationBarBackButtonHidden()
 65:             .toolbar {
 66:             ToolbarItem(placement: .navigationBarLeading) {
 67:                 Button(action: { onPress() }) {
 68:                     Self.getSystemChevron(color: color, directionRight: false)
 69:                 }
 70:             }
 71:         }
 72:     }
 73:     
 74:     static func getAttributedText(forUrlString urlString: String,
 75:                                   text: String) -> AttributedString {
 76:         var attributedString = try! AttributedString(markdown: "[\(text)](\(urlString))")
 77:         attributedString.underlineStyle = .single
 78:         return attributedString
 79:     }
 80:     
 81:     static func getSystemChevron(color: Color, directionRight: Bool = true) -> some View {
 82:         Image(systemName: directionRight ? "chevron.right" : "chevron.left")
 83:             .font(.system(size: 20, weight: .medium, design: .default))
 84:             .foregroundColor(color)
 85:     }
 86:     
 87:     static func getSystemClose(color: Color) -> some View {
 88:         Image(systemName: "xmark")
 89:             .font(.system(size: 16).bold())
 90:             .foregroundColor(color)
 91:     }
 92:     
 93:     func addSystemCloseButton(color: Color, onPress: @escaping () -> ()) -> some View {
 94:         self.navigationBarBackButtonHidden()
 95:             .toolbar {
 96:             ToolbarItem(placement: .navigationBarLeading) {
 97:                 Button(action: { onPress() }) {
 98:                     Self.getSystemClose(color: color)
 99:                 }
100:             }
101:         }
102:     }
103:     
104:     /// Applies the given transform if the given condition evaluates to `true`.
105:     /// - Parameters:
106:     ///   - condition: The condition to evaluate.
107:     ///   - transform: The transform to apply to the source `View`.
108:     /// - Returns: Either the original `View` or the modified `View` if the condition is `true`.
109:     @ViewBuilder func `if`<Content: View>(_ condition: Bool, transform: (Self) -> Content) -> some View {
110:         if condition {
111:             transform(self)
112:         } else {
113:             self
114:         }
115:     }
116:     
117:     @ViewBuilder func actionDialog<A>(_ title: Text,
118:                                       isPresented: Binding<Bool>,
119:                                       titleVisibility: Visibility = .automatic,
120:                                       @ViewBuilder actions: () -> A) -> some View where A : View {
121:         // This platform branching is needed because, on iPad, confirmationDialog brokes interaction subsequent modals
122:         // See: http://openradar.appspot.com/radar?id=5597349300666368
123:         if UIDevice.current.userInterfaceIdiom == .pad {
124:             self.alert(title, isPresented: isPresented, actions: actions)
125:         } else {
126:             self.confirmationDialog(title, isPresented: isPresented, titleVisibility: titleVisibility, actions: actions)
127:         }
128:     }
129:     
130:     var isScrollToAvailable: Bool {
131:         if UIDevice.current.userInterfaceIdiom == .pad {
132:             // ScrollViewProxy.scrollTo() method crashes on certain conditions on iPadOS < 16.4.1
133:             // https://developer.apple.com/forums/thread/712510
134:             if #available(iOS 16.4.1, *) {
135:                 return true
136:             } else {
137:                 return false
138:             }
139:         } else {
140:             return true
141:         }
142:     }
143: }
144: 
145: extension Binding where Value == String {
146:     func max(_ limit: Int) -> Self {
147:         if self.wrappedValue.count > limit {
148:             DispatchQueue.main.async {
149:                 self.wrappedValue = String(self.wrappedValue.dropLast())
150:             }
151:         }
152:         return self
153:     }
154: }
155: 
156: fileprivate extension EditMode {
157:     var text: String {
158:         switch self {
159:         case .active: return "Done"
160:         case .inactive: return "Edit"
161:         case .transient: return ""
162:         @unknown default: return ""
163:         }
164:     }
165: }
```

## File: pdfexpert/Utils/UI/ActivityViewController.swift
```swift
 1: //
 2: //  ActivityViewController.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 30/03/23.
 6: //
 7: 
 8: import SwiftUI
 9: import UIKit
10: import LinkPresentation
11: 
12: 
13: struct ActivityViewController: UIViewControllerRepresentable {
14: 
15:     var activityItems: [Any]
16:     var applicationActivities: [UIActivity]? = nil
17:     var thumbnail: UIImage? = nil
18:     var title: String
19:     
20:     @Environment(\.presentationMode) var presentationMode
21: 
22:     func makeUIViewController(context: UIViewControllerRepresentableContext<ActivityViewController>) -> UIActivityViewController {
23:         var activityItems: [Any] = self.activityItems
24:         activityItems.append(self.makeCoordinator())
25:         let controller = UIActivityViewController(activityItems: activityItems,
26:                                                   applicationActivities: self.applicationActivities)
27:         controller.completionWithItemsHandler = { (activityType, completed, returnedItems, error) in
28:             self.presentationMode.wrappedValue.dismiss()
29:         }
30:         return controller
31:     }
32: 
33:     func updateUIViewController(_ uiViewController: UIActivityViewController, context: UIViewControllerRepresentableContext<ActivityViewController>) {}
34:     
35:     func makeCoordinator() -> ActivityCoordinator {
36:         ActivityCoordinator(thumbnail: self.thumbnail, title: self.title)
37:     }
38: }
39: 
40: class ActivityCoordinator: NSObject, UIActivityItemSource {
41:     
42:     private let thumbnail: UIImage?
43:     private let title: String
44: 
45:     init(thumbnail: UIImage?, title: String) {
46:         self.thumbnail = thumbnail
47:         self.title = title
48:     }
49:     
50:     func activityViewControllerPlaceholderItem(_ activityViewController: UIActivityViewController) -> Any {
51:         return ""
52:     }
53: 
54:     func activityViewController(_ activityViewController: UIActivityViewController, itemForActivityType activityType: UIActivity.ActivityType?) -> Any? {
55:         return nil
56:     }
57: 
58:     func activityViewControllerLinkMetadata(_ activityViewController: UIActivityViewController) -> LPLinkMetadata? {
59:         let metadata = LPLinkMetadata()
60:         if let thumbnail {
61:             metadata.imageProvider = NSItemProvider(object: thumbnail)
62:         }
63:         metadata.title = self.title
64:         return metadata
65:     }
66: }
67: 
68: struct ActivityViewController_Previews: PreviewProvider {
69:     static var previews: some View {
70:         ActivityViewController(activityItems: [URL(string: "https://www.apple.com")!], title: "Test File")
71:     }
72: }
```

## File: pdfexpert/Utils/UI/AsyncView.swift
```swift
  1: //
  2: //  AsyncView.swift
  3: //  ChatAI
  4: //
  5: //  Created by Pcnaid Inc on 02/03/23.
  6: //
  7: 
  8: import Foundation
  9: import SwiftUI
 10: 
 11: extension View {
 12:     
 13:     func asyncView<DataType, ErrorType: LocalizedError>(
 14:         asyncOperation: Binding<AsyncOperation<DataType, ErrorType>>) -> some View {
 15:         return self.modifier(
 16:             AsyncView(asyncOperation: asyncOperation, loadingView: { ProgressView() })
 17:         )
 18:     }
 19:     
 20:     func asyncView<LoadingView: View, DataType, ErrorType: LocalizedError>(
 21:         asyncOperation: Binding<AsyncOperation<DataType, ErrorType>>,
 22:         @ViewBuilder loadingView: @escaping () -> LoadingView) -> some View {
 23:         return self.modifier(
 24:             AsyncView(asyncOperation: asyncOperation, loadingView: loadingView)
 25:         )
 26:     }
 27: }
 28: 
 29: struct AsyncView<LoadingView: View, DataType, ErrorType: LocalizedError>: ViewModifier {
 30:     
 31:     @Binding var asyncOperation: AsyncOperation<DataType, ErrorType>
 32:     
 33:     var loadingView: (() -> LoadingView)
 34:     
 35:     init(asyncOperation: Binding<AsyncOperation<DataType, ErrorType>>,
 36:          loadingView: @escaping (() -> LoadingView)) {
 37:         self._asyncOperation = asyncOperation
 38:         self.loadingView = loadingView
 39:     }
 40:     
 41:     func body(content: Content) -> some View {
 42:         ZStack {
 43:             content
 44:                 .allowsHitTesting(!self.asyncOperation.isLoading)
 45:             self.additionalContent
 46:         }.errorAlert(asyncOperation: self.$asyncOperation)
 47:     }
 48:     
 49:     @ViewBuilder var additionalContent: some View {
 50:         switch self.asyncOperation.status {
 51:         case .empty: Spacer()
 52:         case .loading:
 53:             Color(.black).opacity(0.5)
 54:                 .edgesIgnoringSafeArea(.all)
 55:             self.loadingView()
 56:         case .error: Spacer()
 57:         case .data:  Spacer()
 58:         }
 59:     }
 60: }
 61: 
 62: fileprivate enum AsyncViewError: LocalizedError {}
 63: 
 64: struct AsyncView_Previews: PreviewProvider {
 65:     
 66:     @State fileprivate static var testAsyncOperation = AsyncOperation<Void, AsyncViewError>(status: .loading(Progress(totalUnitCount: 1)))
 67:     
 68:     static var previews: some View {
 69:         Color(.white)
 70:             .asyncView(asyncOperation: $testAsyncOperation)
 71:     }
 72: }
 73: 
 74: 
 75: 
 76: 
 77: 
 78: extension View {
 79:     
 80:     func asyncView<AsyncItem: AsyncFailable & AsyncLoadable>(
 81:         asyncItem: Binding<AsyncItem>) -> some View {
 82:             return self
 83:                 .asyncFailableView(asyncItem: asyncItem)
 84:                 .asyncLoadableView(asyncItem: asyncItem, loadingView: { ProgressView() })
 85:     }
 86:     
 87:     func asyncView<LoadingView: View, AsyncItem: AsyncFailable & AsyncLoadable>(
 88:         asyncItem: Binding<AsyncItem>,
 89:         @ViewBuilder loadingView: @escaping () -> LoadingView) -> some View {
 90:             return self
 91:                 .asyncFailableView(asyncItem: asyncItem)
 92:                 .asyncLoadableView(asyncItem: asyncItem, loadingView: loadingView)
 93:     }
 94:     
 95:     func asyncView<AsyncItem: AsyncFailable>(
 96:         asyncItem: Binding<AsyncItem>) -> some View {
 97:             return self
 98:                 .asyncFailableView(asyncItem: asyncItem)
 99:     }
100:     
101:     func asyncView<AsyncItem: AsyncLoadable>(
102:         asyncItem: Binding<AsyncItem>) -> some View {
103:             return self
104:                 .asyncLoadableView(asyncItem: asyncItem, loadingView: { ProgressView() })
105:     }
106:     
107:     func asyncView<LoadingView: View, AsyncItem: AsyncLoadable>(
108:         asyncItem: Binding<AsyncItem>,
109:         @ViewBuilder loadingView: @escaping () -> LoadingView) -> some View {
110:             return self
111:                 .asyncLoadableView(asyncItem: asyncItem, loadingView: loadingView)
112:     }
113:     
114:     func asyncFailableView<AsyncItem: AsyncFailable>(
115:         asyncItem: Binding<AsyncItem>) -> some View {
116:         return self.modifier(
117:             AsyncFailableView(asyncItem: asyncItem)
118:         )
119:     }
120:     
121:     func asyncLoadableView<LoadingView: View, AsyncItem: AsyncLoadable>(
122:         asyncItem: Binding<AsyncItem>,
123:         @ViewBuilder loadingView: @escaping () -> LoadingView) -> some View {
124:         return self.modifier(
125:             AsyncLoadableView(asyncItem: asyncItem, loadingView: loadingView)
126:         )
127:     }
128: }
129: 
130: struct AsyncFailableView<AsyncItem: AsyncFailable>: ViewModifier {
131:     
132:     @Binding var asyncItem: AsyncItem
133:     
134:     init(asyncItem: Binding<AsyncItem>) {
135:         self._asyncItem = asyncItem
136:     }
137:     
138:     func body(content: Content) -> some View {
139:         content.errorAlert(asyncFailable: self.$asyncItem)
140:     }
141: }
142: 
143: struct AsyncLoadableView<LoadingView: View, AsyncItem: AsyncLoadable>: ViewModifier {
144:     
145:     @Binding var asyncItem: AsyncItem
146:     
147:     var loadingView: (() -> LoadingView)
148:     
149:     init(asyncItem: Binding<AsyncItem>, loadingView: @escaping (() -> LoadingView)) {
150:         self._asyncItem = asyncItem
151:         self.loadingView = loadingView
152:     }
153:     
154:     func body(content: Content) -> some View {
155:         ZStack {
156:             content.allowsHitTesting(!self.asyncItem.isLoading)
157:             if self.asyncItem.isLoading {
158:                 Color(.black).opacity(0.5)
159:                     .edgesIgnoringSafeArea(.all)
160:                 self.loadingView()
161:             }
162:         }
163:     }
164: }
```

## File: pdfexpert/Utils/UI/CircularProgressView.swift
```swift
 1: //
 2: //  CircularProgressView.swift
 3: //  StoryKidsAI
 4: //
 5: //  Created by Pcnaid Inc on 08/03/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct CircularProgressView: View {
11:     
12:     let foregroundColor: Color
13:     let backgroundColor: Color
14:     let width: CGFloat
15:     let progress: Double
16:     
17:     var body: some View {
18:         ZStack {
19:             Circle()
20:                 .stroke(
21:                     self.backgroundColor,
22:                     lineWidth: self.width
23:                 )
24:             Circle()
25:                 .trim(from: 0, to: self.progress)
26:                 .stroke(
27:                     self.foregroundColor,
28:                     style: StrokeStyle(
29:                         lineWidth: self.width,
30:                         lineCap: .round
31:                     )
32:                 )
33:                 .rotationEffect(.degrees(-90))
34:                 .animation(.easeOut, value: self.progress)
35: 
36:         }
37:     }
38: }
39: 
40: struct CircularProgressView_Previews: PreviewProvider {
41:     static var previews: some View {
42:         CircularProgressView(foregroundColor: .black,
43:                              backgroundColor: .gray,
44:                              width: 20,
45:                              progress: 0.4)
46:         .previewLayout(PreviewLayout.fixed(width: 200, height: 200))
47:         .padding()
48:     }
49: }
```

## File: pdfexpert/Utils/UI/FilePicker.swift
```swift
 1: //
 2: //  FilePicker.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 29/03/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: import UIKit
11: import UniformTypeIdentifiers.UTType
12: 
13: typealias FilePickerCallback = ([URL]) -> ()
14: 
15: struct FilePicker: UIViewControllerRepresentable {
16:     
17:     let fileTypes: [UTType]
18:     let multipleSelection: Bool
19:     let onPickedFiles: FilePickerCallback
20:     
21:     func makeUIViewController(context: Context) -> some UIViewController {
22:         let controller = UIDocumentPickerViewController(forOpeningContentTypes: self.fileTypes, asCopy: true)
23:         controller.allowsMultipleSelection = self.multipleSelection
24:         controller.shouldShowFileExtensions = true
25:         controller.view.backgroundColor = UIColor(ColorPalette.primaryBG)
26:         controller.delegate = context.coordinator
27:         return controller
28:     }
29:     
30:     func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) {
31:         
32:     }
33:     
34:     func makeCoordinator() -> FilePickerCoordinator {
35:         FilePickerCoordinator(onPickedFiles: self.onPickedFiles)
36:     }
37: }
38: 
39: class FilePickerCoordinator: NSObject, UIDocumentPickerDelegate {
40:     
41:     let onPickedFiles: FilePickerCallback
42: 
43:     init(onPickedFiles: @escaping FilePickerCallback) {
44:         self.onPickedFiles = onPickedFiles
45:     }
46:     
47:     func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
48:         self.onPickedFiles(urls)
49:     }
50: }
51: 
52: extension View {
53:     @ViewBuilder func filePicker(isPresented: Binding<Bool>,
54:                                  fileTypes: [UTType],
55:                                  multipleSelection: Bool = false,
56:                                  onPickedFiles: @escaping FilePickerCallback) -> some View {
57:         if UIDevice.current.userInterfaceIdiom == .pad {
58:             self.sheet(isPresented: isPresented) {
59:                 FilePicker(fileTypes: fileTypes, multipleSelection: multipleSelection, onPickedFiles: onPickedFiles)
60:             }
61:         } else {
62:             self.fullScreenCover(isPresented: isPresented) {
63:                 FilePicker(fileTypes: fileTypes, multipleSelection: multipleSelection, onPickedFiles: onPickedFiles)
64:             }
65:         }
66:     }
67: }
68: 
69: protocol FilePickerTypeProvider: Identifiable {
70:     var fileTypes: [UTType] { get }
71: }
72: 
73: extension View {
74:     @ViewBuilder func filePicker<Item: FilePickerTypeProvider>(item: Binding<Item?>,
75:                                                                multipleSelection: Bool = false,
76:                                                                onPickedFiles: @escaping FilePickerCallback) -> some View {
77:         if UIDevice.current.userInterfaceIdiom == .pad {
78:             self.sheet(item: item) {
79:                 FilePicker(fileTypes: $0.fileTypes, multipleSelection: multipleSelection, onPickedFiles: onPickedFiles)
80:             }
81:         } else {
82:             self.fullScreenCover(item: item) {
83:                 FilePicker(fileTypes: $0.fileTypes, multipleSelection: multipleSelection, onPickedFiles: onPickedFiles)
84:             }
85:         }
86:     }
87: }
```

## File: pdfexpert/Utils/UI/FormSheet.swift
```swift
  1: //
  2: //  FormSheet.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 14/06/23.
  6: //
  7: 
  8: import SwiftUI
  9: 
 10: // MARK: - FormSheet Boolean
 11: 
 12: class FormSheetWrapper<Content: View>: UIViewController, UIPopoverPresentationControllerDelegate {
 13: 
 14:     var size: CGSize
 15:     var content: () -> Content
 16:     var onDismiss: (() -> Void)?
 17: 
 18:     private var hostVC: UIHostingController<Content>?
 19: 
 20:     required init?(coder: NSCoder) { fatalError("") }
 21: 
 22:     init(size: CGSize, content: @escaping () -> Content) {
 23:         self.size = size
 24:         self.content = content
 25:         super.init(nibName: nil, bundle: nil)
 26:     }
 27: 
 28:     func show() {
 29:         guard hostVC == nil else { return }
 30:         let vc = UIHostingController(rootView: content())
 31: 
 32:         vc.preferredContentSize = self.size
 33:         vc.modalPresentationStyle = .formSheet
 34:         vc.presentationController?.delegate = self
 35:         hostVC = vc
 36:         self.present(vc, animated: true, completion: nil)
 37:     }
 38: 
 39:     func hide() {
 40:         guard let vc = self.hostVC, !vc.isBeingDismissed else { return }
 41:         dismiss(animated: true, completion: nil)
 42:         hostVC = nil
 43:     }
 44:     
 45:     func presentationControllerDidDismiss(_ presentationController: UIPresentationController) {
 46:         hostVC = nil
 47:         self.onDismiss?()
 48:     }
 49: }
 50: 
 51: struct FormSheet<Content: View> : UIViewControllerRepresentable {
 52: 
 53:     @Binding var show: Bool
 54:     let size: CGSize
 55: 
 56:     let content: () -> Content
 57: 
 58:     func makeUIViewController(context: UIViewControllerRepresentableContext<FormSheet<Content>>) -> FormSheetWrapper<Content> {
 59: 
 60:         let vc = FormSheetWrapper(size: self.size, content: content)
 61:         vc.onDismiss = { self.show = false }
 62:         return vc
 63:     }
 64: 
 65:     func updateUIViewController(_ uiViewController: FormSheetWrapper<Content>,
 66:                                 context: UIViewControllerRepresentableContext<FormSheet<Content>>) {
 67:         if self.show {
 68:             uiViewController.show()
 69:         }
 70:         else {
 71:             uiViewController.hide()
 72:         }
 73:     }
 74: }
 75: 
 76: // MARK: - FormSheet Identifiable
 77: 
 78: public protocol FormSheetItem: Identifiable {
 79:     var viewSize: CGSize { get }
 80: }
 81: 
 82: class FormSheetWrapperIdentifiable<Content: View, Item: FormSheetItem>: UIViewController, UIPopoverPresentationControllerDelegate {
 83:     
 84:     var content: (Item) -> Content
 85:     var onDismiss: (() -> Void)?
 86: 
 87:     private var hostVC: UIHostingController<Content>?
 88: 
 89:     required init?(coder: NSCoder) { fatalError("") }
 90: 
 91:     init(content: @escaping (Item) -> Content) {
 92:         self.content = content
 93:         super.init(nibName: nil, bundle: nil)
 94:     }
 95: 
 96:     func show(item: Item) {
 97:         guard hostVC == nil else { return }
 98:         let vc = UIHostingController(rootView: content(item))
 99: 
100:         vc.preferredContentSize = item.viewSize
101:         vc.modalPresentationStyle = .formSheet
102:         vc.presentationController?.delegate = self
103:         hostVC = vc
104:         self.present(vc, animated: true, completion: nil)
105:     }
106: 
107:     func hide() {
108:         guard let vc = self.hostVC, !vc.isBeingDismissed else { return }
109:         dismiss(animated: true, completion: nil)
110:         hostVC = nil
111:     }
112: 
113:     func presentationControllerDidDismiss(_ presentationController: UIPresentationController) {
114:         hostVC = nil
115:         self.onDismiss?()
116:     }
117: }
118: 
119: struct FormSheetIdentifiable<Content: View, Item: FormSheetItem> : UIViewControllerRepresentable {
120: 
121:     @Binding var item: Item?
122: 
123:     let content: (Item) -> Content
124: 
125:     func makeUIViewController(context: UIViewControllerRepresentableContext<FormSheetIdentifiable<Content, Item>>) -> FormSheetWrapperIdentifiable<Content, Item> {
126: 
127:         let vc = FormSheetWrapperIdentifiable(content: content)
128:         vc.onDismiss = { self.item = nil }
129:         return vc
130:     }
131: 
132:     func updateUIViewController(_ uiViewController: FormSheetWrapperIdentifiable<Content, Item>,
133:                                 context: UIViewControllerRepresentableContext<FormSheetIdentifiable<Content, Item>>) {
134:         if let item = self.item {
135:             uiViewController.show(item: item)
136:         }
137:         else {
138:             uiViewController.hide()
139:         }
140:     }
141: }
142: 
143: // MARK: - View Extensions
144: 
145: extension View {
146:     @ViewBuilder public func formSheet<Content: View>(isPresented: Binding<Bool>,
147:                                                       size: CGSize,
148:                                                       @ViewBuilder content: @escaping () -> Content) -> some View {
149:         if UIDevice.current.userInterfaceIdiom == .pad {
150:             self.background(FormSheet(show: isPresented,
151:                                       size: size,
152:                                       content: content))
153:         } else {
154:             self.sheet(isPresented: isPresented) {
155:                 content()
156:                     .presentationDetents([.height(size.height)])
157:             }
158:         }
159:     }
160:     
161:     @ViewBuilder public func formSheet<Content: View, Item: FormSheetItem>(item: Binding<Item?>,
162:                                                                           @ViewBuilder content: @escaping (Item) -> Content) -> some View {
163:         if UIDevice.current.userInterfaceIdiom == .pad {
164:             self.background(FormSheetIdentifiable(item: item,
165:                                                   content: content))
166:         } else {
167:             self.sheet(item: item) { item in
168:                 content(item)
169:                     .presentationDetents([.height(item.viewSize.height)])
170:             }
171:         }
172:     }
173: }
```

## File: pdfexpert/Utils/UI/FullScreenClearBackground.swift
```swift
 1: //
 2: //  FullScreenClearBackground.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 10/08/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: struct FullScreenClearBackground: UIViewControllerRepresentable {
12:     
13:     public func makeUIViewController(context: UIViewControllerRepresentableContext<Self>) -> UIViewController {
14:         return Controller()
15:     }
16:     
17:     public func updateUIViewController(_ uiViewController: UIViewController, context: UIViewControllerRepresentableContext<Self>) {
18:     }
19:     
20:     class Controller: UIViewController {
21:         
22:         override func viewDidLoad() {
23:             super.viewDidLoad()
24:             self.view.backgroundColor = .clear
25:         }
26:         
27:         override func willMove(toParent parent: UIViewController?) {
28:             super.willMove(toParent: parent)
29:             parent?.view?.backgroundColor = .clear
30:             parent?.modalPresentationStyle = .overCurrentContext
31:         }
32:     }
33: }
34: 
35: extension View {
36:     @ViewBuilder public func sheetAutoHeight<Content: View>(isPresented: Binding<Bool>,
37:                                                             backgroundColor: Color,
38:                                                             topCornerRadius: CGFloat = 0,
39:                                                             @ViewBuilder content: @escaping () -> Content) -> some View {
40:         self.fullScreenCover(isPresented: isPresented) {
41:             Button(action: { isPresented.wrappedValue = false }) {
42:                 self.getContentView(backgroundColor: backgroundColor,
43:                                     topCornerRadius: topCornerRadius,
44:                                     content: { content() })
45:             }
46:             .background(FullScreenClearBackground())
47:         }
48:     }
49:     
50:     @ViewBuilder public func sheetAutoHeight<Content: View, Item: Identifiable>(item: Binding<Item?>,
51:                                                             backgroundColor: Color,
52:                                                             topCornerRadius: CGFloat = 0,
53:                                                             @ViewBuilder content: @escaping (Item) -> Content) -> some View {
54:         self.fullScreenCover(item: item) { unwrappedItem in
55:             Button(action: { item.wrappedValue = nil }) {
56:                 self.getContentView(backgroundColor: backgroundColor,
57:                                     topCornerRadius: topCornerRadius,
58:                                     content: { content(unwrappedItem) })
59:             }
60:             .background(FullScreenClearBackground())
61:         }
62:     }
63:     
64:     @ViewBuilder private func getContentView<Content: View>(backgroundColor: Color,
65:                                                             topCornerRadius: CGFloat,
66:                                                             @ViewBuilder content: @escaping () -> Content) -> some View {
67:         VStack(spacing: 0) {
68:             Spacer()
69:             if topCornerRadius > 0 {
70:                 backgroundColor.frame(height: topCornerRadius * 2)
71:                     .cornerRadius(topCornerRadius, corners: [.topLeft, .topRight])
72:             }
73:             content()
74:                 .background(backgroundColor)
75:         }
76:     }
77: }
```

## File: pdfexpert/Utils/UI/ImageAnnotationStamp.swift
```swift
 1: //
 2: //  ImageAnnotationStamp.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 10/05/23.
 6: //
 7: 
 8: import Foundation
 9: import UIKit
10: import PDFKit
11: 
12: class ImageStampAnnotation: PDFAnnotation {
13:     
14:     private let stampImage: UIImage?
15:     
16:     init(with image: UIImage, forBounds bounds: CGRect, withProperties properties: [AnyHashable : Any]?) {
17:         self.stampImage = image
18:         super.init(bounds: bounds, forType: PDFAnnotationSubtype.stamp,  withProperties: properties)
19:     }
20:     
21:     required init?(coder aDecoder: NSCoder) {
22:         fatalError("init(coder:) has not been implemented")
23:     }
24:     
25:     override func draw(with box: PDFDisplayBox, in context: CGContext)   {
26:         guard let cgImage = self.stampImage?.cgImage else { return }
27:         context.draw(cgImage, in: self.bounds)
28:     }
29: }
```

## File: pdfexpert/Utils/UI/ImageResizableView.swift
```swift
  1: //
  2: //  ImageResizableView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 16/05/23.
  6: //
  7: 
  8: import SwiftUI
  9: import UIKit
 10: 
 11: struct ImageResizableView: View {
 12:     
 13:     enum HandlePosition { case bottomLeft, bottomRight, topLeft, topRight }
 14:     
 15:     let uiImage: UIImage
 16:     @Binding var imageRect: CGRect
 17:     let borderColor: Color
 18:     let borderWidth: CGFloat
 19:     let handleColor: Color
 20:     let handleSize: CGFloat
 21:     let handleTapSize: CGFloat
 22:     let keepAspectRatio: Bool
 23:     
 24:     @State var tapImageOffset: CGPoint? = nil
 25:     
 26:     private var topLeft: CGPoint {
 27:         self.imageRect.origin
 28:     }
 29:     
 30:     private var topRight: CGPoint {
 31:         CGPoint(x: self.imageRect.origin.x + self.imageRect.size.width,
 32:                 y: self.imageRect.origin.y)
 33:     }
 34:     
 35:     private var bottomLeft: CGPoint {
 36:         CGPoint(x: self.imageRect.origin.x,
 37:                 y: self.imageRect.origin.y + self.imageRect.size.height)
 38:     }
 39:     
 40:     private var bottomRight: CGPoint {
 41:         CGPoint(x: self.imageRect.origin.x + self.imageRect.size.width,
 42:                 y: self.imageRect.origin.y + self.imageRect.size.height)
 43:     }
 44:     
 45:     private var computedCenter: CGPoint {
 46:         CGPoint(x: self.topLeft.x + (self.bottomRight.x - self.topLeft.x) / 2,
 47:                 y: self.topLeft.y + (self.bottomRight.y - self.topLeft.y) / 2)
 48:     }
 49:     
 50:     private var computedSize: CGSize {
 51:         CGSize(width: self.bottomRight.x - self.topLeft.x,
 52:                height: self.bottomRight.y - self.topLeft.y)
 53:     }
 54:     
 55:     init(uiImage: UIImage,
 56:          imageRect: Binding<CGRect>,
 57:          borderColor: Color,
 58:          borderWidth: CGFloat,
 59:          handleColor: Color,
 60:          handleSize: CGFloat,
 61:          handleTapSize: CGFloat,
 62:          keepAspectRatio: Bool) {
 63:         self.uiImage = uiImage
 64:         self._imageRect = imageRect
 65:         self.borderColor = borderColor
 66:         self.borderWidth = borderWidth
 67:         self.handleColor = handleColor
 68:         self.handleSize = handleSize
 69:         self.handleTapSize = handleTapSize
 70:         self.keepAspectRatio = keepAspectRatio
 71:     }
 72:     
 73:     var body: some View {
 74:         GeometryReader { parentGeometryReader in
 75:             ZStack {
 76:                 GeometryReader { _ in
 77:                     Image(uiImage: self.uiImage)
 78:                         .resizable()
 79:                         .background(Rectangle().stroke(self.borderColor, lineWidth: self.borderWidth))
 80:                         .position(self.computedCenter)
 81:                         .frame(width: self.computedSize.width, height: self.computedSize.height)
 82:                         .gesture(
 83:                             DragGesture()
 84:                                 .onChanged { gesture in
 85:                                     self.OnDragImage(dragGestureValue: gesture,
 86:                                                      parentViewSize: parentGeometryReader.size)
 87:                                 }
 88:                                 .onEnded { _ in self.tapImageOffset = nil }
 89:                         )
 90:                 }
 91:                 self.getHandle(handlePosition: .bottomLeft,
 92:                                parentViewSize: parentGeometryReader.size)
 93:                 self.getHandle(handlePosition: .bottomRight,
 94:                                parentViewSize: parentGeometryReader.size)
 95:                 self.getHandle(handlePosition: .topLeft,
 96:                                parentViewSize: parentGeometryReader.size)
 97:                 self.getHandle(handlePosition: .topRight,
 98:                                parentViewSize: parentGeometryReader.size)
 99:             }
100:         }
101:     }
102:     
103:     private func OnDragImage(dragGestureValue: DragGesture.Value, parentViewSize: CGSize) {
104:         
105:         let location = dragGestureValue.location
106:         let center = self.computedCenter
107:         let size = self.computedSize
108:         
109:         if self.tapImageOffset == nil {
110:             self.tapImageOffset = CGPoint(x: dragGestureValue.startLocation.x - center.x,
111:                                           y: dragGestureValue.startLocation.y - center.y)
112:         }
113:         
114:         guard let tapImageOffset = self.tapImageOffset else {
115:             return
116:         }
117:         
118:         var newCenterX = location.x - tapImageOffset.x
119:         newCenterX = max(min(newCenterX, parentViewSize.width - size.width / 2), size.width / 2)
120:         var newCenterY = location.y - tapImageOffset.y
121:         newCenterY = max(min(newCenterY, parentViewSize.height - size.height / 2), size.height / 2)
122:         
123:         let currentEventTranslation: CGPoint = CGPoint(x: newCenterX - center.x,
124:                                                        y: newCenterY - center.y)
125:         let bottomRight = CGPoint(x: self.bottomRight.x + currentEventTranslation.x,
126:                                   y: self.bottomRight.y + currentEventTranslation.y)
127:         let topLeft = CGPoint(x: self.topLeft.x + currentEventTranslation.x,
128:                               y: self.topLeft.y + currentEventTranslation.y)
129:         self.updateRect(topLeft: topLeft, bottomRight: bottomRight)
130:     }
131:     
132:     private func OnDrag(handlePosition: HandlePosition,
133:                         dragGestureValue: DragGesture.Value,
134:                         parentViewSize: CGSize) {
135:         
136:         let location = self.getDragLocation(originalDragLocation: dragGestureValue.location,
137:                                             handle: handlePosition)
138:         
139:         var bottomRight: CGPoint = .zero
140:         var topLeft: CGPoint = .zero
141:         
142:         switch handlePosition {
143:         case .bottomLeft:
144:             var bottomLeft = CGPoint(x: location.x,
145:                                      y: location.y)
146:                 .getBoundedPoint(containerSize: parentViewSize,
147:                                  margin: self.handleSize / 2,
148:                                  keepAspectRatio: self.keepAspectRatio,
149:                                  originalPoint: self.bottomLeft)
150:             bottomLeft = CGPoint(
151:                 x: min(bottomLeft.x, self.bottomRight.x - self.handleSize),
152:                 y: max(bottomLeft.y, self.topLeft.y + self.handleSize)
153:             )
154:             bottomRight = CGPoint(x: self.bottomRight.x, y: bottomLeft.y)
155:             topLeft = CGPoint(x: bottomLeft.x, y: self.topLeft.y)
156:         case .bottomRight:
157:             bottomRight = CGPoint(x: location.x,
158:                                   y: location.y)
159:             .getBoundedPoint(containerSize: parentViewSize,
160:                              margin: self.handleSize / 2,
161:                              keepAspectRatio: self.keepAspectRatio,
162:                              originalPoint: self.bottomRight)
163:             bottomRight = CGPoint(
164:                 x: max(bottomRight.x, self.topLeft.x + self.handleSize),
165:                 y: max(bottomRight.y, self.topLeft.y + self.handleSize)
166:             )
167:             topLeft = self.topLeft
168:         case .topLeft:
169:             topLeft = CGPoint(x: location.x,
170:                               y: location.y)
171:             .getBoundedPoint(containerSize: parentViewSize,
172:                              margin: self.handleSize / 2,
173:                              keepAspectRatio: self.keepAspectRatio,
174:                              originalPoint: self.topLeft)
175:             topLeft = CGPoint(
176:                 x: min(topLeft.x, self.bottomRight.x - self.handleSize),
177:                 y: min(topLeft.y, self.bottomRight.y - self.handleSize)
178:             )
179:             bottomRight = self.bottomRight
180:         case .topRight:
181:             var topRight = CGPoint(x: location.x,
182:                                    y: location.y)
183:                 .getBoundedPoint(containerSize: parentViewSize,
184:                                  margin: self.handleSize / 2,
185:                                  keepAspectRatio: self.keepAspectRatio,
186:                                  originalPoint: self.topRight)
187:             topRight = CGPoint(
188:                 x: max(topRight.x, self.topLeft.x + self.handleSize),
189:                 y: min(topRight.y, self.bottomRight.y - self.handleSize)
190:             )
191:             bottomRight = CGPoint(x: topRight.x, y: self.bottomRight.y)
192:             topLeft = CGPoint(x: self.topLeft.x, y: topRight.y)
193:         }
194:         self.updateRect(topLeft: topLeft, bottomRight: bottomRight)
195:     }
196:     
197:     private func getHandle(handlePosition: HandlePosition,
198:                            parentViewSize: CGSize) -> some View {
199:         Group {
200:             Circle()
201:                 .frame(width: self.handleSize, height: self.handleSize)
202:                 .foregroundColor(self.handleColor)
203:         }
204:         .frame(width: self.handleTapSize, height: self.handleTapSize)
205:         .contentShape(Circle())
206:         .position(handlePosition.getPosition(forParentViewSize: self.computedSize,
207:                                              parentCenter: self.computedCenter))
208:         .gesture(
209:             DragGesture()
210:                 .onChanged { gesture in
211:                     self.OnDrag(handlePosition: handlePosition,
212:                                 dragGestureValue: gesture,
213:                                 parentViewSize: parentViewSize)
214:                 }
215:         )
216:     }
217:     
218:     private func updateRect(topLeft: CGPoint, bottomRight: CGPoint) {
219:         self.imageRect = CGRect(x: topLeft.x,
220:                                 y: topLeft.y,
221:                                 width: bottomRight.x - topLeft.x,
222:                                 height: bottomRight.y - topLeft.y)
223:     }
224:     
225:     private func getDragLocation(originalDragLocation: CGPoint, handle: HandlePosition) -> CGPoint {
226:         guard self.keepAspectRatio else {
227:             return originalDragLocation
228:         }
229:         
230:         let line = {
231:             switch handle {
232:             case .bottomLeft, .topRight:
233:                 return MathUtils.getLine(ofLinePassingThrough: self.bottomLeft, and: self.topRight)
234:             case .bottomRight, .topLeft:
235:                 return MathUtils.getLine(ofLinePassingThrough: self.bottomRight, and: self.topLeft)
236:             }
237:         }()
238:         return line.closestPoint(toPoint: originalDragLocation)
239:     }
240: }
241: 
242: fileprivate extension ImageResizableView.HandlePosition {
243:     func getPosition(forParentViewSize parentViewSize: CGSize, parentCenter: CGPoint) -> CGPoint {
244:         switch self {
245:         case .bottomLeft: return CGPoint(x: parentCenter.x - parentViewSize.width / 2,
246:                                          y: parentCenter.y + parentViewSize.height / 2)
247:         case .bottomRight: return CGPoint(x: parentCenter.x + parentViewSize.width / 2,
248:                                           y: parentCenter.y + parentViewSize.height / 2)
249:         case .topLeft: return CGPoint(x: parentCenter.x - parentViewSize.width / 2,
250:                                       y: parentCenter.y - parentViewSize.height / 2)
251:         case .topRight: return CGPoint(x: parentCenter.x + parentViewSize.width / 2,
252:                                        y: parentCenter.y - parentViewSize.height / 2)
253:         }
254:     }
255: }
256: 
257: fileprivate extension CGPoint {
258:     func getBoundedPoint(containerSize: CGSize,
259:                          margin: CGFloat,
260:                          keepAspectRatio: Bool,
261:                          originalPoint: CGPoint) -> CGPoint {
262:         if keepAspectRatio {
263:             // If aspect ratio must be kept, discard any change outside margins.
264:             if self.x < margin
265:                 || self.x > containerSize.width - margin
266:                 || self.y < margin
267:                 || self.y > containerSize.height - margin {
268:                 return originalPoint
269:             } else {
270:                 return self
271:             }
272:         } else {
273:             return CGPoint(
274:                 x: min(max(self.x, margin), containerSize.width - margin),
275:                 y: min(max(self.y, margin), containerSize.height - margin)
276:             )
277:         }
278:     }
279: }
280: 
281: struct ImageResizableView_Previews: PreviewProvider {
282:     
283:     static let imageSize: CGSize = CGSize(width: 200, height: 200)
284:     
285:     static var previews: some View {
286:         if let image = UIImage(named: "gallery") {
287:             GeometryReader { geometryReader in
288:                 ImageResizableView(
289:                     uiImage: image,
290:                     imageRect: .constant(CGRect(x: geometryReader.size.width * 0.5 - imageSize.width / 2,
291:                                                 y: geometryReader.size.height * 0.5 - imageSize.height / 2,
292:                                                 width: imageSize.width,
293:                                                 height: imageSize.height)),
294:                     borderColor: .red,
295:                     borderWidth: 2,
296:                     handleColor: .white,
297:                     handleSize: 10,
298:                     handleTapSize: 50,
299:                     keepAspectRatio: true
300:                 )
301:             }
302:         } else {
303:             Spacer()
304:         }
305:     }
306: }
```

## File: pdfexpert/Utils/UI/LoadingView.swift
```swift
 1: //
 2: //  LoadingView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 03/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: extension View {
11:     
12:     func loadingView(show: Binding<Bool>) -> some View {
13:         return self.modifier(
14:             LoadingView(show: show, loadingView: { ProgressView() })
15:         )
16:     }
17:     
18:     func loadingView<T: View>(
19:         show: Binding<Bool>,
20:         @ViewBuilder loadingView: @escaping () -> T) -> some View {
21:         return self.modifier(
22:             LoadingView(show: show, loadingView: loadingView)
23:         )
24:     }
25: }
26: 
27: struct LoadingView<T: View>: ViewModifier {
28:     
29:     @Binding var show: Bool
30:     
31:     var loadingView: (() -> T)
32:     
33:     init(show: Binding<Bool>,
34:          loadingView: @escaping (() -> T)) {
35:         self._show = show
36:         self.loadingView = loadingView
37:     }
38:     
39:     func body(content: Content) -> some View {
40:         ZStack {
41:             content
42:                 .allowsHitTesting(!self.show)
43:             if self.show {
44:                 self.loadingView()
45:             }
46:         }
47:     }
48: }
```

## File: pdfexpert/Utils/UI/LottieView.swift
```swift
 1: //
 2: //  LottieView.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 23/02/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Lottie
10: 
11: struct LottieView: UIViewRepresentable {
12:     let animationView = LottieAnimationView()
13:     var filename = "loading"
14:     
15:     func makeUIView(context: Context) -> some UIView {
16:         let view = UIView()
17:         
18:         let animation = LottieAnimation.named(filename)
19:         animationView.animation = animation
20:         animationView.contentMode = .scaleAspectFit
21:         animationView.play()
22:         
23:         animationView.translatesAutoresizingMaskIntoConstraints = false
24:         view.addSubview(animationView)
25:         
26:         NSLayoutConstraint.activate([
27:             animationView.heightAnchor.constraint(equalTo: view.heightAnchor),
28:             animationView.widthAnchor.constraint(equalTo: view.widthAnchor),
29:         ])
30:         
31:         return view
32:     }
33:     
34:     func updateUIView(_ uiView: UIViewType, context: Context) {}
35:     
36:     func loop(autoReverse: Bool = false) -> Self {
37:         let view = self
38:         view.animationView.loopMode = autoReverse ? .autoReverse : .loop
39:         return view
40:     }
41: }
42: 
43: struct LottieView_Previews: PreviewProvider {
44:     static var previews: some View {
45:         LottieView()
46:     }
47: }
```

## File: pdfexpert/Utils/UI/PageControl.swift
```swift
 1: //
 2: //  PageControl.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/04/23.
 6: //
 7: 
 8: import SwiftUI
 9: import UIKit
10: 
11: struct PageControl: UIViewRepresentable {
12:     
13:     var currentPageIndex: Int
14:     var numberOfPages: Int
15:     var currentPageColor: Color
16:     var normalPageColor: Color
17:     var enableInteraction: Bool
18:     
19:     func makeUIView(context: Context) -> UIPageControl {
20:         let pageControl = UIPageControl()
21:         pageControl.pageIndicatorTintColor = UIColor(self.normalPageColor)
22:         pageControl.currentPageIndicatorTintColor = UIColor(self.currentPageColor)
23:         pageControl.numberOfPages = self.numberOfPages
24:         pageControl.isUserInteractionEnabled = self.enableInteraction
25:         return pageControl
26:     }
27:     
28:     func updateUIView(_ uiView: UIPageControl, context: Context) {
29:         uiView.currentPage = self.currentPageIndex
30:     }
31: }
32: 
33: struct PageControl_Previews: PreviewProvider {
34:     static var previews: some View {
35:         PageControl(currentPageIndex: 0,
36:                     numberOfPages: 3,
37:                     currentPageColor: .red,
38:                     normalPageColor: .blue,
39:                     enableInteraction: false)
40:     }
41: }
```

## File: pdfexpert/Utils/UI/PdfKitView.swift
```swift
  1: //
  2: //  PdfKitView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 11/04/23.
  6: //
  7: 
  8: import SwiftUI
  9: import PDFKit
 10: 
 11: struct PdfKitView: UIViewRepresentable {
 12:     typealias UIViewType = PDFView
 13:     typealias OnTapPageCallback = ((PDFPage?) -> ())
 14:     typealias ViewToPageRectConversionCallback = ((CGRect) -> ())
 15: 
 16:     let pdfDocument: PDFDocument?
 17:     let singlePage: Bool
 18:     let pageMargins: UIEdgeInsets?
 19:     let currentPage: Int?
 20:     let backgroundColor: UIColor?
 21:     let usePaginator: Bool
 22:     let onTapPage: OnTapPageCallback?
 23:     var viewRect: Binding<CGRect>?
 24:     var viewToPageRectConversionCallback: ViewToPageRectConversionCallback?
 25: 
 26:     init(
 27:         pdfDocument: PDFDocument?,
 28:         singlePage: Bool = false,
 29:         pageMargins: UIEdgeInsets? = nil,
 30:         currentPage: Int? = nil,
 31:         backgroundColor: UIColor? = nil,
 32:         usePaginator: Bool = false,
 33:         onTapPage: OnTapPageCallback? = nil,
 34:         viewRect: Binding<CGRect>? = nil,
 35:         viewToPageRectConversionCallback: ViewToPageRectConversionCallback? = nil
 36:     ) {
 37:         self.pdfDocument = pdfDocument
 38:         self.singlePage = singlePage
 39:         self.pageMargins = pageMargins
 40:         self.currentPage = currentPage
 41:         self.backgroundColor = backgroundColor
 42:         self.usePaginator = usePaginator
 43:         self.onTapPage = onTapPage
 44:         self.viewRect = viewRect
 45:         self.viewToPageRectConversionCallback = viewToPageRectConversionCallback
 46:     }
 47: 
 48:     func makeUIView(context: Context) -> UIViewType {
 49:         let pdfView = PDFView()
 50:         self.updatePdfView(pdfView)
 51:         if nil != self.onTapPage {
 52:             let tapGesture = UITapGestureRecognizer(target: context.coordinator,
 53:                                                     action: #selector(context.coordinator.onTap))
 54:             tapGesture.delegate = context.coordinator
 55:             pdfView.addGestureRecognizer(tapGesture)
 56:         }
 57:         return pdfView
 58:     }
 59:     
 60:     func makeCoordinator() -> PdfKitViewCoordinator {
 61:         PdfKitViewCoordinator(onTapPage: { [self] tap in
 62:             guard let onTapPage = self.onTapPage,
 63:                   let pdfView = tap.view as? PDFView else { return }
 64:             let position = tap.location(in: tap.view)
 65:             onTapPage(pdfView.page(for: position, nearest: false))
 66:         })
 67:     }
 68: 
 69:     func updateUIView(_ pdfView: UIViewType, context: Context) {
 70:         self.updatePdfView(pdfView)
 71:         if let page = pdfView.currentPage, let viewRect = self.viewRect?.wrappedValue {
 72:             self.viewToPageRectConversionCallback?(pdfView.convert(viewRect, to: page))
 73:         }
 74:     }
 75:     
 76:     private func updatePdfView(_ pdfView: UIViewType) {
 77:         pdfView.document = self.pdfDocument
 78:         pdfView.autoScales = true
 79:         self.updateBackground(pdfView: pdfView)
 80:         self.updateSinglePage(pdfView: pdfView)
 81:         self.updatePageMargins(pdfView: pdfView)
 82:         self.updateCurrentPage(pdfView: pdfView)
 83:         self.updateUsePaginator(pdfView: pdfView)
 84:     }
 85:     
 86:     private func updateBackground(pdfView: UIViewType) {
 87:         if let backgroundColor = self.backgroundColor {
 88:             pdfView.backgroundColor = backgroundColor
 89:         }
 90:     }
 91:     
 92:     private func updateSinglePage(pdfView: UIViewType) {
 93:         if self.singlePage {
 94:             pdfView.displayMode = .singlePage
 95:         }
 96:     }
 97:     
 98:     private func updatePageMargins(pdfView: UIViewType) {
 99:         if let pageMargins = self.pageMargins {
100:             pdfView.pageBreakMargins = pageMargins
101:         }
102:     }
103:     
104:     private func updateCurrentPage(pdfView: UIViewType) {
105:         if let currentPage = self.currentPage,
106:            currentPage >= 0,
107:            currentPage < self.pdfDocument?.pageCount ?? 0,
108:            let page = self.pdfDocument?.page(at: currentPage) {
109:             pdfView.go(to: page)
110:         }
111:     }
112:     
113:     private func updateUsePaginator(pdfView: UIViewType) {
114:         pdfView.usePageViewController(self.usePaginator)
115:     }
116: }
117: 
118: class PdfKitViewCoordinator: NSObject, UIGestureRecognizerDelegate {
119:     
120:     typealias OnTapPageCallback = ((UITapGestureRecognizer) -> ())
121:     
122:     let onTapPage: OnTapPageCallback?
123: 
124:     init(onTapPage: OnTapPageCallback? = nil) {
125:         self.onTapPage = onTapPage
126:     }
127:     
128:     @objc func onTap(sender: UITapGestureRecognizer) {
129:         self.onTapPage?(sender)
130:     }
131: }
132: 
133: struct PdfKitView_Previews: PreviewProvider {
134:     static var previews: some View {
135:         PdfKitView(
136:             pdfDocument: K.Test.DebugPdfDocument,
137:             singlePage: false,
138:             pageMargins: nil,
139:             currentPage: nil,
140:             backgroundColor: nil,
141:             usePaginator: true,
142:             onTapPage: { page in print("Test Tap. Page hash: \(page.hashValue)") }
143:         )
144:     }
145: }
```

## File: pdfexpert/Utils/UI/PdfKitViewBinder.swift
```swift
 1: //
 2: //  PdfKitViewBinder.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 29/05/23.
 6: //
 7: 
 8: import SwiftUI
 9: import PDFKit
10: 
11: struct PdfKitViewBinder: UIViewRepresentable {
12:     typealias UIViewType = PDFView
13: 
14:     @Binding var pdfView: PDFView
15:     let singlePage: Bool
16:     let pageMargins: UIEdgeInsets?
17:     let backgroundColor: UIColor?
18:     let usePaginator: Bool
19: 
20:     init(
21:         pdfView: Binding<PDFView>,
22:         singlePage: Bool = false,
23:         pageMargins: UIEdgeInsets? = nil,
24:         backgroundColor: UIColor? = nil,
25:         usePaginator: Bool = false
26:     ) {
27:         self._pdfView = pdfView
28:         self.singlePage = singlePage
29:         self.pageMargins = pageMargins
30:         self.backgroundColor = backgroundColor
31:         self.usePaginator = usePaginator
32:     }
33: 
34:     func makeUIView(context: Context) -> UIViewType {
35:         self.updatePdfView(self.pdfView)
36:         return pdfView
37:     }
38: 
39:     func updateUIView(_ pdfView: UIViewType, context: Context) {
40:         self.updatePdfView(pdfView)
41:     }
42:     
43:     private func updatePdfView(_ pdfView: UIViewType) {
44:         self.updateScale(pdfView: pdfView)
45:         self.updateBackground(pdfView: pdfView)
46:         self.updateSinglePage(pdfView: pdfView)
47:         self.updatePageMargins(pdfView: pdfView)
48:         self.updateUsePaginator(pdfView: pdfView)
49:     }
50:     
51:     private func updateScale(pdfView: UIViewType) {
52:         pdfView.autoScales = true
53:         let minScaleFactor = pdfView.scaleFactorForSizeToFit
54:         if minScaleFactor > 0 {
55:             pdfView.minScaleFactor = minScaleFactor
56:         }
57:     }
58:     
59:     private func updateBackground(pdfView: UIViewType) {
60:         if let backgroundColor = self.backgroundColor {
61:             pdfView.backgroundColor = backgroundColor
62:         }
63:     }
64:     
65:     private func updateSinglePage(pdfView: UIViewType) {
66:         if self.singlePage {
67:             pdfView.displayMode = .singlePage
68:         }
69:     }
70:     
71:     private func updatePageMargins(pdfView: UIViewType) {
72:         if let pageMargins = self.pageMargins {
73:             pdfView.pageBreakMargins = pageMargins
74:         }
75:     }
76:     
77:     private func updateUsePaginator(pdfView: UIViewType) {
78:         pdfView.usePageViewController(self.usePaginator)
79:     }
80: }
81: 
82: struct PdfKitViewBinder_Previews: PreviewProvider {
83:     
84:     static let pdfView = {
85:         let pdfView = PDFView()
86:         pdfView.document = K.Test.DebugPdfDocument
87:         return pdfView
88:     }()
89:     
90:     static var previews: some View {
91:         PdfKitViewBinder(
92:             pdfView: .constant(pdfView),
93:             singlePage: false,
94:             pageMargins: nil,
95:             backgroundColor: nil,
96:             usePaginator: true
97:         )
98:     }
99: }
```

## File: pdfexpert/Utils/UI/PencilKitView.swift
```swift
 1: //
 2: //  PencilKitView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 19/05/23.
 6: //
 7: 
 8: import SwiftUI
 9: import PencilKit
10: import UIKit
11: 
12: struct PencilKitView: UIViewRepresentable {
13:     
14:     @Binding var canvasView: PKCanvasView
15:     
16:     let backgroundColor: Color
17:     let inkColor: Color
18:     let onSaved: () -> Void
19:     
20:     func makeUIView(context: Context) -> PKCanvasView {
21:         self.canvasView.drawingPolicy = .anyInput
22:         
23:         // Needed to prevent dark colors (e.g: black) to be converted to bright colors
24:         // (and vice versa) in case of dark mode.
25:         self.canvasView.overrideUserInterfaceStyle = .light
26:         
27:         self.canvasView.tool = PKInkingTool(.pen, color: UIColor(self.inkColor), width: 15)
28:         self.canvasView.backgroundColor = UIColor(self.backgroundColor)
29:         
30:         return self.canvasView
31:     }
32:     
33:     func updateUIView(_ canvasView: PKCanvasView, context: Context) {}
34: }
35: 
36: struct PencilKitView_Previews: PreviewProvider {
37:     
38:     static let canvasView = PKCanvasView()
39:     
40:     static var previews: some View {
41:         PencilKitView(canvasView: .constant(canvasView),
42:                       backgroundColor: .white,
43:                       inkColor: .black,
44:                       onSaved: { print("PencilKitView - On Saved") })
45:     }
46: }
```

## File: pdfexpert/Utils/UI/PopupView.swift
```swift
 1: //
 2: //  PopupView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 31/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct PopupView<PopupContent: View>: ViewModifier {
11: 
12:     @Binding var isPresenting: Bool
13:     let backgroundColor: Color
14:     let tapToDismiss: Bool
15:     var popupContent: () -> PopupContent
16:     
17:     private var screen: CGRect {
18:         return UIScreen.main.bounds
19:     }
20: 
21:     func body(content: Content) -> some View {
22:         content
23:             .overlay(
24:                 ZStack{
25:                     if self.isPresenting {
26:                         self.backgroundView
27:                         HStack {
28:                             Spacer()
29:                             VStack {
30:                                 Spacer()
31:                                 self.popupContent()
32:                                     .transition(.move(edge: .bottom))
33:                                 Spacer()
34:                             }
35:                             Spacer()
36:                         }
37:                         .transition(.move(edge: .bottom))
38:                     }
39:                 }.frame(width: self.screen.width,
40:                         height: self.screen.height)
41:                 .edgesIgnoringSafeArea(.all)
42:                 .animation(.easeOut, value: self.isPresenting)
43:             )
44:     }
45:     
46:     @ViewBuilder var backgroundView: some View {
47:         let color = self.backgroundColor
48:         if self.tapToDismiss {
49:             color.onTapGesture {
50:                 self.isPresenting = false
51:             }
52:         } else {
53:             color
54:         }
55:     }
56: }
57: 
58: extension View {
59:     func popup<PopupContent: View> (
60:         isPresenting: Binding<Bool>,
61:         backgroundColor: Color = Color.black.opacity(0.3),
62:         tapToDismiss: Bool = true,
63:         @ViewBuilder popupContent: @escaping () -> PopupContent
64:     ) -> some View {
65:         self.modifier(PopupView(isPresenting: isPresenting,
66:                                 backgroundColor: backgroundColor,
67:                                 tapToDismiss: tapToDismiss,
68:                                 popupContent: popupContent))
69:     }
70: }
71: 
72: struct PopupView_Previews: PreviewProvider {
73:     
74:     static var previews: some View {
75:         Color.white
76:         .popup(
77:             isPresenting: .constant(true)
78:         ) {
79:             Color.red.frame(width: 200, height: 300)
80:         }
81:     }
82: }
```

## File: pdfexpert/Utils/UI/RoundedCorner.swift
```swift
 1: //
 2: //  RoundedCorner.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 29/03/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: struct RoundedCorner: Shape {
12: 
13:     var radius: CGFloat = .infinity
14:     var corners: UIRectCorner = .allCorners
15: 
16:     func path(in rect: CGRect) -> Path {
17:         let path = UIBezierPath(roundedRect: rect,
18:                                 byRoundingCorners: self.corners,
19:                                 cornerRadii: CGSize(width: self.radius,
20:                                                     height: self.radius))
21:         return Path(path.cgPath)
22:     }
23: }
24: 
25: extension View {
26:     func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
27:         self.clipShape( RoundedCorner(radius: radius, corners: corners) )
28:     }
29: }
```

## File: pdfexpert/Utils/UI/SizePrinter.swift
```swift
 1: //
 2: //  SizePrinter.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 01/06/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: struct SizePrinter: ViewModifier {
12:     
13:     @State var size: CGSize = .zero { didSet { print("SizePrinter - size: \(self.size)") } }
14:     
15:     func body(content: Content) -> some View {
16:         content
17:             .background(
18:                 GeometryReader { proxy in
19:                     Color.clear // we just want the reader to get triggered, so let's use an empty color
20:                         .onAppear {
21:                             self.size = proxy.size
22:                         }
23:                 }
24:             )
25:     }
26: }
27: 
28: extension View {
29:     func printSize() -> some View {
30:         modifier(SizePrinter())
31:     }
32: }
```

## File: pdfexpert/Utils/UI/TextResizableView.swift
```swift
  1: //
  2: //  TextResizableView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 26/05/23.
  6: //
  7: 
  8: import SwiftUI
  9: import UIKit
 10: 
 11: typealias TextResizableViewDeleteCallback = (() -> ())
 12: 
 13: struct TextResizableViewData {
 14:     var text: String
 15:     var rect: CGRect
 16: }
 17: 
 18: struct TextResizableView: View {
 19:     
 20:     enum FocusField: Hashable {
 21:         case field
 22:     }
 23:     
 24:     @Binding var data: TextResizableViewData
 25:     let fontName: String
 26:     let fontColor: UIColor
 27:     let color: Color
 28:     let borderWidth: CGFloat
 29:     let minSize: CGSize
 30:     let handleSize: CGFloat
 31:     let handleTapSize: CGFloat
 32:     let deleteCallback: TextResizableViewDeleteCallback
 33:     let suggestedWords: [String]
 34:     
 35:     @State private var tapOffset: CGPoint? = nil
 36:     @FocusState private var focusedField: FocusField?
 37:     @State private var filteredSuggestedWords: [String] = []
 38:     
 39:     private var topLeft: CGPoint {
 40:         self.data.rect.origin
 41:     }
 42:     
 43:     private var bottomRight: CGPoint {
 44:         CGPoint(x: self.data.rect.origin.x + self.data.rect.size.width,
 45:                 y: self.data.rect.origin.y + self.data.rect.size.height)
 46:     }
 47:     
 48:     private var computedCenter: CGPoint {
 49:         CGPoint(x: self.topLeft.x + (self.bottomRight.x - self.topLeft.x) / 2,
 50:                 y: self.topLeft.y + (self.bottomRight.y - self.topLeft.y) / 2)
 51:     }
 52:     
 53:     private var computedSize: CGSize {
 54:         CGSize(width: self.bottomRight.x - self.topLeft.x,
 55:                height: self.bottomRight.y - self.topLeft.y)
 56:     }
 57:     
 58:     private var font: UIFont {
 59:         UIFont.font(named: self.fontName,
 60:                     fitting: self.data.text,
 61:                     into: self.computedSize,
 62:                     with: [:],
 63:                     options: [])
 64:     }
 65:     
 66:     init(data: Binding<TextResizableViewData>,
 67:          fontName: String,
 68:          fontColor: UIColor,
 69:          color: Color,
 70:          borderWidth: CGFloat,
 71:          minSize: CGSize,
 72:          handleSize: CGFloat,
 73:          handleTapSize: CGFloat,
 74:          suggestedWords: [String],
 75:          deleteCallback: @escaping TextResizableViewDeleteCallback) {
 76:         self._data = data
 77:         self.fontName = fontName
 78:         self.fontColor = fontColor
 79:         self.color = color
 80:         self.borderWidth = borderWidth
 81:         self.minSize = minSize
 82:         self.handleSize = handleSize
 83:         self.handleTapSize = handleTapSize
 84:         self.suggestedWords = suggestedWords
 85:         self.deleteCallback = deleteCallback
 86:     }
 87:     
 88:     var body: some View {
 89:         ZStack {
 90:             Rectangle()
 91:                 .foregroundColor(.clear)
 92:                 .contentShape(Rectangle())
 93:                 .allowsHitTesting(self.focusedField == .field)
 94:                 .onTapGesture {
 95:                     self.focusedField = .none
 96:                 }
 97:             GeometryReader { parentGeometryReader in
 98:                 ZStack {
 99:                     GeometryReader { _ in
100:                         TextField("", text: self.$data.text)
101:                             .multilineTextAlignment(.center)
102:                             .lineLimit(1)
103:                             .font(Font(self.font))
104:                             .foregroundColor(Color(self.fontColor))
105:                             .focused(self.$focusedField, equals: .field)
106:                             .onAppear {
107:                                 self.tapOffset = nil
108:                                 // Dispatch on main thread is currently necessary
109:                                 // to avoid memory leak on the view model of the parent view.
110:                                 DispatchQueue.main.async {
111:                                     self.focusedField = .field
112:                                 }
113:                             }
114:                             .contentShape(Rectangle())
115:                             .frame(width: self.computedSize.width, height: self.computedSize.height)
116:                             .background(Rectangle().stroke(self.color, lineWidth: self.borderWidth))
117:                             .position(self.computedCenter)
118:                             .gesture(
119:                                 DragGesture()
120:                                     .onChanged { gesture in
121:                                         self.OnDrag(dragGestureValue: gesture,
122:                                                     parentViewSize: parentGeometryReader.size)
123:                                     }
124:                                     .onEnded { _ in self.tapOffset = nil }
125:                             )
126:                             .toolbar {
127:                                 ToolbarItem(placement: .keyboard) {
128:                                     ScrollView(.horizontal, showsIndicators: false) {
129:                                         HStack(spacing: 8) {
130:                                             ForEach(self.filteredSuggestedWords, id: \.self) { suggestedWord in
131:                                                 Button(action: {
132:                                                     self.data.text = suggestedWord
133:                                                 }) {
134:                                                     Text(suggestedWord)
135:                                                         .foregroundColor(ColorPalette.primaryText)
136:                                                         .font(FontCategory.body2.font.bold())
137:                                                         .padding([.trailing, .leading], 8)
138:                                                 }
139:                                                 .background(ColorPalette.secondaryText)
140:                                                 .clipShape(Capsule())
141:                                             }
142:                                         }
143:                                     }
144:                                 }
145:                             }
146:                             .onChange(of: self.data.text) { _ in
147:                                 self.updateFilteredSuggestedWords()
148:                             }
149:                     }
150:                     self.getResizeHandle(parentViewSize: parentGeometryReader.size)
151:                     self.getDeleteButton(parentViewSize: parentGeometryReader.size)
152:                 }
153:             }
154:         }
155:     }
156:     
157:     private func OnDrag(dragGestureValue: DragGesture.Value, parentViewSize: CGSize) {
158:         
159:         let location = dragGestureValue.location
160:         let center = self.computedCenter
161:         let size = self.computedSize
162:         
163:         if self.tapOffset == nil {
164:             self.tapOffset = CGPoint(x: dragGestureValue.startLocation.x - center.x,
165:                                           y: dragGestureValue.startLocation.y - center.y)
166:         }
167:         
168:         guard let tapOffset = self.tapOffset else {
169:             return
170:         }
171:         
172:         var newCenterX = location.x - tapOffset.x
173:         newCenterX = max(min(newCenterX, parentViewSize.width - size.width / 2), size.width / 2)
174:         var newCenterY = location.y - tapOffset.y
175:         newCenterY = max(min(newCenterY, parentViewSize.height - size.height / 2), size.height / 2)
176:         
177:         let currentEventTranslation: CGPoint = CGPoint(x: newCenterX - center.x,
178:                                                        y: newCenterY - center.y)
179:         let bottomRight = CGPoint(x: self.bottomRight.x + currentEventTranslation.x,
180:                                   y: self.bottomRight.y + currentEventTranslation.y)
181:         let topLeft = CGPoint(x: self.topLeft.x + currentEventTranslation.x,
182:                               y: self.topLeft.y + currentEventTranslation.y)
183:         self.updateRect(topLeft: topLeft, bottomRight: bottomRight, text: self.data.text)
184:     }
185:     
186:     private func onResizeDrag(dragGestureValue: DragGesture.Value, parentViewSize: CGSize) {
187:         
188:         let location = dragGestureValue.location
189:         
190:         var bottomRight = CGPoint(x: location.x,y: location.y)
191:             .getBoundedPoint(containerSize: parentViewSize, margin: self.handleSize / 2)
192:         bottomRight = CGPoint(
193:             x: max(bottomRight.x, self.topLeft.x + self.minSize.width),
194:             y: max(bottomRight.y, self.topLeft.y + self.minSize.height)
195:         )
196:         
197:         self.updateRect(topLeft: self.topLeft, bottomRight: bottomRight, text: self.data.text)
198:     }
199: 
200:     private func getResizeHandle(parentViewSize: CGSize) -> some View {
201:         ZStack {
202:             Circle()
203:                 .frame(width: self.handleSize, height: self.handleSize)
204:                 .foregroundColor(.white)
205:             Image(systemName: "arrow.up.left.and.arrow.down.right.circle.fill")
206:                 .resizable()
207:                 .frame(width: self.handleSize, height: self.handleSize)
208:                 .foregroundColor(self.color)
209:         }
210:         .frame(width: self.handleTapSize, height: self.handleTapSize)
211:         .contentShape(Circle())
212:         .position(CGPoint(x: self.computedCenter.x + self.computedSize.width / 2,
213:                           y: self.computedCenter.y + self.computedSize.height / 2))
214:         .gesture(
215:             DragGesture()
216:                 .onChanged { gesture in
217:                     self.onResizeDrag(dragGestureValue: gesture, parentViewSize: parentViewSize)
218:                 }
219:         )
220:     }
221:     
222:     private func getDeleteButton(parentViewSize: CGSize) -> some View {
223:         Button(action: { self.deleteCallback() }) {
224:             ZStack {
225:                 Circle()
226:                     .frame(width: self.handleSize, height: self.handleSize)
227:                     .foregroundColor(.white)
228:                 Image(systemName: "trash.circle.fill")
229:                     .resizable()
230:                     .frame(width: self.handleSize, height: self.handleSize)
231:                     .foregroundColor(self.color)
232:             }
233:         }
234:         .frame(width: self.handleTapSize, height: self.handleTapSize)
235:         .contentShape(Circle())
236:         .position(CGPoint(x: self.computedCenter.x - self.computedSize.width / 2,
237:                           y: self.computedCenter.y - self.computedSize.height / 2))
238:     }
239: 
240:     private func updateRect(topLeft: CGPoint, bottomRight: CGPoint, text: String) {
241:         let rect = CGRect(x: topLeft.x,
242:                           y: topLeft.y,
243:                           width: bottomRight.x - topLeft.x,
244:                           height: bottomRight.y - topLeft.y)
245:         self.data = TextResizableViewData(text: self.data.text, rect: rect)
246:     }
247:     
248:     private func updateFilteredSuggestedWords() {
249:         self.filteredSuggestedWords = self.suggestedWords
250:             .filter { $0.hasPrefix(self.data.text) && !self.data.text.isEmpty && $0 != self.data.text }
251:     }
252: }
253: 
254: fileprivate extension CGPoint {
255:     func getBoundedPoint(containerSize: CGSize, margin: CGFloat) -> CGPoint {
256:         return CGPoint(
257:             x: min(max(self.x, margin), containerSize.width - margin),
258:             y: min(max(self.y, margin), containerSize.height - margin)
259:         )
260:     }
261: }
262: 
263: struct TextResizableView_Previews: PreviewProvider {
264:     
265:     static let size: CGSize = CGSize(width: 100, height: 50)
266:     static let text: String = "Test String"
267:     
268:     static var previews: some View {
269:         GeometryReader { geometryReader in
270:             TextResizableView(data: .constant(getData(forParentSize: geometryReader.size)),
271:                               fontName: "Arial",
272:                               fontColor: .white,
273:                               color: .orange,
274:                               borderWidth: 4,
275:                               minSize: CGSize(width: 5, height: 5),
276:                               handleSize: 25,
277:                               handleTapSize: 50,
278:                               suggestedWords: ["Merlin", "Wizard", "North-West Tower"],
279:                               deleteCallback: { print("TextResizableView_Previews - Delete callback called!") })
280:             .position(x: geometryReader.size.width/2, y: geometryReader.size.height/2)
281:             .frame(width: geometryReader.size.width, height: geometryReader.size.height)
282:         }
283:     }
284:     
285:     private static func getData(forParentSize parentSize: CGSize) -> TextResizableViewData {
286:         TextResizableViewData(text: text, rect: getRect(forParentSize: parentSize))
287:     }
288:     
289:     private static func getRect(forParentSize parentSize: CGSize) -> CGRect {
290:         CGRect(x: parentSize.width * 0.5 - size.width / 2,
291:                y: parentSize.height * 0.5 - size.height / 2,
292:                width: size.width,
293:                height: size.height)
294:     }
295: }
```

## File: pdfexpert/Utils/UI/UnderlyingError.swift
```swift
 1: //
 2: //  UnderlyingError.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 02/03/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: protocol UnderlyingError: Error {
11:     static func getUnknownError() -> Self
12:     static func getUnderlyingError(errorDescription: String) -> Self
13:     static func convertUnderlyingError(fromError error: Error) -> Self?
14: }
15: 
16: extension Error {
17:     static func getSelfError(forError error: Error) -> Self? {
18:         return error as? Self
19:     }
20: }
21: 
22: extension UnderlyingError {
23:     static func convertError(fromError error: Error) -> Self {
24:         return Self.getSelfError(forError: error) ?? Self.convertUnderlyingError(fromError: error) ?? Self.getUnknownError()
25:     }
26:     
27:     static func convertUnderlyingError(fromError error: Error) -> Self? {
28:         return Self.getUnderlyingError(errorDescription: error.localizedDescription)
29:     }
30: }
```

## File: pdfexpert/Utils/UI/ZoomImageModifier.swift
```swift
  1: import SwiftUI
  2: import UIKit
  3: 
  4: struct ZoomImageModifier: ViewModifier {
  5:     private var contentSize: CGSize
  6:     private var min: CGFloat = 1.0
  7:     private var max: CGFloat = 3.0
  8:     @State var currentScale: CGFloat = 1.0
  9: 
 10:     init(contentSize: CGSize) {
 11:         self.contentSize = contentSize
 12:     }
 13:     
 14:     var doubleTapGesture: some Gesture {
 15:         TapGesture(count: 2).onEnded {
 16:             if currentScale <= min { currentScale = max } else
 17:             if currentScale >= max { currentScale = min } else {
 18:                 currentScale = ((max - min) * 0.5 + min) < currentScale ? max : min
 19:             }
 20:         }
 21:     }
 22:     
 23:     func body(content: Content) -> some View {
 24:         ScrollView([.horizontal, .vertical]) {
 25:             content
 26:                 .frame(width: contentSize.width * currentScale, height: contentSize.height * currentScale, alignment: .center)
 27:                 .modifier(PinchToZoom(minScale: min, maxScale: max, scale: $currentScale))
 28:         }
 29:         .gesture(doubleTapGesture)
 30:         .animation(.easeInOut, value: currentScale)
 31:     }
 32: }
 33: 
 34: class PinchZoomView: UIView {
 35:     let minScale: CGFloat
 36:     let maxScale: CGFloat
 37:     var isPinching: Bool = false
 38:     var scale: CGFloat = 1.0
 39:     let scaleChange: (CGFloat) -> Void
 40:     
 41:     init(minScale: CGFloat,
 42:            maxScale: CGFloat,
 43:          currentScale: CGFloat,
 44:          scaleChange: @escaping (CGFloat) -> Void) {
 45:         self.minScale = minScale
 46:         self.maxScale = maxScale
 47:         self.scale = currentScale
 48:         self.scaleChange = scaleChange
 49:         super.init(frame: .zero)
 50:         let pinchGesture = UIPinchGestureRecognizer(target: self, action: #selector(pinch(gesture:)))
 51:         pinchGesture.cancelsTouchesInView = false
 52:         addGestureRecognizer(pinchGesture)
 53:     }
 54:     
 55:     required init?(coder: NSCoder) {
 56:         fatalError()
 57:     }
 58:     
 59:     @objc private func pinch(gesture: UIPinchGestureRecognizer) {
 60:         switch gesture.state {
 61:         case .began:
 62:             isPinching = true
 63:             
 64:         case .changed, .ended:
 65:             if gesture.scale <= minScale {
 66:                 scale = minScale
 67:             } else if gesture.scale >= maxScale {
 68:                 scale = maxScale
 69:             } else {
 70:                 scale = gesture.scale
 71:             }
 72:             scaleChange(scale)
 73:         case .cancelled, .failed:
 74:             isPinching = false
 75:             scale = 1.0
 76:         default:
 77:             break
 78:         }
 79:     }
 80: }
 81: 
 82: struct PinchZoom: UIViewRepresentable {
 83:     let minScale: CGFloat
 84:     let maxScale: CGFloat
 85:     @Binding var scale: CGFloat
 86:     @Binding var isPinching: Bool
 87:     
 88:     func makeUIView(context: Context) -> PinchZoomView {
 89:         let pinchZoomView = PinchZoomView(minScale: minScale, maxScale: maxScale, currentScale: scale, scaleChange: { scale = $0 })
 90:         return pinchZoomView
 91:     }
 92:     
 93:     func updateUIView(_ pageControl: PinchZoomView, context: Context) { }
 94: }
 95: 
 96: struct PinchToZoom: ViewModifier {
 97:     let minScale: CGFloat
 98:     let maxScale: CGFloat
 99:     @Binding var scale: CGFloat
100:     @State var anchor: UnitPoint = .center
101:     @State var isPinching: Bool = false
102:     
103:     func body(content: Content) -> some View {
104:         content
105:             .scaleEffect(scale, anchor: anchor)
106:             .animation(.spring(), value: isPinching)
107:             .overlay(PinchZoom(minScale: minScale, maxScale: maxScale, scale: $scale, isPinching: $isPinching))
108:     }
109: }
```

## File: pdfexpert/Utils/Async.swift
```swift
  1: //
  2: //  Async.swift
  3: //  ChatAI
  4: //
  5: //  Created by Pcnaid Inc on 23/02/23.
  6: //
  7: 
  8: import Foundation
  9: import SwiftUI
 10: 
 11: protocol AsyncLoadable {
 12:     var isLoading: Bool { get }
 13:     func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool) -> Self
 14: }
 15: 
 16: protocol AsyncFailable {
 17:     
 18:     associatedtype E: LocalizedError
 19:     
 20:     var error: E? { get }
 21:     static var resetState: Self { get }
 22: }
 23: 
 24: enum AsyncOperationStatus<T, E: LocalizedError> {
 25:     case empty
 26:     case data(T)
 27:     case error(E)
 28:     case loading(Progress)
 29: }
 30: 
 31: struct AsyncOperation<T, E: LocalizedError> {
 32:     let status: AsyncOperationStatus<T, E>
 33: }
 34: 
 35: extension AsyncOperation: AsyncLoadable, AsyncFailable where E: LocalizedError {
 36:     
 37:     var success: Bool {
 38:         switch self.status {
 39:         case .empty: return false
 40:         case .data: return true
 41:         case .error: return false
 42:         case .loading: return false
 43:         }
 44:     }
 45:     
 46:     var isLoading: Bool {
 47:         switch self.status {
 48:         case .empty: return false
 49:         case .data: return false
 50:         case .error: return false
 51:         case .loading: return true
 52:         }
 53:     }
 54:     
 55:     var data: T? {
 56:         switch self.status {
 57:         case .empty: return nil
 58:         case .data(let data): return data
 59:         case .error: return nil
 60:         case .loading: return nil
 61:         }
 62:     }
 63:     
 64:     var error: E? {
 65:         switch self.status {
 66:         case .empty: return nil
 67:         case .data: return nil
 68:         case .error(let error): return error
 69:         case .loading: return nil
 70:         }
 71:     }
 72:     
 73:     func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool = true) -> Self {
 74:         switch self.status {
 75:         case .loading(let progress):
 76:             return AsyncOperation(status: .loading(progress.update(newProgress: loadingProgress, onlyIfLess: onlyIfLess)))
 77:         default:
 78:             return self
 79:         }
 80:     }
 81:     
 82:     static var resetState: Self { .init(status: .empty) }
 83: }
 84: 
 85: enum AsyncEmptyFailable<E: LocalizedError>: AsyncLoadable, AsyncFailable {
 86:     case idle
 87:     case loading(Progress)
 88:     case error(E)
 89:     
 90:     var isLoading: Bool {
 91:         switch self {
 92:         case .idle: return false
 93:         case .error: return false
 94:         case .loading: return true
 95:         }
 96:     }
 97:     
 98:     var error: E? {
 99:         switch self {
100:         case .idle: return nil
101:         case .error(let error): return error
102:         case .loading: return nil
103:         }
104:     }
105:     
106:     func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool = true) -> Self {
107:         switch self {
108:         case .loading(let progress):
109:             return .loading(progress.update(newProgress: loadingProgress, onlyIfLess: onlyIfLess))
110:         default:
111:             return self
112:         }
113:     }
114:     
115:     static var resetState: Self { .idle }
116: }
117: 
118: enum AsyncEmpty: AsyncLoadable {
119:     case idle
120:     case loading(Progress)
121:     
122:     var isLoading: Bool {
123:         switch self {
124:         case .idle: return false
125:         case .loading: return true
126:         }
127:     }
128:     
129:     func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool = true) -> Self {
130:         switch self {
131:         case .loading(let progress):
132:             return .loading(progress.update(newProgress: loadingProgress, onlyIfLess: onlyIfLess))
133:         default:
134:             return self
135:         }
136:     }
137: }
138: 
139: enum AsyncItem<T>: AsyncLoadable {
140:     
141:     case empty
142:     case loading(Progress)
143:     case data(T)
144:     
145:     var hasData: Bool {
146:         switch self {
147:         case .empty: return false
148:         case .loading: return false
149:         case .data: return true
150:         }
151:     }
152:     
153:     var isLoading: Bool {
154:         switch self {
155:         case .empty: return false
156:         case .loading: return true
157:         case .data: return false
158:         }
159:     }
160:     
161:     var data: T? {
162:         switch self {
163:         case .empty: return nil
164:         case .loading: return nil
165:         case .data(let data): return data
166:         }
167:     }
168:     
169:     func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool = true) -> Self {
170:         switch self {
171:         case .loading(let progress):
172:             return .loading(progress.update(newProgress: loadingProgress, onlyIfLess: onlyIfLess))
173:         default:
174:             return self
175:         }
176:     }
177: }
178: 
179: enum AsyncItemFailable<T, E: LocalizedError>: AsyncLoadable, AsyncFailable {
180:     
181:     case empty
182:     case loading(Progress)
183:     case data(T)
184:     case error(E)
185:     
186:     var success: Bool {
187:         switch self {
188:         case .empty: return false
189:         case .data: return true
190:         case .error: return false
191:         case .loading: return false
192:         }
193:     }
194:     
195:     var isLoading: Bool {
196:         switch self {
197:         case .empty: return false
198:         case .loading: return true
199:         case .data: return false
200:         case .error: return false
201:         }
202:     }
203:     
204:     var data: T? {
205:         switch self {
206:         case .empty: return nil
207:         case .loading: return nil
208:         case .data(let data): return data
209:         case .error: return nil
210:         }
211:     }
212:     
213:     var error: E? {
214:         switch self {
215:         case .empty: return nil
216:         case .data: return nil
217:         case .error(let error): return error
218:         case .loading: return nil
219:         }
220:     }
221:     
222:     func updateLoadingProgress(loadingProgress: Progress, onlyIfLess: Bool = true) -> Self {
223:         switch self {
224:         case .loading(let progress):
225:             return .loading(progress.update(newProgress: loadingProgress, onlyIfLess: onlyIfLess))
226:         default:
227:             return self
228:         }
229:     }
230:     
231:     static var resetState: Self { .empty }
232: }
233: 
234: extension Progress {
235:     static var undeterminedProgress: Self {
236:         .init(totalUnitCount: 1)
237:     }
238:     
239:     func update(newProgress: Progress, onlyIfLess: Bool = true) -> Progress {
240:         if !onlyIfLess || self.completedUnitCount < newProgress.completedUnitCount {
241:             return newProgress
242:         } else {
243:             return self
244:         }
245:     }
246: }
```

## File: pdfexpert/Utils/CombineUtils.swift
```swift
 1: //
 2: //  CombineUtils.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 20/07/23.
 6: //
 7: 
 8: import Foundation
 9: import Combine
10: 
11: extension Just {
12:     static func withErrorType<E>(_ value: Output, _ errorType: E.Type
13:     ) -> AnyPublisher<Output, E> {
14:         return Just(value)
15:             .setFailureType(to: E.self)
16:             .eraseToAnyPublisher()
17:     }
18: }
19: 
20: extension Publisher where Failure: LocalizedError {
21:     func sinkToAsyncStatus(_ completion: @escaping (AsyncOperationStatus<Output, Failure>) -> Void) -> AnyCancellable {
22:         return sink(receiveCompletion: { subscriptionCompletion in
23:             if let error = subscriptionCompletion.error {
24:                 completion(AsyncOperationStatus<Output, Failure>.error(error))
25:             }
26:         }, receiveValue: { value in
27:             completion(AsyncOperationStatus<Output, Failure>.data(value))
28:         })
29:     }
30: }
31: 
32: extension Subscribers.Completion {
33:     var error: Failure? {
34:         switch self {
35:         case let .failure(error): return error
36:         default: return nil
37:         }
38:     }
39: }
40: 
41: extension Publisher {
42:     
43:     /// Includes the current element as well as the previous element from the upstream publisher in a tuple where the previous element is optional.
44:     /// The first time the upstream publisher emits an element, the previous element will be `nil`.
45:     ///
46:     ///     let range = (1...5)
47:     ///     cancellable = range.publisher
48:     ///         .withPrevious()
49:     ///         .sink { print ("(\($0.previous), \($0.current))", terminator: " ") }
50:     ///      // Prints: "(nil, 1) (Optional(1), 2) (Optional(2), 3) (Optional(3), 4) (Optional(4), 5) ".
51:     ///
52:     /// - Returns: A publisher of a tuple of the previous and current elements from the upstream publisher.
53:     func withPrevious() -> AnyPublisher<(previous: Output?, current: Output), Failure> {
54:         scan(Optional<(Output?, Output)>.none) { ($0?.1, $1) }
55:             .compactMap { $0 }
56:             .eraseToAnyPublisher()
57:     }
58:     
59:     /// Includes the current element as well as the previous element from the upstream publisher in a tuple where the previous element is not optional.
60:     /// The first time the upstream publisher emits an element, the previous element will be the `initialPreviousValue`.
61:     ///
62:     ///     let range = (1...5)
63:     ///     cancellable = range.publisher
64:     ///         .withPrevious(0)
65:     ///         .sink { print ("(\($0.previous), \($0.current))", terminator: " ") }
66:     ///      // Prints: "(0, 1) (1, 2) (2, 3) (3, 4) (4, 5) ".
67:     ///
68:     /// - Parameter initialPreviousValue: The initial value to use as the "previous" value when the upstream publisher emits for the first time.
69:     /// - Returns: A publisher of a tuple of the previous and current elements from the upstream publisher.
70:     func withPrevious(_ initialPreviousValue: Output) -> AnyPublisher<(previous: Output, current: Output), Failure> {
71:         scan((initialPreviousValue, initialPreviousValue)) { ($0.1, $1) }.eraseToAnyPublisher()
72:     }
73: }
```

## File: pdfexpert/Utils/DebugUtils.swift
```swift
 1: //
 2: //  DebugUtils.swift
 3: //  FourBooks
 4: //
 5: //  Created by Pcnaid Inc on 15/06/2020.
 6: //  Copyright  2020 4Books. All rights reserved.
 7: //
 8: 
 9: import Foundation
10: 
11: @discardableResult
12: public func debugPrintElapsedTimeSince(operationName: String, startTime: CFAbsoluteTime) -> CFAbsoluteTime {
13:     let currentTime = CFAbsoluteTimeGetCurrent()
14:     print("Debug - Time elapsed for \(operationName): \(currentTime - startTime) s.")
15:     return currentTime
16: }
17: 
18: public func debugPrint(for type: Any.Type, message: String, function: String = #function) {
19:     print("\(String(describing: type)) - \(function) - \(message)")
20: }
21: 
22: public func debugPrint(for instance: Any, message: String, function: String = #function) {
23:     debugPrint(for: type(of: instance), message: message)
24: }
25: 
26: public func isPreview() -> Bool {
27:     return ProcessInfo.processInfo.environment["XCODE_RUNNING_FOR_PREVIEWS"] == "1"
28: }
```

## File: pdfexpert/Utils/MathUtils.swift
```swift
 1: //
 2: //  MathUtils.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 25/08/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: struct Line {
11:     let slope: CGFloat
12:     let intercept: CGFloat
13: }
14: 
15: class MathUtils {
16:     
17:     static func getSlope(ofLinePassingThrough pointA: CGPoint, and pointB: CGPoint) -> CGFloat {
18:         let x1 = pointA.x
19:         let x2 = pointB.x
20:         let y1 = pointA.y
21:         let y2 = pointB.y
22:         
23:         return (y2 - y1) / (x2 - x1)
24:     }
25:     
26:     static func getIntercept(ofLinePassingThrough pointA: CGPoint, and pointB: CGPoint) -> CGFloat {
27:         let x1 = pointA.x
28:         let x2 = pointB.x
29:         let y1 = pointA.y
30:         let y2 = pointB.y
31:         
32:         return (x2*y1 - x1*y2) / (x2 - x1)
33:     }
34:     
35:     static func getLine(ofLinePassingThrough pointA: CGPoint, and pointB: CGPoint) -> Line {
36:         let slope = self.getSlope(ofLinePassingThrough: pointA, and: pointB)
37:         let intercept = self.getIntercept(ofLinePassingThrough: pointA, and: pointB)
38:         
39:         return Line(slope: slope,
40:                     intercept: intercept)
41:     }
42: }
43: 
44: extension Line {
45:     
46:     var direction: CGPoint {
47:         CGPoint(x: 1, y: self.slope).normalized
48:     }
49:     
50:     func getY(forX x: CGFloat) -> CGFloat {
51:         return x * self.slope + self.intercept
52:     }
53:     
54:     func closestPoint(toPoint point: CGPoint) -> CGPoint {
55:         let direction = self.direction
56:         let translatedPoint = CGPoint(x: point.x, y: point.y - self.intercept)
57:         let pointProjectionLength = CGPoint.dot(direction, translatedPoint)
58:         let translatedClosestPoint = direction.scale(by: pointProjectionLength)
59:         return CGPoint(x: translatedClosestPoint.x, y: translatedClosestPoint.y + self.intercept)
60:     }
61: }
62: 
63: extension CGPoint {
64:     
65:     var length: CGFloat {
66:         CGFloat(sqrtf(powf(Float(self.x), 2.0) + powf(Float(self.y), 2.0)))
67:     }
68:     
69:     var normalized: CGPoint {
70:         let length = self.length
71:         if length > 0.0 {
72:             return self.scale(by: 1.0 / length)
73:         } else {
74:             return .zero
75:         }
76:     }
77:     
78:     func scale(by scaleFactor: CGFloat) -> CGPoint {
79:         CGPoint(x: self.x * scaleFactor, y: self.y * scaleFactor)
80:     }
81:     
82:     static func dot(_ pointA: CGPoint, _ pointB: CGPoint) -> CGFloat {
83:         pointA.x * pointB.x + pointA.y * pointB.y
84:     }
85: }
```

## File: pdfexpert/Utils/ParentalCheck.swift
```swift
 1: //
 2: //  ParentalCheck.swift
 3: //  StoryKidsAI
 4: //
 5: //  Created by Pcnaid Inc on 14/03/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: enum ParentalCheck<T: Hashable>: Hashable, Identifiable {
11:     case checking(T)
12:     case success(T)
13:     
14:     var id: Self { self }
15: }
```

## File: pdfexpert/Utils/PDFImageExtractor.swift
```swift
  1: //
  2: //  main.swift
  3: //  ImageExtractor
  4: //
  5: //  Created by Damiaan on 13/08/2019.
  6: //  Copyright  2019 dPro. All rights reserved.
  7: //
  8: 
  9: import Foundation
 10: import PDFKit
 11: 
 12: enum PDFReadError: Error {
 13: 	case couldNotOpenPage(Int)
 14: 	case couldNotGetPageReference
 15: 	case couldNotOpenPageDictionary
 16: 	case couldNotReadResources
 17: 	case cannotCopyData
 18: }
 19: 
 20: enum EmbeddedImage {
 21: 	case jpg(Data)
 22: 	case raw(CGImage)
 23: }
 24: 
 25: func extractImages(from pdf: PDFDocument, extractor: @escaping (EmbeddedImage, Int, String)->Void) throws {
 26: 	for pageNumber in 0..<pdf.pageCount {
 27: 		guard let page = pdf.page(at: pageNumber) else {
 28: 			throw PDFReadError.couldNotOpenPage(pageNumber)
 29: 		}
 30: 		try extractImages(from: page) { extractor($0, pageNumber, $1) }
 31: 	}
 32: }
 33: 
 34: func extractImages(from page: PDFPage, extractor: @escaping (EmbeddedImage, String)->Void) throws {
 35: 	guard let page = page.pageRef else {
 36: 		throw PDFReadError.couldNotGetPageReference
 37: 	}
 38: 
 39: 	guard let dictionary = page.dictionary else {
 40: 		throw PDFReadError.couldNotOpenPageDictionary
 41: 	}
 42: 
 43: 	guard let resources = dictionary[CGPDFDictionaryGetDictionary, "Resources"] else {
 44: 		throw PDFReadError.couldNotReadResources
 45: 	}
 46: 
 47: 	if let xObject = resources[CGPDFDictionaryGetDictionary, "XObject"] {
 48: 		func iterator(key: UnsafePointer<Int8>, object: CGPDFObjectRef, info: UnsafeMutableRawPointer?) -> Bool {
 49: 			do {
 50: 				if let data = try extractImage(key: key, object: object) {
 51: 					extractor(data, String(cString: key))
 52: 				}
 53: 			} catch {
 54: 				print(error)
 55: 				return true
 56: 			}
 57: 			return true
 58: 		}
 59: 		CGPDFDictionaryApplyBlock(xObject, iterator, nil)
 60: 	}
 61: }
 62: 
 63: enum RawDecodingError: Error {
 64: 	case cannotConstructImage
 65: 	case cannotReadSize
 66: 	case cannotReadBitsPerComponent
 67: 	case noColorSpace([String]?)
 68: 	case unkownColorSpace(String)
 69: 	case corruptColorSpace
 70: 	case noLookupTable
 71: }
 72: 
 73: func extractImage(key: UnsafePointer<Int8>, object: CGPDFObjectRef) throws -> EmbeddedImage? {
 74: 	guard let stream: CGPDFStreamRef = object[CGPDFObjectGetValue, .stream] else { return nil }
 75: 	guard let dictionary = CGPDFStreamGetDictionary(stream) else {return nil}
 76: 
 77: 	guard dictionary.getName("Subtype", CGPDFDictionaryGetName) == "Image" else {return nil}
 78: 	print(String(cString: key))
 79: 
 80: 	var format = CGPDFDataFormat.raw
 81: 	guard let data = CGPDFStreamCopyData(stream, &format) else { throw PDFReadError.cannotCopyData }
 82: 
 83: 	if format == .JPEG2000 || format == .jpegEncoded {
 84: 		if
 85: 			let colorSpace = try? dictionary[CGPDFDictionaryGetObject, "ColorSpace"]?.getColorSpace(),
 86: 			let provider = CGDataProvider(data: data),
 87: 			let embeddedImage = CGImage(
 88: 				jpegDataProviderSource: provider,
 89: 				decode: nil,
 90: 				shouldInterpolate: false,
 91: 				intent: .defaultIntent
 92: 			),
 93: 			let correctedImage = embeddedImage.copy(colorSpace: colorSpace)
 94: 		{
 95:             return .raw(correctedImage)
 96: 		}
 97: 		return .jpg(data as Data)
 98: 	} else {
 99: 		return .raw( try getCGImage(data: data, info: dictionary) )
100: 	}
101: }
102: 
103: func getCGImage(data: CFData, info: CGPDFDictionaryRef) throws -> CGImage {
104: 	guard let colorSpace = try info[CGPDFDictionaryGetObject, "ColorSpace"]?.getColorSpace() else {
105: 		throw RawDecodingError.noColorSpace(info.getNameArray(for: "Filter"))
106: 	}
107: 
108: 	guard
109: 		let width = info[CGPDFDictionaryGetInteger, "Width"],
110: 		let height = info[CGPDFDictionaryGetInteger, "Height"]
111: 		else {
112: 			throw RawDecodingError.cannotReadSize
113: 	}
114: 	guard let bitsPerComponent = info[CGPDFDictionaryGetInteger, "BitsPerComponent"] else {
115: 		throw RawDecodingError.cannotReadBitsPerComponent
116: 	}
117: 
118: 	let decode: [CGFloat]?
119: 	if let decodeRef = info[CGPDFDictionaryGetArray, "Decode"] {
120: 		let count = CGPDFArrayGetCount(decodeRef)
121: 		decode = (0..<count).map {
122: 			decodeRef[CGPDFArrayGetNumber, $0]!
123: 		}
124: 	} else {
125: 		decode = nil
126: 	}
127: 
128: 	guard let databuffer = CGDataProvider(data: data) else {throw RawDecodingError.cannotConstructImage}
129: 	guard let image = CGImage(
130: 		width: width,
131: 		height: height,
132: 		bitsPerComponent: bitsPerComponent,
133: 		bitsPerPixel: bitsPerComponent * colorSpace.numberOfComponents,
134: 		bytesPerRow: Int((Double(width * bitsPerComponent * colorSpace.numberOfComponents) / 8.0).rounded(.up)),
135: 		space: colorSpace,
136: 		bitmapInfo: CGBitmapInfo(),
137: 		provider: databuffer,
138: 		decode: decode,
139: 		shouldInterpolate: false,
140: 		intent: .defaultIntent
141: 	) else {throw RawDecodingError.cannotConstructImage}
142: 
143: 	return image
144: }
145: 
146: protocol DefaultInitializer {
147: 	init()
148: }
149: 
150: extension Int: DefaultInitializer {}
151: extension CGFloat: DefaultInitializer {}
152: 
153: extension CGPDFObjectRef {
154: 	func getName<K>(_ key: K, _ getter: (OpaquePointer, K, UnsafeMutablePointer<UnsafePointer<Int8>?>)->Bool) -> String? {
155: 		guard let pointer = self[getter, key] else { return nil }
156: 		return String(cString: pointer)
157: 	}
158: 
159: 	func getName<K>(_ key: K, _ getter: (OpaquePointer, K, UnsafeMutableRawPointer?)->Bool) -> String? {
160: 		guard let pointer: UnsafePointer<UInt8> = self[getter, key] else { return nil }
161: 		return String(cString: pointer)
162: 	}
163: 
164: 	subscript<R, K>(_ getter: (OpaquePointer, K, UnsafeMutablePointer<R?>)->Bool, _ key: K) -> R? {
165: 		var result: R!
166: 		guard getter(self, key, &result) else { return nil }
167: 		return result
168: 	}
169: 
170: 	subscript<R: DefaultInitializer, K>(_ getter: (OpaquePointer, K, UnsafeMutablePointer<R>)->Bool, _ key: K) -> R? {
171: 		var result = R()
172: 		guard getter(self, key, &result) else { return nil }
173: 		return result
174: 	}
175: 
176:     subscript<R, K>(_ getter: (OpaquePointer, K, UnsafeMutableRawPointer?)->Bool, _ key: K) -> R? {
177:             var result: R!
178:             guard getter(self, key, &result) else { return nil }
179:             return result
180:         }
181: 
182: 	func getNameArray(for key: String) -> [String]? {
183: 		var object: CGPDFObjectRef!
184: 		guard CGPDFDictionaryGetObject(self, key, &object) else { return nil }
185: 
186: 		if let name = object.getName(.name, CGPDFObjectGetValue) {
187: 			return [name]
188: 		} else {
189: 			guard let array: CGPDFArrayRef = object[CGPDFObjectGetValue, .array] else {return nil}
190: 			var names = [String]()
191: 			for index in 0..<CGPDFArrayGetCount(array) {
192: 				guard let name = array.getName(index, CGPDFArrayGetName) else { continue }
193: 				names.append(name)
194: 			}
195: 			assert(names.count == CGPDFArrayGetCount(array))
196: 			return names
197: 		}
198: 	}
199: 
200: 	func getColorSpace() throws -> CGColorSpace {
201: 		if let name = getName(.name, CGPDFObjectGetValue) {
202: 			switch name {
203: 			case "DeviceGray":
204: 				return CGColorSpaceCreateDeviceGray()
205: 			case "DeviceRGB":
206: 				return CGColorSpaceCreateDeviceRGB()
207: 			case "DeviceCMYK":
208: 				return CGColorSpaceCreateDeviceCMYK()
209: 			default:
210: 				throw RawDecodingError.unkownColorSpace(name)
211: 			}
212: 		} else {
213: 			guard
214: 				let array: CGPDFArrayRef = self[CGPDFObjectGetValue, .array],
215: 				let name = array.getName(0, CGPDFArrayGetName)
216: 				else {
217: 					throw RawDecodingError.corruptColorSpace
218: 			}
219: 
220: 			switch name {
221: 			case "Indexed":
222: 				guard
223: 					let base = try array[CGPDFArrayGetObject, 1]?.getColorSpace(),
224: 					let hival = array[CGPDFArrayGetInteger, 2],
225: 					hival < 256
226: 					else {
227: 						throw RawDecodingError.corruptColorSpace
228: 				}
229: 				let colorSpace: CGColorSpace?
230: 				if let lookupTable = array[CGPDFArrayGetString, 3] {
231: 					guard let pointer = CGPDFStringGetBytePtr(lookupTable) else { throw RawDecodingError.corruptColorSpace }
232: 					colorSpace = CGColorSpace(indexedBaseSpace: base, last: hival, colorTable: pointer)
233: 				} else if let lookupTable = array[CGPDFArrayGetStream, 3] {
234: 					var format = CGPDFDataFormat.raw
235: 					guard let data = CGPDFStreamCopyData(lookupTable, &format) else {
236: 						throw RawDecodingError.corruptColorSpace
237: 					}
238: 					colorSpace = CGColorSpace(
239: 						indexedBaseSpace: base,
240: 						last: hival,
241: 						colorTable: CFDataGetBytePtr(data)
242: 					)
243: 				} else {
244: 					throw RawDecodingError.noLookupTable
245: 				}
246: 				guard let result = colorSpace else { throw RawDecodingError.corruptColorSpace }
247: 				return result
248: 			case "ICCBased":
249: 				var format = CGPDFDataFormat.raw
250: 				guard
251: 					let stream = array[CGPDFArrayGetStream, 1],
252: 					let info = CGPDFStreamGetDictionary(stream),
253: 					let componentCount = info[CGPDFDictionaryGetInteger, "N"],
254: 					let profileData = CGPDFStreamCopyData(stream, &format),
255: 					let profile = CGDataProvider(data: profileData)
256: 					else {
257: 						throw RawDecodingError.corruptColorSpace
258: 				}
259: 				let alternate = try info[CGPDFDictionaryGetObject, "Alternate"]?.getColorSpace()
260: 				guard let colorSpace = CGColorSpace(
261: 					iccBasedNComponents: componentCount,
262: 					range: nil,
263: 					profile: profile,
264: 					alternate: alternate
265: 					) else {
266: 						throw RawDecodingError.corruptColorSpace
267: 				}
268: 				return colorSpace
269: 			case "Lab":
270: 				guard
271: 					let info = array[CGPDFArrayGetDictionary, 1],
272: 					let whitePointRef = info[CGPDFDictionaryGetArray, "WhitePoint"]?.asFloatArray()
273: 					else { throw RawDecodingError.corruptColorSpace }
274: 				guard let colorSpace = CGColorSpace(
275: 					labWhitePoint: whitePointRef,
276: 					blackPoint: info[CGPDFDictionaryGetArray, "BlackPoint"]?.asFloatArray(),
277: 					range: info[CGPDFDictionaryGetArray, "Range"]?.asFloatArray()
278: 					) else {
279: 						throw RawDecodingError.corruptColorSpace
280: 				}
281: 				return colorSpace
282: 			default:
283: 				throw RawDecodingError.unkownColorSpace(name)
284: 			}
285: 		}
286: 	}
287: 
288: 	func asFloatArray() -> [CGFloat] {
289: 		return (0..<CGPDFArrayGetCount(self)).map {
290: 			self[CGPDFArrayGetNumber, $0]!
291: 		}
292: 	}
293: }
```

## File: pdfexpert/ViewModels/ArchiveViewModel.swift
```swift
  1: //
  2: //  ArchiveViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 06/04/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import CoreData
 11: import Combine
 12: import CloudKitSyncMonitor
 13: 
 14: extension Container {
 15:     var archiveViewModel: Factory<ArchiveViewModel> {
 16:         self { ArchiveViewModel() }
 17:     }
 18: }
 19: 
 20: class ArchiveViewModel: ObservableObject {
 21:     
 22:     @Published var asyncItems: AsyncOperation<[Pdf], SharedLocalizedError> = AsyncOperation(status: .empty)
 23:     @Published var asyncItemDelete: AsyncOperation<(), SharedLocalizedError> = AsyncOperation(status: .empty)
 24:     @Published var isLoading: Bool = false
 25:     
 26:     @Injected(\.repository) private var repository
 27:     @Injected(\.store) private var store
 28:     @Injected(\.analyticsManager) private var analyticsManager
 29:     @Injected(\.mainCoordinator) private var mainCoordinator
 30:     @Injected(\.pdfShareCoordinator) var pdfShareCoordinator
 31:     
 32:     let syncMonitor = SyncMonitor.shared
 33:     
 34:     private var cancelBag = Set<AnyCancellable>()
 35:     
 36:     init() {
 37:         SyncMonitor.shared.$importState.sink { [weak self] importState in
 38:             switch importState {
 39:             case .inProgress:
 40:                 self?.isLoading = true
 41:             case .succeeded:
 42:                 self?.refresh()
 43:                 self?.isLoading = false
 44:             case .failed:
 45:                 self?.refresh()
 46:                 self?.isLoading = false
 47:             case .notStarted:
 48:                 self?.isLoading = false
 49:             }
 50:             self?.updateView()
 51:         }.store(in: &self.cancelBag)
 52:         
 53:         // Refresh the pdf list every time the pdf edit flow is dismissed
 54:         self.mainCoordinator.$pdfEditFlowData.filter { $0 == nil }.sink { data in
 55:             self.refresh()
 56:         }.store(in: &self.cancelBag)
 57:     }
 58:     
 59:     func editItem(item: Pdf) {
 60:         self.analyticsManager.track(event: .existingPdfOpened)
 61:         self.mainCoordinator.showPdfEditFlow(pdf: item, isNewPdf: false)
 62:     }
 63:     
 64:     func shareItem(item: Pdf) {
 65:         self.pdfShareCoordinator.share(pdf: item, applyPostProcess: true, onComplete: { [weak self] in
 66:             self?.mainCoordinator.startReview()
 67:         })
 68:     }
 69:     
 70:     func delete(item: Pdf) {
 71:         self.asyncItemDelete = AsyncOperation(status: .empty)
 72:         do {
 73:             try self.repository.delete(pdf: item)
 74:             self.asyncItemDelete = AsyncOperation(status: .empty)
 75:         } catch {
 76:             debugPrint(for: self, message: "Deletion failed. Error: \(error)")
 77:             self.asyncItemDelete = AsyncOperation(status: .error(.unknownError))
 78:         }
 79:         self.refresh()
 80:     }
 81:     
 82:     func onAppear() {
 83:         self.analyticsManager.track(event: .reportScreen(.files))
 84:         self.refresh()
 85:     }
 86:     
 87:     func refresh() {
 88:         do {
 89:             let items = try self.repository.loadPdfs()
 90:             self.asyncItems = AsyncOperation(status: .data(items))
 91:         } catch {
 92:             debugPrint(for: self, message: "Refresh failed. Error: \(error)")
 93:             self.asyncItems = AsyncOperation(status: .error(SharedLocalizedError.unknownError))
 94:         }
 95:     }
 96:     
 97:     func updateView(){
 98:         self.objectWillChange.send()
 99:     }
100: }
```

## File: pdfexpert/ViewModels/CameraImageProviderFlow.swift
```swift
 1: //
 2: //  CameraImageProviderFlow.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 06/09/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import UIKit
11: 
12: extension Container {
13:     var cameraImageProviderFlow: Factory<CameraImageProviderFlow> {
14:         self { CameraImageProviderFlow() }
15:     }
16: }
17: 
18: class CameraImageProviderFlow: ObservableObject {
19:     
20:     typealias CameraImageTakenCallback = ((UIImage) -> ())
21:     
22:     @Published var cameraShow: Bool = false
23:     
24:     private var onImageTaken: CameraImageTakenCallback?
25:     
26:     func startFlow(onImageTaken: @escaping CameraImageTakenCallback) {
27:         self.onImageTaken = onImageTaken
28:         self.cameraShow = true
29:     }
30:     
31:     func onPhotoCaptured(image: UIImage) {
32:         self.cameraShow = false
33:         self.onImageTaken?(image)
34:     }
35: }
```

## File: pdfexpert/ViewModels/CameraViewModel.swift
```swift
 1: //
 2: //  CameraViewModel.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 30/03/23.
 6: //
 7: 
 8: import Foundation
 9: import AVFoundation
10: import Combine
11: import Factory
12: import UIKit
13: 
14: typealias ImageCapturedCallback = (UIImage) -> ()
15: 
16: extension Container {
17:     var cameraService: Factory<CameraService> {
18:         self { CameraService() }
19:     }
20: }
21: 
22: extension Container {
23:     var cameraViewModel: ParameterFactory<ImageCapturedCallback, CameraViewModel> {
24:         self { CameraViewModel(onImageCaptured: $0) }.shared
25:     }
26: }
27: 
28: final class CameraViewModel: ObservableObject {
29:     
30:     @Injected(\.cameraService) var cameraService
31:     
32:     @Published var error: CameraError?
33:     
34:     @Published var showAlertError: Bool = false
35:     
36:     @Published var isFlashOn = false
37:     
38:     @Published var willCapturePhoto = false
39:     
40:     var session: AVCaptureSession { self.cameraService.session }
41:     
42:     private var onImageCaptured: ImageCapturedCallback
43:     
44:     private var subscriptions = Set<AnyCancellable>()
45:     
46:     init(onImageCaptured: @escaping ImageCapturedCallback) {
47:         
48:         self.onImageCaptured = onImageCaptured
49:         
50:         self.cameraService.$photo.sink { [weak self] (photo) in
51:             if let photo = photo {
52:                 self?.onImageCaptured(photo.image!)
53:             }
54:         }
55:         .store(in: &self.subscriptions)
56:         
57:         self.cameraService.$error.sink { [weak self] (error) in
58:             self?.error = error
59:             if nil != error {
60:                 self?.showAlertError = true
61:             }
62:         }
63:         .store(in: &self.subscriptions)
64:         
65:         self.cameraService.$flashMode.sink { [weak self] (mode) in
66:             self?.isFlashOn = mode == .on
67:         }
68:         .store(in: &self.subscriptions)
69:         
70:         self.cameraService.$willCapturePhoto.sink { [weak self] (val) in
71:             self?.willCapturePhoto = val
72:         }
73:         .store(in: &self.subscriptions)
74:     }
75:     
76:     func configure() {
77:         self.cameraService.checkForPermissions()
78:         self.cameraService.configure()
79:     }
80:     
81:     func capturePhoto() {
82:         self.cameraService.capturePhoto(saveToLibrary: false)
83:     }
84:     
85:     func flipCamera() {
86:         self.cameraService.changeCamera()
87:     }
88:     
89:     func zoom(with factor: CGFloat) {
90:         self.cameraService.set(zoom: factor)
91:     }
92:     
93:     func switchFlash() {
94:         self.cameraService.flashMode = self.cameraService.flashMode == .on ? .off : .on
95:     }
96: }
```

## File: pdfexpert/ViewModels/ChatPdfSelectionViewModel.swift
```swift
  1: //
  2: //  ChatPdfSelectionViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 19/07/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import PhotosUI
 11: import PSPDFKit
 12: import Combine
 13: 
 14: @MainActor
 15: extension Container {
 16:     var chatPdfSelectionViewModel: Factory<ChatPdfSelectionViewModel> {
 17:         self { ChatPdfSelectionViewModel() }
 18:     }
 19: }
 20: 
 21: @MainActor
 22: final class ChatPdfSelectionViewModel: ObservableObject {
 23:     
 24:     @Published var importOptionGroup: ImportOptionGroup? = nil
 25:     @Published var importFileOption: ImportFileOption? = nil
 26:     
 27:     @Published var scannerShow: Bool = false
 28:     @Published var cameraPermissionDeniedShow: Bool = false
 29:     
 30:     @MainActor @Published var asyncImportPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
 31:         didSet {
 32:             if let pdf = self.asyncImportPdf.data {
 33:                 self.trackFullActionCompleted()
 34:                 self.uploadPdf(pdf: pdf)
 35:             }
 36:         }
 37:     }
 38:     
 39:     @Published var asyncChatPdfSetup: AsyncOperation<ChatPdfInitParams, ChatPdfError> = AsyncOperation(status: .empty) {
 40:         didSet {
 41:             if let chatPdfInitParams = self.asyncChatPdfSetup.data {
 42:                 self.chatPdfInitParams = chatPdfInitParams
 43:             } else {
 44:                 self.chatPdfInitParams = nil
 45:             }
 46:         }
 47:     }
 48:     
 49:     @Published var chatPdfInitParams: ChatPdfInitParams? = nil
 50:     
 51:     @Published var monetizationShow: Bool = false
 52:     
 53:     @Injected(\.store) private var store
 54:     @Injected(\.chatPdfManager) private var chatPdfManager
 55:     @Injected(\.analyticsManager) private var analyticsManager
 56:     
 57:     lazy var pdfUnlockViewModel: PdfUnlockViewModel = {
 58:             Container.shared.pdfUnlockViewModel(PdfUnlockViewModel.Params(asyncUnlockedPdfSingleOutput: self.asyncSubject(\.asyncImportPdf)))
 59:         }()
 60:     
 61: 
 62: 
 63:     
 64:     
 65:     
 66:     
 67:     private var currentAnalyticsImportOption: ImportOption? = nil
 68:     private var currentAnalyticsFileExtension: String? = nil
 69:     
 70:     private var cancelBag = Set<AnyCancellable>()
 71:     
 72:     func onAppear() {
 73:         self.analyticsManager.track(event: .reportScreen(.chatPdfSelection))
 74:     }
 75:     
 76:     func getPdfButtonPressed() {
 77:         self.trackPdfSelection()
 78:         if self.store.isPremium.value {
 79:             self.importOptionGroup = .fileAndScan
 80:         } else {
 81:             self.monetizationShow = true
 82:         }
 83:     }
 84:     
 85:     @MainActor
 86:     func handleImportOption(importOption: ImportOption) {
 87:         switch importOption {
 88:         case .camera:
 89:             // TODO: Improve this by defining context-specific ImportOption types
 90:             assertionFailure("Unexpected import option")
 91:             break
 92:         case .gallery:
 93:             // TODO: Improve this by defining context-specific ImportOption types
 94:             assertionFailure("Unexpected import option")
 95:             break
 96:         case .scan: self.scanPdf()
 97:         case .file(let fileSource):
 98:             switch fileSource {
 99:             case .google: self.openFilePicker(fileSource: .google)
100:             case .dropbox: self.openFilePicker(fileSource: .dropbox)
101:             case .icloud: self.openFilePicker(fileSource: .icloud)
102:             case .files: self.openFilePicker(fileSource: .files)
103:             }
104:         }
105:     }
106:     
107:     @MainActor
108:     func openFilePicker(fileSource: FileSource) {
109:         self.trackFullActionChosen(importOption: .file(fileSource: fileSource))
110:         self.importOptionGroup = nil
111:         Task {
112:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
113:             self.importFileOption = .allDocs
114:         }
115:     }
116:     
117:     @MainActor
118:     func scanPdf() {
119:         self.importOptionGroup = nil
120:         // In this case ImportOption.scan is not actually been selected by the user,
121:         // but is provided for coherence
122:         self.trackFullActionChosen(importOption: .scan)
123:         Task {
124:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
125:             self.showScanner()
126:         }
127:     }
128:     
129:     @MainActor
130:     func convertScan(scannerResult: ScannerResult) {
131:         self.scannerShow = false
132:         Task {
133:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
134:             PdfScanUtility.convertScan(scannerResult: scannerResult, asyncOperation: self.asyncSubject(\.asyncImportPdf))
135:         }
136:     }
137:     
138:     @MainActor
139:     func processPickedFileUrl(_ fileUrl: URL?) {
140:         guard let fileUrl else {
141:             assertionFailure("Missing expected url")
142:             self.asyncImportPdf = AsyncOperation(status: .error(.unknownError))
143:             return
144:         }
145:         
146:         self.importFileOption = nil
147:         Task {
148:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
149:             self.convertFileByUrl(fileUrl: fileUrl)
150:         }
151:     }
152:     
153:     @MainActor
154:     func importPdf(pdfUrl: URL) {
155:         guard let pdf = Pdf(pdfUrl: pdfUrl) else {
156:             assertionFailure("Missing expected file for give url")
157:             return
158:         }
159:         
160:         self.currentAnalyticsFileExtension = pdfUrl.pathExtension
161:         self.pdfUnlockViewModel.unlockPdf(pdf: pdf)
162:     }
163:     
164:     @MainActor
165:     private func convertFileByUrl(fileUrl: URL) {
166:         let fileUtType = UTType(filenameExtension: fileUrl.pathExtension)
167:         if fileUtType?.conforms(to: .pdf) ?? false {
168:             self.importPdf(pdfUrl: fileUrl)
169:         } else {
170:             self.asyncImportPdf = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
171:             Processor.generatePDF(from: fileUrl, options: [:]) { data, error in
172:                 if let error = error {
173:                     debugPrint(for: self, message: "Error converting word file. Error: \(error)")
174:                     self.asyncImportPdf = AsyncOperation(status: .error(.unknownError))
175:                 } else if let data = data, let pdf = Pdf(data: data) {
176:                     self.currentAnalyticsFileExtension = fileUrl.pathExtension
177:                     self.asyncImportPdf = AsyncOperation(status: .data(pdf))
178:                 } else {
179:                     self.asyncImportPdf = AsyncOperation(status: .error(.unknownError))
180:                 }
181:             }
182:         }
183:     }
184:     
185:     @MainActor
186:     private func showScanner() {
187:         switch AVCaptureDevice.authorizationStatus(for: .video) {
188:         case .authorized, .notDetermined:
189:             self.scannerShow = true
190:         default:
191:             self.cameraPermissionDeniedShow = true
192:         }
193:     }
194:     
195:     @MainActor
196:     private func uploadPdf(pdf: Pdf) {
197:         guard let pdfData = pdf.rawData else {
198:             assertionFailure("Missing expected pdf data")
199:             self.asyncChatPdfSetup = AsyncOperation(status: .error(.unknownError))
200:             return
201:         }
202:         
203:         self.asyncChatPdfSetup = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
204:         
205:         guard pdfData.count <= K.ChatPdf.MaxBytes else {
206:             self.asyncChatPdfSetup = AsyncOperation(status: .error(.pdfTooLarge))
207:             return
208:         }
209:         
210:         guard pdf.pdfDocument.pageCount <= K.ChatPdf.MaxPages else {
211:             self.asyncChatPdfSetup = AsyncOperation(status: .error(.pdfTooManyPages))
212:             return
213:         }
214:         
215:         self.chatPdfManager.sendPdf(pdf: pdfData)
216:             .flatMap { chatPdfRef in
217:                 self.chatPdfManager.getSetupData(ref: chatPdfRef)
218:                     .map { ChatPdfInitParams(chatPdfRef: chatPdfRef, setupData: $0) }
219:             }
220:             .sinkToAsyncStatus { [weak self] status in
221:                 self?.asyncChatPdfSetup = AsyncOperation(status: status)
222:             }.store(in: &self.cancelBag)
223:     }
224:     
225:     private func trackPdfSelection() {
226:         self.analyticsManager.track(event: .chatPdfSelectionActionChosen)
227:     }
228:     
229:     private func trackFullActionChosen(importOption: ImportOption?) {
230:         self.currentAnalyticsImportOption = importOption
231:         self.analyticsManager.track(event: .chatPdfSelectionFullActionChosen(importOption: importOption))
232:     }
233:     
234:     private func trackFullActionCompleted() {
235:         self.analyticsManager.track(event: .chatPdfSelectionFullActionCompleted(importOption: currentAnalyticsImportOption,
236:                                                                                 fileExtension: self.currentAnalyticsFileExtension))
237:         self.currentAnalyticsImportOption = nil
238:         self.currentAnalyticsFileExtension = nil
239:     }
240: }
```

## File: pdfexpert/ViewModels/ChatPdfViewModel.swift
```swift
 1: //
 2: //  ChatPdfViewModel.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 19/07/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import Combine
11: 
12: @MainActor
13: extension Container {
14:     var chatPdfViewModel: ParameterFactory<ChatPdfViewModel.Parameters, ChatPdfViewModel> {
15:         self { ChatPdfViewModel(parameters: $0) }
16:     }
17: }
18: 
19: class ChatPdfViewModel: ObservableObject {
20:     
21:     struct Parameters {
22:         let chatPdfInitParams: ChatPdfInitParams
23:     }
24:     
25:     @Injected(\.chatPdfManager) private var chatPdfManager
26:     @Injected(\.analyticsManager) private var analyticsManager
27:     
28:     @Published var messages = [ChatPdfMessage]()
29:     
30:     private let chatPdfRef: ChatPdfRef
31:     
32:     private var cancelBag = Set<AnyCancellable>()
33:     
34:     init(parameters: Parameters) {
35:         self.chatPdfRef = parameters.chatPdfInitParams.chatPdfRef
36:         self.messages.append(parameters.chatPdfInitParams.setupData.message)
37:     }
38:     
39:     func onAppear() {
40:         self.analyticsManager.track(event: .reportScreen(.chatPdf))
41:     }
42:     
43:     func onDisappear() {
44:         self.chatPdfManager.deletePdf(ref: self.chatPdfRef)
45:     }
46:     
47:     func getResponse(text: String) {
48:         
49:         self.analyticsManager.track(event: .chatPdfMessageSent)
50:         
51:         self.addMessage(ChatPdfMessage(role: .user, type: .text, content: text))
52:         self.addMessage(ChatPdfMessage(role: .assistant, type: .indicator, content: ""))
53:         
54:         self.chatPdfManager.generateText(ref: self.chatPdfRef, prompt: text)
55:             .sink(receiveCompletion: { [weak self] subscriptionCompletion in
56:                 if let error = subscriptionCompletion.error {
57:                     self?.addMessage(ChatPdfMessage(role: .assistant, type: .text, content: error.localizedDescription))
58:                 }
59:             }, receiveValue: { [weak self] message in
60:                 self?.addMessage(message)
61:             }).store(in: &self.cancelBag)
62:     }
63:     
64:     private func addMessage(_ message: ChatPdfMessage) {
65:         // if messages list is empty just add new message
66:         guard let lastMessage = self.messages.last else {
67:             self.messages.append(message)
68:             return
69:         }
70:         // if last message is an indicator switch with new one
71:         if lastMessage.type == .indicator && lastMessage.role != .user {
72:             self.messages[self.messages.count - 1] = message
73:         } else {
74:             // otherwise, add new message to the end of the list
75:             self.messages.append(message)
76:         }
77:     }
78: }
79: 
80: fileprivate extension ChatPdfSetupData {
81:     var message: ChatPdfMessage {
82:         ChatPdfMessage(role: .assistant, type: .text, content: self.summary, suggestedQuestions: self.suggestedQuestions)
83:     }
84: }
```

## File: pdfexpert/ViewModels/GalleryImageProviderFlow.swift
```swift
 1: //
 2: //  GalleryImageProviderFlow.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 06/09/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import PhotosUI
11: import UIKit
12: import SwiftUI
13: 
14: extension Container {
15:     var galleryImageProviderFlow: Factory<GalleryImageProviderFlow> {
16:         self { GalleryImageProviderFlow() }
17:     }
18: }
19: 
20: class GalleryImageProviderFlow: ObservableObject {
21:     
22:     typealias GalleryImageSelectedCallback = ((UIImage) -> ())
23:     
24:     @Published var asyncImageLoading: AsyncEmptyFailable<SharedUnderlyingError> = .idle
25:     @Published var imagePickerShow: Bool = false
26:     @Published var imageSelection: PhotosPickerItem? = nil {
27:         didSet {
28:             if let imageSelection {
29:                 let progress = self.loadTransferable(from: imageSelection)
30:                 self.asyncImageLoading = .loading(progress)
31:             } else {
32:                 self.asyncImageLoading = .idle
33:             }
34:         }
35:     }
36:     
37:     private var onImageSelected: GalleryImageSelectedCallback?
38:     
39:     func startFlow(onImageSelected: @escaping GalleryImageSelectedCallback) {
40:         self.onImageSelected = onImageSelected
41:         self.imagePickerShow = true
42:     }
43:     
44:     private func loadTransferable(from imageSelection: PhotosPickerItem) -> Progress {
45:         return imageSelection.loadTransferable(type: PickedImage.self) { result in
46:             DispatchQueue.main.async {
47:                 switch result {
48:                 case .success(let image?):
49:                     self.asyncImageLoading = .idle
50:                     self.onImageSelected?(image.uiImage)
51:                 case .success(nil):
52:                     self.asyncImageLoading = .idle
53:                 case .failure(let error):
54:                     self.asyncImageLoading = .error(SharedUnderlyingError.convertError(fromError: error))
55:                 }
56:             }
57:         }
58:     }
59: }
```

## File: pdfexpert/ViewModels/HomeViewModel.swift
```swift
  1: //
  2: //  HomeViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 28/03/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import SwiftUI
 11: import PhotosUI
 12: import PSPDFKit
 13: 
 14: @MainActor
 15: extension Container {
 16:     var homeViewModel: Factory<HomeViewModel> {
 17:         self { HomeViewModel() }
 18:     }
 19: }
 20: 
 21: enum HomeAction: Hashable, Identifiable {
 22:     
 23:     var id: Self { return self }
 24:     
 25:     case appExtension
 26:     
 27:     case imageToPdf
 28:     case wordToPdf
 29:     case excelToPdf
 30:     case powerpointToPdf
 31:     case scan
 32:     
 33:     case merge
 34:     case split
 35:     
 36:     case sign
 37:     case formFill
 38:     case addText
 39:     case createPdf
 40:     
 41:     case importPdf
 42:     
 43:     case readPdf
 44:     
 45:     case removePassword
 46:     case addPassword
 47:     
 48:     var importFileOption: ImportFileOption? {
 49:         switch self {
 50:         case .appExtension: return nil
 51:         case .imageToPdf: return .image
 52:         case .wordToPdf: return .word
 53:         case .excelToPdf: return .excel
 54:         case .powerpointToPdf: return .powerpoint
 55:         case .scan: return nil
 56:         case .merge: return .pdf
 57:         case .split: return .pdf
 58:         case .sign: return .allDocs
 59:         case .formFill: return .pdf
 60:         case .addText: return .allDocs
 61:         case .createPdf: return nil
 62:         case .importPdf: return .pdf
 63:         case .readPdf: return .pdf
 64:         case .removePassword: return .pdf
 65:         case .addPassword: return .pdf
 66:         }
 67:     }
 68:     
 69:     var editStartAction: PdfEditStartAction? {
 70:         switch self {
 71:         case .appExtension: return nil
 72:         case .imageToPdf: return nil
 73:         case .wordToPdf: return nil
 74:         case .excelToPdf: return nil
 75:         case .powerpointToPdf: return nil
 76:         case .scan: return nil
 77:         case .merge: return nil
 78:         case .split: return nil
 79:         case .sign: return .openSignature
 80:         case .formFill: return .openFillWidget
 81:         case .addText: return .openFillForm
 82:         case .createPdf: return nil
 83:         case .importPdf: return nil
 84:         case .readPdf: return nil
 85:         case .removePassword: return nil
 86:         case .addPassword: return nil
 87:         }
 88:     }
 89:     
 90:     var homePostImportAction: HomePostImportAction? {
 91:         switch self {
 92:         case .appExtension: return nil
 93:         case .imageToPdf: return nil
 94:         case .wordToPdf: return nil
 95:         case .excelToPdf: return nil
 96:         case .powerpointToPdf: return nil
 97:         case .scan: return nil
 98:         case .merge: return nil
 99:         case .split: return nil
100:         case .sign: return nil
101:         case .formFill: return nil
102:         case .addText: return nil
103:         case .createPdf: return nil
104:         case .importPdf: return nil
105:         case .readPdf: return nil
106:         case .removePassword: return .removePassword
107:         case .addPassword: return .addPassword
108:         }
109:     }
110: }
111: 
112: enum ImportFileOption: Hashable, Identifiable {
113:     
114:     var id: Self { return self }
115:     
116:     case image
117:     case word
118:     case excel
119:     case powerpoint
120:     case pdf
121:     case allDocs
122: }
123: 
124: enum FileSource: Hashable, Identifiable {
125:     var id: Self { return self }
126:     case google, dropbox, icloud, files
127: }
128: 
129: enum HomePostImportAction: Hashable, Identifiable {
130:     var id: Self { return self }
131:     case addPassword, removePassword
132: }
133: 
134: @MainActor
135: public class HomeViewModel : ObservableObject {
136:     
137:     @Published var importOptionGroup: ImportOptionGroup? = nil
138:     @Published var importFileOption: ImportFileOption? = nil
139:     
140:     @Published var imagePickerShow: Bool = false
141:     @Published var imageSelection: PhotosPickerItem? = nil {
142:         didSet {
143:             if let imageSelection {
144:                 let progress = self.loadTransferable(from: imageSelection)
145:                 self.asyncImageLoading = AsyncOperation(status: .loading(progress))
146:             } else {
147:                 self.asyncImageLoading = AsyncOperation(status: .empty)
148:             }
149:         }
150:     }
151:     
152:     @Published var asyncImageLoading: AsyncOperation<(), SharedUnderlyingError> = AsyncOperation(status: .empty)
153:     
154:     @Published var cameraShow: Bool = false
155:     @Published var scannerShow: Bool = false
156:     @Published var cameraPermissionDeniedShow: Bool = false
157:     @Published var addPasswordShow: Bool = false
158:     
159:     @Published var asyncPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
160:         didSet {
161:             if let pdf = self.asyncPdf.data {
162:                 self.trackFullActionCompleted()
163:                 if let homePostImportAction = self.action?.homePostImportAction {
164:                     self.performHomePostImportAction(homePostImportAction)
165:                 } else {
166:                     self.mainCoordinator.showPdfEditFlow(pdf: pdf, startAction: self.editStartAction, isNewPdf: true)
167:                 }
168:             }
169:         }
170:     }
171:     
172:     @Published var pdfSaved: Pdf? = nil
173:     @Published var addPasswordCompletedShow: Bool = false
174:     @Published var removePasswordCompletedShow: Bool = false
175:     @Published var addPasswordError: AddPasswordError? = nil
176:     @Published var removePasswordError: RemovePasswordError? = nil
177:     
178:     @Injected(\.store) private var store
179:     @Injected(\.analyticsManager) private var analyticsManager
180:     @Injected(\.repository) private var repository
181:     @Injected(\.mainCoordinator) private var mainCoordinator
182:     @Injected(\.pdfShareCoordinator) var pdfShareCoordinator
183:     @Injected(\.pdfSplitViewModel) var pdfSplitViewModel
184:     @Injected(\.pdfReadViewModel) var pdfReadViewModel
185:     
186:     lazy var pdfUnlockViewModel: PdfUnlockViewModel = {
187:         Container.shared.pdfUnlockViewModel(PdfUnlockViewModel.Params(asyncUnlockedPdfSingleOutput: self.asyncSubject(\.asyncPdf)))
188:     }()
189:     
190:     lazy var pdfMergeViewModel: PdfMergeViewModel = { Container.shared.pdfMergeViewModel(PdfMergeViewModel.Params(asyncPdf: self.asyncSubject(\.asyncPdf)))
191:     }()
192:     
193:     var editStartAction: PdfEditStartAction? { self.action?.editStartAction }
194:     
195:     private var action: HomeAction? = nil
196:     private var currentAnalyticsImportOption: ImportOption? = nil
197:     private var currentAnalyticsFileExtension: String? = nil
198:     
199:     @MainActor
200:     func onAppear() {
201:         self.action = nil
202:         Task {
203:             try await self.store.refreshAll()
204:         }
205:         self.analyticsManager.track(event: .reportScreen(.home))
206:     }
207:     
208:     @MainActor
209:     func onDidBecomeActive() {
210:         Task {
211:             try await self.checkShareExtensionPdf()
212:         }
213:     }
214:     
215:     @MainActor
216:     func performHomeAction(_ action: HomeAction) {
217:         self.action = action
218:         self.trackActionChosen(action: action)
219:         
220:         switch action {
221:         case .appExtension:
222:             assertionFailure("App Extension behaviour is not supposed to be triggered by a CTA")
223:             break
224:         case .imageToPdf:
225:             self.importOptionGroup = .image
226:         case .wordToPdf, .excelToPdf, .powerpointToPdf, .importPdf, .formFill, .removePassword, .addPassword:
227:             self.openFilePicker(fileSource: .files)
228:         case .sign, .addText:
229:             self.importOptionGroup = .fileAndScan
230:         case .createPdf:
231:             self.createPdf()
232:         case .scan:
233:             self.scanPdf()
234:         case .merge:
235:             self.pdfMergeViewModel.merge()
236:         case .readPdf:
237:             self.pdfReadViewModel.read(pdf: nil)
238:         case .split:
239:             self.pdfSplitViewModel.split(pdf: nil,
240:                                          onSplitCompleted: { [weak self] in
241:                 self?.trackFullActionCompleted()
242:                 self?.mainCoordinator.goToArchive()
243:             })
244:         }
245:     }
246:     
247:     @MainActor
248:     func handleImportOption(importOption: ImportOption) {
249:         switch importOption {
250:         case .camera: self.openCamera()
251:         case .gallery: self.openGallery()
252:         case .scan: self.scanPdf()
253:         case .file(let fileSource):
254:             switch fileSource {
255:             case .google: self.openFilePicker(fileSource: .google)
256:             case .dropbox: self.openFilePicker(fileSource: .dropbox)
257:             case .icloud: self.openFilePicker(fileSource: .icloud)
258:             case .files: self.openFilePicker(fileSource: .files)
259:             }
260:         }
261:     }
262:     
263:     @MainActor
264:     func openFilePicker(fileSource: FileSource) {
265:         self.trackFullActionChosen(importOption: .file(fileSource: fileSource))
266:         self.importOptionGroup = nil
267:         Task {
268:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
269:             guard let importFileOption = self.action?.importFileOption else {
270:                 assertionFailure("Missing expected import file option for current action")
271:                 return
272:             }
273:             self.importFileOption = importFileOption
274:         }
275:     }
276:     
277:     @MainActor
278:     func openCamera() {
279:         self.importOptionGroup = nil
280:         self.trackFullActionChosen(importOption: .camera)
281:         Task {
282:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
283:             self.cameraShow = true
284:         }
285:     }
286:     
287:     @MainActor
288:     func openGallery() {
289:         self.importOptionGroup = nil
290:         self.trackFullActionChosen(importOption: .gallery)
291:         Task {
292:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
293:             self.imagePickerShow = true
294:         }
295:     }
296:     
297:     @MainActor
298:     func scanPdf() {
299:         self.importOptionGroup = nil
300:         // In this case ImportOption.scan is not actually been selected by the user,
301:         // but is provided for coherence
302:         self.trackFullActionChosen(importOption: .scan)
303:         Task {
304:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
305:             self.showScanner()
306:         }
307:     }
308:     
309:     @MainActor
310:     func convertImage(uiImage: UIImage) {
311:         self.cameraShow = false
312:         Task {
313:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
314:             self.convertUiImageToPdf(uiImage: uiImage, filename: nil)
315:         }
316:     }
317:     
318:     @MainActor
319:     func convertScan(scannerResult: ScannerResult) {
320:         self.scannerShow = false
321:         Task {
322:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
323:             PdfScanUtility.convertScan(scannerResult: scannerResult, asyncOperation: self.asyncSubject(\.asyncPdf))
324:         }
325:     }
326:     
327:     @MainActor
328:     func processPickedFileUrl(_ fileUrl: URL?) {
329:         guard let fileUrl else {
330:             assertionFailure("Missing expected url")
331:             self.asyncPdf = AsyncOperation(status: .error(.unknownError))
332:             return
333:         }
334:         
335:         self.importFileOption = nil
336:         Task {
337:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
338:             switch self.action {
339:             case .imageToPdf:
340:                 self.convertFileImageByURL(fileImageUrl: fileUrl)
341:             case .wordToPdf, .excelToPdf, .powerpointToPdf, .sign, .formFill, .addText, .createPdf:
342:                 self.convertFileByUrl(fileUrl: fileUrl)
343:             case .importPdf, .removePassword, .addPassword:
344:                 self.importPdf(pdfUrl: fileUrl)
345:             case .scan, .appExtension, .none, .merge, .split, .readPdf:
346:                 assertionFailure("Selected file url is not handled for the current action")
347:             }
348:         }
349:     }
350:     
351:     @MainActor
352:     func importPdf(pdfUrl: URL) {
353:         guard let pdf = Pdf(pdfUrl: pdfUrl) else {
354:             assertionFailure("Missing expected file for give url")
355:             return
356:         }
357:         
358:         self.currentAnalyticsFileExtension = pdfUrl.pathExtension
359:         if pdf.pdfDocument.isLocked, self.action?.homePostImportAction == .addPassword {
360:             self.addPasswordError = .pdfHasPassword
361:         } else if !pdf.pdfDocument.isLocked, self.action?.homePostImportAction == .removePassword {
362:             self.removePasswordError = .pdfNoPassword
363:         } else {
364:             self.pdfUnlockViewModel.unlockPdf(pdf: pdf)
365:         }
366:     }
367:     
368:     func setPassword(_ password: String) {
369:         self.internalSetPassword(password)
370:         debugPrint(for: self, message: "New password: \(password)")
371:         self.analyticsManager.track(event: .passwordAdded)
372:     }
373:     
374:     func goToArchive() {
375:         self.mainCoordinator.goToArchive()
376:         self.pdfSaved = nil
377:     }
378:     
379:     func share() {
380:         guard let pdfSaved else {
381:             assertionFailure("Missing expected pdfSaved entity")
382:             return
383:         }
384:         self.pdfShareCoordinator.share(pdf: pdfSaved, applyPostProcess: false, onComplete: { [weak self] in
385:             self?.mainCoordinator.startReview()
386:         })
387:         self.pdfSaved = nil
388:     }
389:     
390:     @MainActor
391:     private func convertFileImageByURL(fileImageUrl: URL) {
392:         do {
393:             let imageData = try Data(contentsOf: fileImageUrl)
394:             guard let uiImage = UIImage(data: imageData) else {
395:                 self.asyncImageLoading = AsyncOperation(status: .error(.unknownError))
396:                 return
397:             }
398:             self.currentAnalyticsFileExtension = fileImageUrl.pathExtension
399:             self.convertUiImageToPdf(uiImage: uiImage, filename: fileImageUrl.filename)
400:         } catch {
401:             debugPrint(for: self, message: "Error retrieving file. Error: \(error)")
402:             self.asyncImageLoading = AsyncOperation(status: .error(.unknownError))
403:         }
404:     }
405:     
406:     @MainActor
407:     private func convertFileByUrl(fileUrl: URL) {
408:         let fileUtType = UTType(filenameExtension: fileUrl.pathExtension)
409:         if fileUtType?.conforms(to: .pdf) ?? false {
410:             self.importPdf(pdfUrl: fileUrl)
411:         } else {
412:             self.asyncPdf = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
413:             Processor.generatePDF(from: fileUrl, options: [:]) { data, error in
414:                 if let error = error {
415:                     debugPrint(for: self, message: "Error converting word file. Error: \(error)")
416:                     self.asyncPdf = AsyncOperation(status: .error(.unknownError))
417:                 } else if let data = data, var pdf = Pdf(data: data) {
418:                     self.currentAnalyticsFileExtension = fileUrl.pathExtension
419:                     pdf.updateFilename(fileUrl.filename)
420:                     self.asyncPdf = AsyncOperation(status: .data(pdf))
421:                 } else {
422:                     self.asyncPdf = AsyncOperation(status: .error(.unknownError))
423:                 }
424:             }
425:         }
426:     }
427:     
428:     private func loadTransferable(from imageSelection: PhotosPickerItem) -> Progress {
429:         return imageSelection.loadTransferable(type: PickedImage.self) { result in
430:             DispatchQueue.main.async {
431:                 guard imageSelection == self.imageSelection else {
432:                     print("Failed to get the selected item.")
433:                     return
434:                 }
435:                 switch result {
436:                 case .success(let image?):
437:                     self.asyncImageLoading = AsyncOperation(status: .data(()))
438:                     self.convertUiImageToPdf(uiImage: image.uiImage, filename: nil)
439:                 case .success(nil):
440:                     self.asyncImageLoading = AsyncOperation(status: .empty)
441:                 case .failure(let error):
442:                     let convertedError = SharedUnderlyingError.convertError(fromError: error)
443:                     self.asyncImageLoading = AsyncOperation(status: .error(convertedError))
444:                 }
445:             }
446:         }
447:     }
448:     
449:     private func convertUiImageToPdf(uiImage: UIImage, filename: String?) {
450:         let pdfDocument = PDFUtility.convertUiImageToPdf(uiImage: uiImage)
451:         var pdf = Pdf(pdfDocument: pdfDocument)
452:         if let filename {
453:             pdf.updateFilename(filename)
454:         }
455:         self.asyncPdf = AsyncOperation(status: .data(pdf))
456:     }
457:     
458:     @MainActor
459:     private func showScanner() {
460:         switch AVCaptureDevice.authorizationStatus(for: .video) {
461:         case .authorized, .notDetermined:
462:             self.scannerShow = true
463:         default:
464:             self.cameraPermissionDeniedShow = true
465:         }
466:     }
467:     
468:     @MainActor
469:     private func checkShareExtensionPdf() async throws {
470:         let pdfDataExpected = SharedStorage.pdfDataShareExtensionExistanceFlag
471:         let pdfData = SharedStorage.pdfDataShareExtension
472:         
473:         let resetSharedStorage = {
474:             SharedStorage.pdfDataShareExtension = nil
475:             SharedStorage.pdfDataShareExtensionExistanceFlag = false
476:             SharedStorage.pdfDataShareExtensionPassword = nil
477:         }
478:         
479:         if let pdfData = pdfData {
480:             let fileSizeWithUnit = ByteCountFormatter.string(fromByteCount: Int64(pdfData.count), countStyle: .file)
481:             debugPrint("Share Extension - Loaded pdf data with size: \(fileSizeWithUnit)")
482:         }
483:         
484:         guard pdfDataExpected, let pdfData = pdfData else {
485:             if pdfDataExpected {
486:                 self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfMissingRawData))
487:                 resetSharedStorage()
488:             } else if pdfData != nil {
489:                 self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfExistingUnexpectedRawData))
490:                 resetSharedStorage()
491:             }
492:             return
493:         }
494:         
495:         guard var pdf = Pdf(data: pdfData) else {
496:             self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfCannotDecode))
497:             resetSharedStorage()
498:             return
499:         }
500:         
501:         if pdf.pdfDocument.isEncrypted {
502:             let password = SharedStorage.pdfDataShareExtensionPassword ?? ""
503:             
504:             guard pdf.pdfDocument.unlock(withPassword: password) else {
505:                 self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfInvalidPasswordForLockedFile))
506:                 resetSharedStorage()
507:                 return
508:             }
509:             
510:             guard let pdfEncryptedData = pdf.pdfDocument.dataRepresentation() else {
511:                 self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfMissingDataForUnlockedFile))
512:                 resetSharedStorage()
513:                 return
514:             }
515:             guard let pdfDecryptedData = try? PDFUtility.removePassword(data: pdfEncryptedData, existingPDFPassword: password) else {
516:                 self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfDecryptionFailed))
517:                 resetSharedStorage()
518:                 return
519:             }
520:             guard var pdfDecrypted = Pdf(data: pdfDecryptedData) else {
521:                 self.analyticsManager.track(event: .reportNonFatalError(.shareExtensionPdfCannotDecodeDecryptedData))
522:                 resetSharedStorage()
523:                 return
524:             }
525:             pdfDecrypted.updatePassword(password)
526:             pdf = pdfDecrypted
527:         }
528:         resetSharedStorage()
529:         // TODO: Ask the user whether to discard the current pdf or not
530:         if self.asyncPdf.data != nil {
531:             self.asyncPdf = AsyncOperation(status: .empty)
532:             // This is a workaround to force swiftui to update its state and dismiss
533:             // the current modal for the pdf edit flow, so that the new one can be
534:             // shown in its place.
535:             try await Task.sleep(until: .now + .seconds(0.5), clock: .continuous)
536:         }
537:         
538:         self.analyticsManager.track(event: .homeFullActionCompleted(homeAction: .appExtension, importOption: nil, fileExtension: "pdf"))
539:         self.asyncPdf = AsyncOperation(status: .data(pdf))
540:     }
541:     
542:     private func createPdf() {
543:         self.trackFullActionChosen(importOption: nil)
544:         self.asyncPdf = AsyncOperation(status: .data(Pdf()))
545:     }
546:     
547:     private func performHomePostImportAction(_ action: HomePostImportAction) {
548:         switch action {
549:         case .addPassword:
550:             self.addPasswordShow = true
551:         case .removePassword:
552:             self.internalSetPassword(nil)
553:             debugPrint(for: self, message: "Password removed")
554:             self.analyticsManager.track(event: .passwordRemoved)
555:         }
556:     }
557:     
558:     private func internalSetPassword(_ password: String?) {
559:         guard var pdf = self.asyncPdf.data else {
560:             assertionFailure("Missing expected pdf ")
561:             self.asyncPdf = AsyncOperation(status: .error(.unknownError))
562:             return
563:         }
564:         do {
565:             pdf.updatePassword(password)
566:             self.pdfSaved = try self.repository.savePdf(pdf: pdf)
567:             if password != nil {
568:                 self.addPasswordCompletedShow = true
569:             } else {
570:                 self.removePasswordCompletedShow = true
571:             }
572:             self.asyncPdf = AsyncOperation(status: .empty)
573:         } catch {
574:             debugPrint(for: self, message: "Pdf save failed with error: \(error)")
575:             self.asyncPdf = AsyncOperation(status: .error(.unknownError))
576:         }
577:     }
578:     
579:     private func trackActionChosen(action: HomeAction) {
580:         self.analyticsManager.track(event: .homeActionChosen(homeAction: action))
581:     }
582:     
583:     private func trackFullActionChosen(importOption: ImportOption?) {
584:         if let action = self.action {
585:             self.currentAnalyticsImportOption = importOption
586:             self.analyticsManager.track(event: .homeFullActionChosen(homeAction: action, importOption: importOption))
587:         }
588:     }
589:     
590:     private func trackFullActionCompleted() {
591:         if let action = self.action {
592:             self.analyticsManager.track(event: .homeFullActionCompleted(homeAction: action,
593:                                                                         importOption: self.currentAnalyticsImportOption,
594:                                                                         fileExtension: self.currentAnalyticsFileExtension))
595:         }
596:         self.currentAnalyticsImportOption = nil
597:         self.currentAnalyticsFileExtension = nil
598:     }
599: }
```

## File: pdfexpert/ViewModels/ImageCropFlow.swift
```swift
 1: //
 2: //  ImageCropFlow.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 06/09/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import UIKit
11: import Mantis
12: 
13: extension Container {
14:     var imageCropFlow: Factory<ImageCropFlow> {
15:         self { ImageCropFlow() }
16:     }
17: }
18: 
19: class ImageCropFlow: ObservableObject {
20:     
21:     typealias ImageCroppedCallback = ((UIImage) -> ())
22:     
23:     @Published var cropperShow: Bool = false
24:     @Published var image: UIImage? = nil {
25:         didSet {
26:             self.onCropCompleted(image: image)
27:         }
28:     }
29:     @Published var cropShapeType: Mantis.CropShapeType = .rect
30:     @Published var presetFixedRatioType: Mantis.PresetFixedRatioType = .canUseMultiplePresetFixedRatio()
31:     @Published var type: ImageCropperType = .normal
32:     
33:     private var onImageCropped: ImageCroppedCallback? = nil
34:     
35:     func startFlow(
36:         image: UIImage,
37:         cropShapeType: Mantis.CropShapeType = .rect,
38:         presetFixedRatioType: Mantis.PresetFixedRatioType = .canUseMultiplePresetFixedRatio(),
39:         type: ImageCropperType = .normal,
40:         onImageCropped: @escaping ImageCroppedCallback
41:     ) {
42:         self.cropperShow = true
43:         self.image = image
44:         self.cropShapeType = cropShapeType
45:         self.presetFixedRatioType = presetFixedRatioType
46:         self.type = type
47:         self.onImageCropped = onImageCropped
48:     }
49:     
50:     func onCropViewDismiss() {
51:         self.onCropCompleted(image: nil)
52:     }
53:     
54:     private func onCropCompleted(image: UIImage?) {
55:         if let image {
56:             self.onImageCropped?(image)
57:         }
58:         self.onImageCropped = nil
59:     }
60: }
```

## File: pdfexpert/ViewModels/OnboardingViewModel.swift
```swift
 1: //
 2: //  OnboardingViewModel.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 25/05/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: 
11: extension Container {
12:     var onboardingViewModel: Factory<OnboardingViewModel> {
13:         self { OnboardingViewModel() }
14:     }
15: }
16: 
17: struct OnboardingItem {
18:     let imageName: String
19:     let title: String
20:     let description: String
21: }
22: 
23: public class OnboardingViewModel : ObservableObject {
24:     
25:     let items: [OnboardingItem] = [
26:         OnboardingItem(
27:             imageName: "onboarding_convert",
28:             title: "Convert files to PDF",
29:             description: "You can convert to pdf a lot of file types from the programs you prefer."
30:         ),
31:         OnboardingItem(
32:             imageName: "onboarding_signature",
33:             title: "Enter and edit your signature",
34:             description: "Insert your signature in the pdf you created with a single tap."
35:         ),
36:         OnboardingItem(
37:             imageName: "onboarding_password",
38:             title: "Protect your files with password",
39:             description: "Enter a password to protect your pdf, you can delete it and change it whenever you want."
40:         ),
41:         OnboardingItem(
42:             imageName: "onboarding_chat_pdf",
43:             title: "Chat with any PDF files",
44:             description: "You can ask questions to any PDF and get quick insights and clarifications."
45:         ),
46:     ]
47:     
48:     @Published var monetizationShow: Bool = false
49:     @Published var pageIndex = 0
50:     
51:     @Injected(\.store) private var store
52:     @Injected(\.mainCoordinator) private var coordinator
53:     @Injected(\.cacheManager) private var cacheManager
54:     @Injected(\.analyticsManager) private var analyticsManager
55:     
56:     func onMonetizationClose() {
57:         self.coordinator.goToMain()
58:     }
59:     
60:     func continueButtonPressed() {
61:         if self.pageIndex >= self.items.count - 1 {
62:             self.analyticsManager.track(event: .onboardingCompleted)
63:             self.closeOnboarding()
64:         } else {
65:             self.pageIndex += 1
66:         }
67:     }
68:     
69:     func skipButtonPressed() {
70:         self.analyticsManager.track(event: .onboardingSkipped)
71:         self.closeOnboarding()
72:     }
73:     
74:     private func closeOnboarding() {
75:         self.cacheManager.onboardingShown = true
76:         
77:         if self.store.isPremium.value {
78:             self.coordinator.goToMain()
79:         } else {
80:             self.monetizationShow = true
81:         }
82:     }
83: }
```

## File: pdfexpert/ViewModels/PdfEditViewModel.swift
```swift
  1: //
  2: //  PdfEditViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 11/04/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import SwiftUI
 11: import UIKit
 12: import PhotosUI
 13: import PSPDFKit
 14: 
 15: @MainActor
 16: extension Container {
 17:     var pdfEditViewModel: ParameterFactory<PdfEditViewModel.InputParameter, PdfEditViewModel> {
 18:         self { PdfEditViewModel(inputParameter: $0) }
 19:     }
 20: }
 21: 
 22: enum PdfEditStartAction {
 23:     case openFillWidget
 24:     case openFillForm
 25:     case openSignature
 26: }
 27: 
 28: enum EditAction: CaseIterable {
 29:     case password
 30:     case compression
 31:     case split
 32: }
 33: 
 34: @MainActor
 35: class PdfEditViewModel: ObservableObject {
 36:     
 37:     struct InputParameter {
 38:         let pdf: Pdf
 39:         let startAction: PdfEditStartAction?
 40:         let shouldShowCloseWarning: Binding<Bool>
 41:     }
 42:     
 43:     @Published private(set)var pdf: Pdf
 44:     @Published var pdfCurrentPageIndex: Int = 0
 45:     @Published var pageImages: [UIImage] = []
 46:     @Published var pdfThumbnails: [UIImage] = []
 47:     @Published var pdfSaveError: PdfEditSaveError? = nil
 48:     @Published var filePickerShow: Bool = false
 49:     @Published var cameraShow: Bool = false
 50:     @Published var imagePickerShow: Bool = false
 51:     @Published var scannerShow: Bool = false
 52:     @Published var cameraPermissionDeniedShow: Bool = false
 53:     @Published var missingWidgetWarningShow: Bool = false
 54:     
 55:     @Published var imageSelection: PhotosPickerItem? = nil {
 56:         didSet {
 57:             if let imageSelection {
 58:                 let progress = self.loadTransferable(from: imageSelection)
 59:                 self.asyncImageLoading = AsyncOperation(status: .loading(progress))
 60:             } else {
 61:                 self.asyncImageLoading = AsyncOperation(status: .empty)
 62:             }
 63:         }
 64:     }
 65:     
 66:     @Published var asyncImageLoading: AsyncOperation<(), SharedUnderlyingError> = AsyncOperation(status: .empty)
 67:     @Published var asyncPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
 68:         didSet {
 69:             if let pdf = self.asyncPdf.data  {
 70:                 self.appendPdfToPdf(pdf: pdf)
 71:                 self.asyncPdf = AsyncOperation(status: .empty)
 72:             }
 73:         }
 74:     }
 75:     
 76:     @Published var saveSuccessfulAlertShow: Bool = false
 77:     
 78:     @Published var pdfFilename: String {
 79:         didSet {
 80:             self.onPdfChanged()
 81:         }
 82:     }
 83:     @Published var compression: CompressionOption {
 84:         didSet {
 85:             self.onPdfChanged()
 86:         }
 87:     }
 88:     
 89:     @Published var signatureAddViewShow: Bool = false
 90:     @Published var fillFormViewShow: Bool = false
 91:     @Published var fillWidgetViewShow: Bool = false
 92:     
 93:     @Published var editOptionListShow: Bool = false
 94:     @Published var passwordTextFieldShow: Bool = false
 95:     @Published var removePasswordAlertShow: Bool = false
 96:     @Published var splitSuccessAlertShow: Bool = false
 97:     @Published var compressionShow: Bool = false
 98:     
 99:     @Injected(\.repository) private var repository
100:     @Injected(\.mainCoordinator) private var mainCoordinator
101:     @Injected(\.pdfCoordinator) private var pdfCoordinator
102:     @Injected(\.analyticsManager) private var analyticsManager
103:     @Injected(\.pdfShareCoordinator) var pdfShareCoordinator
104:     @Injected(\.pdfSplitViewModel) var pdfSplitViewModel
105:     
106:     lazy var pdfUnlockViewModel: PdfUnlockViewModel = {
107:         Container.shared.pdfUnlockViewModel(PdfUnlockViewModel.Params(asyncUnlockedPdfSingleOutput: self.asyncSubject(\.asyncPdf)))
108:     }()
109:     
110:     // This boolean is set to true every time a change is applied to the original pdf.
111:     // TODO: Find a more robust solution
112:     var shouldShowCloseWarning: Binding<Bool>
113:     var urlToFileToConvert: URL?
114:     var imageToConvert: UIImage?
115:     var scannerResult: ScannerResult?
116:     
117:     var currentAnalyticsPdfInputType: AnalyticsPdfInputType? = nil
118:     var currentAnalyticsInputFileExtension: String? = nil
119:     var startAction: PdfEditStartAction? = nil
120:     
121:     init(inputParameter: InputParameter) {
122:         self.pdf = inputParameter.pdf
123:         self.pdfFilename = inputParameter.pdf.filename
124:         self.compression = inputParameter.pdf.compression
125:         self.startAction = inputParameter.startAction
126:         self.shouldShowCloseWarning = inputParameter.shouldShowCloseWarning
127:         self.refreshImages()
128:         self.refreshThumbnails()
129:     }
130:     
131:     @MainActor
132:     func onAppear() {
133:         Task {
134:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
135:             
136:             if let startAction = self.startAction {
137:                 switch startAction {
138:                 case .openFillWidget:
139:                     if PDFUtility.hasPdfWidget(pdf: self.pdf) {
140:                         self.fillWidgetViewShow = true
141:                     } else {
142:                         self.missingWidgetWarningShow = true
143:                     }
144:                 case .openFillForm:
145:                     self.fillFormViewShow = true
146:                 case .openSignature:
147:                     self.signatureAddViewShow = true
148:                 }
149:             }
150:             self.startAction = nil
151:         }
152:     }
153:     
154:     func deleteCurrentPage() {
155:         guard self.pdfThumbnails.count == self.pdf.pdfDocument.pageCount else {
156:             assertionFailure("Inconsistency error: pdf thumbnails count doesn't match pdf pages count")
157:             return
158:         }
159:         guard self.pageImages.count == self.pdf.pdfDocument.pageCount else {
160:             assertionFailure("Inconsistency error: pdf page images count doesn't match pdf pages count")
161:             return
162:         }
163:         let maxIndex = self.pdf.pdfDocument.pageCount
164:         
165:         guard self.pdfCurrentPageIndex >= 0, self.pdfCurrentPageIndex < maxIndex else {
166:             debugPrint(for: self, message: "Out of bound index!")
167:             return
168:         }
169:         self.pdf.pdfDocument.removePage(at: self.pdfCurrentPageIndex)
170:         self.pdfThumbnails.remove(at: self.pdfCurrentPageIndex)
171:         self.pageImages.remove(at: self.pdfCurrentPageIndex)
172:         
173:         let newMaxIndex = self.pdf.pdfDocument.pageCount
174:         
175:         if self.pdfCurrentPageIndex >= newMaxIndex {
176:             self.pdfCurrentPageIndex = (newMaxIndex > 0) ? newMaxIndex - 1 : 0
177:         }
178:         
179:         self.shouldShowCloseWarning.wrappedValue = true
180:         
181:         self.analyticsManager.track(event: .pageRemoved)
182:     }
183:     
184:     func openFilePicker() {
185:         self.filePickerShow = true
186:         self.currentAnalyticsPdfInputType = .file
187:     }
188:     
189:     func openCamera() {
190:         self.cameraShow = true
191:         self.currentAnalyticsPdfInputType = .camera
192:     }
193:     
194:     func openGallery() {
195:         self.imagePickerShow = true
196:         self.currentAnalyticsPdfInputType = .gallery
197:     }
198:     
199:     func openScanner() {
200:         self.currentAnalyticsPdfInputType = .scan
201:         self.showScanner()
202:     }
203:     
204:     func save() {
205:         do {
206:             try self.internalSave()
207:             self.saveSuccessfulAlertShow = true
208:         } catch let error as PdfEditSaveError  {
209:             debugPrint(for: self, message: "Pdf save failed with error: \(error)")
210:             self.pdfSaveError = error
211:         } catch {
212:             self.pdfSaveError = .unknown
213:         }
214:     }
215:     
216:     func share() {
217:         do {
218:             try self.internalSave()
219:             self.internalShare()
220:         } catch let error as PdfEditSaveError  {
221:             debugPrint(for: self, message: "Pdf save failed with error: \(error)")
222:             self.pdfSaveError = error
223:         } catch {
224:             self.pdfSaveError = .unknown
225:         }
226:     }
227:     
228:     func goToArchive() {
229:         self.mainCoordinator.closePdfEditFlow()
230:         self.mainCoordinator.goToArchive()
231:     }
232:     
233:     func showAddSignature() {
234:         self.signatureAddViewShow = true
235:     }
236:     
237:     func showFillForm() {
238:         self.fillFormViewShow = true
239:     }
240:     
241:     func showFillWidget() {
242:         if PDFUtility.hasPdfWidget(pdf: self.pdf) {
243:             self.fillWidgetViewShow = true
244:         } else {
245:             self.missingWidgetWarningShow = true
246:         }
247:     }
248:     
249:     @MainActor
250:     func handleEditAction(_ action: EditAction) {
251:         
252:         self.editOptionListShow = false
253:         
254:         Task {
255:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
256:             
257:             switch action {
258:             case .password:
259:                 if self.pdf.password != nil {
260:                     self.removePasswordAlertShow = true
261:                 } else {
262:                     self.passwordTextFieldShow = true
263:                 }
264:             case .compression:
265:                 self.compressionShow = true
266:             case .split:
267:                 self.pdfSplitViewModel.split(pdf: self.pdf, onSplitCompleted: { [weak self] in
268:                     self?.splitSuccessAlertShow = true
269:                 })
270:             }
271:         }
272:     }
273:     
274:     func setPassword(_ password: String) {
275:         self.internalSetPassword(password)
276:         debugPrint(for: self, message: "New password: \(password)")
277:         self.analyticsManager.track(event: .passwordAdded)
278:     }
279:     
280:     func removePassword() {
281:         self.internalSetPassword(nil)
282:         debugPrint(for: self, message: "Password removed")
283:         self.analyticsManager.track(event: .passwordRemoved)
284:     }
285:     
286:     @MainActor
287:     func convert() {
288:         if let urlToFileToConvert = self.urlToFileToConvert {
289:             self.urlToFileToConvert = nil
290:             self.convertFileByUrl(fileUrl: urlToFileToConvert)
291:         } else if let imageToConvert = self.imageToConvert {
292:             self.imageToConvert = nil
293:             self.appendUiImageToPdf(uiImage: imageToConvert)
294:         } else if let scannerResult = self.scannerResult {
295:             self.scannerResult = nil
296:             PdfScanUtility.convertScan(scannerResult: scannerResult, asyncOperation: self.asyncSubject(\.asyncPdf))
297:         }
298:     }
299:     
300:     func updatePdf(pdf: Pdf) {
301:         // TODO: Update thumbnails only for changed pages
302:         self.pdf = pdf
303:         self.shouldShowCloseWarning.wrappedValue = true
304:         self.refreshThumbnails()
305:         self.refreshImages()
306:     }
307:     
308:     func handlePageReordering(fromIndex: Int, toIndex: Int) {
309:         if fromIndex != toIndex {
310:             // exchangePage throws an exception if used after pages are added. Apparently it doesn't update its internal indices when adding pages,
311:             // which it relies upon to perform the swap. A manual workaround using removePage and insert methods seems to work fine, though.
312: //            self.pdf.pdfDocument.exchangePage(at: fromIndex, withPageAt: toIndex)
313:             if let toPage = self.pdf.pdfDocument.page(at: toIndex), let fromPage = self.pdf.pdfDocument.page(at: fromIndex) {
314:                 self.pdf.pdfDocument.removePage(at: fromIndex)
315:                 self.pdf.pdfDocument.insert(toPage, at: fromIndex)
316:                 self.pdf.pdfDocument.removePage(at: toIndex)
317:                 self.pdf.pdfDocument.insert(fromPage, at: toIndex)
318:                 
319:                 self.pdfThumbnails.move(fromOffsets: IndexSet(integer: fromIndex), toOffset: (toIndex > fromIndex ? (toIndex + 1) : toIndex))
320:                 self.pageImages.move(fromOffsets: IndexSet(integer: fromIndex), toOffset: (toIndex > fromIndex ? (toIndex + 1) : toIndex))
321:                 if self.pdfCurrentPageIndex == fromIndex {
322:                     self.pdfCurrentPageIndex = toIndex
323:                 } else if self.pdfCurrentPageIndex == toIndex {
324:                     self.pdfCurrentPageIndex = fromIndex
325:                 }
326:                 self.shouldShowCloseWarning.wrappedValue = true
327:             }
328:         }
329:     }
330:     
331:     private func internalSave() throws {
332:         guard self.pdf.pdfDocument.pageCount > 0 else {
333:             throw PdfEditSaveError.noPages
334:         }
335:         self.pdf = try self.repository.savePdf(pdf: self.pdf)
336:         self.shouldShowCloseWarning.wrappedValue = false
337:     }
338:     
339:     private func internalShare() {
340:         self.pdfShareCoordinator.share(pdf: self.pdf, applyPostProcess: true, onComplete: { [weak self] in
341:             self?.pdfCoordinator.startReview()
342:         })
343:     }
344:     
345:     private func onPdfChanged() {
346:         if self.pdf.filename != self.pdfFilename {
347:             self.pdf.updateFilename(self.pdfFilename)
348:             self.shouldShowCloseWarning.wrappedValue = true
349:             self.analyticsManager.track(event: .pdfRenamed)
350:         }
351:         if self.pdf.compression != self.compression {
352:             self.pdf.updateCompression(self.compression)
353:             self.shouldShowCloseWarning.wrappedValue = true
354:             self.analyticsManager.track(event: .compressionOptionChanged(compressionOption: self.compression))
355:         }
356:     }
357:     
358:     @MainActor
359:     private func convertFileByUrl(fileUrl: URL) {
360:         let fileUtType = UTType(filenameExtension: fileUrl.pathExtension)
361:         if fileUtType?.conforms(to: .pdf) ?? false {
362:             self.importPdf(pdfUrl: fileUrl)
363:         } else if fileUtType?.conforms(to: .image) ?? false {
364:             self.convertFileImageByURL(fileImageUrl: fileUrl)
365:         } else {
366:             self.asyncPdf = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
367:             Processor.generatePDF(from: fileUrl, options: [:]) { data, error in
368:                 if let error = error {
369:                     debugPrint(for: self, message: "Error converting word file. Error: \(error)")
370:                     self.asyncPdf = AsyncOperation(status: .error(.unknownError))
371:                 } else if let data = data, let pdf = Pdf(data: data) {
372:                     self.currentAnalyticsInputFileExtension = fileUrl.pathExtension
373:                     self.asyncPdf = AsyncOperation(status: .data(pdf))
374:                 } else {
375:                     self.asyncPdf = AsyncOperation(status: .error(.unknownError))
376:                 }
377:             }
378:         }
379:     }
380:     
381:     @MainActor
382:     func importPdf(pdfUrl: URL) {
383:         guard let pdf = Pdf(pdfUrl: pdfUrl) else {
384:             assertionFailure("Missing expected file for give url")
385:             return
386:         }
387:         
388:         self.currentAnalyticsInputFileExtension = pdfUrl.pathExtension
389:         self.pdfUnlockViewModel.unlockPdf(pdf: pdf)
390:     }
391:     
392:     @MainActor
393:     private func convertFileImageByURL(fileImageUrl: URL) {
394:         do {
395:             let imageData = try Data(contentsOf: fileImageUrl)
396:             guard let uiImage = UIImage(data: imageData) else {
397:                 self.asyncImageLoading = AsyncOperation(status: .error(.unknownError))
398:                 return
399:             }
400:             self.currentAnalyticsInputFileExtension = fileImageUrl.pathExtension
401:             self.appendUiImageToPdf(uiImage: uiImage)
402:         } catch {
403:             debugPrint(for: self, message: "Error retrieving file. Error: \(error)")
404:             self.asyncImageLoading = AsyncOperation(status: .error(.unknownError))
405:         }
406:     }
407:     
408:     private func loadTransferable(from imageSelection: PhotosPickerItem) -> Progress {
409:         return imageSelection.loadTransferable(type: PickedImage.self) { result in
410:             DispatchQueue.main.async {
411:                 guard imageSelection == self.imageSelection else {
412:                     print("Failed to get the selected item.")
413:                     return
414:                 }
415:                 switch result {
416:                 case .success(let image?):
417:                     self.asyncImageLoading = AsyncOperation(status: .data(()))
418:                     self.appendUiImageToPdf(uiImage: image.uiImage)
419:                 case .success(nil):
420:                     self.asyncImageLoading = AsyncOperation(status: .empty)
421:                 case .failure(let error):
422:                     let convertedError = SharedUnderlyingError.convertError(fromError: error)
423:                     self.asyncImageLoading = AsyncOperation(status: .error(convertedError))
424:                 }
425:             }
426:         }
427:     }
428:     
429:     private func appendUiImageToPdf(uiImage: UIImage) {
430:         PDFUtility.appendImageToPdfDocument(pdfDocument: self.pdf.pdfDocument, uiImage: uiImage)
431:         let pageImage = PDFUtility.generatePdfThumbnail(pdfDocument: self.pdf.pdfDocument,
432:                                                         size: nil,
433:                                                         forPageIndex: self.pdf.pdfDocument.pageCount - 1)
434:         let thumbnail = PDFUtility.generatePdfThumbnail(pdfDocument: self.pdf.pdfDocument,
435:                                                     size: K.Misc.ThumbnailEditSize,
436:                                                     forPageIndex: self.pdf.pdfDocument.pageCount - 1)
437:         if let pageImage = pageImage, let thumbnail = thumbnail {
438:             self.pageImages.append(pageImage)
439:             self.pdfThumbnails.append(thumbnail)
440:         }
441:         self.shouldShowCloseWarning.wrappedValue = true
442:         self.trackPageAddedEvent()
443:     }
444:     
445:     private func appendPdfToPdf(pdf: Pdf) {
446:         PDFUtility.appendPdfDocument(pdf.pdfDocument, toPdfDocument: self.pdf.pdfDocument)
447:         let pageImages = PDFUtility.generatePdfThumbnails(pdfDocument: pdf.pdfDocument, size: nil).compactMap { $0 }
448:         self.pageImages.append(contentsOf: pageImages)
449:         let thumbnails = PDFUtility.generatePdfThumbnails(pdfDocument: pdf.pdfDocument, size: K.Misc.ThumbnailEditSize).compactMap { $0 }
450:         self.pdfThumbnails.append(contentsOf: thumbnails)
451:         self.shouldShowCloseWarning.wrappedValue = true
452:         self.trackPageAddedEvent()
453:     }
454:     
455:     private func showScanner() {
456:         switch AVCaptureDevice.authorizationStatus(for: .video) {
457:         case .authorized, .notDetermined:
458:             self.scannerShow = true
459:         default:
460:             self.cameraPermissionDeniedShow = true
461:         }
462:     }
463:     
464:     private func internalSetPassword(_ password: String?) {
465:         if self.pdf.password != password {
466:             self.pdf.updatePassword(password)
467:             self.shouldShowCloseWarning.wrappedValue = true
468:             self.objectWillChange.send()
469:         }
470:     }
471:     
472:     private func refreshImages() {
473:         self.pageImages = PDFUtility.generatePdfThumbnails(pdfDocument: self.pdf.pdfDocument, size: nil).compactMap { $0 }
474:     }
475:     
476:     private func refreshThumbnails() {
477:         self.pdfThumbnails = PDFUtility.generatePdfThumbnails(pdfDocument: self.pdf.pdfDocument, size: K.Misc.ThumbnailEditSize).compactMap { $0 }
478:     }
479:     
480:     private func trackPageAddedEvent() {
481:         guard let currentAnalyticsPdfInputType = self.currentAnalyticsPdfInputType else {
482:             assertionFailure("Missing exptected analytics pdf input type")
483:             return
484:         }
485:         self.analyticsManager.track(event: .pageAdded(pdfInputType: currentAnalyticsPdfInputType, fileExtension: self.currentAnalyticsInputFileExtension))
486:         self.currentAnalyticsPdfInputType = nil
487:         self.currentAnalyticsInputFileExtension = nil
488:     }
489: }
490: 
491: enum PdfEditSaveError: LocalizedError {
492:     case unknown
493:     case noPages
494:     
495:     var errorDescription: String? {
496:         switch self {
497:         case .unknown: return "Internal Error. Please try again later."
498:         case .noPages: return "Your pdf doesn't contain any pages."
499:         }
500:     }
501: }
```

## File: pdfexpert/ViewModels/PdfFillFormViewModel.swift
```swift
  1: //
  2: //  PdfFillFormViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 26/05/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import PDFKit
 11: import UIKit
 12: 
 13: extension Container {
 14:     var pdfFillFormViewModel: ParameterFactory<PdfFillFormViewModel.InputParameter, PdfFillFormViewModel> {
 15:         self { PdfFillFormViewModel(inputParameter: $0) }
 16:     }
 17: }
 18: 
 19: typealias PdfFillFormViewCallback = ((Pdf) -> ())
 20: 
 21: class PdfFillFormViewModel: ObservableObject {
 22:     
 23:     struct InputParameter {
 24:         let pdf: Pdf
 25:         let currentPageIndex: Int
 26:         let onConfirm: PdfFillFormViewCallback
 27:     }
 28:     
 29:     @Published var pdfDocument: PDFDocument
 30:     @Published var pageImages: [UIImage]
 31:     @Published var pageIndex: Int {
 32:         didSet {
 33:             self.applyCurrentEditedTextAnnotation()
 34:             self.editedPageIndex = nil
 35:         }
 36:     }
 37:     @Published var annotations: [PDFAnnotation]
 38:     @Published var currentTextResizableViewData: TextResizableViewData = TextResizableViewData(text: "", rect: .zero)
 39:     @Published var editedPageIndex: Int? = nil
 40:     @Published var showSuggestedFields: Bool = false {
 41:         didSet {
 42:             if !self.showSuggestedFields {
 43:                 self.refreshSuggestedFields()
 44:             }
 45:         }
 46:     }
 47:     @Published var suggestedFields: SuggestedFields? = nil
 48:     
 49:     var pageViewSize: CGSize = .zero
 50:     var unsavedChangesExist: Bool = false
 51:     
 52:     // Used only to perform point and rect conversions from view space to page space and viceversa
 53:     // A dedicated PDFView for each page is needed, because changing page on the fly based on the
 54:     // needed page appears not to be done instantly, giving wrong results.
 55:     // This way we achieve correctness but at the cost of an increased memory consumption.
 56:     private let pdfViews: [PDFView]
 57:     
 58:     @Injected(\.analyticsManager) private var analyticsManager
 59:     private let repository = resolve(\.repository)
 60:     
 61:     private var onConfirm: PdfFillFormViewCallback
 62:     
 63:     private var pdf: Pdf
 64:     
 65:     init(inputParameter: InputParameter) {
 66:         self.pdf = inputParameter.pdf
 67:         var pdfDocumentCopy = PDFDocument()
 68:         if let pdfData = inputParameter.pdf.pdfDocument.dataRepresentation(), let copy = PDFDocument(data: pdfData) {
 69:             pdfDocumentCopy = copy
 70:         }
 71:         self.pdfDocument = pdfDocumentCopy
 72:         
 73:         self.onConfirm = inputParameter.onConfirm
 74:         
 75:         var pdfViews: [PDFView] = []
 76:         var annotationLists: [PDFAnnotation] = []
 77:         var pageImages: [UIImage] = []
 78:         for pageIndex in 0..<pdfDocumentCopy.pageCount {
 79:             if let page = pdfDocumentCopy.page(at: pageIndex) {
 80:                 let annotations = page.annotations.supportedAnnotations
 81:                 // Store annotations
 82:                 annotationLists.append(contentsOf: annotations)
 83:                 // Detach annotations from page
 84:                 for annotation in annotations {
 85:                     page.removeAnnotation(annotation)
 86:                 }
 87:                 // Render page
 88:                 pageImages.append(page.thumbnail(of: page.bounds(for: .mediaBox).size, for: .mediaBox))
 89:                 
 90:                 let pdfView = PDFView()
 91:                 pdfView.document = pdfDocumentCopy
 92:                 pdfView.autoScales = true
 93:                 pdfView.displayMode = .singlePage
 94:                 pdfView.go(to: page)
 95:                 pdfViews.append(pdfView)
 96:             }
 97:         }
 98:         self.annotations = annotationLists
 99:         self.pageImages = pageImages
100:         self.pdfViews = pdfViews
101:         
102:         self.pageIndex = inputParameter.currentPageIndex
103:         
104:         self.refreshSuggestedFields()
105:     }
106:     
107:     func onAppear() {
108:         self.analyticsManager.track(event: .reportScreen(.fillForm))
109:     }
110:     
111:     func getAnnotations(forPageIndex pageIndex: Int) -> [PDFAnnotation] {
112:         guard let page = self.pdfDocument.page(at: pageIndex) else {
113:             return []
114:         }
115:         return self.annotations
116:             .filter { $0.page == page }
117:     }
118:     
119:     func tapOnPdfView(positionInView: CGPoint, pageIndex: Int, pageViewSize: CGSize) {
120:         guard let page = self.pdfDocument.page(at: pageIndex) else {
121:             return
122:         }
123:         
124:         if self.pageViewSize == .zero {
125:             self.pageViewSize = pageViewSize
126:         }
127:         
128:         debugPrint(for: self, message: "Tap in: \(positionInView), for page index: \(pageIndex)")
129:         
130:         let pointInPage = self.convertPoint(positionInView, viewSize: pageViewSize, toPage: page)
131:         let textAnnotations = self.annotations.filter { $0.isTextAnnotation }
132:         let textAnnotationsInPoint = textAnnotations.filter { $0.page == page && $0.verticalCenteredTextBounds.contains(pointInPage) }
133:         
134:         if self.editedPageIndex != nil, self.currentTextResizableViewData.rect.contains(positionInView) {
135:             // Tapping inside the currently selected text resizable view -> Do nothing
136:             return
137:         }
138:         
139:         if self.editedPageIndex != nil {
140:             // Tapping outside the currently selected text resizable view -> convert that text resizable view to text annotation
141:             self.applyCurrentEditedTextAnnotation()
142:             self.editedPageIndex = nil
143: 
144:             if let textAnnotation = textAnnotationsInPoint.first {
145:                 // Tapping inside a different text annotation -> convert that text annotation to text resizable view
146:                 let rect = self.convertRect(textAnnotation.verticalCenteredTextBounds, viewSize: self.pageViewSize, fromPage: page)
147:                 self.currentTextResizableViewData = TextResizableViewData(text: textAnnotation.text, rect: rect)
148:                 self.editedPageIndex = pageIndex
149:                 self.annotations.removeAll(where: { $0 == textAnnotation })
150:             }
151:             // Changes are applied, set the dirty flag
152:             self.unsavedChangesExist = true
153:         } else if let textAnnotation = textAnnotationsInPoint.first {
154:             // Tapping inside a text annotation -> convert that text annotation to text resizable view
155:             let rect = self.convertRect(textAnnotation.verticalCenteredTextBounds, viewSize: self.pageViewSize, fromPage: page)
156:             self.currentTextResizableViewData = TextResizableViewData(text: textAnnotation.contents ?? "", rect: rect)
157:             self.editedPageIndex = pageIndex
158:             self.annotations.removeAll(where: { $0 == textAnnotation })
159:             // Nothing changes in this exact instant, but it will if the user modify the text resizable view
160:             // Just set the dirty flag here to keep it simple
161:             self.unsavedChangesExist = true
162:         } else {
163:             // Tapping in empty area -> create a new text resizable view
164:             let size = CGSize(width: 100, height: 15)
165:             let rect = CGRect(x: positionInView.x - (size.width / 2), y: positionInView.y - (size.height / 2), width: size.width, height: size.height)
166:             self.currentTextResizableViewData = TextResizableViewData(text: "", rect: rect)
167:             self.editedPageIndex = pageIndex
168:             // The newly created text resizable view will be added as an annotation upon confirmation
169:             // thus the dirty flag must be set
170:             self.unsavedChangesExist = true
171:         }
172:     }
173:     
174:     func onDeleteAnnotationPressed() {
175:         self.editedPageIndex = nil
176:         self.analyticsManager.track(event: .textAnnotationRemoved)
177:         // A text resizable view has been removed. If that view was associated to an existing text annotation
178:         // a change has been made to the original file. Just setting the dirty flag anyway to keep it simple
179:         self.unsavedChangesExist = true
180:     }
181:     
182:     func onConfirmButtonPressed() {
183:         if self.editedPageIndex != nil {
184:             self.applyCurrentEditedTextAnnotation()
185:         }
186:         
187:         if self.unsavedChangesExist {
188:             for pageIndex in 0..<self.pdfDocument.pageCount {
189:                 if let page = self.pdfDocument.page(at: pageIndex) {
190:                     let pageAnnotations = self.annotations.filter { $0.page == page }
191:                     // Attach annotations to page
192:                     for pageAnnotation in pageAnnotations {
193:                         page.addAnnotation(pageAnnotation)
194:                     }
195:                 }
196:             }
197:             self.pdf.updateDocument(self.pdfDocument)
198:             self.onConfirm(self.pdf)
199:         }
200:         
201:         self.analyticsManager.track(event: .annotationsConfirmed)
202:     }
203:     
204:     func onSuggestedFieldsButtonPressed() {
205:         self.showSuggestedFields = true
206:     }
207:     
208:     private func refreshSuggestedFields() {
209:         self.suggestedFields = try? self.repository.loadSuggestedFields()
210:     }
211:     
212:     private func applyCurrentEditedTextAnnotation() {
213:         guard let pageIndex = self.editedPageIndex, let page = self.pdfDocument.page(at: pageIndex), !self.currentTextResizableViewData.text.isEmpty else {
214:             return
215:         }
216:         let bounds = self.convertRect(self.currentTextResizableViewData.rect, viewSize: self.pageViewSize, toPage: page)
217:         let annotation = PDFAnnotation.create(with: self.currentTextResizableViewData.text,
218:                                               forBounds: bounds,
219:                                               textColor: .black,
220:                                               fontName: K.Misc.DefaultAnnotationTextFontName,
221:                                               withProperties: nil)
222:         annotation.page = page
223:         self.annotations.append(annotation)
224:         self.unsavedChangesExist = true
225:         self.analyticsManager.track(event: .textAnnotationAdded)
226:     }
227:     
228:     func convertPoint(_ point: CGPoint, viewSize: CGSize, toPage: PDFPage) -> CGPoint {
229:         guard let pdfView = self.getPdfView(viewSize: viewSize, page: toPage) else {
230:             return .zero
231:         }
232:         return pdfView.convert(point, to: toPage)
233:     }
234: 
235:     func convertPoint(_ point: CGPoint, viewSize: CGSize, fromPage: PDFPage) -> CGPoint {
236:         guard let pdfView = self.getPdfView(viewSize: viewSize, page: fromPage) else {
237:             return .zero
238:         }
239:         return pdfView.convert(point, from: fromPage)
240:     }
241:     
242:     func convertRect(_ rect: CGRect, viewSize: CGSize, toPage: PDFPage) -> CGRect {
243:         guard let pdfView = self.getPdfView(viewSize: viewSize, page: toPage) else {
244:             return .zero
245:         }
246:         return pdfView.convert(rect, to: toPage)
247:     }
248:     
249:     func convertRect(_ rect: CGRect, viewSize: CGSize, fromPage: PDFPage) -> CGRect {
250:         guard let pdfView = self.getPdfView(viewSize: viewSize, page: fromPage) else {
251:             return .zero
252:         }
253:         return pdfView.convert(rect, from: fromPage)
254:     }
255:     
256:     private func getPdfView(viewSize: CGSize, page: PDFPage) -> PDFView? {
257:         guard let pdfView = self.pdfViews.first(where: { $0.currentPage == page }) else {
258:             assertionFailure("Missing PdfView with given page")
259:             return nil
260:         }
261:         pdfView.frame = CGRect(origin: .zero, size: viewSize)
262:         return pdfView
263:     }
264: }
265: 
266: fileprivate extension Array where Element == PDFAnnotation {
267:     var supportedAnnotations: [PDFAnnotation] {
268:         self.filter { $0.isTextAnnotation }
269:     }
270: }
271: 
272: extension CGRect {
273:     func getYInverted(forParentSize parentHeight: CGFloat) -> CGRect {
274:         return CGRect(origin: CGPoint(x: self.origin.x, y: parentHeight-self.origin.y-self.size.height), size: self.size)
275:     }
276: }
277: 
278: extension CGPoint {
279:     func getYInverted(forParentSize parentHeight: CGFloat) -> CGPoint {
280:         return CGPoint(x: self.x, y: parentHeight-self.y)
281:     }
282: }
```

## File: pdfexpert/ViewModels/PdfFillWidgetViewModel.swift
```swift
 1: //
 2: //  PdfFillWidgetViewModel.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 22/06/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import PDFKit
11: import UIKit
12: 
13: extension Container {
14:     var pdfFillWidgetViewModel: ParameterFactory<PdfFillWidgetViewModel.InputParameter, PdfFillWidgetViewModel> {
15:         self { PdfFillWidgetViewModel(inputParameter: $0) }
16:     }
17: }
18: 
19: typealias PdfFillWidgetViewModelCallback = ((Pdf) -> ())
20: 
21: class PdfFillWidgetViewModel: ObservableObject {
22:     
23:     struct InputParameter {
24:         let pdf: Pdf
25:         let currentPageIndex: Int
26:         let onConfirm: PdfFillWidgetViewModelCallback
27:     }
28:     
29:     @Published var pdfDocument: PDFDocument
30:     @Published var pdfView: PDFView = PDFView()
31:     @Published var pdfCurrentPageIndex: Int
32:     
33:     @Injected(\.analyticsManager) private var analyticsManager
34:     
35:     var unsavedChangesExist: Bool = true
36:     
37:     private var onConfirm: PdfFillWidgetViewModelCallback
38:     
39:     private var pdf: Pdf
40:     
41:     init(inputParameter: InputParameter) {
42:         self.pdf = inputParameter.pdf
43:         var pdfDocumentCopy = PDFDocument()
44:         if let pdfData = inputParameter.pdf.pdfDocument.dataRepresentation(), let copy = PDFDocument(data: pdfData) {
45:             pdfDocumentCopy = copy
46:         }
47:         self.onConfirm = inputParameter.onConfirm
48:         self.pdfDocument = pdfDocumentCopy
49:         self.pdfCurrentPageIndex = inputParameter.currentPageIndex
50:         self.pdfView.document = pdfDocumentCopy
51:         
52:         if let page = self.pdfView.document?.page(at: inputParameter.currentPageIndex) {
53:             self.pdfView.go(to: page)
54:         }
55:         
56:         NotificationCenter.default.addObserver(
57:               self,
58:               selector: #selector(self.handlePageChange(notification:)),
59:               name: Notification.Name.PDFViewPageChanged,
60:               object: nil)
61:     }
62:     
63:     deinit {
64:         NotificationCenter.default.removeObserver(self, name: Notification.Name.PDFViewPageChanged, object: nil)
65:     }
66:     
67:     func onAppear() {
68:         self.analyticsManager.track(event: .reportScreen(.fillWidget))
69:     }
70:     
71:     func onCancelButtonPressed() {
72:         self.analyticsManager.track(event: .fillWidgetCancelled)
73:     }
74:     
75:     func onConfirmButtonPressed() {
76:         // TODO: Check if there are changes in the annotations and propagate changes only in that case
77:         self.analyticsManager.track(event: .fillWidgetConfirmed)
78:         self.pdf.updateDocument(self.pdfDocument)
79:         self.onConfirm(self.pdf)
80:     }
81:     
82:     @objc private func handlePageChange(notification: Notification) {
83:         guard let currentPageindex = self.pdfView.currentPageIndex else {
84:             assertionFailure("Missing expected page index")
85:             return
86:         }
87:         self.pdfCurrentPageIndex = currentPageindex
88:     }
89: }
```

## File: pdfexpert/ViewModels/PdfImportMultipleViewModel.swift
```swift
 1: //
 2: //  PdfImportMultipleViewModel.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/08/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import SwiftUI
11: import UniformTypeIdentifiers
12: 
13: extension Container {
14:     var pdfImportMultipleViewModel: ParameterFactory<PdfImportMultipleViewModel.Params, PdfImportMultipleViewModel> {
15:         self { PdfImportMultipleViewModel(params: $0) }
16:     }
17: }
18: 
19: class PdfImportMultipleViewModel: ObservableObject {
20:     
21:     struct Params {
22:         let asyncPdfs: Binding<AsyncOperation<[Pdf], PdfError>>
23:     }
24:     
25:     @Published var loading: Bool = false
26:     @Published var showFilePicker: Bool = false
27:     
28:     lazy var pdfUnlockViewModel: PdfUnlockViewModel = {
29:         Container.shared.pdfUnlockViewModel(PdfUnlockViewModel.Params(asyncUnlockedPdfMultipleOutput: self.asyncImportedPdfs))
30:     }()
31:     
32:     var importFileTypes: [UTType] = []
33:     
34:     private let asyncImportedPdfs: Binding<AsyncOperation<[Pdf], PdfError>>
35:     
36:     init(params: Params) {
37:         self.asyncImportedPdfs = params.asyncPdfs
38:     }
39:     
40:     func importPdfs(importFileTypes: [UTType]) {
41:         self.importFileTypes = importFileTypes
42:         self.showFilePicker = true
43:     }
44:     
45:     @MainActor
46:     func processSelectedUrls(_ urls: [URL]) {
47:         guard urls.count > 0 else {
48:             assertionFailure("Missing selected urls")
49:             self.asyncImportedPdfs.wrappedValue = .init(status: .error(.urlToPdfConversionError))
50:             return
51:         }
52:         
53:         self.loading = true
54:         Task {
55:             let task = Task<[Pdf], Never> {
56:                 return urls.compactMap { Pdf(pdfUrl: $0) }
57:             }
58:             let pdfs = await task.value
59:             if pdfs.count > 0 {
60:                 self.pdfUnlockViewModel.unlockPdfs(pdfs: pdfs)
61:             } else {
62:                 self.asyncImportedPdfs.wrappedValue = .init(status: .error(.urlToPdfConversionError))
63:             }
64:             self.loading = false
65:         }
66:     }
67: }
```

## File: pdfexpert/ViewModels/PdfImportViewModel.swift
```swift
 1: //
 2: //  PdfImportViewModel.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/08/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import SwiftUI
11: import UniformTypeIdentifiers
12: 
13: extension Container {
14:     var pdfImportViewModel: ParameterFactory<PdfImportViewModel.Params, PdfImportViewModel> {
15:         self { PdfImportViewModel(params: $0) }
16:     }
17: }
18: 
19: class PdfImportViewModel: ObservableObject {
20:     
21:     struct Params {
22:         let asyncPdf: Binding<AsyncOperation<Pdf, PdfError>>
23:     }
24:     
25:     @Published var loading: Bool = false
26:     @Published var showFilePicker: Bool = false
27:     
28:     lazy var pdfUnlockViewModel: PdfUnlockViewModel = {
29:         Container.shared.pdfUnlockViewModel(PdfUnlockViewModel.Params(asyncUnlockedPdfSingleOutput: self.asyncImportedPdf))
30:     }()
31:     
32:     var importFileTypes: [UTType] = []
33:     
34:     private let asyncImportedPdf: Binding<AsyncOperation<Pdf, PdfError>>
35:     
36:     init(params: Params) {
37:         self.asyncImportedPdf = params.asyncPdf
38:     }
39:     
40:     func importPdf(importFileTypes: [UTType]) {
41:         self.importFileTypes = importFileTypes
42:         self.showFilePicker = true
43:     }
44:     
45:     @MainActor
46:     func processSelectedUrls(_ urls: [URL]) {
47:         guard let url = urls.first else {
48:             assertionFailure("Missing selected url")
49:             self.asyncImportedPdf.wrappedValue = .init(status: .error(.urlToPdfConversionError))
50:             return
51:         }
52:         
53:         self.loading = true
54:         Task {
55:             let task = Task<Pdf?, Never> {
56:                 return Pdf(pdfUrl: url)
57:             }
58:             if let pdf = await task.value {
59:                 self.pdfUnlockViewModel.unlockPdf(pdf: pdf)
60:             } else {
61:                 self.asyncImportedPdf.wrappedValue = .init(status: .error(.urlToPdfConversionError))
62:             }
63:             self.loading = false
64:         }
65:     }
66: }
```

## File: pdfexpert/ViewModels/PdfMergeViewModel.swift
```swift
  1: //
  2: //  PdfMergeViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 02/08/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import SwiftUI
 11: 
 12: @MainActor
 13: extension Container {
 14:     var pdfMergeViewModel: ParameterFactory<PdfMergeViewModel.Params, PdfMergeViewModel> {
 15:         self { PdfMergeViewModel(params: $0) }
 16:     }
 17: }
 18: 
 19: @MainActor
 20: class PdfMergeViewModel: ObservableObject {
 21:     
 22:     struct Params {
 23:         let asyncPdf: Binding<AsyncOperation<Pdf, PdfError>>
 24:     }
 25:     
 26:     @Published var loading: Bool = false
 27:     @Published var showPdfSorter: Bool = false
 28:     @Published var asyncImportedPdfs: AsyncOperation<[Pdf], PdfError> = AsyncOperation(status: .empty) {
 29:         didSet {
 30:             if let importedPdfs = self.asyncImportedPdfs.data {
 31:                 self.onImportCompleted(pdfs: importedPdfs)
 32:                 self.asyncImportedPdfs = .init(status: .empty)
 33:             }
 34:         }
 35:     }
 36:     @Published var toBeSortedPdfs: [Pdf] = []
 37:     
 38:     @Injected(\.analyticsManager) private var analyticsManager
 39:     
 40:     lazy var pdfImportMultipleViewModel: PdfImportMultipleViewModel = {
 41:         Container.shared.pdfImportMultipleViewModel(PdfImportMultipleViewModel.Params(asyncPdfs: self.asyncSubject(\.asyncImportedPdfs)))
 42:     }()
 43:     
 44:     private let asyncMergedPdf: Binding<AsyncOperation<Pdf, PdfError>>
 45:     
 46:     init(params: Params) {
 47:         self.asyncMergedPdf = params.asyncPdf
 48:     }
 49:     
 50:     func merge() {
 51:         self.pdfImportMultipleViewModel.importPdfs(importFileTypes: K.Misc.ImportFileTypesForMerge)
 52:     }
 53:     
 54:     func onSortedCancelled() {
 55:         self.toBeSortedPdfs = []
 56:         self.showPdfSorter = false
 57:     }
 58:     
 59:     func onSortedConfirmed() {
 60:         self.showPdfSorter = false
 61:     }
 62:     
 63:     @MainActor
 64:     func onSortedCompleted() {
 65:         if self.toBeSortedPdfs.count > 0 {
 66:             self.mergePdfs(pdfs: self.toBeSortedPdfs)
 67:             self.toBeSortedPdfs = []
 68:         } else {
 69:             self.asyncMergedPdf.wrappedValue = .init(status: .empty)
 70:         }
 71:     }
 72:     
 73:     private func onImportCompleted(pdfs: [Pdf]) {
 74:         if pdfs.count > 1 {
 75:             self.toBeSortedPdfs = pdfs
 76:             self.showPdfSorter = true
 77:         } else if pdfs.count == 1, let pdf = pdfs.first {
 78:             self.asyncMergedPdf.wrappedValue = AsyncOperation(status: .data(pdf))
 79:         } else {
 80:             self.asyncMergedPdf.wrappedValue = .init(status: .empty)
 81:         }
 82:     }
 83:     
 84:     @MainActor
 85:     private func mergePdfs(pdfs: [Pdf]) {
 86:         self.loading = true
 87:         
 88:         Task {
 89:             let task = Task<Pdf, Never> {
 90:                 return pdfs.reduce(Pdf()) { accumulatedPdf, currentPdf in
 91:                     var accumulatedPdf = accumulatedPdf
 92:                     let document = accumulatedPdf.pdfDocument
 93:                     PDFUtility.appendPdfDocument(currentPdf.pdfDocument, toPdfDocument: document)
 94:                     accumulatedPdf.updateDocument(document)
 95:                     return accumulatedPdf
 96:                 }
 97:             }
 98:             let mergedPdf = await task.value
 99:             self.loading = false
100:             self.asyncMergedPdf.wrappedValue = AsyncOperation(status: .data(mergedPdf))
101:             self.analyticsManager.track(event: .pdfMerge)
102:         }
103:     }
104: }
```

## File: pdfexpert/ViewModels/PdfPageRangeEditorViewModel.swift
```swift
  1: //
  2: //  PdfPageRangeEditorViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 04/08/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import SwiftUI
 11: import Combine
 12: 
 13: extension Container {
 14:     var pdfPageRangeEditorViewModel: ParameterFactory<PdfPageRangeEditorViewModel.Params, PdfPageRangeEditorViewModel> {
 15:         self { PdfPageRangeEditorViewModel(params: $0) }
 16:     }
 17: }
 18: 
 19: typealias PdfPageRangeEditorConfirmCallback = () -> ()
 20: typealias PdfPageRangeEditorCancelCallback = () -> ()
 21: 
 22: enum PdfPageRangeFocusable: Hashable {
 23:     case lowerBound(index: Int)
 24:     case upperBound(index: Int)
 25: }
 26: 
 27: class PdfPageRangeEditorViewModel: ObservableObject {
 28:     
 29:     struct Params {
 30:         let pageRanges: Binding<[ClosedRange<Int>]>
 31:         let totalPages: Int
 32:         let confirmCallback: PdfPageRangeEditorConfirmCallback
 33:         let cancelCallback: PdfPageRangeEditorCancelCallback
 34:     }
 35:     
 36:     private var pageRanges: Binding<[ClosedRange<Int>]>
 37:     
 38:     @Published var pageRangeLowerBounds: [String]
 39:     @Published var pageRangeUpperBounds: [String]
 40:     
 41:     @Published var pdfPageRangeInFocus: PdfPageRangeFocusable? = nil
 42:     
 43:     private let totalPages: Int
 44:     private let confirmCallback: PdfPageRangeEditorConfirmCallback
 45:     private let cancelCallback: PdfPageRangeEditorCancelCallback
 46:     
 47:     private var cancelBag = Set<AnyCancellable>()
 48:     
 49:     init(params: Params) {
 50:         self.pageRanges = params.pageRanges
 51:         self.totalPages = params.totalPages
 52:         self.confirmCallback = params.confirmCallback
 53:         self.cancelCallback = params.cancelCallback
 54:         
 55:         self.pageRangeLowerBounds = params.pageRanges.wrappedValue.map { "\($0.lowerBound + 1)" }
 56:         self.pageRangeUpperBounds = params.pageRanges.wrappedValue.map { "\($0.upperBound + 1)" }
 57:         
 58:         self.$pdfPageRangeInFocus
 59:             .withPrevious(nil)
 60:             .sink { [weak self] previousField, _ in
 61:                 guard let self else { return }
 62:                 // Validate the focus field that is losing focus.
 63:                 if let previousField {
 64:                     self.validateField(field: previousField)
 65:                 }
 66:             }.store(in: &self.cancelBag)
 67:     }
 68:     
 69:     func focus(index: Int, isLowerBound: Bool) {
 70:         self.pdfPageRangeInFocus = isLowerBound ? .lowerBound(index: index) : .upperBound(index: index)
 71:     }
 72:     
 73:     func confirm() {
 74:         self.pdfPageRangeInFocus = nil
 75:         guard let pageRanges = self.getPageRangesFromRangeStrings() else {
 76:             self.cancelCallback()
 77:             return
 78:         }
 79:         self.pageRanges.wrappedValue = pageRanges
 80:         self.confirmCallback()
 81:     }
 82:     
 83:     func cancel() {
 84:         self.pdfPageRangeInFocus = nil
 85:         self.cancelCallback()
 86:     }
 87:     
 88:     func onConfirmRange() {
 89:         self.pdfPageRangeInFocus = nil
 90:     }
 91:     
 92:     func addRange() {
 93:         self.pdfPageRangeInFocus = nil
 94:         self.pageRangeLowerBounds.append("1")
 95:         self.pageRangeUpperBounds.append("\(self.totalPages)")
 96:     }
 97:     
 98:     func removeRange(atIndex index: Int) {
 99:         self.pdfPageRangeInFocus = nil
100:         self.pageRangeLowerBounds.remove(at: index)
101:         self.pageRangeUpperBounds.remove(at: index)
102:     }
103:     
104:     func validateLowerBound(forIndex index: Int) {
105:         guard self.pageRangeLowerBounds.count == self.pageRangeUpperBounds.count else {
106:             assertionFailure("lower bounds count and upper bounds count don't match")
107:             return
108:         }
109:         
110:         guard index >= 0, index < self.pageRangeLowerBounds.count else {
111:             assertionFailure("Given index is out of range!")
112:             return
113:         }
114:         
115:         let userFriendlyUpperBound = Int(self.pageRangeUpperBounds[index])
116:         
117:         guard let userFriendlyUpperBound else {
118:             assertionFailure("Upper bound strings couldn't be parsed")
119:             return
120:         }
121:         
122:         let userFriendlyLowerBound = Int(self.pageRangeLowerBounds[index])
123:         
124:         if let userFriendlyLowerBound {
125:             if userFriendlyLowerBound < 1 {
126:                 self.pageRangeLowerBounds[index] = 1.toString
127:             } else if userFriendlyLowerBound > userFriendlyUpperBound {
128:                 self.pageRangeLowerBounds[index] = userFriendlyUpperBound.toString
129:             } else {
130:                 // This is a normalizing step. E.g.: Input: 03 -> Output 3
131:                 self.pageRangeLowerBounds[index] = userFriendlyLowerBound.toString
132:             }
133:         } else {
134:             self.pageRangeLowerBounds[index] = 1.toString
135:         }
136:     }
137:     
138:     func getTextFieldText(index: Int, isLowerBound: Bool) -> Binding<String> {
139:         // Inline binding avoid out of index exception when deleting an in-focus range
140:         Binding(get: {
141:             guard index < self.pageRangeLowerBounds.count else {
142:                 return ""
143:             }
144:             return isLowerBound
145:             ? self.pageRangeLowerBounds[index]
146:             : self.pageRangeUpperBounds[index]
147:         }, set: { newValue in
148:             guard index < self.pageRangeLowerBounds.count else {
149:                 return
150:             }
151:             if isLowerBound {
152:                 self.pageRangeLowerBounds[index] = newValue
153:             } else {
154:                 self.pageRangeUpperBounds[index] = newValue
155:             }
156:         })
157:     }
158:     
159:     private func validateField(field: PdfPageRangeFocusable) {
160:         switch field {
161:         case .lowerBound(let index):
162:             self.validateLowerBound(forIndex: index)
163:         case .upperBound(let index):
164:             self.validateUpperBound(forIndex: index)
165:         }
166:     }
167:     
168:     func validateUpperBound(forIndex index: Int) {
169:         guard self.pageRangeLowerBounds.count == self.pageRangeUpperBounds.count else {
170:             assertionFailure("lower bounds count and upper bounds count don't match")
171:             return
172:         }
173:         
174:         guard index >= 0, index < self.pageRangeUpperBounds.count else {
175:             assertionFailure("Given index is out of range!")
176:             return
177:         }
178:         
179:         let userFriendlyLowerBound = Int(self.pageRangeLowerBounds[index])
180:         
181:         guard let userFriendlyLowerBound else {
182:             assertionFailure("Lower bound strings couldn't be parsed")
183:             return
184:         }
185:         
186:         let userFriendlyUpperBound = Int(self.pageRangeUpperBounds[index])
187:         
188:         if let userFriendlyUpperBound {
189:             if userFriendlyUpperBound > self.totalPages {
190:                 self.pageRangeUpperBounds[index] = self.totalPages.toString
191:             } else if userFriendlyLowerBound > userFriendlyUpperBound {
192:                 self.pageRangeUpperBounds[index] = userFriendlyLowerBound.toString
193:             } else {
194:                 // This is a normalizing step. E.g.: Input: 03 -> Output 3
195:                 self.pageRangeUpperBounds[index] = userFriendlyUpperBound.toString
196:             }
197:         } else {
198:             self.pageRangeUpperBounds[index] = self.totalPages.toString
199:         }
200:     }
201:     
202:     private func getPageRangesFromRangeStrings() -> [ClosedRange<Int>]? {
203:         guard self.pageRangeLowerBounds.count == self.pageRangeUpperBounds.count else {
204:             assertionFailure("lower bounds count and upper bounds count don't match")
205:             return nil
206:         }
207:         
208:         var result: [ClosedRange<Int>] = []
209:         
210:         for index in 0..<self.pageRangeLowerBounds.count {
211:             let userFriendlyLowerBound = Int(self.pageRangeLowerBounds[index])
212:             let userFriendlyUpperBound = Int(self.pageRangeUpperBounds[index])
213:             if let userFriendlyLowerBound, let userFriendlyUpperBound {
214:                 let lowerBound = userFriendlyLowerBound - 1
215:                 let upperBound = userFriendlyUpperBound - 1
216:                 if lowerBound >= 0, upperBound < self.totalPages, lowerBound <= upperBound {
217:                     result.append(lowerBound...upperBound)
218:                 } else {
219:                     assertionFailure("Lower or upper bound contained invalid values")
220:                 }
221:             } else {
222:                 assertionFailure("Lower or upper bound strings couldn't be parsed")
223:             }
224:         }
225:         
226: //        print("PdfPageRangeEditorViewModel - Lower Bounds: \(self.pageRangeLowerBounds)")
227: //        print("PdfPageRangeEditorViewModel - Upper Bounds: \(self.pageRangeUpperBounds)")
228: //        print("PdfPageRangeEditorViewModel - Result: \(result)")
229:         
230:         return result
231:     }
232: }
```

## File: pdfexpert/ViewModels/PdfReaderViewModel.swift
```swift
  1: //
  2: //  PdfReaderViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 21/08/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import SwiftUI
 11: import PDFKit
 12: 
 13: extension Container {
 14:     var pdfReaderViewModel: ParameterFactory<PdfReaderViewModel.Params, PdfReaderViewModel> {
 15:         self { PdfReaderViewModel(params: $0) }
 16:     }
 17: }
 18: 
 19: class PdfReaderViewModel: ObservableObject {
 20:     
 21:     struct Params {
 22:         let pdf: Pdf
 23:     }
 24:     
 25:     @Published var pages: [AttributedString?] = []
 26:     @Published var pageIndex: Int = 0 {
 27:         didSet {
 28:             if let page = self.pdfView.document?.page(at: self.pageIndex) {
 29:                 self.pdfView.go(to: page)
 30:             }
 31:         }
 32:     }
 33:     
 34:     @Published var pdfView: PDFView = PDFView()
 35:     
 36:     @Published var textMode: Bool = false
 37:     @Published var fontScale: CGFloat = K.Misc.PdfReaderDefaultFontScale
 38:     
 39:     @Published var pageThumbnails: AsyncItem<[UIImage?]> = .empty
 40:     @Published var showPageSelection: Bool = false
 41:     
 42:     @Published var pageImages: AsyncItemFailable<[PdfImage], SharedUnderlyingError> = .empty
 43:     @Published var showPageImages: Bool = false
 44:     
 45:     @Injected(\.analyticsManager) private var analyticsManager
 46:     
 47:     var filename: String { self.pdf.filename }
 48:     var pageCount: Int { self.pdf.pageCount }
 49:     
 50:     private let pdf: Pdf
 51:     
 52:     init(params: Params) {
 53:         self.pdf = params.pdf
 54:         self.updatePages()
 55:         
 56:         var pdfDocumentCopy = PDFDocument()
 57:         if let pdfData = params.pdf.pdfDocument.dataRepresentation(), let copy = PDFDocument(data: pdfData) {
 58:             pdfDocumentCopy = copy
 59:         }
 60:         pdfDocumentCopy.pages.forEach{ $0.annotations.forEach { $0.isReadOnly = true } }
 61:         self.pdfView.document = pdfDocumentCopy
 62:         self.pdfView.displayDirection = .horizontal
 63:         
 64:         NotificationCenter.default.addObserver(
 65:               self,
 66:               selector: #selector(self.handlePageChange(notification:)),
 67:               name: Notification.Name.PDFViewPageChanged,
 68:               object: nil)
 69:     }
 70:     
 71:     deinit {
 72:         NotificationCenter.default.removeObserver(self, name: Notification.Name.PDFViewPageChanged, object: nil)
 73:     }
 74:     
 75:     func onAppear() {
 76:         self.analyticsManager.track(event: .reportScreen(.reader))
 77:     }
 78:     
 79:     func updatePages() {
 80:         self.pages = self.pdf.map { $0.attributedString?.getPdfBodyText(fontScale: self.fontScale) }
 81:     }
 82:     
 83:     @MainActor
 84:     func presentPageSelection() {
 85:         if self.pageThumbnails.hasData {
 86:             self.showPageSelection = true
 87:         } else {
 88:             self.pageThumbnails = .loading(.undeterminedProgress)
 89:             Task {
 90:                 let task = Task<[UIImage?], Never> {
 91:                     return PDFUtility.generatePdfThumbnails(pdfDocument: self.pdf.pdfDocument,
 92:                                                             size: K.Misc.ThumbnailSize)
 93:                 }
 94:                 self.pageThumbnails = .data(await task.value)
 95:                 self.showPageSelection = true
 96:             }
 97:         }
 98:     }
 99:     
100:     @MainActor
101:     func presentPageImages() {
102:         guard self.pageIndex < self.pdf.pageCount else {
103:             self.pageImages = .error(.unknownError)
104:             return
105:         }
106:         
107:         let page = self.pdf[self.pageIndex]
108:         
109:         self.pageImages = .loading(.undeterminedProgress)
110:         do {
111:             var images: [PdfImage] = []
112:             try extractImages(from: page) { image, name in
113:                 let uiImage: UIImage? = {
114:                     switch image {
115:                     case .jpg(let data):
116:                         return UIImage(data: data)
117:                     case .raw(let cgImage):
118:                         return UIImage(cgImage: cgImage)
119:                     }
120:                 }()
121:                 if let uiImage {
122:                     images.append(PdfImage(image: uiImage, caption: name))
123:                 }
124:             }
125:             self.pageImages = .data(images)
126:             self.showPageImages = true
127:         } catch {
128:             self.pageImages = .error(SharedUnderlyingError.convertError(fromError: error))
129:         }
130:     }
131:     
132:     func switchTextMode() {
133:         self.textMode = !self.textMode
134:     }
135:     
136:     @objc private func handlePageChange(notification: Notification) {
137:         guard let currentPageindex = self.pdfView.currentPageIndex, notification.object as? PDFView == self.pdfView else {
138:             assertionFailure("Missing expected page index")
139:             return
140:         }
141:         self.pageIndex = currentPageindex
142:     }
143: }
144: 
145: fileprivate extension NSAttributedString {
146:     
147:     func getPdfBodyText(fontScale: CGFloat) -> AttributedString? {
148:         
149:         let trimmedAttributedString = self.attributedStringByTrimmingCharacterSet(charSet: .whitespacesAndNewlines)
150:         
151:         guard trimmedAttributedString.length > 0 else {
152:             return nil
153:         }
154:         
155:         var attributedString = AttributedString(trimmedAttributedString)
156:         attributedString.foregroundColor = ColorPalette.primaryText
157:         for run in attributedString.runs {
158:             let fontSize: CGFloat? = run.uiKit.font?.fontDescriptor
159:                 .fontAttributes[UIFontDescriptor.AttributeName.size] as? CGFloat
160:             let scaledFontSize = (fontSize ?? 16.0) * fontScale
161:             attributedString[run.range].font = FontPalette.fontMedium(withSize: scaledFontSize)
162:         }
163:         return attributedString
164:     }
165: }
```

## File: pdfexpert/ViewModels/PdfReadViewModel.swift
```swift
 1: //
 2: //  PdfReadViewModel.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 21/08/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: 
11: @MainActor
12: extension Container {
13:     var pdfReadViewModel: Factory<PdfReadViewModel> {
14:         self { PdfReadViewModel() }
15:     }
16: }
17: 
18: @MainActor
19: class PdfReadViewModel: ObservableObject {
20:     
21:     @Published var asyncImportedPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
22:         didSet {
23:             if let importedPdf = self.asyncImportedPdf.data {
24:                 self.toBeReadPdf = importedPdf
25:                 self.asyncImportedPdf = .init(status: .empty)
26:             }
27:         }
28:     }
29:     @Published var toBeReadPdf: Pdf? = nil
30:     
31:     @Injected(\.repository) private var repository
32:     @Injected(\.analyticsManager) private var analyticsManager
33:     
34:     lazy var pdfImportViewModel: PdfImportViewModel = {
35:         Container.shared.pdfImportViewModel(PdfImportViewModel.Params(asyncPdf: self.asyncSubject(\.asyncImportedPdf)))
36:     }()
37:     
38:     func read(pdf: Pdf?) {
39:         if let pdf = pdf {
40:             self.asyncImportedPdf = .init(status: .data(pdf))
41:         } else {
42:             self.pdfImportViewModel.importPdf(importFileTypes: K.Misc.ImportFileTypesForRead)
43:         }
44:     }
45: }
```

## File: pdfexpert/ViewModels/PdfSignatureCanvasViewModel.swift
```swift
  1: //
  2: //  PdfSignatureCanvasViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 19/05/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import UIKit
 11: import PencilKit
 12: 
 13: extension Container {
 14:     var pdfSignatureCanvasViewModel: ParameterFactory<PdfSignatureCanvasViewModel.ConfirmationCallback, PdfSignatureCanvasViewModel> {
 15:         self { PdfSignatureCanvasViewModel(onConfirm: $0) }
 16:     }
 17: }
 18: 
 19: enum SignatureSource: CaseIterable, Hashable {
 20:     case drawing
 21:     case image
 22:     case camera
 23: }
 24: 
 25: class PdfSignatureCanvasViewModel: NSObject, ObservableObject {
 26:     
 27:     typealias ConfirmationCallback = ((Signature) -> ())
 28:     
 29:     @Published var canvasView = PKCanvasView()
 30:     @Published var signatureGalleryImage: UIImage? = nil
 31:     @Published var signatureCameraImage: UIImage? = nil
 32:     @Published var shouldSaveSignature: Bool = false
 33:     @Published var pdfSaveError: SharedUnderlyingError? = nil
 34:     @Published var source: SignatureSource = .drawing {
 35:         didSet {
 36:             self.onSourceChanged(oldValue: oldValue)
 37:         }
 38:     }
 39:     
 40:     @Injected(\.repository) private var repository
 41:     @Injected(\.analyticsManager) private var analyticsManager
 42:     @Injected(\.galleryImageProviderFlow) var galleryImageProviderFlow
 43:     @Injected(\.cameraImageProviderFlow) var cameraImageProviderFlow
 44:     @Injected(\.imageCropFlow) var imageCropFlow
 45:     
 46:     var confirmAllowed: Bool {
 47:         switch self.source {
 48:         case .drawing: return self.canvasView.drawing.strokes.count > 0
 49:         case .image: return self.signatureGalleryImage != nil
 50:         case .camera: return self.signatureCameraImage != nil
 51:         }
 52:     }
 53:     
 54:     private var currentSignatureImage: UIImage? {
 55:         switch self.source {
 56:         case .drawing: return self.canvasView.drawing.signatureImage
 57:         case .image: return self.signatureGalleryImage
 58:         case .camera: return self.signatureCameraImage
 59:         }
 60:     }
 61:     
 62:     private let onConfirm: ConfirmationCallback
 63:     
 64:     init(onConfirm: @escaping ConfirmationCallback) {
 65:         self.onConfirm = onConfirm
 66:         super.init()
 67:         self.canvasView.delegate = self
 68:     }
 69:     
 70:     func onClearButtonPressed() {
 71:         self.canvasView.drawing = PKDrawing()
 72:     }
 73:     
 74:     func toggleShouldSave() {
 75:         self.shouldSaveSignature = !self.shouldSaveSignature
 76:     }
 77:     
 78:     func onConfirmButtonPressed() {
 79:         
 80:         guard let currentSignatureImage else {
 81:             assertionFailure("Missing expected current signature image!")
 82:             return
 83:         }
 84:         
 85:         var signature = Signature(image: currentSignatureImage)
 86:         if self.shouldSaveSignature {
 87:             do {
 88:                 signature = try self.repository.saveSignature(signature: signature)
 89:             } catch {
 90:                 self.pdfSaveError = .convertError(fromError: error)
 91:             }
 92:         }
 93:         self.analyticsManager.track(event: .signatureCreated)
 94:         self.onConfirm(signature)
 95:     }
 96:     
 97:     func onSelectImageButtonPressed() {
 98:         self.startGetImageFlow()
 99:     }
100:     
101:     func onTakePictureButtonPressed() {
102:         self.startTakePictureFlow()
103:     }
104:     
105:     private func onSourceChanged(oldValue: SignatureSource) {
106:         if oldValue != self.source {
107:             switch self.source {
108:             case .drawing:
109:                 break
110:             case .image:
111:                 if self.signatureGalleryImage == nil {
112:                     self.startGetImageFlow()
113:                 }
114:             case .camera:
115:                 if self.signatureCameraImage == nil {
116:                     self.startTakePictureFlow()
117:                 }
118:             }
119:         }
120:     }
121:     
122:     private func startGetImageFlow() {
123:         self.galleryImageProviderFlow.startFlow { [weak self] in
124:             self?.imageCropFlow.startFlow(image: $0, onImageCropped: { [weak self]  in
125:                 self?.signatureGalleryImage = $0
126:             })
127:         }
128:     }
129:     
130:     private func startTakePictureFlow() {
131:         self.cameraImageProviderFlow.startFlow { [weak self] in
132:             self?.imageCropFlow.startFlow(image: $0, onImageCropped: { [weak self]  in
133:                 self?.signatureCameraImage = $0
134:             })
135:         }
136:     }
137: }
138: 
139: extension PdfSignatureCanvasViewModel: PKCanvasViewDelegate {
140:     
141:     func canvasViewDrawingDidChange(_ canvasView: PKCanvasView) {
142:         if self.canvasView == canvasView {
143:             // This is needed mainly to refresh the confirm button availability
144:             self.objectWillChange.send()
145:         }
146:     }
147: }
```

## File: pdfexpert/ViewModels/PdfSignaturePickerViewModel.swift
```swift
  1: //
  2: //  PdfSignaturePickerViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 28/08/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: 
 11: extension Container {
 12:     var pdfSignaturePickerViewModel: ParameterFactory<PdfSignaturePickerViewModel.Params, PdfSignaturePickerViewModel> {
 13:         self { PdfSignaturePickerViewModel(params: $0) }
 14:     }
 15: }
 16: 
 17: class PdfSignaturePickerViewModel: ObservableObject {
 18:     
 19:     typealias ConfirmationCallback = ((Signature) -> ())
 20:     typealias CancelCallback = (() -> ())
 21:     typealias CreateNewSignatureCallback = (() -> ())
 22:     
 23:     struct Params {
 24:         let confirmationCallback: ConfirmationCallback
 25:         let cancelCallback: CancelCallback
 26:         let createNewSignatureCallback: CreateNewSignatureCallback
 27:     }
 28:     
 29:     @Published var asyncItems: AsyncOperation<[Signature], SharedLocalizedError> = AsyncOperation(status: .empty)
 30:     @Published var asyncItemDelete: AsyncOperation<(), SharedLocalizedError> = AsyncOperation(status: .empty)
 31:     @Published var isLoading: Bool = false
 32:     
 33:     @Injected(\.repository) var repository
 34:     @Injected(\.analyticsManager) private var analyticsManager
 35:     
 36:     private let onConfirm: ConfirmationCallback
 37:     private let onCancel: CancelCallback
 38:     private let onCreateNewSignature: CreateNewSignatureCallback
 39:     
 40:     init(params: Params) {
 41:         self.onConfirm = params.confirmationCallback
 42:         self.onCancel = params.cancelCallback
 43:         self.onCreateNewSignature = params.createNewSignatureCallback
 44:     }
 45:     
 46:     func pick(item: Signature) {
 47:         self.onConfirm(item)
 48:     }
 49:     
 50:     func delete(item: Signature) {
 51:         self.asyncItemDelete = AsyncOperation(status: .empty)
 52:         do {
 53:             try self.repository.delete(signature: item)
 54:             self.asyncItemDelete = AsyncOperation(status: .empty)
 55:         } catch {
 56:             debugPrint(for: self, message: "Deletion failed. Error: \(error)")
 57:             self.asyncItemDelete = AsyncOperation(status: .error(.unknownError))
 58:         }
 59:         self.refresh()
 60:     }
 61:     
 62:     func delete(indexSet: IndexSet) {
 63:         guard let allSignatures = asyncItems.data else {
 64:             return
 65:         }
 66:         
 67:         let signatures = indexSet.filteredIndexSet { $0 < allSignatures.count }.map { allSignatures[$0] }
 68:         
 69:         self.asyncItemDelete = AsyncOperation(status: .empty)
 70:         do {
 71:             try self.repository.delete(signatures: signatures)
 72:             self.asyncItemDelete = AsyncOperation(status: .empty)
 73:         } catch {
 74:             debugPrint(for: self, message: "Deletion failed. Error: \(error)")
 75:             self.asyncItemDelete = AsyncOperation(status: .error(.unknownError))
 76:         }
 77:         self.refresh()
 78:     }
 79:     
 80:     func onAppear() {
 81:         self.analyticsManager.track(event: .reportScreen(.signaturePicker))
 82:         self.refresh()
 83:     }
 84:     
 85:     func cancel() {
 86:         self.onCancel()
 87:     }
 88:     
 89:     func createNewSignature() {
 90:         self.onCreateNewSignature()
 91:     }
 92:     
 93:     func refresh() {
 94:         do {
 95:             let items = try self.repository.loadSignatures()
 96:             self.asyncItems = AsyncOperation(status: .data(items))
 97:         } catch {
 98:             debugPrint(for: self, message: "Refresh failed. Error: \(error)")
 99:             self.asyncItems = AsyncOperation(status: .error(SharedLocalizedError.unknownError))
100:         }
101:     }
102: }
```

## File: pdfexpert/ViewModels/PdfSignaturePrioviderFlow.swift
```swift
 1: //
 2: //  PdfSignaturePrioviderFlow.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 29/08/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import UIKit
11: 
12: extension Container {
13:     var pdfSignaturePrioviderFlow: Factory<PdfSignaturePrioviderFlow> {
14:         self { PdfSignaturePrioviderFlow() }
15:     }
16: }
17: 
18: class PdfSignaturePrioviderFlow: ObservableObject {
19:     
20:     typealias SignatureSelectedCallback = ((UIImage) -> ())
21:     
22:     @Published var showSignatureCreation: Bool = false
23:     @Published var showSignaturePicker: Bool = false
24:     
25:     @Injected(\.repository) private var repository
26:     
27:     private var onSignatureSelected: SignatureSelectedCallback?
28:     
29:     func startFlow(onSignatureSelected: @escaping SignatureSelectedCallback) {
30:         self.onSignatureSelected = onSignatureSelected
31:         if (try? self.repository.getDoSignatureExist()) ?? false {
32:             self.showSignaturePicker = true
33:         } else {
34:             self.showSignatureCreation = true
35:         }
36:     }
37:     
38:     func onSignatureSelected(signature: Signature) {
39:         self.showSignatureCreation = false
40:         self.showSignaturePicker = false
41:         self.onSignatureSelected?(signature.image)
42:     }
43:     
44:     @MainActor
45:     func onCreateNewSignature() {
46:         self.showSignaturePicker = false
47:         Task {
48:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
49:             self.showSignatureCreation = true
50:         }
51:     }
52: }
```

## File: pdfexpert/ViewModels/PdfSignatureViewModel.swift
```swift
  1: //
  2: //  PdfSignatureViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 10/05/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import PDFKit
 11: import UIKit
 12: import Combine
 13: 
 14: extension Container {
 15:     var pdfSignatureViewModel: ParameterFactory<PdfSignatureViewModel.InputParameter, PdfSignatureViewModel> {
 16:         self { PdfSignatureViewModel(inputParameter: $0) }
 17:     }
 18: }
 19: 
 20: typealias PdfSignatureCallback = ((Pdf) -> ())
 21: 
 22: class PdfSignatureViewModel: ObservableObject {
 23:     
 24:     struct InputParameter {
 25:         let pdf: Pdf
 26:         let currentPageIndex: Int
 27:         let onConfirm: PdfSignatureCallback
 28:     }
 29:     
 30:     @Published var pdfDocument: PDFDocument
 31:     @Published var pageImages: [UIImage]
 32:     @Published var pageIndex: Int
 33:     @Published var editedPageIndex: Int? = nil
 34:     @Published var annotations: [PDFAnnotation]
 35:     @Published var signatureRect: CGRect = .zero
 36:     @Published var signatureImage: UIImage? = nil
 37:     
 38:     var pageViewSize: CGSize = .zero
 39:     var unsavedChangesExist: Bool = false
 40:     
 41:     // Used only to perform point and rect conversions from view space to page space and viceversa
 42:     // A dedicated PDFView for each page is needed, because changing page on the fly based on the
 43:     // needed page appears not to be done instantly, giving wrong results.
 44:     // This way we achieve correctness but at the cost of an increased memory consumption.
 45:     private let pdfViews: [PDFView]
 46:     
 47:     @Injected(\.analyticsManager) private var analyticsManager
 48:     @Injected(\.pdfSignaturePrioviderFlow) var pdfSignaturePrioviderFlow
 49:     
 50:     private var onConfirm: PdfSignatureCallback
 51:     private var pdf: Pdf
 52:     private var isReplacing: Bool = false
 53:     
 54:     private var cancelBag = Set<AnyCancellable>()
 55:     
 56:     init(inputParameter: InputParameter) {
 57:         self.pdf = inputParameter.pdf
 58:         var pdfDocumentCopy = PDFDocument()
 59:         if let pdfData = inputParameter.pdf.pdfDocument.dataRepresentation(), let copy = PDFDocument(data: pdfData) {
 60:             pdfDocumentCopy = copy
 61:         }
 62:         self.pdfDocument = pdfDocumentCopy
 63:         
 64:         self.onConfirm = inputParameter.onConfirm
 65:         
 66:         var pdfViews: [PDFView] = []
 67:         var annotationLists: [PDFAnnotation] = []
 68:         var pageImages: [UIImage] = []
 69:         for pageIndex in 0..<pdfDocumentCopy.pageCount {
 70:             if let page = pdfDocumentCopy.page(at: pageIndex) {
 71:                 let annotations = page.annotations.signatureAnnotations
 72:                 // Store annotations
 73:                 annotationLists.append(contentsOf: annotations)
 74:                 // Detach annotations from page
 75:                 for annotation in annotations {
 76:                     page.removeAnnotation(annotation)
 77:                 }
 78:                 // Render page
 79:                 pageImages.append(page.thumbnail(of: page.bounds(for: .mediaBox).size, for: .mediaBox))
 80:                 
 81:                 let pdfView = PDFView()
 82:                 pdfView.document = pdfDocumentCopy
 83:                 pdfView.autoScales = true
 84:                 pdfView.displayMode = .singlePage
 85:                 pdfView.go(to: page)
 86:                 pdfViews.append(pdfView)
 87:             }
 88:         }
 89:         self.annotations = annotationLists
 90:         self.pageImages = pageImages
 91:         self.pdfViews = pdfViews
 92:         
 93:         self.pageIndex = inputParameter.currentPageIndex
 94:         
 95:         self.$pageIndex
 96:             .sink { [weak self] _ in
 97:                 self?.applyCurrentEditedAnnotation()
 98:             }.store(in: &self.cancelBag)
 99:     }
100:     
101:     func onAppear() {
102:         self.analyticsManager.track(event: .reportScreen(.signature))
103:     }
104:     
105:     func getAnnotations(forPageIndex pageIndex: Int) -> [PDFAnnotation] {
106:         guard let page = self.pdfDocument.page(at: pageIndex) else {
107:             return []
108:         }
109:         return self.annotations
110:             .filter { $0.page == page }
111:     }
112:     
113:     func tapOnPdfView(positionInView: CGPoint, pageIndex: Int, pageViewSize: CGSize) {
114:         guard let page = self.pdfDocument.page(at: pageIndex) else {
115:             return
116:         }
117:         
118:         self.pageViewSize = pageViewSize
119:         
120:         let pointInPage = self.convertPoint(positionInView, viewSize: pageViewSize, toPage: page)
121:         let annotationsInPoint = self.annotations.filter { $0.page == page && $0.bounds.contains(pointInPage) }
122:         
123:         if self.signatureImage != nil, self.signatureRect.contains(positionInView) {
124:             // Tapping inside the currently selected image resizable view -> Do nothing
125:             return
126:         }
127:         
128:         if self.signatureImage != nil {
129:             // Tapping outside the currently selected image resizable view -> convert that image resizable view to signature annotation
130:             self.applyCurrentEditedAnnotation()
131: 
132:             if let annotationInPoint = annotationsInPoint.first {
133:                 // Tapping inside a different signature annotation -> convert that signature annotation to image resizable view
134:                 self.convertAnnotationToView(annotation: annotationInPoint,
135:                                              pageIndex: pageIndex)
136:             }
137:             // Changes are applied, set the dirty flag
138:             self.unsavedChangesExist = true
139:         } else if let annotationInPoint = annotationsInPoint.first {
140:             // Tapping inside a signature annotation -> convert that signature annotation to image resizable view
141:             self.convertAnnotationToView(annotation: annotationInPoint,
142:                                          pageIndex: pageIndex)
143:             // Nothing changes in this exact instant, but it will if the user changes the image of the signature
144:             // Just set the dirty flag here to keep it simple
145:             self.unsavedChangesExist = true
146:         } else {
147:             // Tapping in empty area -> start the signature creation flow
148:             self.editedPageIndex = pageIndex
149:             self.startSignatureSelectionFlow(isReplacing: false)
150:         }
151:     }
152:     
153:     func onDeleteAnnotationPressed() {
154:         self.signatureImage = nil
155:         self.editedPageIndex = nil
156:         self.analyticsManager.track(event: .signatureRemoved)
157:         // A image resizable view has been removed. If that view was associated to an existing signature annotation
158:         // a change has been made to the original file. Just setting the dirty flag anyway to keep it simple.
159:         self.unsavedChangesExist = true
160:     }
161:     
162:     func onReplaceAnnotationPressed() {
163:         self.startSignatureSelectionFlow(isReplacing: true)
164:     }
165:     
166:     func onConfirmButtonPressed() {
167:         self.applyCurrentEditedAnnotation()
168:         
169:         if self.unsavedChangesExist {
170:             for pageIndex in 0..<self.pdfDocument.pageCount {
171:                 if let page = self.pdfDocument.page(at: pageIndex) {
172:                     let pageAnnotations = self.annotations.filter { $0.page == page }
173:                     // Attach annotations to page
174:                     for pageAnnotation in pageAnnotations {
175:                         page.addAnnotation(pageAnnotation)
176:                     }
177:                 }
178:             }
179:             self.pdf.updateDocument(self.pdfDocument)
180:             self.onConfirm(self.pdf)
181:         }
182:         
183:         self.analyticsManager.track(event: .signaturesConfirmed)
184:     }
185:     
186:     private func applyCurrentEditedAnnotation() {
187:         if let signatureImage = self.signatureImage,
188:            let pageIndex = self.editedPageIndex,
189:            let page = self.pdfDocument.page(at: pageIndex) {
190:             let bounds = self.convertRect(self.signatureRect, viewSize: self.pageViewSize, toPage: page)
191:             let annotation = PDFAnnotation.createSignature(with: signatureImage, forBounds: bounds)
192:             annotation.page = page
193:             self.annotations.append(annotation)
194:             self.unsavedChangesExist = true
195:             self.analyticsManager.track(event: .signatureAdded)
196:         }
197:         self.signatureImage = nil
198:         self.editedPageIndex = nil
199:     }
200:     
201:     private func convertAnnotationToView(annotation: PDFAnnotation,
202:                                          pageIndex: Int) {
203:         guard let page = self.pdfDocument.page(at: pageIndex) else {
204:             assertionFailure("Missing page with given page index")
205:             return
206:         }
207:         
208:         self.signatureRect = self.convertRect(annotation.bounds, viewSize: self.pageViewSize, fromPage: page)
209:         self.signatureImage = annotation.image
210:         self.annotations.removeAll(where: { $0 == annotation })
211:         self.editedPageIndex = pageIndex
212:     }
213:     
214:     func startSignatureSelectionFlow(isReplacing: Bool) {
215:         self.isReplacing = isReplacing
216:         self.pdfSignaturePrioviderFlow.startFlow { [weak self] signatureImage in
217:             self?.onSignatureSelected(signatureImage: signatureImage)
218:         }
219:     }
220:     
221:     func onSignatureSelected(signatureImage: UIImage) {
222:         guard let page = self.pdfDocument.page(at: self.pageIndex) else {
223:             assertionFailure("Missing page with given page index")
224:             return
225:         }
226:         guard let pdfView = self.getPdfView(viewSize: self.pageViewSize, page: page) else {
227:             assertionFailure("Missing page view with given page")
228:             return
229:         }
230:         self.signatureImage = signatureImage
231:         if !self.isReplacing {
232:             let startingSignatureWidthOverPdfViewWidth = 0.7
233:             let margin: CGFloat = 40.0
234:             
235:             let signatureDefaultViewWidth: CGFloat = pdfView.bounds.size.width * startingSignatureWidthOverPdfViewWidth
236:             let signatureDefaultViewHeight: CGFloat = signatureDefaultViewWidth / signatureImage.size.aspectRatio
237:             
238:             var signatureDefaultViewSize = CGSize(width: signatureDefaultViewWidth,
239:                                                   height: signatureDefaultViewHeight)
240:             signatureDefaultViewSize = signatureDefaultViewSize.clipToSize(pdfView.bounds.size,
241:                                                                            horizontalMargin: margin,
242:                                                                            verticalMargin: margin,
243:                                                                            keepAspectRatio: true)
244:             
245:             self.signatureRect = CGRect(origin: CGPoint(x: pdfView.bounds.size.width * 0.5 - signatureDefaultViewSize.width / 2,
246:                                                         y: pdfView.bounds.size.height * 0.5 - signatureDefaultViewSize.height / 2) ,
247:                                         size: signatureDefaultViewSize)
248:         }
249:         // The newly created image resizable view will be added as a signature annotation upon confirmation
250:         // thus the dirty flag must be set
251:         self.unsavedChangesExist = true
252:     }
253:     
254:     func convertPoint(_ point: CGPoint, viewSize: CGSize, toPage: PDFPage) -> CGPoint {
255:         guard let pdfView = self.getPdfView(viewSize: viewSize, page: toPage) else {
256:             return .zero
257:         }
258:         return pdfView.convert(point, to: toPage)
259:     }
260: 
261:     func convertPoint(_ point: CGPoint, viewSize: CGSize, fromPage: PDFPage) -> CGPoint {
262:         guard let pdfView = self.getPdfView(viewSize: viewSize, page: fromPage) else {
263:             return .zero
264:         }
265:         return pdfView.convert(point, from: fromPage)
266:     }
267:     
268:     func convertRect(_ rect: CGRect, viewSize: CGSize, toPage: PDFPage) -> CGRect {
269:         guard let pdfView = self.getPdfView(viewSize: viewSize, page: toPage) else {
270:             return .zero
271:         }
272:         return pdfView.convert(rect, to: toPage)
273:     }
274:     
275:     func convertRect(_ rect: CGRect, viewSize: CGSize, fromPage: PDFPage) -> CGRect {
276:         guard let pdfView = self.getPdfView(viewSize: viewSize, page: fromPage) else {
277:             return .zero
278:         }
279:         return pdfView.convert(rect, from: fromPage)
280:     }
281:     
282:     private func getPdfView(viewSize: CGSize, page: PDFPage) -> PDFView? {
283:         guard let pdfView = self.pdfViews.first(where: { $0.currentPage == page }) else {
284:             assertionFailure("Missing PdfView with given page")
285:             return nil
286:         }
287:         pdfView.frame = CGRect(origin: .zero, size: viewSize)
288:         return pdfView
289:     }
290: }
291: 
292: fileprivate extension Array where Element == PDFAnnotation {
293:     var signatureAnnotations: [PDFAnnotation] {
294:         self.filter { $0.isSignatureAnnotation }
295:     }
296: }
```

## File: pdfexpert/ViewModels/PdfSortViewModel.swift
```swift
 1: //
 2: //  PdfSortViewModel.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 02/08/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import SwiftUI
11: 
12: extension Container {
13:     var pdfSortViewModel: ParameterFactory<PdfSortViewModel.Params, PdfSortViewModel> {
14:         self { PdfSortViewModel(params: $0) }
15:     }
16: }
17: 
18: typealias PdfSortConfirmCallback = () -> ()
19: typealias PdfSortCancelCallback = () -> ()
20: 
21: class PdfSortViewModel: ObservableObject {
22:     
23:     struct Params {
24:         let pdfs: Binding<[Pdf]>
25:         let confirmButtonText: String
26:         let confirmCallback: PdfSortConfirmCallback
27:         let cancelCallback: PdfSortCancelCallback
28:     }
29:     
30:     let confirmButtonText: String
31:     
32:     @Binding var pdfs: [Pdf]
33:     
34:     private let confirmCallback: PdfSortConfirmCallback
35:     private let cancelCallback: PdfSortCancelCallback
36:     
37:     init(params: Params) {
38:         self._pdfs = params.pdfs
39:         self.confirmButtonText = params.confirmButtonText
40:         self.confirmCallback = params.confirmCallback
41:         self.cancelCallback = params.cancelCallback
42:     }
43:     
44:     func confirm() {
45:         self.confirmCallback()
46:     }
47:     
48:     func cancel() {
49:         self.cancelCallback()
50:     }
51: }
```

## File: pdfexpert/ViewModels/PdfSplitViewModel.swift
```swift
  1: //
  2: //  PdfSplitViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 04/08/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import SwiftUI
 11: 
 12: @MainActor
 13: extension Container {
 14:     var pdfSplitViewModel: Factory<PdfSplitViewModel> {
 15:         self { PdfSplitViewModel() }
 16:     }
 17: }
 18: 
 19: typealias SplitCompletedCallback = (() -> ())
 20: 
 21: @MainActor
 22: class PdfSplitViewModel: ObservableObject {
 23:     
 24:     @Published var showPageRangeEditor: Bool = false
 25:     @Published var showSuccess: Bool = false
 26:     @Published var asyncImportedPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
 27:         didSet {
 28:             if let importedPdf = self.asyncImportedPdf.data {
 29:                 self.onImportCompleted(pdf: importedPdf)
 30:                 self.asyncImportedPdf = .init(status: .empty)
 31:             }
 32:         }
 33:     }
 34:     @Published var toBeSplitPdf: Pdf? = nil
 35:     @Published var pageRanges: [ClosedRange<Int>] = []
 36:     @Published var asyncSplit: AsyncEmptyFailable<PdfSplitError> = .idle
 37:     
 38:     @Injected(\.repository) private var repository
 39:     @Injected(\.analyticsManager) private var analyticsManager
 40:     
 41:     lazy var pdfImportViewModel: PdfImportViewModel = {
 42:         Container.shared.pdfImportViewModel(PdfImportViewModel.Params(asyncPdf: self.asyncSubject(\.asyncImportedPdf)))
 43:     }()
 44:     
 45:     var totalPages: Int = 0
 46:     
 47:     private var onSplitCompleted: SplitCompletedCallback?
 48:     
 49:     func split(pdf: Pdf?, onSplitCompleted: SplitCompletedCallback?) {
 50:         self.onSplitCompleted = onSplitCompleted
 51:         if let pdf = pdf {
 52:             self.asyncImportedPdf = .init(status: .data(pdf))
 53:         } else {
 54:             self.pdfImportViewModel.importPdf(importFileTypes: K.Misc.ImportFileTypesForSplit)
 55:         }
 56:     }
 57:     
 58:     func onPageRangeEditingCancelled() {
 59:         self.toBeSplitPdf = nil
 60:         self.showPageRangeEditor = false
 61:     }
 62:     
 63:     func onPageRangeEditingConfirmed() {
 64:         self.showPageRangeEditor = false
 65:     }
 66:     
 67:     @MainActor
 68:     func onPageRangeEditingCompleted() {
 69:         self.splitPdf()
 70:     }
 71:     
 72:     private func onImportCompleted(pdf: Pdf) {
 73:         guard pdf.pageCount > 0 else {
 74:             self.asyncSplit = .error(.pdfNoPage)
 75:             return
 76:         }
 77:         guard pdf.pageCount > 1 else {
 78:             // TODO: Decide whether pdf must still be saved or not
 79:             self.asyncSplit = .error(.pdfSinglePage)
 80:             return
 81:         }
 82:         self.toBeSplitPdf = pdf
 83:         self.pageRanges = [0...pdf.pageCount - 1]
 84:         self.totalPages = pdf.pageCount
 85:         self.showPageRangeEditor = true
 86:     }
 87:     
 88:     @MainActor
 89:     private func splitPdf() {
 90:         guard let pdf = self.toBeSplitPdf else {
 91:             self.asyncSplit = .idle
 92:             return
 93:         }
 94:         guard self.pageRanges.count > 0 else {
 95:             assertionFailure("Page range array is empty!")
 96:             self.asyncSplit = .error(.unknownError)
 97:             return
 98:         }
 99:         self.asyncSplit = .loading(Progress.undeterminedProgress)
100:         
101:         Task {
102:             do {
103:                 let splitPdfs = try await Self.splitPdf(pdf: pdf, pageRanges: self.pageRanges)
104:                 try self.savePdfs(pdfs: splitPdfs)
105:                 self.asyncSplit = .idle
106:                 self.analyticsManager.track(event: .pdfSplit)
107:                 self.onSplitCompleted?()
108:             } catch let splitError as PdfSplitError {
109:                 self.asyncSplit = .error(splitError)
110:             } catch {
111:                 self.asyncSplit = .error(PdfSplitError.convertError(fromError: error))
112:             }
113:             
114:             self.toBeSplitPdf = nil
115:             self.pageRanges = []
116:             self.totalPages = 0
117:         }
118:     }
119:     
120:     private static func splitPdf(pdf: Pdf, pageRanges: [ClosedRange<Int>]) async throws -> [Pdf] {
121:         var pdfs: [Pdf] = []
122:         for pageRange in pageRanges {
123:             pdfs.append(try await Self.getPdfSlice(fromPdf: pdf, pageRange: pageRange))
124:         }
125:         return pdfs
126:     }
127:     
128:     private func savePdfs(pdfs: [Pdf]) throws {
129:         // Any error is not blocking the entire save sequence
130:         var occurredError: Error?
131:         for pdf in pdfs {
132:             do {
133:                 _ = try self.repository.savePdf(pdf: pdf)
134:             } catch {
135:                 occurredError = error
136:             }
137:         }
138:         
139:         if let occurredError {
140:             throw occurredError
141:         }
142:     }
143:     
144:     private static func getPdfSlice(fromPdf pdf: Pdf, pageRange: ClosedRange<Int>) async throws -> Pdf {
145:         guard pageRange.overlaps(0...pdf.pageCount) else {
146:             throw PdfSplitError.incompatibleRange
147:         }
148:         let task = Task<Pdf, Never> {
149:             var pdfSlice = Pdf()
150:             let pdfSliceDocument = pdfSlice.pdfDocument
151:             for pageIndex in pageRange {
152:                 if let page = pdf.pdfDocument.page(at: pageIndex) {
153:                     pdfSliceDocument.insert(page, at: pdfSliceDocument.pageCount)
154:                 } else {
155:                     assertionFailure("Missing expected page!")
156:                 }
157:             }
158:             pdfSlice.updateFilename(pdf.filename + pageRange.pdfFilenameSuffix)
159:             return pdfSlice
160:         }
161:         return await task.value
162:     }
163: }
164: 
165: fileprivate extension ClosedRange where Bound == Int {
166:     var pdfFilenameSuffix: String {
167:         "-\(self.lowerBound + 1)-\(self.upperBound + 1)"
168:     }
169: }
```

## File: pdfexpert/ViewModels/PdfUnlockViewModel.swift
```swift
  1: //
  2: //  PdfUnlockViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 02/08/23.
  6: //
  7: 
  8: import Foundation
  9: import Factory
 10: import SwiftUI
 11: 
 12: extension Container {
 13:     var pdfUnlockViewModel: ParameterFactory<PdfUnlockViewModel.Params, PdfUnlockViewModel> {
 14:         self { PdfUnlockViewModel(params: $0) }
 15:     }
 16: }
 17: 
 18: class PdfUnlockViewModel: ObservableObject {
 19:     
 20:     struct Params {
 21:         let asyncUnlockedPdfMultipleOutput: Binding<AsyncOperation<[Pdf], PdfError>>?
 22:         let asyncUnlockedPdfSingleOutput: Binding<AsyncOperation<Pdf, PdfError>>?
 23:         
 24:         init(asyncUnlockedPdfMultipleOutput: Binding<AsyncOperation<[Pdf], PdfError>>) {
 25:             self.asyncUnlockedPdfMultipleOutput = asyncUnlockedPdfMultipleOutput
 26:             self.asyncUnlockedPdfSingleOutput = nil
 27:         }
 28:         
 29:         init(asyncUnlockedPdfSingleOutput: Binding<AsyncOperation<Pdf, PdfError>>) {
 30:             self.asyncUnlockedPdfMultipleOutput = nil
 31:             self.asyncUnlockedPdfSingleOutput = asyncUnlockedPdfSingleOutput
 32:         }
 33:     }
 34:     
 35:     @Published var showPasswordInputView: Bool = false
 36:     @Published var passwordText: String = ""
 37:     @Published var asyncUnlockedPdf: AsyncOperation<Pdf, PdfError> = AsyncOperation(status: .empty) {
 38:         didSet {
 39:             switch self.asyncUnlockedPdf.status {
 40:             case .empty:
 41:                 // Just in case this reset is caused by an error alert dismiss, go the next pdf
 42:                 self.unlockNextPdf()
 43:             case .loading:
 44:                 break
 45:             case .error:
 46:                 // The error will be shown in the view
 47:                 break
 48:             case .data(let unlockedPdf):
 49:                 self.onUnlockCompleted(forPdf: unlockedPdf)
 50:             }
 51:         }
 52:     }
 53:     
 54:     var unlockingPdf: Pdf? = nil
 55:     
 56:     private let asyncUnlockedPdfMultipleOutput: Binding<AsyncOperation<[Pdf], PdfError>>?
 57:     private let asyncUnlockedPdfSingleOutput: Binding<AsyncOperation<Pdf, PdfError>>?
 58:     
 59:     private var toBeUnlockedPdfs: [Pdf] = []
 60:     private var unlockedPdfs: [Pdf] = []
 61:     
 62:     init(params: Params) {
 63:         self.asyncUnlockedPdfMultipleOutput = params.asyncUnlockedPdfMultipleOutput
 64:         self.asyncUnlockedPdfSingleOutput = params.asyncUnlockedPdfSingleOutput
 65:     }
 66:     
 67:     func unlockPdfs(pdfs: [Pdf]) {
 68:         guard pdfs.count > 0 else {
 69:             self.asyncUnlockedPdfMultipleOutput?.wrappedValue = .init(status: .empty)
 70:             self.asyncUnlockedPdfSingleOutput?.wrappedValue = .init(status: .empty)
 71:             return
 72:         }
 73:         self.toBeUnlockedPdfs = pdfs
 74:         self.unlockNextPdf()
 75:     }
 76:     
 77:     func unlockPdf(pdf: Pdf) {
 78:         // Must skip a frame to make the view correctly dismiss and show again the password input alert
 79:         DispatchQueue.main.async { [weak self] in
 80:             guard let self else { return }
 81:             
 82:             if pdf.pdfDocument.isLocked {
 83:                 self.unlockingPdf = pdf
 84:                 self.showPasswordInputView = true
 85:             } else {
 86:                 self.onUnlockCompleted(forPdf: pdf)
 87:             }
 88:         }
 89:     }
 90:     
 91:     @MainActor
 92:     func decryptPdf() {
 93:         guard let pdf = self.unlockingPdf else {
 94:             assertionFailure("Missing expected pdf")
 95:             self.asyncUnlockedPdf = AsyncOperation(status: .empty)
 96:             return
 97:         }
 98:         self.asyncUnlockedPdf = .init(status: .loading(Progress(totalUnitCount: 1)))
 99:         Task {
100:             let task = Task<AsyncOperation<Pdf, PdfError>, Never> {
101:                 return PDFUtility.decryptFile(pdf: pdf, password: self.passwordText)
102:             }
103:             self.asyncUnlockedPdf = await task.value
104:             self.passwordText = ""
105:             self.unlockingPdf = nil
106:         }
107:     }
108:     
109:     private func unlockNextPdf() {
110:         guard let pdf = self.toBeUnlockedPdfs.popLast() else {
111:             self.asyncUnlockedPdfMultipleOutput?.wrappedValue = AsyncOperation(status: .data(self.unlockedPdfs))
112:             if let unlockedPdf = self.unlockedPdfs.first {
113:                 self.asyncUnlockedPdfSingleOutput?.wrappedValue = AsyncOperation(status: .data(unlockedPdf))
114:             } else {
115:                 self.asyncUnlockedPdfSingleOutput?.wrappedValue = AsyncOperation(status: .empty)
116:             }
117:             self.unlockedPdfs = []
118:             return
119:         }
120:         
121:         self.unlockPdf(pdf: pdf)
122:     }
123:     
124:     private func onUnlockCompleted(forPdf pdf: Pdf) {
125:         self.unlockedPdfs.append(pdf)
126:         self.unlockNextPdf()
127:     }
128: }
```

## File: pdfexpert/ViewModels/ReviewFlow.swift
```swift
 1: //
 2: //  ReviewFlow.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 31/08/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: import SwiftUI
11: import StoreKit
12: 
13: extension Container {
14:     var reviewFlow: Factory<ReviewFlow> {
15:         self { ReviewFlow() }
16:     }
17: }
18: 
19: class ReviewFlow: ObservableObject {
20:     
21:     @Published var showPreReviewView: Bool = false
22:     @Published var showLowReviewView: Bool = false
23:     
24:     @Injected(\.analyticsManager) var analyticsManager
25:     @Injected(\.cacheManager) var cacheManager
26:     @Injected(\.store) var store
27:     
28:     private var shouldShow: Bool {
29:         return self.neverSeenBefore && self.store.isPremium.value
30:     }
31:     
32:     private var neverSeenBefore: Bool {
33:         #if DEBUG
34:             if K.Test.Review.ShowAlways {
35:                 return true
36:             } else {
37:                 return !self.cacheManager.preReviewShown
38:             }
39:         #else
40:             !self.cacheManager.preReviewShown
41:         #endif
42:     }
43:     
44:     func startFlowIfNeeded() {
45:         if self.shouldShow {
46:             self.cacheManager.preReviewShown = true
47:             self.showPreReviewView = true
48:         }
49:     }
50:     
51:     @MainActor
52:     func onPreReviewRateSelected(preReviewRate: Int, nativeReviewCallback: @escaping (() -> ())) {
53:         Task {
54:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
55:             self.showPreReviewView = false
56:             try await Task.sleep(until: .now + .seconds(0.25), clock: .continuous)
57:             if preReviewRate >= K.Review.MinimumRateForNativePopup {
58:                 nativeReviewCallback()
59:             } else {
60:                 self.showLowReviewView = true
61:             }
62:         }
63:     }
64:     
65:     func onPreReviewLowRateFeedbackSent(feedback: String) {
66:         self.showLowReviewView = false
67:         if !feedback.isEmpty {
68:             self.analyticsManager.track(event: .reviewLowRateFeedback(feedback: feedback))
69:         }
70:     }
71: }
```

## File: pdfexpert/ViewModels/SubscribeViewModel.swift
```swift
  1: //
  2: //  SubscribeViewModel.swift
  3: //  ChatAI
  4: //
  5: //  Created by Pcnaid Inc on 23/02/23.
  6: //
  7: 
  8: import Foundation
  9: import StoreKit
 10: import Combine
 11: import Factory
 12: import Collections
 13: 
 14: protocol SubscriptionPlan: Hashable {
 15:     var product: Product? { get }
 16: }
 17: 
 18: struct SubscriptionPlanCombo<T: SubscriptionPlan> {
 19:     let standardSubscriptionPlan: T?
 20:     let freeTrialSubscriptionPlan: T?
 21:     
 22:     func getPlan(forFreeTrialState freeTrialState: Bool) -> T? {
 23:         return freeTrialState ? self.freeTrialSubscriptionPlan : self.standardSubscriptionPlan
 24:     }
 25: }
 26: 
 27: class SubscribeViewModel<S: SubscriptionPlan>: ObservableObject {
 28:     
 29:     @Published var isPremium: Bool = false
 30:     @Published var restorePurchaseRequest: AsyncOperation<Bool, SharedUnderlyingError> = AsyncOperation(status: .empty)
 31:     @Published var purchaseRequest: AsyncOperation<(), SharedUnderlyingError> = AsyncOperation(status: .empty)
 32:     
 33:     @Published var currentSubscriptionPlan: S?
 34:     
 35:     @Injected(\.store) private var store
 36:     @Injected(\.analyticsManager) private var analyticsManager
 37:     
 38:     private var cancelBag = Set<AnyCancellable>()
 39:     
 40:     init() {
 41:         self.store.isPremium.sink { self.onPremiumStateChanged(isPremium: $0) }.store(in: &self.cancelBag)
 42:     }
 43:     
 44:     @MainActor
 45:     open func refresh() {}
 46:     
 47:     @MainActor
 48:     func subscribe() {
 49:         
 50:         guard let product = self.currentSubscriptionPlan?.product else {
 51:             self.purchaseRequest = AsyncOperation(status: .error(.unknownError))
 52:             return
 53:         }
 54:         
 55:         self.purchaseRequest = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
 56:         
 57:         Task {
 58:             do {
 59:                 _ = try await self.store.purchase(product)
 60:                 self.purchaseRequest = AsyncOperation(status: .data(()))
 61:             } catch let error {
 62:                 print("Subscribe Error: " + error.localizedDescription)
 63:                 let convertedError = SharedUnderlyingError.convertError(fromError: error)
 64:                 self.purchaseRequest = AsyncOperation(status: .error(convertedError))
 65:             }
 66:         }
 67:     }
 68:     
 69:     @MainActor
 70:     func restorePurchases() {
 71:         Task {
 72:             self.restorePurchaseRequest = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
 73:             //This call displays a system prompt that asks users to authenticate with their App Store credentials.
 74:             //Call this function only in response to an explicit user action, such as tapping a button.
 75:             do {
 76:                 let currentIsPremium = self.isPremium
 77:                 try await AppStore.sync()
 78:                 await self.store.updateCustomerProductStatus()
 79:                 self.restorePurchaseRequest = AsyncOperation(status: .data(self.isPremium && self.isPremium != currentIsPremium))
 80:             } catch {
 81:                 let convertedError = SharedUnderlyingError.convertError(fromError: error)
 82:                 self.restorePurchaseRequest = AsyncOperation(status: .error(convertedError))
 83:             }
 84:         }
 85:     }
 86:     
 87:     @MainActor
 88:     func onAppear() {
 89:         self.analyticsManager.track(event: .reportScreen(.subscription))
 90:         self.analyticsManager.track(event: .subscriptionShown)
 91:         self.refresh()
 92:     }
 93:     
 94:     private func onPremiumStateChanged(isPremium: Bool) {
 95:         self.isPremium = isPremium
 96:     }
 97: }
 98: 
 99: // MARK: - Errors
100: 
101: enum RefreshError: LocalizedError, UnderlyingError {
102:     case unknownError
103:     case underlyingError(errorDescription: String)
104:     case missingExpectedSubscriptionPlanError
105:     
106:     static func getUnknownError() -> Self { Self.unknownError }
107:     
108:     static func getUnderlyingError(errorDescription: String) -> Self {
109:         return .underlyingError(errorDescription: errorDescription)
110:     }
111:     
112:     var errorDescription: String? {
113:         switch self {
114:         case .unknownError: return "Internal Error. Please try again later"
115:         case .underlyingError(let errorMessage): return errorMessage
116:         case .missingExpectedSubscriptionPlanError: return "Internal Error. Please try again later"
117:         }
118:     }
119: }
```

## File: pdfexpert/ViewModels/SubscriptionPairsViewModel.swift
```swift
 1: //
 2: //  SubscriptionPairsViewModel.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 13/04/23.
 6: //
 7: 
 8: import Foundation
 9: import StoreKit
10: import Combine
11: import Factory
12: 
13: extension Container {
14:     var subscribtionPairsViewModel: Factory<SubscriptionPairsViewModel> {
15:         self { SubscriptionPairsViewModel() }
16:     }
17: }
18: 
19: struct SubscriptionPlanPairItem: SubscriptionPlan {
20:     let product: Product?
21:     let title: String
22:     let weeklyPriceAndPeriod: String
23:     let fullDescriptionText: String
24: }
25: 
26: fileprivate extension Product {
27:     var subscriptionPlanPairItem: SubscriptionPlanPairItem? {
28:         return SubscriptionPlanPairItem(
29:             product: self,
30:             title: self.title,
31:             weeklyPriceAndPeriod: self.weeklyPriceAndPeriod,
32:             fullDescriptionText: self.fullDescriptionText
33:         )
34:     }
35: }
36: 
37: fileprivate let productMetaViewValuePairs: String = "pairs"
38: 
39: class SubscriptionPairsViewModel: SubscribeViewModel<SubscriptionPlanPairItem> {
40:     
41:     typealias PlanPair = SubscriptionPlanCombo<SubscriptionPlanPairItem>
42:     
43:     @Published var selectedSubscriptionPairIndex: Int = 0 {
44:         didSet { self.updateCurrentSubscriptionPlan() }
45:     }
46:     @Published var isFreeTrialEnabled: Bool = false {
47:         didSet { self.updateCurrentSubscriptionPlan() }
48:     }
49:     @Published var asyncSubscriptionPlanPairs: AsyncOperation<[PlanPair], RefreshError> = AsyncOperation(status: .empty) {
50:         didSet { self.updateCurrentSubscriptionPlan() }
51:     }
52:     
53:     @Published var currentSubscriptionPlanPair: PlanPair?
54:     
55:     @Injected(\.store) private var store
56:     
57:     @MainActor
58:     override func refresh() {
59:         
60:         self.asyncSubscriptionPlanPairs = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
61:         
62:         Task {
63:             do {
64:                 try await self.store.refreshAll()
65:                 let subscriptionPlanPairs = try await self.productsToSubscriptionPairs(products: self.store.subscriptions)
66:                 if subscriptionPlanPairs.count > 0 {
67:                     self.asyncSubscriptionPlanPairs = AsyncOperation(status: .data(subscriptionPlanPairs))
68:                 } else {
69:                     self.asyncSubscriptionPlanPairs = AsyncOperation(status: .error(.missingExpectedSubscriptionPlanError))
70:                 }
71:             } catch {
72:                 let convertedError = RefreshError.convertError(fromError: error)
73:                 self.asyncSubscriptionPlanPairs = AsyncOperation(status: .error(convertedError))
74:             }
75:         }
76:     }
77:     
78:     private func productsToSubscriptionPairs(products: [Product]) async throws -> [PlanPair] {
79:         let subscriptionProducts = getSubscriptionsForView(products: products, store: self.store, viewKey: productMetaViewValuePairs)
80:         return try await subscriptionProducts.subscriptionPairs(periodOrderDesc: true, conversion: { $0?.subscriptionPlanPairItem })
81:     }
82:     
83:     private func updateCurrentSubscriptionPlan() {
84:         guard let subscriptionPlanPairs = self.asyncSubscriptionPlanPairs.data,
85:               self.selectedSubscriptionPairIndex >= 0,
86:               self.selectedSubscriptionPairIndex < subscriptionPlanPairs.count else {
87:             return
88:         }
89:         let currentSubscriptionPlanPair = subscriptionPlanPairs[self.selectedSubscriptionPairIndex]
90:         if self.isFreeTrialEnabled {
91:             self.currentSubscriptionPlan = currentSubscriptionPlanPair.freeTrialSubscriptionPlan ?? currentSubscriptionPlanPair.standardSubscriptionPlan
92:         } else {
93:             self.currentSubscriptionPlan = currentSubscriptionPlanPair.standardSubscriptionPlan ?? currentSubscriptionPlanPair.freeTrialSubscriptionPlan
94:         }
95:         self.currentSubscriptionPlanPair = currentSubscriptionPlanPair
96:     }
97: }
```

## File: pdfexpert/ViewModels/SubscriptionPickerViewModel.swift
```swift
  1: //
  2: //  SubscriptionPickerViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 08/08/23.
  6: //
  7: 
  8: import Foundation
  9: import StoreKit
 10: import Combine
 11: import Factory
 12: 
 13: extension Container {
 14:     var subscriptionPickerViewModel: Factory<SubscriptionPickerViewModel> {
 15:         self { SubscriptionPickerViewModel() }
 16:     }
 17: }
 18: 
 19: struct SubscriptionPlanPickerItem: SubscriptionPlan {
 20:     let product: Product?
 21:     let title: String
 22:     let period: String
 23:     let weeklyPriceAndPeriod: String
 24:     let fullDescriptionText: String
 25:     let priceText: String
 26:     let bestDiscountText: String?
 27: }
 28: 
 29: fileprivate extension Product {
 30:     func getSubscriptionPlanPickerItem(totalProducts: [Product]) -> SubscriptionPlanPickerItem {
 31:         return SubscriptionPlanPickerItem(
 32:             product: self,
 33:             title: self.title,
 34:             period: self.period,
 35:             weeklyPriceAndPeriod: self.weeklyPriceAndPeriod,
 36:             fullDescriptionText: self.fullDescriptionText,
 37:             priceText: self.priceText,
 38:             bestDiscountText: self.getBestDiscount(forProducts: totalProducts)
 39:         )
 40:     }
 41: }
 42: 
 43: class SubscriptionPickerViewModel: SubscribeViewModel<SubscriptionPlanPickerItem> {
 44:     
 45:     fileprivate static let productMetaViewValue: String = "picker"
 46:     
 47:     typealias PlanPair = SubscriptionPlanCombo<SubscriptionPlanPickerItem>
 48:     
 49:     @Published var selectedSubscriptionPairIndex: Int = 0 {
 50:         didSet { self.updateCurrentSubscriptionPlan() }
 51:     }
 52:     @Published var isFreeTrialEnabled: Bool = false {
 53:         didSet { self.updateCurrentSubscriptionPlan() }
 54:     }
 55:     @Published var asyncSubscriptionPlanPairs: AsyncOperation<[PlanPair], RefreshError> = AsyncOperation(status: .empty) {
 56:         didSet { self.updateCurrentSubscriptionPlan() }
 57:     }
 58:     
 59:     @Published var currentSubscriptionPlanPair: PlanPair?
 60:     
 61:     var subscriptionPlans: [SubscriptionPlanPickerItem] {
 62:         guard let pairs = self.asyncSubscriptionPlanPairs.data else {
 63:             return []
 64:         }
 65:         let plans = pairs.compactMap { $0.freeTrialSubscriptionPlan ?? $0.standardSubscriptionPlan }
 66:         guard plans.count == pairs.count else {
 67:             return []
 68:         }
 69:         return plans
 70:     }
 71:     
 72:     @Injected(\.store) private var store
 73:     
 74:     @MainActor
 75:     override func refresh() {
 76:         
 77:         self.asyncSubscriptionPlanPairs = .init(status: .loading(.undeterminedProgress))
 78:         
 79:         Task {
 80:             do {
 81:                 try await self.store.refreshAll()
 82:                 let subscriptionPlanPairs = try await self.productsToSubscriptionPairs(products: self.store.subscriptions)
 83:                 if subscriptionPlanPairs.count > 0 {
 84:                     self.asyncSubscriptionPlanPairs = .init(status: .data(subscriptionPlanPairs))
 85:                 } else {
 86:                     self.asyncSubscriptionPlanPairs = .init(status: .error(.missingExpectedSubscriptionPlanError))
 87:                 }
 88:             } catch {
 89:                 let convertedError = RefreshError.convertError(fromError: error)
 90:                 self.asyncSubscriptionPlanPairs = AsyncOperation(status: .error(convertedError))
 91:             }
 92:         }
 93:     }
 94:     
 95:     private func productsToSubscriptionPairs(products: [Product]) async throws -> [PlanPair] {
 96:         let subscriptionProducts = getSubscriptionsForView(products: products, store: self.store, viewKey: Self.productMetaViewValue)
 97:         return try await subscriptionProducts.subscriptionPairs(periodOrderDesc: false, conversion: { $0?.getSubscriptionPlanPickerItem(totalProducts: products) })
 98:     }
 99:     
100:     private func updateCurrentSubscriptionPlan() {
101:         guard let subscriptionPlanPairs = self.asyncSubscriptionPlanPairs.data,
102:               self.selectedSubscriptionPairIndex >= 0,
103:               self.selectedSubscriptionPairIndex < subscriptionPlanPairs.count else {
104:             return
105:         }
106:         let currentSubscriptionPlanPair = subscriptionPlanPairs[self.selectedSubscriptionPairIndex]
107:         if self.isFreeTrialEnabled {
108:             self.currentSubscriptionPlan = currentSubscriptionPlanPair.freeTrialSubscriptionPlan ?? currentSubscriptionPlanPair.standardSubscriptionPlan
109:         } else {
110:             self.currentSubscriptionPlan = currentSubscriptionPlanPair.standardSubscriptionPlan ?? currentSubscriptionPlanPair.freeTrialSubscriptionPlan
111:         }
112:         self.currentSubscriptionPlanPair = currentSubscriptionPlanPair
113:     }
114: }
```

## File: pdfexpert/ViewModels/SubscriptionVerticalViewModel.swift
```swift
  1: //
  2: //  SubscriptionVerticalViewModel.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 13/04/23.
  6: //
  7: 
  8: import Foundation
  9: import StoreKit
 10: import Combine
 11: import Factory
 12: 
 13: enum SubscriptionVerticalViewMode {
 14:     case highlightLongPeriod
 15:     case highlightShortPeriod
 16: }
 17: 
 18: extension Container {
 19:     var subscriptionVerticalViewModel: ParameterFactory<SubscriptionVerticalViewMode, SubscriptionVerticalViewModel> {
 20:         self { SubscriptionVerticalViewModel(mode: $0) }
 21:     }
 22: }
 23: 
 24: struct SubscriptionPlanVerticalItem: SubscriptionPlan {
 25:     let product: Product?
 26:     let titleShort: String
 27:     let weeklyPriceAndPeriod: String
 28:     let fullDescriptionText: String
 29:     let freeTrialText: String?
 30:     let bestDiscountText: String?
 31:     let discountText: String?
 32: }
 33: 
 34: fileprivate extension Product {
 35:     func getSubscriptionPlanVerticalItem(totalProducts: [Product], hideBestDiscount: Bool) -> SubscriptionPlanVerticalItem {
 36:         return SubscriptionPlanVerticalItem(
 37:             product: self,
 38:             titleShort: self.titleShort,
 39:             weeklyPriceAndPeriod: self.weeklyPriceAndPeriod,
 40:             fullDescriptionText: self.fullDescriptionText,
 41:             freeTrialText: self.freeTrialText,
 42:             bestDiscountText: hideBestDiscount ? nil : self.getBestDiscount(forProducts: totalProducts),
 43:             discountText: self.getDiscount(forProducts: totalProducts)
 44:         )
 45:     }
 46: }
 47: 
 48: fileprivate let productMetaViewValueVertical: String = "vertical"
 49: 
 50: class SubscriptionVerticalViewModel: SubscribeViewModel<SubscriptionPlanVerticalItem> {
 51:     
 52:     @Published var asyncSubscriptionPlanList: AsyncOperation<[SubscriptionPlanVerticalItem], RefreshError> = AsyncOperation(status: .empty) {
 53:         didSet { self.updateCurrentSubscriptionPlan() }
 54:     }
 55:     
 56:     @Published var selectedSubscriptionItemIndex: Int = 0 {
 57:         didSet { self.updateCurrentSubscriptionPlan() }
 58:     }
 59:     
 60:     @Injected(\.store) private var store
 61:     
 62:     private let mode: SubscriptionVerticalViewMode
 63:     
 64:     init(mode: SubscriptionVerticalViewMode) {
 65:         self.mode = mode
 66:         super.init()
 67:     }
 68:     
 69:     @MainActor
 70:     override func refresh() {
 71:         
 72:         self.asyncSubscriptionPlanList = AsyncOperation(status: .loading(Progress(totalUnitCount: 1)))
 73:         
 74:         Task {
 75:             do {
 76:                 try await self.store.refreshAll()
 77:                 let subscriptionPlanList = try await self.productsToSubscriptionList(products: self.store.subscriptions)
 78:                 if subscriptionPlanList.count > 0 {
 79:                     self.asyncSubscriptionPlanList = AsyncOperation(status: .data(subscriptionPlanList))
 80:                 } else {
 81:                     self.asyncSubscriptionPlanList = AsyncOperation(status: .error(.missingExpectedSubscriptionPlanError))
 82:                 }
 83:             } catch {
 84:                 let convertedError = RefreshError.convertError(fromError: error)
 85:                 self.asyncSubscriptionPlanList = AsyncOperation(status: .error(convertedError))
 86:             }
 87:         }
 88:     }
 89:     
 90:     private func productsToSubscriptionList(products: [Product]) async throws -> [SubscriptionPlanVerticalItem] {
 91:         var subscriptions = getSubscriptionsForView(products: products, store: self.store, viewKey: productMetaViewValueVertical)
 92:         
 93:         subscriptions.sort { product1, product2 in
 94:             product1.subscription?.subscriptionPeriod.days ?? 0 > product2.subscription?.subscriptionPeriod.days ?? 0
 95:         }
 96:         
 97:         var hideBestDiscount = false
 98:         switch self.mode {
 99:         case .highlightLongPeriod:
100:             break
101:         case .highlightShortPeriod:
102:             hideBestDiscount = true
103:             subscriptions.reverse()
104:         }
105:         
106:         return subscriptions.map { $0.getSubscriptionPlanVerticalItem(totalProducts: subscriptions, hideBestDiscount: hideBestDiscount) }
107:     }
108:     
109:     private func updateCurrentSubscriptionPlan() {
110:         guard let subscriptionPlanList = self.asyncSubscriptionPlanList.data,
111:               self.selectedSubscriptionItemIndex >= 0,
112:               self.selectedSubscriptionItemIndex < subscriptionPlanList.count else {
113:             return
114:         }
115:         self.currentSubscriptionPlan = subscriptionPlanList[self.selectedSubscriptionItemIndex]
116:     }
117: }
```

## File: pdfexpert/ViewModels/SuggestedFieldsFormViewModel.swift
```swift
 1: //
 2: //  SuggestedFieldsFormViewModel.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 07/09/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: 
11: extension Container {
12:     var suggestedFieldsFormViewModel: Factory<SuggestedFieldsFormViewModel> {
13:         self { SuggestedFieldsFormViewModel() }
14:     }
15: }
16: 
17: class SuggestedFieldsFormViewModel: ObservableObject {
18:     
19:     @Published var firstName: String
20:     @Published var lastName: String
21:     @Published var address: String
22:     @Published var city: String
23:     @Published var country: String
24:     @Published var email: String
25:     @Published var phone: String
26:     
27:     @Injected(\.analyticsManager) private var analyticsManager
28:     private let repository = resolve(\.repository)
29:     
30:     private var suggestedFields: SuggestedFields
31:     
32:     init() {
33:         self.suggestedFields = (try? self.repository.loadSuggestedFields()) ?? SuggestedFields()
34:         self._firstName = .init(initialValue: self.suggestedFields.firstName ?? "")
35:         self._lastName = .init(initialValue: self.suggestedFields.lastName ?? "")
36:         self._address = .init(initialValue: self.suggestedFields.address ?? "")
37:         self._city = .init(initialValue: self.suggestedFields.city ?? "")
38:         self._country = .init(initialValue: self.suggestedFields.country ?? "")
39:         self._email = .init(initialValue: self.suggestedFields.email ?? "")
40:         self._phone = .init(initialValue: self.suggestedFields.phone ?? "")
41:     }
42:     
43:     func onAppear() {
44:         self.analyticsManager.track(event: .reportScreen(.suggestedFields))
45:     }
46:     
47:     func onConfirmButtonPressed() {
48:         self.update(keyPath: \.firstName, value: self.firstName)
49:         self.update(keyPath: \.lastName, value: self.lastName)
50:         self.update(keyPath: \.address, value: self.address)
51:         self.update(keyPath: \.city, value: self.city)
52:         self.update(keyPath: \.country, value: self.country)
53:         self.update(keyPath: \.email, value: self.email)
54:         self.update(keyPath: \.phone, value: self.phone)
55:         
56:         do {
57:             _ = try self.repository.saveSuggestedFields(suggestedFields: self.suggestedFields)
58:         } catch {
59:             debugPrint(for: self, message: "Error: \(error)")
60:         }
61:     }
62:     
63:     private func update(keyPath: WritableKeyPath<SuggestedFields, String?>, value: String) {
64:         let trimmedValue = value.trimmingCharacters(in: .whitespacesAndNewlines)
65:         self.suggestedFields[keyPath: keyPath] = trimmedValue.isEmpty ? nil : trimmedValue
66:     }
67: }
```

## File: pdfexpert/Views/Archive/ArchiveView.swift
```swift
  1: //
  2: //  ArchiveView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 06/04/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct ArchiveView: View {
 12:     
 13:     @InjectedObject(\.archiveViewModel) var viewModel
 14:     
 15:     @State private var showingDeleteAlert = false
 16:     @State private var itemToDelete: Pdf? = nil
 17:     @State private var importTutorialShow: Bool = false
 18:     
 19:     var body: some View {
 20:         ZStack {
 21:             self.content
 22:             if self.viewModel.isLoading {
 23:                 AnyView(self.getLoadingView())
 24:             }
 25:         }
 26:         .background(ColorPalette.primaryBG)
 27:         .onAppear() {
 28:             self.viewModel.onAppear()
 29:         }
 30:         .asyncView(asyncOperation: self.$viewModel.asyncItemDelete)
 31:         .fullScreenCover(isPresented: self.$importTutorialShow) {
 32:             ImportTutorialView()
 33:         }
 34:         .showShareView(coordinator: self.viewModel.pdfShareCoordinator)
 35:     }
 36:     
 37:     var content: some View {
 38:         switch self.viewModel.asyncItems.status {
 39:         case .empty: return AnyView(Spacer())
 40:         case .loading: return AnyView(self.getLoadingView())
 41:         case .data(let items): return AnyView(self.getItemList(items: items))
 42:         case .error: return AnyView(self.getErrorView())
 43:         }
 44:     }
 45:     
 46:     func getItemList(items: [Pdf]) -> some View {
 47:         if items.count > 0 {
 48:             return AnyView(
 49:                 List(items) { item in
 50:                     Button(action: { self.viewModel.editItem(item: item) }) {
 51:                         HStack(spacing: 16) {
 52:                             self.getPdfThumbnail(forPdf: item)
 53:                                 .frame(width: 86)
 54:                             VStack(spacing: 0) {
 55:                                 Spacer()
 56:                                 Text(item.filename)
 57:                                     .font(forCategory: .body1)
 58:                                     .foregroundColor(ColorPalette.primaryText)
 59:                                     .frame(maxWidth: .infinity, alignment: .leading)
 60:                                     .lineLimit(1)
 61:                                 Spacer().frame(height: 16)
 62:                                 HStack(spacing: 16) {
 63:                                     Text(item.pageCountText)
 64:                                         .font(forCategory: .body2)
 65:                                         .foregroundColor(ColorPalette.fourthText)
 66:                                         .frame(maxWidth: .infinity, alignment: .leading)
 67:                                     if item.password != nil {
 68:                                         Image("password_entered")
 69:                                     }
 70:                                     Button(action: { self.viewModel.shareItem(item: item) }) {
 71:                                         Image(systemName: "square.and.arrow.up")
 72:                                             .font(.system(size: 20).bold())
 73:                                             .foregroundColor(ColorPalette.primaryText)
 74:                                     }
 75:                                 }
 76:                                 Spacer()
 77:                             }
 78:                             .frame(maxWidth: .infinity)
 79:                         }
 80:                         .padding(.trailing, 16)
 81:                         .background(ColorPalette.secondaryBG)
 82:                     }
 83:                     .frame(height: 94)
 84:                     .cornerRadius(10)
 85:                     .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
 86:                     .listRowSeparator(.hidden)
 87:                     .listRowBackground(Color(.clear))
 88:                     .swipeActions(allowsFullSwipe: false, content: {
 89:                         Button(role: .none, action: {
 90:                             self.itemToDelete = item
 91:                             self.showingDeleteAlert = true
 92:                         }, label: {
 93:                             Image(systemName: "trash")
 94:                         })
 95:                         .tint(Color.red)
 96:                     })
 97:                     .actionDialog(
 98:                         Text("Are you sure?"),
 99:                         isPresented: self.$showingDeleteAlert,
100:                         titleVisibility: .visible
101:                     ) {
102:                         Button("Delete", role: .destructive) {
103:                             self.showingDeleteAlert = false
104:                             withAnimation {
105:                                 if let itemToDelete = self.itemToDelete {
106:                                     self.viewModel.delete(item: itemToDelete)
107:                                 }
108:                             }
109:                         }
110:                     }
111:                 }
112:                     // Needed to use a custom background color in case of List with inset list style
113:                     .scrollContentBackground(.hidden)
114:                     .listStyle(.inset)
115:                     .safeAreaInset(edge: .bottom) {
116:                         Button(action: { self.importTutorialShow = true }) {
117:                             HStack(spacing: 8) {
118:                                 Image("info")
119:                                     .resizable()
120:                                     .frame(width: 18, height: 18)
121:                                 Text("Convert from any file")
122:                                     .frame(maxHeight: .infinity)
123:                                     .font(forCategory: .button)
124:                                     .foregroundColor(ColorPalette.primaryText)
125:                             }
126:                             .contentShape(Capsule())
127:                         }
128:                         .frame(maxWidth: .infinity)
129:                         .frame(height: 48)
130:                         .background(self.defaultGradientBackground)
131:                         .cornerRadius(10)
132:                         .padding(EdgeInsets(top: 0, leading: 32, bottom: 32, trailing: 32))
133:                     }
134:             )
135:         } else {
136:             return AnyView(self.getEmptyView)
137:         }
138:     }
139:     
140:     var getEmptyView: some View {
141:         VStack(spacing: 16) {
142:             Spacer()
143:             Image("archive_empty")
144:                 .resizable()
145:                 .aspectRatio(contentMode: .fit)
146:                 .frame(height: 80)
147:             Text("You havent converted any files yet")
148:                 .font(forCategory: .body1)
149:                 .foregroundColor(ColorPalette.primaryText)
150:                 .frame(maxWidth: .infinity, alignment: .center)
151:                 .multilineTextAlignment(.center)
152:             Spacer()
153:         }
154:         .padding([.leading, .trailing], 16)
155:     }
156:     
157:     func getLoadingView() -> some View {
158:         AnimationType.dots.view.background(Color(.black).opacity(0.3))
159:     }
160:     
161:     func getErrorView() -> some View {
162:         VStack(spacing: 16) {
163:             Spacer()
164:             Image("subscription_error")
165:                 .resizable()
166:                 .aspectRatio(contentMode: .fit)
167:                 .frame(height: 80)
168:             Text("Oh Know!")
169:                 .font(forCategory: .largeTitle)
170:                 .foregroundColor(ColorPalette.primaryText)
171:                 .frame(maxWidth: .infinity, alignment: .center)
172:             Text("Something went wrong,\n Please try again.")
173:                 .font(forCategory: .body1)
174:                 .foregroundColor(ColorPalette.primaryText)
175:                 .multilineTextAlignment(.center)
176:                 .frame(maxWidth: .infinity, alignment: .center)
177:             self.getDefaultButton(text: "Retry",
178:                                   onButtonPressed: self.viewModel.refresh)
179:             Spacer()
180:         }
181:         .padding([.leading, .trailing], 16)
182:     }
183:     
184:     @ViewBuilder private func getPdfThumbnail(forPdf pdf: Pdf) -> some View {
185:         if let thumbnail = pdf.thumbnail {
186:             Color.clear
187:                 .overlay(Image(uiImage: thumbnail)
188:                     .resizable()
189:                     .scaledToFill())
190:                 .clipShape(RoundedRectangle(cornerRadius: 10,
191:                             style: .continuous))
192:         } else {
193:             ColorPalette.secondaryBG
194:                 .cornerRadius(10)
195:         }
196:     }
197: }
198: 
199: extension Pdf {
200:     
201:     var pageCountText: String {
202:         "\(self.pageCount) pages"
203:     }
204: }
205: 
206: struct ArchiveView_Previews: PreviewProvider {
207:     static var previews: some View {
208:         ArchiveView()
209:     }
210: }
```

## File: pdfexpert/Views/Camera/CameraView.swift
```swift
  1: //
  2: //  CameraView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 30/03/23.
  6: //
  7: 
  8: import SwiftUI
  9: 
 10: struct CameraView: View {
 11:     @StateObject var model: CameraViewModel
 12: 
 13:     @State var currentZoomFactor: CGFloat = 1.0
 14:     
 15:     @Environment(\.dismiss) var dismiss
 16: 
 17:     var captureButton: some View {
 18:         Button(action: {
 19:             model.capturePhoto()
 20:         }, label: {
 21:             Circle()
 22:                 .foregroundColor(.white)
 23:                 .frame(width: 80, height: 80, alignment: .center)
 24:                 .overlay(
 25:                     Circle()
 26:                         .stroke(Color.black.opacity(0.8), lineWidth: 2)
 27:                         .frame(width: 65, height: 65, alignment: .center)
 28:                 )
 29:         })
 30:     }
 31: 
 32:     var flipCameraButton: some View {
 33:         Button(action: {
 34:             model.flipCamera()
 35:         }, label: {
 36:             Circle()
 37:                 .foregroundColor(Color.gray.opacity(0.2))
 38:                 .frame(width: 45, height: 45, alignment: .center)
 39:                 .overlay(
 40:                     Image(systemName: "camera.rotate.fill")
 41:                         .foregroundColor(.white))
 42:         })
 43:     }
 44: 
 45:     var body: some View {
 46:         NavigationView {
 47:             ZStack {
 48:                 GeometryReader { reader in
 49:                     ZStack {
 50:                         Color.black.edgesIgnoringSafeArea(.all)
 51:                         
 52:                         VStack {
 53:                             Button(action: {
 54:                                 model.switchFlash()
 55:                             }, label: {
 56:                                 Image(systemName: model.isFlashOn ? "bolt.fill" : "bolt.slash.fill")
 57:                                     .font(.system(size: 20, weight: .medium, design: .default))
 58:                             })
 59:                             .accentColor(model.isFlashOn ? .yellow : .white)
 60:                             
 61:                             CameraPreviewView(session: model.session)
 62:                                 .gesture(
 63:                                     DragGesture().onChanged({ (val) in
 64:                                         //  Only accept vertical drag
 65:                                         if abs(val.translation.height) > abs(val.translation.width) {
 66:                                             //  Get the percentage of vertical screen space covered by drag
 67:                                             let percentage: CGFloat = -(val.translation.height / reader.size.height)
 68:                                             //  Calculate new zoom factor
 69:                                             let calc = currentZoomFactor + percentage
 70:                                             //  Limit zoom factor to a maximum of 5x and a minimum of 1x
 71:                                             let zoomFactor: CGFloat = min(max(calc, 1), 5)
 72:                                             //  Store the newly calculated zoom factor
 73:                                             currentZoomFactor = zoomFactor
 74:                                             //  Sets the zoom factor to the capture device session
 75:                                             model.zoom(with: zoomFactor)
 76:                                         }
 77:                                     })
 78:                                 )
 79:                                 .onAppear {
 80:                                     model.configure()
 81:                                 }
 82:                                 .alert(isPresented: $model.showAlertError, content: {
 83:                                     let error = self.model.error!
 84:                                     if let confirmText = error.confirmText, let confirmAction = error.confirmAction {
 85:                                         return Alert(title: Text(error.title),
 86:                                                      message: Text(error.message),
 87:                                                      primaryButton: .default(Text(confirmText), action: {
 88:                                             confirmAction()
 89:                                         }),
 90:                                                      secondaryButton: .default(Text(error.dismissText), action: {
 91:                                             model.showAlertError = false
 92:                                         }))
 93:                                     } else {
 94:                                         return Alert(title: Text(error.title),
 95:                                                      message: Text(error.message),
 96:                                                      dismissButton: .default(Text(error.dismissText), action: {
 97:                                             model.showAlertError = false
 98:                                         }))
 99:                                     }
100:                                 })
101:                                 .overlay(
102:                                     Group {
103:                                         if model.willCapturePhoto {
104:                                             Color.black
105:                                         }
106:                                     }
107:                                 )
108:                                 .animation(.easeInOut, value: model.willCapturePhoto)
109:                             
110:                             
111:                             HStack {
112:                                 Spacer().frame(width: 60)
113:                                 
114:                                 Spacer()
115:                                 
116:                                 captureButton
117:                                 
118:                                 Spacer()
119:                                 
120:                                 flipCameraButton
121:                                 
122:                             }
123:                             .padding(.horizontal, 20)
124:                         }
125:                     }
126:                 }
127:                 self.getCloseButton(color: .white, onClose: { self.dismiss() })
128:             }
129:         }
130:     }
131: }
132: 
133: extension CameraError {
134:     var title: String {
135:         switch self {
136:         case .permissionDenied: return "No Permission"
137:         case .cameraUnavailable: return "Camera unavailable"
138:         }
139:     }
140:     
141:     var message: String {
142:         switch self {
143:         case .permissionDenied: return "You have denied permission to access the camera of your device. Please go to your phone Settings to change your camera permission to be able to take pictures of your documents."
144:         case .cameraUnavailable: return "Unable to access camera"
145:         }
146:     }
147:     
148:     var dismissText: String {
149:         switch self {
150:         case .permissionDenied: return "Cancel"
151:         case .cameraUnavailable: return "OK"
152:         }
153:     }
154:     
155:     var confirmText: String? {
156:         switch self {
157:         case .permissionDenied: return "Settings"
158:         case .cameraUnavailable: return nil
159:         }
160:     }
161:     
162:     var confirmAction: (() -> ())? {
163:         switch self {
164:         case .permissionDenied: return {
165:             if let appSettingsUrl = URL(string: UIApplication.openSettingsURLString) {
166:             UIApplication.shared.open(appSettingsUrl,
167:                                           options: [:],
168:                                           completionHandler: nil)
169:                                       }
170:         }
171:         case .cameraUnavailable: return nil
172:         }
173:     }
174: }
175: 
176: struct CameraView_Previews: PreviewProvider {
177:     static var previews: some View {
178:         CameraView(model: CameraViewModel(onImageCaptured: { _ in }))
179:     }
180: }
```

## File: pdfexpert/Views/ChatPdf/ChatPdfSelectionView.swift
```swift
  1: //
  2: //  ChatPdfSelectionView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 19/07/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct ChatPdfSelectionView: View {
 12:     
 13:     @InjectedObject(\.chatPdfSelectionViewModel) var viewModel
 14:     
 15:     var body: some View {
 16:         VStack {
 17:             Spacer()
 18:             Text("Our PDF AI summarize and answer questions for free. Drop your PDF here.")
 19:                 .font(forCategory: .body2)
 20:                 .foregroundColor(ColorPalette.primaryText)
 21:                 .multilineTextAlignment(.center)
 22:                 .padding([.leading, .trailing], 32)
 23:             Spacer().frame(height: 60)
 24:             self.buttonView
 25:             Spacer().frame(height: 50)
 26:             self.warningView
 27:                 .padding([.leading, .trailing], 32)
 28:             Spacer()
 29:         }
 30:         .ignoresSafeArea(.keyboard)
 31:         .background(ColorPalette.primaryBG)
 32:         .onAppear() {
 33:             self.viewModel.onAppear()
 34:         }
 35:         .formSheet(item: self.$viewModel.importOptionGroup) {
 36:             OptionListView.getImportView(forImportOptionGroup: $0,
 37:                                          importViewCallback: { self.viewModel.handleImportOption(importOption: $0) })
 38:         }
 39:         .filePicker(item: self.$viewModel.importFileOption, onPickedFiles: {
 40:             self.viewModel.processPickedFileUrl($0.first)
 41:         })
 42:         .fullScreenCover(isPresented: self.$viewModel.scannerShow) {
 43:             // Scanner
 44:             ScannerView(onScannerResult: {
 45:                 self.viewModel.convertScan(scannerResult: $0)
 46:             })
 47:         }
 48:         .fullScreenCover(item: self.$viewModel.chatPdfInitParams) { chatPdfInitParams in
 49:             let parameters = ChatPdfViewModel.Parameters(chatPdfInitParams: chatPdfInitParams)
 50:             ChatPdfView(viewModel: Container.shared.chatPdfViewModel(parameters))
 51:         }
 52:         .fullScreenCover(isPresented: self.$viewModel.monetizationShow) {
 53:             self.getSubscriptionView(onComplete: {
 54:                 self.viewModel.monetizationShow = false
 55:             })
 56:         }
 57:         .asyncView(asyncOperation: self.$viewModel.asyncImportPdf,
 58:                    loadingView: { AnimationType.pdf.view })
 59:         .asyncView(asyncOperation: self.$viewModel.asyncChatPdfSetup)
 60:         .showUnlockView(viewModel: self.viewModel.pdfUnlockViewModel)
 61:         .alertCameraPermission(isPresented: self.$viewModel.cameraPermissionDeniedShow)
 62:     }
 63:     
 64:     @ViewBuilder var buttonView: some View {
 65:         Button(action: self.viewModel.getPdfButtonPressed) {
 66:             GeometryReader { geometryReader in
 67:                 Group {
 68:                     Image(systemName: "arrow.up.circle.fill")
 69:                         .resizable()
 70:                         .aspectRatio(1, contentMode: .fit)
 71:                         .frame(width: 48)
 72:                         .foregroundColor(ColorPalette.secondaryText)
 73:                 }
 74:                 .frame(width: geometryReader.size.width * 0.7, height: geometryReader.size.height)
 75:                 .overlay(RoundedRectangle(cornerRadius: 8)
 76:                     .strokeBorder(style: StrokeStyle(lineWidth: 2, dash: [10]))
 77:                     .foregroundColor(ColorPalette.primaryText))
 78:                 .position(x: geometryReader.size.width/2, y: geometryReader.size.height/2)
 79:                 .contentShape(RoundedRectangle(cornerRadius: 8))
 80:             }
 81:         }
 82:         .frame(height: 130)
 83:     }
 84:     
 85:     @ViewBuilder var warningView: some View {
 86:         HStack(spacing: 8) {
 87:             Image(systemName: "exclamationmark.circle")
 88:                 .resizable()
 89:                 .aspectRatio(1, contentMode: .fit)
 90:                 .frame(width: 18)
 91:                 
 92:                 .foregroundColor(ColorPalette.thirdText)
 93:             Text("PDF are limited to 32MB per file\nand are limited to 2000 pages")
 94:                 .font(forCategory: .caption1)
 95:                 .foregroundColor(ColorPalette.thirdText)
 96:                 .minimumScaleFactor(0.5)
 97:         }
 98:     }
 99: }
100: 
101: struct ChatPdfSelectionView_Previews: PreviewProvider {
102:     static var previews: some View {
103:         ChatPdfSelectionView()
104:     }
105: }
```

## File: pdfexpert/Views/ChatPdf/ChatPdfView.swift
```swift
  1: //
  2: //  ChatPdfView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 19/07/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct ChatPdfView: View {
 12:     
 13:     @StateObject var viewModel: ChatPdfViewModel
 14:     
 15:     @State var typingMessage: String = ""
 16:     @Namespace var bottomID
 17:     
 18:     @Environment(\.dismiss) var dismiss
 19:     
 20:     var body: some View {
 21:         NavigationStack {
 22:             VStack(alignment: .leading){
 23:                 if !self.viewModel.messages.isEmpty {
 24:                     ScrollViewReader { reader in
 25:                         ScrollView(.vertical) {
 26:                             ForEach(self.viewModel.messages.indices, id: \.self){ index in
 27:                                 let message = self.viewModel.messages[index]
 28:                                 MessageView(message: message,
 29:                                             onSuggestedQuestionTapped: {
 30:                                     self.viewModel.getResponse(text: $0)
 31:                                 })
 32:                             }
 33:                             Text("").id(self.bottomID)
 34:                         }
 35:                         .onAppear{
 36:                             if self.isScrollToAvailable {
 37:                                 withAnimation{
 38:                                     reader.scrollTo(self.bottomID)
 39:                                 }
 40:                             }
 41:                         }
 42:                         .onChange(of: self.viewModel.messages.count){ _ in
 43:                             if self.isScrollToAvailable {
 44:                                 withAnimation{
 45:                                     reader.scrollTo(self.bottomID)
 46:                                 }
 47:                             }
 48:                         }
 49:                     }
 50:                 } else {
 51:                     VStack{
 52:                         Image(systemName: "ellipses.bubble")
 53:                             .font(forCategory: .largeTitle)
 54:                         Text("Write your first message!")
 55:                             .font(forCategory: .body2)
 56:                             .foregroundColor(ColorPalette.primaryText)
 57:                             .padding(10)
 58:                     }
 59:                     .frame(maxWidth: .infinity, maxHeight: .infinity)
 60:                 }
 61:                 
 62:                 HStack(alignment: .center){
 63:                     TextField("Type your Message...", text: self.$typingMessage, axis: .vertical)
 64:                         .padding()
 65:                         .font(forCategory: .body2)
 66:                         .foregroundColor(ColorPalette.primaryText)
 67:                         .lineLimit(3)
 68:                         .disableAutocorrection(true)
 69:                         .autocapitalization(.none)
 70:                     Button {
 71:                         if self.typingMessage != "" {
 72:                             self.viewModel.getResponse(text: self.typingMessage)
 73:                             self.typingMessage = ""
 74:                         }
 75:                     } label: {
 76:                         Image(systemName: self.typingMessage == "" ? "circle" : "paperplane.fill")
 77:                             .resizable()
 78:                             .scaledToFit()
 79:                             .foregroundColor(self.typingMessage == "" ? .white.opacity(0.75) : .white)
 80:                             .frame(width: 20, height: 20)
 81:                             .padding()
 82:                     }
 83:                 }
 84:                 .onDisappear {
 85:                     UIApplication.dismissKeyboard()
 86:                 }
 87:                 .background(ColorPalette.secondaryBG)
 88:                 .cornerRadius(12)
 89:                 .padding([.leading, .trailing, .bottom], 10)
 90:                 .shadow(color: .black, radius: 0.5)
 91:             }
 92:             .background(ColorPalette.primaryBG)
 93:             .navigationBarTitleDisplayMode(.inline)
 94:             .navigationTitle("Chat")
 95:             .addSystemCloseButton(color: ColorPalette.primaryText, onPress: { self.dismiss() })
 96:             .onAppear() {
 97:                 self.viewModel.onAppear()
 98:             }
 99:             .onDisappear() {
100:                 self.viewModel.onDisappear()
101:             }
102:         }
103:         .background(ColorPalette.primaryBG)
104:     }
105: }
106: 
107: struct ChatPdfView_Previews: PreviewProvider {
108:     
109:     private static let testRef = ChatPdfRef(sourceId: "test_source_id")
110:     private static let testSummary = "Welcome Message"
111:     private static let testSuggestedQuestions = [
112:         "How many pages this file has?",
113:         "Which color is more predominant?",
114:         "Who is the author?",
115:     ]
116:     private static let testSetupData = ChatPdfSetupData(summary: testSummary,
117:                                                         suggestedQuestions: testSuggestedQuestions)
118:     private static let testInitParams = ChatPdfInitParams(chatPdfRef: testRef,
119:                                                                  setupData: testSetupData)
120:     private static let testParameters = ChatPdfViewModel.Parameters(chatPdfInitParams: testInitParams)
121:     
122:     static var previews: some View {
123:         let _ = Container.shared.chatPdfManager.register { ChatPdfManagerMock() }
124:         ChatPdfView(viewModel: Container.shared.chatPdfViewModel(self.testParameters))
125:     }
126: }
```

## File: pdfexpert/Views/ChatPdf/MessageIndicatorView.swift
```swift
 1: //
 2: //  MessageIndicatorView.swift
 3: //  OpenAI GPT-DALL-E
 4: //
 5: //  Created by kz on 06/02/2023.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct MessageIndicatorView: View {
11:     var body: some View {
12:         HStack {
13:             DotView()
14:             DotView(delay: 0.2)
15:             DotView(delay: 0.4)
16:         }
17:         .padding(12)
18:         .background(Color.gray.opacity(0.25))
19:         .cornerRadius(25)
20:     }
21: }
22: 
23: struct DotView: View {
24: 
25:     @State var scale: CGFloat = 0.5
26:     @State var delay: Double = 0
27:     var body: some View {
28:         Circle()
29:             .frame(width: 7, height: 7)
30:             .scaleEffect(self.scale)
31:             .onAppear {
32:                 withAnimation(Animation.easeInOut.repeatForever().delay(self.delay)) {
33:                     self.scale = 1
34:                 }
35:             }
36:     }
37: }
38: 
39: struct MessageIndicatorView_Previews: PreviewProvider {
40:     static var previews: some View {
41:         MessageIndicatorView()
42:     }
43: }
```

## File: pdfexpert/Views/ChatPdf/MessageView.swift
```swift
  1: //
  2: //  MessageView.swift
  3: //  ChattingAPP
  4: //
  5: //  Created by kz on 02/02/2023.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct MessageView: View {
 12:     
 13:     let message: ChatPdfMessage
 14:     let onSuggestedQuestionTapped: ((String) -> ())
 15:     
 16:     var body: some View {
 17:         HStack(spacing: 0) {
 18:             VStack(alignment: .leading, spacing: 0) {
 19:                 HStack(alignment: self.message.alignment){
 20:                     switch self.message.type {
 21:                     case .text:
 22:                         let output = self.message.content.trimmingCharacters(in: .whitespacesAndNewlines)
 23:                         Text(output)
 24:                             .frame(maxWidth: .infinity, alignment: .leading)
 25:                             .foregroundColor(self.message.textColor)
 26:                             .font(forCategory: .caption1)
 27:                     case .indicator:
 28:                         MessageIndicatorView()
 29:                     }
 30:                 }
 31:                 if self.message.suggestedQuestions.count > 0 {
 32:                     Spacer().frame(height: 16)
 33:                     Text("Suggested questions:")
 34:                         .frame(maxWidth: .infinity, alignment: .leading)
 35:                         .foregroundColor(self.message.textColor)
 36:                         .font(forCategory: .caption1)
 37:                     Spacer().frame(height: 16)
 38:                     ForEach(self.message.suggestedQuestions, id:\.self) { suggestedQuestion in
 39:                         Text(suggestedQuestion)
 40:                             .frame(maxWidth: .infinity, alignment: .leading)
 41:                             .foregroundColor(ColorPalette.secondaryText)
 42:                             .font(FontCategory.caption1.font.bold())
 43:                             .onTapGesture {
 44:                                 self.onSuggestedQuestionTapped(suggestedQuestion)
 45:                             }
 46:                         Spacer().frame(height: 16)
 47:                     }
 48:                 }
 49:             }
 50:             .padding([.top, .bottom])
 51:             .padding([.leading, .trailing], 16)
 52:             Spacer()
 53:         }
 54:         .background(RoundedCorner(radius: 16, corners: self.message.roundedCorners)
 55:             .fill(self.message.backgroundColor))
 56:         .shadow(radius: self.message.shadowRadius)
 57:         .padding([.leading], self.message.paddingLeading)
 58:         .padding([.trailing], self.message.paddingTrailing)
 59:     }
 60: }
 61: 
 62: fileprivate extension ChatPdfMessage {
 63:     
 64:     var backgroundColor: Color {
 65:         switch self.role {
 66:         case .user: return ColorPalette.secondaryText
 67:         case .assistant: return ColorPalette.primaryText
 68:         }
 69:     }
 70:     
 71:     var textColor: Color {
 72:         switch self.role {
 73:         case .user: return ColorPalette.primaryText
 74:         case .assistant: return ColorPalette.primaryBG
 75:         }
 76:     }
 77:     
 78:     var shadowRadius: CGFloat {
 79:         switch self.role {
 80:         case .user: return 0.0
 81:         case .assistant: return 0.5
 82:         }
 83:     }
 84:     
 85:     var alignment: VerticalAlignment {
 86:         switch self.role {
 87:         case .user: return .center
 88:         case .assistant: return .top
 89:         }
 90:     }
 91:     
 92:     var paddingLeading: CGFloat {
 93:         switch self.role {
 94:         case .user: return 60
 95:         case .assistant: return 16
 96:         }
 97:     }
 98:     
 99:     var paddingTrailing: CGFloat {
100:         switch self.role {
101:         case .user: return 16
102:         case .assistant: return 60
103:         }
104:     }
105:     
106:     var roundedCorners: UIRectCorner {
107:         switch self.role {
108:         case .user: return [.bottomLeft, .bottomRight, .topLeft]
109:         case .assistant: return [.bottomLeft, .bottomRight, .topRight]
110:         }
111:     }
112: }
113: 
114: struct MessageView_Previews: PreviewProvider {
115:     
116:     static var previews: some View {
117:         ScrollView {
118:             VStack {
119:                 MessageView(
120:                     message: ChatPdfMessage(role: .assistant, type: .text, content: "This text explains in detail the meaning of life, without ambiguities, questionable assumptions or subjective points of view of any kind. The author also warns the reader that fully reading this text will cause an invitable transcendence to a new state of existence, and thus doing so only if truly prepared.", suggestedQuestions: [
121:                         "Can you give me a hint about the meaning of life, while avoiding transcendence?",
122:                         "Can I use the meaning of life for commercial purposes?",
123:                         "Who is the author?"
124:                     ]),
125:                     onSuggestedQuestionTapped: { print("Suggested question: '\($0)'") }
126:                 )
127:                 .padding()
128:                 .previewDisplayName("Introductory Message")
129:                 MessageView(
130:                     message: ChatPdfMessage(role: .user, type: .text, content: "Test Message"),
131:                     onSuggestedQuestionTapped: { print("Suggested question: '\($0)'") }
132:                 )
133:                 .padding()
134:                 .previewDisplayName("User Message")
135:                 MessageView(
136:                     message: ChatPdfMessage(role: .assistant, type: .text, content: "Test Message"),
137:                     onSuggestedQuestionTapped: { print("Suggested question: '\($0)'") }
138:                 )
139:                 .padding()
140:                 .previewDisplayName("Chat Bot Message")
141:                 MessageView(
142:                     message: ChatPdfMessage(role: .assistant, type: .text, content: "I guess you guys aren't ready for that, yet. But your kids are gonna love it"),
143:                     onSuggestedQuestionTapped: { print("Suggested question: '\($0)'") }
144:                 )
145:                 .padding()
146:                 MessageView(
147:                     message: ChatPdfMessage(role: .assistant, type: .text, content: "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam eaque ipsa, quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt, explicabo. Nemo enim ipsam voluptatem, quia voluptas sit, aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos, qui ratione voluptatem sequi nesciunt, neque porro quisquam est, qui dolorem ipsum, quia dolor sit, amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt, ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur?"),
148:                     onSuggestedQuestionTapped: { print("Suggested question: '\($0)'") }
149:                 )
150:                 .padding()
151:             }
152:             .previewLayout(PreviewLayout.fixed(width: 500, height: 1500))
153:         }
154:     }
155: }
```

## File: pdfexpert/Views/Common/AddPasswordView.swift
```swift
 1: //
 2: //  AddPasswordView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 26/07/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: typealias AddPasswordCallback = (String) -> ()
11: 
12: struct AddPasswordView: ViewModifier {
13:     
14:     @Binding var show: Bool
15:     
16:     @State var passwordText: String = ""
17:     
18:     let addPasswordCallback: AddPasswordCallback
19: 
20:     func body(content: Content) -> some View {
21:         content
22:             .alert("Protect PDF using password", isPresented: self.$show, actions: {
23:             SecureField("Enter Password", text: self.$passwordText)
24:             Button("Confirm", action: {
25:                 self.addPasswordCallback(self.passwordText)
26:                 self.passwordText = ""
27:             })
28:             Button("Cancel", role: .cancel, action: {})
29:         }, message: {
30:             Text("Enter a password to protect your PDF file.")
31:         })
32:     }
33: }
34: 
35: extension View {
36:     func addPasswordView(show: Binding<Bool>,
37:                          addPasswordCallback: @escaping AddPasswordCallback) -> some View {
38:         modifier(AddPasswordView(show: show, addPasswordCallback: addPasswordCallback))
39:     }
40: }
41: 
42: struct AddPasswordView_Previews: PreviewProvider {
43:     static var previews: some View {
44:         Color(.white)
45:             .addPasswordView(show: .constant(true),
46:                              addPasswordCallback: { print("Add Password completed: \($0)") })
47:     }
48: }
```

## File: pdfexpert/Views/Common/CameraImageProviderFlowView.swift
```swift
 1: //
 2: //  CameraImageProviderFlowView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 06/09/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct CameraImageProviderFlowView: ViewModifier {
12:     
13:     @ObservedObject var flow: CameraImageProviderFlow
14: 
15:     func body(content: Content) -> some View {
16:         content
17:             .fullScreenCover(isPresented: self.$flow.cameraShow) {
18:                 CameraView(model: Container.shared.cameraViewModel({ uiImage in
19:                     self.flow.onPhotoCaptured(image: uiImage)
20:                 }))
21:             }
22:     }
23: }
24: 
25: extension View {
26:     func cameraImageProviderView(flow: CameraImageProviderFlow) -> some View {
27:         self.modifier(CameraImageProviderFlowView(flow: flow))
28:     }
29: }
```

## File: pdfexpert/Views/Common/GalleryImageProviderFlowView.swift
```swift
 1: //
 2: //  GalleryImageProviderFlowView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 06/09/23.
 6: //
 7: 
 8: import SwiftUI
 9: import PhotosUI
10: 
11: struct GalleryImageProviderFlowView: ViewModifier {
12:     
13:     @ObservedObject var flow: GalleryImageProviderFlow
14: 
15:     func body(content: Content) -> some View {
16:         content
17:             .photosPicker(isPresented: self.$flow.imagePickerShow,
18:                           selection: self.$flow.imageSelection,
19:                           matching: .images)
20:             .asyncFailableView(asyncItem: self.$flow.asyncImageLoading)
21:     }
22: }
23: 
24: extension View {
25:     func galleryImageProviderView(flow: GalleryImageProviderFlow) -> some View {
26:         self.modifier(GalleryImageProviderFlowView(flow: flow))
27:     }
28: }
```

## File: pdfexpert/Views/Common/ImageCropFlowView.swift
```swift
 1: //
 2: //  ImageCropFlowView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 06/09/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Mantis
10: 
11: struct ImageCropFlowView: ViewModifier {
12:     
13:     @ObservedObject var flow: ImageCropFlow
14: 
15:     func body(content: Content) -> some View {
16:         content
17:             .fullScreenCover(isPresented: self.$flow.cropperShow) {
18:                 ImageCropper(image: self.$flow.image,
19:                              cropShapeType: self.$flow.cropShapeType,
20:                              presetFixedRatioType: self.$flow.presetFixedRatioType,
21:                              type: self.$flow.type)
22:                 .onDisappear(perform: self.flow.onCropViewDismiss)
23:                 .ignoresSafeArea()
24:             }
25:     }
26: }
27: 
28: extension View {
29:     func imageCropView(flow: ImageCropFlow) -> some View {
30:         self.modifier(ImageCropFlowView(flow: flow))
31:     }
32: }
```

## File: pdfexpert/Views/Common/ImportOption.swift
```swift
 1: //
 2: //  ImportOption.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 19/07/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: 
11: enum ImportOption: Hashable, Identifiable {
12:     
13:     var id: Self { return self }
14:     
15:     case camera
16:     case gallery
17:     case scan
18:     case file(fileSource: FileSource)
19: }
20: 
21: enum ImportOptionGroup: Hashable, Identifiable {
22:     
23:     var id: Self { return self }
24:     
25:     case image
26:     case fileAndScan
27:     
28:     var options: [ImportOption] {
29:         switch self {
30:         case .image: return [.camera, .gallery, .file(fileSource: .files)]
31:         case .fileAndScan: return [.file(fileSource: .files), .scan]
32:         }
33:     }
34: }
35: 
36: extension OptionListView {
37:     
38:     @ViewBuilder static func getImportView(forImportOptionGroup importOptionGroup: ImportOptionGroup,
39:                                            importViewCallback: @escaping (ImportOption) -> ()) -> some View {
40:         OptionListView(title: "Import from", items: importOptionGroup.options.map { importOption in
41:             let callback = { importViewCallback(importOption) }
42:             switch importOption {
43:             case .camera:
44:                 return OptionItem(title: "Camera",
45:                                   imageName: "camera",
46:                                   callBack: callback)
47:             case .gallery:
48:                 return OptionItem(title: "Gallery",
49:                                   imageName: "gallery",
50:                                   callBack: callback)
51:             case .scan:
52:                 return OptionItem(title: "Scan a file",
53:                            imageName: "scan",
54:                            callBack: callback)
55:             case .file(let fileSource):
56:                 switch fileSource {
57:                 case .google:
58:                     return OptionItem(title: "Google Drive",
59:                                imageName: "home_file_source_google",
60:                                callBack: callback)
61:                 case .dropbox:
62:                     return OptionItem(title: "Dropbox",
63:                                imageName: "home_file_source_dropbox",
64:                                callBack: callback)
65:                 case .icloud:
66:                     return OptionItem(title: "iCloud",
67:                                imageName: "home_file_source_icloud",
68:                                callBack: callback)
69:                 case .files:
70:                     return OptionItem(title: "Files",
71:                                imageName: "home_file_source_files",
72:                                callBack: callback)
73:                 }
74:             }
75:         })
76:     }
77: }
```

## File: pdfexpert/Views/Common/OptionItemView.swift
```swift
 1: //
 2: //  OptionItemView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 29/03/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct OptionItemView: View {
11:     
12:     let title: String
13:     let imageName: String
14:     let onPressed: () -> ()
15:     
16:     var body: some View {
17:         Button(action: { self.onPressed() }) {
18:             HStack(spacing: 16) {
19:                 Image(self.imageName)
20:                     .resizable()
21:                     .aspectRatio(contentMode: .fit)
22:                     .frame(width: 20, height: 20)
23:                 Text(self.title)
24:                     .font(forCategory: .headline)
25:                     .foregroundColor(ColorPalette.primaryText)
26:                     .frame(maxWidth: .infinity, alignment: .leading)
27:             }
28:             .padding(.leading, 16)
29:             .padding(.trailing, 16)
30:         }
31:         .frame(height: 48)
32:         .frame(maxWidth: .infinity)
33:         .overlay(RoundedRectangle(cornerRadius: 8).stroke(ColorPalette.thirdText, lineWidth: 1))
34:     }
35: }
36: 
37: struct OptionItemView_Previews: PreviewProvider {
38:     static var previews: some View {
39:         OptionItemView(title: "File", imageName: "edit_option_password_unlock", onPressed: {})
40:     }
41: }
```

## File: pdfexpert/Views/Common/OptionListView.swift
```swift
 1: //
 2: //  OptionListView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 29/03/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct OptionItem {
11:     let title: String
12:     let imageName: String
13:     let callBack: () -> ()
14: }
15: 
16: struct OptionListView: View {
17:     
18:     let title: String
19:     let items: [OptionItem]
20:     
21:     var body: some View {
22:         VStack {
23:             Text(self.title)
24:                 .frame(maxWidth: .infinity, alignment: .leading)
25:                 .font(forCategory: .headline)
26:                 .foregroundColor(ColorPalette.primaryText)
27:             Spacer(minLength: 20)
28:             ForEach(self.items, id: \.title) { item in
29:                 OptionItemView(title: item.title, imageName: item.imageName, onPressed: item.callBack)
30:                 Spacer().frame(height: 10)
31:             }
32:         }
33:         .padding(EdgeInsets(top: 44, leading: 16, bottom: 32, trailing: 16))
34:         .background(ColorPalette.secondaryBG)
35:         .cornerRadius(20, corners: [.topLeft, .topRight])
36:     }
37: }
38: 
39: struct OptionListView_Previews: PreviewProvider {
40:     
41:     static let items = [
42:         OptionItem(title: "File", imageName: "file", callBack: {}),
43:         OptionItem(title: "Gallery", imageName: "gallery", callBack: {}),
44:         OptionItem(title: "Camera", imageName: "camera", callBack: {}),
45:     ]
46:     
47:     static var previews: some View {
48:         OptionListView(title: "Import from", items: items)
49:     }
50: }
```

## File: pdfexpert/Views/Common/PdfImageViewerView.swift
```swift
 1: //
 2: //  PdfImageViewerView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 23/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct PdfImage {
12:     let image: UIImage?
13:     let caption: String
14: }
15: 
16: struct PdfImageViewerView: View {
17:     
18:     let pageIndex: Int
19:     let images: [PdfImage]
20:     
21:     @State var imageIndex: Int = 0
22:     
23:     @Environment(\.dismiss) var dismiss
24:     
25:     @Injected(\.analyticsManager) private var analyticsManager
26:     
27:     var body: some View {
28:         NavigationStack {
29:             VStack(spacing: 16) {
30:                 if self.images.count > 0 {
31:                     TabView(selection: self.$imageIndex) {
32:                         ForEach(Array(self.images.enumerated()), id:\.offset) { _, image in
33:                             VStack(spacing: 16) {
34:                                 if let uiImage = image.image {
35:                                     GeometryReader { proxy in
36:                                         Image(uiImage: uiImage)
37:                                             .resizable()
38:                                             .scaledToFit()
39:                                             .frame(width: proxy.size.width, height: proxy.size.height)
40:                                             .clipShape(Rectangle())
41:                                             .modifier(ZoomImageModifier(contentSize: CGSize(width: proxy.size.width, height: proxy.size.height)))
42:                                     }
43:                                 } else {
44:                                     Spacer()
45:                                     Text("Couldn't extract this image")
46:                                         .font(forCategory: .body1)
47:                                         .foregroundColor(ColorPalette.primaryText)
48:                                     Spacer()
49:                                 }
50:                                 Text(image.caption)
51:                                     .font(forCategory: .body1)
52:                                     .foregroundColor(ColorPalette.primaryText)
53:                                     .frame(height: 100)
54:                             }
55:                         }
56:                     }
57:                     .tabViewStyle(.page(indexDisplayMode: .never))
58:                     .background(ColorPalette.primaryBG)
59:                     self.pageCounter(currentPageIndex: self.imageIndex,
60:                                      totalPages: self.images.count)
61:                 } else {
62:                     Spacer()
63:                     Text("There are no images on this page")
64:                         .font(forCategory: .body1)
65:                         .foregroundColor(ColorPalette.primaryText)
66:                         .frame(maxWidth: .infinity)
67:                     Spacer()
68:                 }
69:             }
70:             .padding(16)
71:             .background(ColorPalette.primaryBG)
72:             .navigationBarTitleDisplayMode(.inline)
73:             .navigationTitle("Page \(self.pageIndex + 1)")
74:             .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
75:                 self.dismiss()
76:             })
77:         }
78:         .background(ColorPalette.primaryBG)
79:         .onAppear {
80:             self.analyticsManager.track(event: .reportScreen(.pageSelection))
81:         }
82:     }
83: }
84: 
85: struct PdfImageViewerView_Previews: PreviewProvider {
86:     static var previews: some View {
87:         PdfImageViewerView(pageIndex: 0, images: [
88:             PdfImage(image: UIImage(named: "onboarding_chat_pdf"), caption: "onboarding chat pdf"),
89:             PdfImage(image: nil, caption: "onboarding chat pdf"),
90:             PdfImage(image: UIImage(named: "onboarding_convert"), caption: "onboarding convert"),
91:             PdfImage(image: UIImage(named: "onboarding_password"), caption: "onboarding password"),
92:             PdfImage(image: UIImage(named: "onboarding_signature"), caption: "onboarding signature"),
93:         ])
94:         .previewDisplayName("Standard")
95:         PdfImageViewerView(pageIndex: 0, images: [])
96:             .previewDisplayName("Empty")
97:     }
98: }
```

## File: pdfexpert/Views/Common/PdfImportMultipleView.swift
```swift
 1: //
 2: //  PdfImportMultipleView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct PdfImportMultipleView: ViewModifier {
12:     
13:     @ObservedObject var viewModel: PdfImportMultipleViewModel
14: 
15:     func body(content: Content) -> some View {
16:         content
17:             .filePicker(isPresented: self.$viewModel.showFilePicker,
18:                         fileTypes: self.viewModel.importFileTypes,
19:                         multipleSelection: true,
20:                         onPickedFiles: {
21:                 self.viewModel.processSelectedUrls($0)
22:             })
23:             .showUnlockView(viewModel: self.viewModel.pdfUnlockViewModel)
24:             .loadingView(show: self.$viewModel.loading)
25:     }
26: }
27: 
28: extension View {
29:     func showImportMultipleView(viewModel: PdfImportMultipleViewModel) -> some View {
30:         modifier(PdfImportMultipleView(viewModel: viewModel))
31:     }
32: }
33: 
34: struct PdfImportMultipleView_Previews: PreviewProvider {
35:     
36:     static let asyncPdfs: AsyncOperation<[Pdf], PdfError> = .init(status: .empty)
37:     static let viewModel = Container.shared
38:         .pdfImportMultipleViewModel(.init(asyncPdfs: .constant(Self.asyncPdfs)))
39:     
40:     static var previews: some View {
41:         Color(.white)
42:             .showImportMultipleView(viewModel: Self.viewModel)
43:     }
44: }
```

## File: pdfexpert/Views/Common/PdfImportView.swift
```swift
 1: //
 2: //  PdfImportView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct PdfImportView: ViewModifier {
12:     
13:     @ObservedObject var viewModel: PdfImportViewModel
14: 
15:     func body(content: Content) -> some View {
16:         content
17:             .filePicker(isPresented: self.$viewModel.showFilePicker,
18:                         fileTypes: self.viewModel.importFileTypes,
19:                         multipleSelection: false,
20:                         onPickedFiles: {
21:                 self.viewModel.processSelectedUrls($0)
22:             })
23:             .showUnlockView(viewModel: self.viewModel.pdfUnlockViewModel)
24:             .loadingView(show: self.$viewModel.loading)
25:     }
26: }
27: 
28: extension View {
29:     func showImportView(viewModel: PdfImportViewModel) -> some View {
30:         modifier(PdfImportView(viewModel: viewModel))
31:     }
32: }
33: 
34: struct PdfImportView_Previews: PreviewProvider {
35:     
36:     static let asyncPdf: AsyncOperation<Pdf, PdfError> = .init(status: .empty)
37:     static let viewModel = Container.shared
38:         .pdfImportViewModel(.init(asyncPdf: .constant(Self.asyncPdf)))
39:     
40:     static var previews: some View {
41:         Color(.white)
42:             .showImportView(viewModel: Self.viewModel)
43:     }
44: }
```

## File: pdfexpert/Views/Common/PdfMergeView.swift
```swift
 1: //
 2: //  PdfMergeView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 02/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct PdfMergeView: ViewModifier {
12:     
13:     @ObservedObject var viewModel: PdfMergeViewModel
14: 
15:     func body(content: Content) -> some View {
16:         content
17:             .showImportMultipleView(viewModel: self.viewModel.pdfImportMultipleViewModel)
18:             .loadingView(show: self.$viewModel.loading)
19:             .asyncView(asyncOperation: self.$viewModel.asyncImportedPdfs)
20:             .showSortView(isPresented: self.$viewModel.showPdfSorter,
21:                           onDismiss: { self.viewModel.onSortedCompleted() },
22:                           params: PdfSortViewModel.Params(
23:                             pdfs: self.$viewModel.toBeSortedPdfs,
24:                             confirmButtonText: "Merge PDF",
25:                             confirmCallback: {
26:                                 self.viewModel.onSortedConfirmed()
27:                             },
28:                             cancelCallback: {
29:                                 self.viewModel.onSortedCancelled()
30:                             }))
31:     }
32: }
33: 
34: extension View {
35:     func showMergeView(viewModel: PdfMergeViewModel) -> some View {
36:         modifier(PdfMergeView(viewModel: viewModel))
37:     }
38: }
39: 
40: struct PdfMergeView_Previews: PreviewProvider {
41:     
42:     static let asyncPdf: AsyncOperation<Pdf, PdfError> = .init(status: .empty)
43:     static let viewModel = Container.shared
44:         .pdfMergeViewModel(.init(asyncPdf: .constant(Self.asyncPdf)))
45:     
46:     static var previews: some View {
47:         Color(.white)
48:             .showMergeView(viewModel: Self.viewModel)
49:     }
50: }
```

## File: pdfexpert/Views/Common/PdfPageRangeEditorView.swift
```swift
  1: //
  2: //  PdfPageRangeEditorView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 04/08/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct PdfPageRangeEditorView: View {
 12:     
 13:     @ObservedObject var viewModel: PdfPageRangeEditorViewModel
 14:     
 15:     @Injected(\.analyticsManager) private var analyticsManager
 16:     
 17:     @FocusState private var pdfPageRangeInFocus: PdfPageRangeFocusable?
 18:     
 19:     @Namespace var bottomID
 20:     
 21:     @State var previousNumberOfRanges: Int = 0
 22:     
 23:     var body: some View {
 24:         NavigationStack {
 25:             ZStack {
 26:                 self.listView
 27:                 self.bottomView
 28:                     .ignoresSafeArea(.keyboard)
 29:             }
 30:             .padding(.top, 48)
 31:             .navigationBarTitleDisplayMode(.inline)
 32:             .navigationTitle("Split pages into ranges")
 33:             .background(ColorPalette.primaryBG)
 34:             .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
 35:                 self.viewModel.cancel()
 36:             })
 37:             .toolbar {
 38:                 ToolbarItemGroup(placement: .keyboard) {
 39:                     Spacer()
 40:                     Button(action: {
 41:                         self.viewModel.onConfirmRange()
 42:                     }) {
 43:                         Text("Done")
 44:                             .foregroundColor(ColorPalette.secondaryText)
 45:                             .bold()
 46:                     }
 47:                 }
 48:             }
 49:         }
 50:         .background(ColorPalette.primaryBG)
 51:         .onAppear {
 52:             self.analyticsManager.track(event: .reportScreen(.pageRangeEditor))
 53:         }
 54:         // The focus state in the viewmodel is the one in charge and allow field validation.
 55:         // The one in the view must by synced with it
 56:         .onChange(of: self.viewModel.pdfPageRangeInFocus) { self.pdfPageRangeInFocus = $0 }
 57:     }
 58:     
 59:     private var listView: some View {
 60:         ScrollViewReader { scrollViewProxy in
 61:             List {
 62:                 ForEach(Array(self.viewModel.pageRangeLowerBounds.enumerated()), id:\.offset) { index, item in
 63:                     self.getItemView(atIndex: index)
 64:                         .listRowBackground(ColorPalette.secondaryBG)
 65:                 }
 66:                 .onChange(of: self.viewModel.pageRangeLowerBounds.count) { newValue in
 67:                     if self.isScrollToAvailable, newValue > self.previousNumberOfRanges {
 68:                         withAnimation {
 69:                             scrollViewProxy.scrollTo(self.bottomID, anchor: .bottom)
 70:                         }
 71:                     }
 72:                     self.previousNumberOfRanges = newValue
 73:                 }
 74:                 HStack {
 75:                     Spacer()
 76:                     self.addRangeButton
 77:                 }
 78:                 .listRowBackground(ColorPalette.primaryBG)
 79:                 .listRowSeparator(.hidden)
 80:                 Spacer()
 81:                     .frame(height: 135)
 82:                     .listRowBackground(ColorPalette.primaryBG)
 83:                     .id(self.bottomID)
 84:             }
 85:             .safeAreaInset(edge: .bottom, content: {
 86:                 Spacer().frame(height: 8)
 87:             })
 88:             .scrollContentBackground(.hidden)
 89:         }
 90:     }
 91:     
 92:     private var bottomView: some View {
 93:         VStack(spacing: 0) {
 94:             Spacer()
 95:             VStack(spacing: 0) {
 96:                 self.getDefaultButton(text: "Split PDF", onButtonPressed: {
 97:                     self.viewModel.confirm()
 98:                 })
 99:                 .padding([.leading, .trailing], 16)
100:                 .padding(.bottom, 80)
101:                 .padding(.top, 16)
102:             }.background(ColorPalette.primaryBG)
103:         }
104:     }
105:     
106:     private var addRangeButton: some View {
107:         Button(action: {
108:             withAnimation {
109:                 self.viewModel.addRange()
110:             }
111:         }) {
112:             HStack(spacing: 10) {
113:                 Image(systemName: "plus.circle.fill")
114:                     .foregroundColor(ColorPalette.secondaryText)
115:                 Text("Add new range")
116:                     .font(forCategory: .body1)
117:                     .foregroundColor(ColorPalette.secondaryText)
118:                     .lineLimit(1)
119:             }
120:         }
121:     }
122:     
123:     private func getRangeHeader(atIndex index: Int) -> some View {
124:         HStack {
125:             Text("Range \(index + 1)")
126:                 .font(forCategory: .body1)
127:                 .foregroundColor(ColorPalette.primaryText)
128:             Spacer()
129:             if index > 0 {
130:                 Button(action: {
131:                     withAnimation {
132:                         self.viewModel.removeRange(atIndex: index)
133:                     }
134:                 }) {
135:                     Image(systemName: "trash.fill")
136:                         .foregroundColor(ColorPalette.thirdText)
137:                 }
138:             }
139:         }
140:     }
141:     
142:     private func getItemView(atIndex index: Int) -> some View {
143:         Section(header: self.getRangeHeader(atIndex: index)) {
144:             self.getBoundView(index: index, isLowerBound: true)
145:             self.getBoundView(index: index, isLowerBound: false)
146:         }
147:     }
148:     
149:     private func getBoundView(index: Int, isLowerBound: Bool) -> some View {
150:         ZStack {
151:             HStack {
152:                 Text(isLowerBound ? "From page number" : "To page number")
153:                     .font(forCategory: .callout)
154:                     .foregroundColor(ColorPalette.thirdText)
155:                     .frame(maxWidth: .infinity, alignment: .leading)
156:                     .lineLimit(1)
157:                 TextField("", text: self.viewModel.getTextFieldText(index: index,
158:                                                                     isLowerBound: isLowerBound))
159:                 .font(forCategory: .body2)
160:                 .foregroundColor(ColorPalette.primaryText)
161:                 .lineLimit(1)
162:                 .disableAutocorrection(true)
163:                 .autocapitalization(.none)
164:                 .fixedSize(horizontal: true, vertical: true)
165:                 .allowsHitTesting(false)
166:                 .focused(self.$pdfPageRangeInFocus,
167:                          equals: isLowerBound ? .lowerBound(index: index) : .upperBound(index: index))
168:                 .keyboardType(.numberPad)
169:             }
170:             Button("") {
171:                 self.viewModel.focus(index: index, isLowerBound: isLowerBound)
172:             }
173:             .frame(maxWidth: .infinity, maxHeight: .infinity)
174:         }
175:     }
176: }
177: 
178: extension View {
179:     func showPageRangeEditorView(isPresented: Binding<Bool>,
180:                                  onDismiss: (() -> Void)?,
181:                                  params: PdfPageRangeEditorViewModel.Params) -> some View {
182:         self.fullScreenCover(isPresented: isPresented, onDismiss: onDismiss) {
183:             let viewModel = Container.shared.pdfPageRangeEditorViewModel(params)
184:             PdfPageRangeEditorView(viewModel: viewModel)
185:         }
186:     }
187: }
188: 
189: struct PdfPageRangeEditorView_Previews: PreviewProvider {
190:     
191:     static let params = PdfPageRangeEditorViewModel.Params(
192:         pageRanges: .constant([0...1, 0...1]),
193:         totalPages: 10,
194:         confirmCallback: { print("Split confirmed!") },
195:         cancelCallback: { print("Split cancelled...") })
196:     
197:     static var previews: some View {
198:         Color(.white)
199:             .showPageRangeEditorView(isPresented: .constant(true),
200:                                      onDismiss: { print("Split completed.") },
201:                                      params: Self.params)
202:     }
203: }
```

## File: pdfexpert/Views/Common/PdfPageSelectionView.swift
```swift
  1: //
  2: //  PdfPageSelectionView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 21/08/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct PdfPageSelectionView: View {
 12:     
 13:     @Binding var pageIndex: Int
 14:     
 15:     let title: String
 16:     let pageThumbnails: [UIImage?]
 17:     
 18:     @Injected(\.analyticsManager) private var analyticsManager
 19:     
 20:     @Environment(\.dismiss) var dismiss
 21:     
 22:     var body: some View {
 23:         NavigationStack {
 24:             ScrollViewReader { reader in
 25:                 ScrollView {
 26:                     LazyVStack(spacing: 0) {
 27:                         ForEach(Array(self.pageThumbnails.enumerated()), id:\.offset) { index, pageThumbnail in
 28:                             Button(action: {
 29:                                 self.pageIndex = index
 30:                                 self.dismiss()
 31:                             }) {
 32:                                 HStack {
 33:                                     Text("\(index)")
 34:                                         .foregroundColor(ColorPalette.primaryText)
 35:                                         .font(forCategory: .body2)
 36:                                         .minimumScaleFactor(0.5)
 37:                                         .frame(width: 40, alignment: .leading)
 38:                                     self.getPdfPageThumbnail(fromImage: pageThumbnail)
 39:                                         .frame(width: 86)
 40:                                         .padding([.top, .bottom], 8)
 41:                                     Spacer()
 42:                                 }
 43:                                 .padding([.trailing, .leading], 16)
 44:                             }
 45:                             .frame(height: 94)
 46:                             .background(self.getPageBackgroundColor(forPageIndex: index))
 47:                             .id(index)
 48:                         }
 49:                     }
 50:                     .onAppear{
 51:                         if self.isScrollToAvailable {
 52:                             reader.scrollTo(self.pageIndex, anchor: .center)
 53:                         }
 54:                     }
 55:                 }
 56:                 .padding([.top, .bottom], 16)
 57:                 .background(ColorPalette.primaryBG)
 58:             }
 59:             .navigationBarTitleDisplayMode(.inline)
 60:             .navigationTitle(self.title)
 61:             .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
 62:                 self.dismiss()
 63:             })
 64:         }
 65:         .background(ColorPalette.primaryBG)
 66:         .onAppear {
 67:             self.analyticsManager.track(event: .reportScreen(.pageSelection))
 68:         }
 69:     }
 70:     
 71:     func getPageBackgroundColor(forPageIndex pageIndex: Int) -> Color {
 72:         if self.pageIndex == pageIndex {
 73:             return ColorPalette.secondaryBG
 74:         } else {
 75:             return .clear
 76:         }
 77:     }
 78:     
 79:     @ViewBuilder private func getPdfPageThumbnail(fromImage image: UIImage?) -> some View {
 80:         if let thumbnail = image {
 81:             Color.clear
 82:                 .overlay(Image(uiImage: thumbnail)
 83:                     .resizable()
 84:                     .scaledToFill())
 85:                 .clipShape(RoundedRectangle(cornerRadius: 10,
 86:                             style: .continuous))
 87:         } else {
 88:             ColorPalette.secondaryBG
 89:                 .cornerRadius(10)
 90:         }
 91:     }
 92: }
 93: 
 94: struct PdfPageSelectionView_Previews: PreviewProvider {
 95:     
 96:     static var previews: some View {
 97:         if let pdf = K.Test.DebugPdf {
 98:             let thumbnails = PDFUtility.generatePdfThumbnails(pdfDocument: pdf.pdfDocument,
 99:                                                               size: K.Misc.ThumbnailSize)
100:             PdfPageSelectionView(pageIndex: .constant(0),
101:                                  title: pdf.filename,
102:                                  pageThumbnails: thumbnails)
103:         }
104:     }
105: }
```

## File: pdfexpert/Views/Common/PdfReaderView.swift
```swift
  1: //
  2: //  PdfReaderView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 21/08/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct PdfReaderView: View {
 12:     
 13:     @Injected(\.analyticsManager) private var analyticsManager
 14:     
 15:     @Environment(\.dismiss) var dismiss
 16:     
 17:     @StateObject var viewModel: PdfReaderViewModel
 18:     
 19:     var body: some View {
 20:         NavigationStack {
 21:             self.contentView
 22:             .padding(16)
 23:             .background(ColorPalette.primaryBG)
 24:             .navigationBarTitleDisplayMode(.inline)
 25:             .navigationTitle(self.viewModel.filename)
 26:             .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
 27:                 self.dismiss()
 28:             })
 29:             .toolbar {
 30:                 ToolbarItemGroup(placement: .navigationBarTrailing) {
 31:                     self.toolbar
 32:                 }
 33:             }
 34:             .fullScreenCover(isPresented: self.$viewModel.showPageSelection) {
 35:                 PdfPageSelectionView(pageIndex: self.$viewModel.pageIndex,
 36:                                      title: self.viewModel.filename,
 37:                                      pageThumbnails: self.viewModel.pageThumbnails.data ?? [])
 38:             }
 39:             .fullScreenCover(isPresented: self.$viewModel.showPageImages) {
 40:                 PdfImageViewerView(pageIndex: self.viewModel.pageIndex,
 41:                                    images: self.viewModel.pageImages.data ?? [])
 42:             }
 43:         }
 44:         .background(ColorPalette.primaryBG)
 45:         .onAppear(perform: self.viewModel.onAppear)
 46:         .asyncView(asyncItem: self.$viewModel.pageThumbnails)
 47:         .asyncView(asyncItem: self.$viewModel.pageImages)
 48:     }
 49:     
 50:     @ViewBuilder var contentView: some View {
 51:         VStack(spacing: 16) {
 52:             if self.viewModel.textMode {
 53:                 self.textView
 54:             } else {
 55:                 self.standardView
 56:             }
 57:             self.pageCounter(currentPageIndex: self.viewModel.pageIndex,
 58:                              totalPages: self.viewModel.pageCount)
 59:         }
 60:     }
 61:     
 62:     var textView: some View {
 63:         TabView(selection: self.$viewModel.pageIndex) {
 64:             ForEach(Array(self.viewModel.pages.enumerated()), id:\.offset) { _, page in
 65:                 if let page = page {
 66:                     ScrollView {
 67:                         Text(page)
 68:                     }
 69:                 } else {
 70:                     Text("No text available on this page")
 71:                         .font(forCategory: .body1)
 72:                         .foregroundColor(ColorPalette.primaryText)
 73:                 }
 74:             }
 75:         }
 76:         .tabViewStyle(.page(indexDisplayMode: .never))
 77:         .background(ColorPalette.primaryBG)
 78:     }
 79:     
 80:     var standardView: some View {
 81:         PdfKitViewBinder(
 82:             pdfView: self.$viewModel.pdfView,
 83:             singlePage: false,
 84:             pageMargins: UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0),
 85:             backgroundColor: UIColor(ColorPalette.primaryBG),
 86:             usePaginator: true
 87:         )
 88:     }
 89:     
 90:     @ViewBuilder var toolbar: some View {
 91:         Button(action: { self.viewModel.switchTextMode() }) {
 92:             Image(systemName: self.viewModel.textMode ? "doc" : "doc.text")
 93:                 .foregroundColor(ColorPalette.primaryText)
 94:         }
 95:         Button(action: { self.viewModel.presentPageImages() }) {
 96:             Image(systemName: "photo.stack")
 97:                 .foregroundColor(ColorPalette.primaryText)
 98:         }
 99:         Button(action: { self.viewModel.presentPageSelection() }) {
100:             Image("page_selection")
101:                 .foregroundColor(ColorPalette.primaryText)
102:         }
103:     }
104: }
105: 
106: extension View {
107:     func showPdfReaderView(item: Binding<Pdf?>) -> some View {
108:         self.fullScreenCover(item: item) { pdf in
109:             let params = PdfReaderViewModel.Params(pdf: pdf)
110:             let viewModel = Container.shared.pdfReaderViewModel(params)
111:             PdfReaderView(viewModel: viewModel)
112:         }
113:     }
114: }
115: 
116: struct PdfReaderView_Previews: PreviewProvider {
117:     
118:     static var previews: some View {
119:         Color.white
120:             .showPdfReaderView(item: .constant(K.Test.DebugPdf))
121:     }
122: }
```

## File: pdfexpert/Views/Common/PdfReadView.swift
```swift
 1: //
 2: //  PdfReadView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 21/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct PdfReadViewModifier: ViewModifier {
11:     
12:     @ObservedObject var viewModel: PdfReadViewModel
13:     
14:     func body(content: Content) -> some View {
15:         content
16:             .showImportView(viewModel: self.viewModel.pdfImportViewModel)
17:             .asyncView(asyncItem: self.$viewModel.asyncImportedPdf)
18:             .showPdfReaderView(item: self.$viewModel.toBeReadPdf)
19:     }
20: }
21: 
22: extension View {
23:     func showReadView(viewModel: PdfReadViewModel) -> some View {
24:         self.modifier(PdfReadViewModifier(viewModel: viewModel))
25:     }
26: }
```

## File: pdfexpert/Views/Common/PdfShareView.swift
```swift
 1: //
 2: //  PdfShareView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 31/07/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct PdfShareView: ViewModifier {
12:     
13:     @ObservedObject var coordinator: PdfShareCoordinator
14: 
15:     func body(content: Content) -> some View {
16:         content
17:             .showSubscriptionView(self.$coordinator.monetizationShow, onComplete: { self.coordinator.onMonetizationClose() })
18:             .sharePdf(self.$coordinator.pdfToBeShared,
19:                       applyPostProcess: self.coordinator.applyPostProcess,
20:                       onDismiss: { self.coordinator.onShareDismiss() })
21:     }
22: }
23: 
24: extension View {
25:     func showShareView(coordinator: PdfShareCoordinator) -> some View {
26:         modifier(PdfShareView(coordinator: coordinator))
27:     }
28: }
29: 
30: struct PdfShareView_Previews: PreviewProvider {
31:     
32:     static let coordinator = Container.shared.pdfShareCoordinator()
33:     
34:     static var previews: some View {
35:         Color(.white)
36:             .showShareView(coordinator: Self.coordinator)
37:     }
38: }
```

## File: pdfexpert/Views/Common/PdfSortView.swift
```swift
  1: //
  2: //  PdfSortView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 02/08/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct PdfSortView: View {
 12:     
 13:     @ObservedObject var viewModel: PdfSortViewModel
 14:     
 15:     @Injected(\.analyticsManager) private var analyticsManager
 16:     
 17:     var body: some View {
 18:         NavigationStack {
 19:             VStack(spacing: 0) {
 20:                 List {
 21:                     ForEach(Array(self.viewModel.pdfs.enumerated()), id:\.offset) { _, item in
 22:                         self.getItemView(forItem: item)
 23:                             .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
 24:                             .listRowSeparator(.hidden)
 25:                             .listRowBackground(Color(.clear))
 26:                     }
 27:                     .onMove { from, to in
 28:                         self.viewModel.pdfs.move(fromOffsets: from, toOffset: to)
 29:                     }
 30:                 }
 31:                 .environment(\.editMode, .constant(.active))
 32:                 .scrollContentBackground(.hidden)
 33:                 .listStyle(.inset)
 34:                 Spacer()
 35:                 self.getDefaultButton(text: self.viewModel.confirmButtonText, onButtonPressed: {
 36:                     self.viewModel.confirm()
 37:                 })
 38:             }
 39:             .padding([.leading, .trailing], 16)
 40:             .padding(.top, 48)
 41:             .padding(.bottom, 80)
 42:             .navigationBarTitleDisplayMode(.inline)
 43:             .navigationTitle("Drag and drop to sort your documents")
 44:             .background(ColorPalette.primaryBG)
 45:             .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
 46:                 self.viewModel.cancel()
 47:             })
 48:         }
 49:         .background(ColorPalette.primaryBG)
 50:         .onAppear {
 51:             self.analyticsManager.track(event: .reportScreen(.sortPdf))
 52:         }
 53:     }
 54:     
 55:     private func getItemView(forItem item: Pdf) -> some View {
 56:         HStack(spacing: 16) {
 57:             self.getPdfThumbnail(forPdf: item)
 58:                 .frame(width: 86)
 59:             VStack(spacing: 0) {
 60:                 Spacer()
 61:                 Text(item.filename)
 62:                     .font(forCategory: .body1)
 63:                     .foregroundColor(ColorPalette.primaryText)
 64:                     .frame(maxWidth: .infinity, alignment: .leading)
 65:                     .lineLimit(1)
 66:                 Spacer().frame(height: 16)
 67:                 HStack(spacing: 16) {
 68:                     Text(item.pageCountText)
 69:                         .font(forCategory: .body1)
 70:                         .foregroundColor(ColorPalette.fourthText)
 71:                         .frame(maxWidth: .infinity, alignment: .leading)
 72:                 }
 73:                 Spacer()
 74:             }
 75:             .frame(maxWidth: .infinity)
 76:             
 77:         }
 78:         .padding(.trailing, 16)
 79:         .background(ColorPalette.secondaryBG)
 80:         .frame(height: 94)
 81:         .cornerRadius(10)
 82:     }
 83:     
 84:     @ViewBuilder private func getPdfThumbnail(forPdf pdf: Pdf) -> some View {
 85:         if let thumbnail = pdf.thumbnail {
 86:             Color.clear
 87:                 .overlay(Image(uiImage: thumbnail)
 88:                     .resizable()
 89:                     .scaledToFill())
 90:                 .clipShape(RoundedRectangle(cornerRadius: 10,
 91:                                             style: .continuous))
 92:         } else {
 93:             ColorPalette.secondaryBG
 94:                 .cornerRadius(10)
 95:         }
 96:     }
 97: }
 98: 
 99: extension View {
100:     func showSortView(isPresented: Binding<Bool>,
101:                       onDismiss: (() -> Void)?,
102:                       params: PdfSortViewModel.Params) -> some View {
103:         self.fullScreenCover(isPresented: isPresented, onDismiss: onDismiss) {
104:             let viewModel = Container.shared.pdfSortViewModel(params)
105:             PdfSortView(viewModel: viewModel)
106:         }
107:     }
108: }
109: 
110: struct PdfSortView_Previews: PreviewProvider {
111:     
112:     static let params = PdfSortViewModel.Params(
113:         pdfs: .constant([K.Test.DebugPdf, K.Test.DebugPdf, K.Test.DebugPdf].compactMap { $0 }),
114:         confirmButtonText: "Merge PDF",
115:         confirmCallback: { print("Sort confirmed!") },
116:         cancelCallback: { print("Sort cancelled...") })
117:     
118:     static var previews: some View {
119:         Color(.white)
120:             .showSortView(isPresented: .constant(true),
121:                           onDismiss: { print("Sort completed.") },
122:                           params: Self.params)
123:     }
124: }
```

## File: pdfexpert/Views/Common/PdfSplitView.swift
```swift
 1: //
 2: //  PdfSplitView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 04/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct PdfSplitView: ViewModifier {
12:     
13:     @ObservedObject var viewModel: PdfSplitViewModel
14:     
15:     func body(content: Content) -> some View {
16:         content
17:             .showImportView(viewModel: self.viewModel.pdfImportViewModel)
18:             .asyncView(asyncItem: self.$viewModel.asyncImportedPdf)
19:             .asyncView(asyncItem: self.$viewModel.asyncSplit)
20:             .showPageRangeEditorView(isPresented: self.$viewModel.showPageRangeEditor,
21:                                      onDismiss: { self.viewModel.onPageRangeEditingCompleted() },
22:                                      params: PdfPageRangeEditorViewModel.Params(
23:                                         pageRanges: self.$viewModel.pageRanges,
24:                                         totalPages: self.viewModel.totalPages,
25:                                         confirmCallback: {
26:                                             self.viewModel.onPageRangeEditingConfirmed()
27:                                         },
28:                                         cancelCallback: {
29:                                             self.viewModel.onPageRangeEditingCancelled()
30:                                         }))
31:     }
32: }
33: 
34: extension View {
35:     func showSplitView(viewModel: PdfSplitViewModel) -> some View {
36:         modifier(PdfSplitView(viewModel: viewModel))
37:     }
38: }
39: 
40: struct PdfSplitView_Previews: PreviewProvider {
41:     
42:     static let viewModel = Container.shared.pdfSplitViewModel()
43:     
44:     static var previews: some View {
45:         Color(.white)
46:             .showSplitView(viewModel: Self.viewModel)
47:     }
48: }
```

## File: pdfexpert/Views/Common/PdfUnlockView.swift
```swift
 1: //
 2: //  PdfUnlockView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 02/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct PdfUnlockView: ViewModifier {
12:     
13:     @ObservedObject var viewModel: PdfUnlockViewModel
14:     
15:     func body(content: Content) -> some View {
16:         content
17:             .alert("Your pdf is protected",
18:                    isPresented: self.$viewModel.showPasswordInputView,
19:                    actions: {
20:                 SecureField("Enter Password", text: self.$viewModel.passwordText)
21:                 Button("Confirm", action: {
22:                     self.viewModel.decryptPdf()
23:                 })
24:                 Button("Cancel", role: .cancel, action: {})
25:             }, message: {
26:                 Text("Enter the password of\n\(self.viewModel.unlockingPdf?.filename ?? "")\nin order to import it.")
27:             })
28:             .asyncView(asyncOperation: self.$viewModel.asyncUnlockedPdf)
29:     }
30: }
31: 
32: extension View {
33:     func showUnlockView(viewModel: PdfUnlockViewModel) -> some View {
34:         modifier(PdfUnlockView(viewModel: viewModel))
35:     }
36: }
37: 
38: struct PdfUnlockView_Previews: PreviewProvider {
39:     
40:     static let asyncUnlockedPdfSingle: AsyncOperation<Pdf, PdfError> = .init(status: .empty)
41:     static let viewModel = Container.shared
42:         .pdfUnlockViewModel(.init(asyncUnlockedPdfSingleOutput: .constant(Self.asyncUnlockedPdfSingle)))
43:     
44:     static var previews: some View {
45:         Color(.white)
46:             .showUnlockView(viewModel: Self.viewModel)
47:     }
48: }
```

## File: pdfexpert/Views/Common/SuggestedFieldsFormView.swift
```swift
  1: //
  2: //  SuggestedFieldsFormView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 07/09/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct SuggestedFieldsFormView: View {
 12:     
 13:     @InjectedObject(\.suggestedFieldsFormViewModel) var viewModel: SuggestedFieldsFormViewModel
 14:     
 15:     @Environment(\.dismiss) var dismiss
 16:     
 17:     var body: some View {
 18:         NavigationStack {
 19:             // The ZStack is needed to disable keyboard avoiding for the footer
 20:             // while keeping it for the textfields in the content view
 21:             ZStack {
 22:                 self.contentView
 23:                 self.footerView
 24:                     .ignoresSafeArea(.keyboard)
 25:             }
 26:             .navigationBarTitleDisplayMode(.inline)
 27:             .navigationTitle("Personal data")
 28:             .background(ColorPalette.primaryBG)
 29:             .addSystemCloseButton(color: ColorPalette.primaryText,
 30:                                   onPress: {
 31:                 self.dismiss()
 32:             })
 33:         }
 34:         .background(ColorPalette.primaryBG)
 35:         .onAppear(perform: self.viewModel.onAppear)
 36:     }
 37:     
 38:     private var contentView: some View {
 39:         VStack(spacing: 0) {
 40:             Form {
 41:                 Section(header: self.headerView) {}
 42:                 self.getTextField(name: "First Name",
 43:                                   text: self.$viewModel.firstName,
 44:                                   textContentType: .givenName)
 45:                 self.getTextField(name: "Last Name",
 46:                                   text: self.$viewModel.lastName,
 47:                                   textContentType: .familyName)
 48:                 self.getTextField(name: "Address",
 49:                                   text: self.$viewModel.address,
 50:                                   textContentType: .streetAddressLine1)
 51:                 self.getTextField(name: "City",
 52:                                   text: self.$viewModel.city,
 53:                                   textContentType: .addressCity)
 54:                 self.getTextField(name: "Country",
 55:                                   text: self.$viewModel.country,
 56:                                   textContentType: .countryName)
 57:                 self.getTextField(name: "Email",
 58:                                   text: self.$viewModel.email,
 59:                                   textContentType: .emailAddress,
 60:                                   keyboardType: .emailAddress)
 61:                 self.getTextField(name: "Phone",
 62:                                   text: self.$viewModel.phone,
 63:                                   textContentType: .telephoneNumber,
 64:                                   keyboardType: .numberPad)
 65:                 // This space is needed to create an inset equivalent to the footerView height
 66:                 Spacer().frame(height: 90)
 67:                     .listRowBackground(ColorPalette.primaryBG)
 68:             }
 69:             .foregroundColor(ColorPalette.primaryText)
 70:             .background(ColorPalette.primaryBG)
 71:             .scrollContentBackground(.hidden)
 72:         }
 73:     }
 74:     
 75:     private var footerView: some View {
 76:         VStack(spacing: 0) {
 77:             Spacer()
 78:             self.getDefaultButton(text: "Finish", onButtonPressed: {
 79:                 self.viewModel.onConfirmButtonPressed()
 80:                 self.dismiss()
 81:             })
 82:             .padding([.top, .leading, .trailing], 16)
 83:             .padding(.bottom, 80)
 84:             .background(ColorPalette.primaryBG)
 85:         }
 86:     }
 87:     
 88:     private var headerView: some View {
 89:         Text("Enter your data to allow us to help you fill in the forms faster")
 90:             .multilineTextAlignment(.center)
 91:             .foregroundColor(ColorPalette.primaryText)
 92:             .font(forCategory: .body2)
 93:             .textCase(nil)
 94:             .frame(maxWidth: .infinity)
 95:     }
 96:     
 97:     private func getTextField(
 98:         name: String,
 99:         text: Binding<String>,
100:         textContentType: UITextContentType? = nil,
101:         keyboardType: UIKeyboardType = .default
102:     ) -> some View {
103:         Section(header:Text(name)
104:             .font(forCategory: .caption1)
105:             .foregroundColor(ColorPalette.primaryText)
106:         ) {
107:             TextField("Add \(name)", text: text)
108:                 .frame(maxWidth: .infinity)
109:                 .font(forCategory: .body2)
110:                 .foregroundColor(ColorPalette.primaryText)
111:                 .textContentType(textContentType)
112:                 .keyboardType(keyboardType)
113:         }
114:         .listRowBackground(ColorPalette.secondaryBG)
115:     }
116: }
117: 
118: struct SuggestedFieldsFormView_Previews: PreviewProvider {
119:     static var previews: some View {
120:         SuggestedFieldsFormView()
121:     }
122: }
```

## File: pdfexpert/Views/Home/HomeItemView.swift
```swift
 1: //
 2: //  HomeItemView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 28/03/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct HomeItemView: View {
11:     
12:     let title: String
13:     let description: String
14:     let imageName: String
15:     let onButtonPressed: () -> ()
16:     
17:     var body: some View {
18:         Button(action: {
19:             self.onButtonPressed()
20:         }) {
21:             GeometryReader { geometryReader in
22:                 VStack(spacing: 0) {
23:                     Spacer().frame(height: 24)
24:                     Image(self.imageName)
25:                         .resizable()
26:                         .aspectRatio(contentMode: .fit)
27:                         .frame(height: UIDevice.current.userInterfaceIdiom == .pad ? 54.0 : 32.0)
28:                     Spacer().frame(height: 16)
29:                     Text(self.title)
30:                         .font(forCategory: .body1)
31:                         .foregroundColor(ColorPalette.primaryText)
32:                         .frame(maxWidth: .infinity, alignment: .center)
33:                         .minimumScaleFactor(0.5)
34:                         .multilineTextAlignment(.center)
35:                         .lineLimit(1)
36:                         .padding([.leading, .trailing], 12)
37:                     Spacer().frame(height: 4)
38:                     Text(self.description)
39:                         .font(forCategory: .caption1)
40:                         .foregroundColor(ColorPalette.primaryText)
41:                         .frame(maxWidth: .infinity, alignment: .center)
42:                         .minimumScaleFactor(0.5)
43:                         .multilineTextAlignment(.center)
44:                         .lineLimit(3)
45:                         .padding([.leading, .trailing], 12)
46:                     Spacer()
47:                     Spacer().frame(height: 12)
48:                 }
49:             }
50:         }
51:         .background(
52:             self.defaultGradientBackground
53:             .cornerRadius(10)
54:         )
55:     }
56: }
57: 
58: struct HomeItemView_Previews: PreviewProvider {
59:     static var previews: some View {
60:         GeometryReader { geometryReader in
61:             HomeItemView(title: "Powerpoint to PDF",
62:                          description: "Make PPT file easy to view by converting them to PDF converting them to PDF",
63:                          imageName: "home_image_to_pdf",
64:                          onButtonPressed: {})
65:             .aspectRatio(1.0, contentMode: .fit)
66:             .frame(width: geometryReader.size.width * 0.5)
67:         }
68:     }
69: }
```

## File: pdfexpert/Views/Home/HomeView.swift
```swift
  1: //
  2: //  HomeView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 28/03/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: import PhotosUI
 11: 
 12: struct HomeItem: Identifiable {
 13:     let id = UUID()
 14:     let title: String
 15:     let description: String
 16:     let imageName: String
 17:     let homeAction: HomeAction
 18: }
 19: 
 20: struct HomeView: View {
 21:     
 22:     @InjectedObject(\.homeViewModel) var viewModel
 23:     
 24:     let mostUsedItems: [HomeItem] = [
 25:         HomeItem(title: "Image to PDF",
 26:                  description: "Convert image to PDF in seconds",
 27:                  imageName: "home_image_to_pdf",
 28:                  homeAction: .imageToPdf),
 29:         HomeItem(title: "Scan",
 30:                  description: "Scan file from your smartphone or your camera",
 31:                  imageName: "home_scan",
 32:                  homeAction: .scan),
 33:         HomeItem(title: "Read PDF",
 34:                  description: "Read PDF improves the readability of your PDF",
 35:                  imageName: "home_read",
 36:                  homeAction: .readPdf)
 37:     ]
 38:     
 39:     let convertItems: [HomeItem] = [
 40:         HomeItem(title: "Word to PDF",
 41:                  description: "Make DOC file easy to read by converting them to PDF",
 42:                  imageName: "home_word_to_pdf",
 43:                  homeAction: .wordToPdf),
 44:         HomeItem(title: "Excel to PDF",
 45:                  description: "Make EXCEL file easy to read by converting them to PDF",
 46:                  imageName: "home_excel_to_pdf",
 47:                  homeAction: .excelToPdf),
 48:         HomeItem(title: "Powerpoint to PDF",
 49:                  description: "Make PPT file easy to view by converting them to PDF",
 50:                  imageName: "home_power_to_pdf",
 51:                  homeAction: .powerpointToPdf)
 52:     ]
 53:     
 54:     let organizeItems: [HomeItem] = [
 55:         HomeItem(title: "Merge PDF",
 56:                  description: "Combine pdf files in the order you want",
 57:                  imageName: "home_merge",
 58:                  homeAction: .merge),
 59:         HomeItem(title: "Split PDF",
 60:                  description: "Separate a set of pages for easy conversion into PDF",
 61:                  imageName: "home_split",
 62:                  homeAction: .split),
 63:     ]
 64:         
 65:     let editItems: [HomeItem] = [
 66:         HomeItem(title: "Sign PDF",
 67:                  description: "Sign a document or send a signature request to others",
 68:                  imageName: "home_sign",
 69:                  homeAction: .sign),
 70:         HomeItem(title: "Fill in a form",
 71:                  description: "Fill in a form or file",
 72:                  imageName: "home_fill_form",
 73:                  homeAction: .formFill),
 74:         HomeItem(title: "Add text",
 75:                  description: "Add text on your files",
 76:                  imageName: "home_add_text",
 77:                  homeAction: .addText),
 78:         HomeItem(title: "Create PDF",
 79:                  description: "Create a pdf from scratch and edit it",
 80:                  imageName: "home_create_pdf",
 81:                  homeAction: .createPdf)
 82:     ]
 83:     
 84:     let importItems: [HomeItem] = [
 85:         HomeItem(title: "Import PDF",
 86:                  description: "Import pdf from your files",
 87:                  imageName: "home_import_pdf",
 88:                  homeAction: .importPdf)
 89:     ]
 90:     
 91:     let protectItems: [HomeItem] = [
 92:         HomeItem(title: "Unlock PDF",
 93:                  description: "Unlock a PDF",
 94:                  imageName: "home_remove_password",
 95:                  homeAction: .removePassword),
 96:         HomeItem(title: "PDF Protector",
 97:                  description: "Enter a password to protect your pdf",
 98:                  imageName: "home_add_password",
 99:                  homeAction: .addPassword)
100:     ]
101:     
102:     private static let standardGridItemLayout: [GridItem] = {
103:         if UIDevice.current.userInterfaceIdiom == .pad {
104:             return [GridItem(.flexible(), spacing: 14),
105:                     GridItem(.flexible(), spacing: 14),
106:                     GridItem(.flexible(), spacing: 14),
107:                     GridItem(.flexible(), spacing: 14)]
108:         } else {
109:             return [GridItem(.flexible(), spacing: 14),
110:                     GridItem(.flexible(), spacing: 14)]
111:         }
112:     }()
113:     
114:     private static let expandedGridItemLayout: [GridItem] = {
115:         if UIDevice.current.userInterfaceIdiom == .pad {
116:             return [
117:                     GridItem(.flexible(), spacing: 14),
118:                     GridItem(.flexible(), spacing: 14)]
119:         } else {
120:             return [GridItem(.flexible(), spacing: 14)]
121:         }
122:     }()
123:     
124:     var body: some View {
125:         ScrollView {
126:             VStack {
127:                 LazyVGrid(columns: Self.expandedGridItemLayout, spacing: 14) {
128:                     self.section(forItems: self.mostUsedItems, sectionTitle: "Most used", aspectRatio: 2.5)
129:                 }
130:                 .padding(14)
131:                 LazyVGrid(columns: Self.standardGridItemLayout, spacing: 14) {
132:                     self.section(forItems: self.convertItems, sectionTitle: "Convert to PDF")
133:                     self.section(forItems: self.organizeItems, sectionTitle: "Organize PDF")
134:                     self.section(forItems: self.editItems, sectionTitle: "Edit PDF")
135:                     self.section(forItems: self.importItems, sectionTitle: "Convert from PDF")
136:                     self.section(forItems: self.protectItems, sectionTitle: "Protect PDF")
137:                 }
138:                 .padding(14)
139:             }
140:         }
141:         .padding(.top, 16)
142:         .listStyle(.plain)
143:         .background(ColorPalette.primaryBG)
144:         .onAppear() {
145:             self.viewModel.onAppear()
146:         }
147:         .formSheet(item: self.$viewModel.importOptionGroup) {
148:             OptionListView.getImportView(forImportOptionGroup: $0,
149:                                          importViewCallback: { self.viewModel.handleImportOption(importOption: $0) })
150:         }
151:         .filePicker(item: self.$viewModel.importFileOption, onPickedFiles: {
152:             self.viewModel.processPickedFileUrl($0.first)
153:         })
154:         .fullScreenCover(isPresented: self.$viewModel.scannerShow) {
155:             // Scanner
156:             ScannerView(onScannerResult: {
157:                 self.viewModel.convertScan(scannerResult: $0)
158:             })
159:         }
160:         .fullScreenCover(isPresented: self.$viewModel.cameraShow) {
161:             // Camera for image capture
162:             CameraView(model: Container.shared.cameraViewModel({ uiImage in
163:                 self.viewModel.convertImage(uiImage: uiImage)
164:             }))
165:         }
166:         // Photo gallery picker
167:         .photosPicker(isPresented: self.$viewModel.imagePickerShow,
168:                       selection: self.$viewModel.imageSelection,
169:                       matching: .images)
170:         .asyncView(asyncOperation: self.$viewModel.asyncPdf,
171:                    loadingView: { AnimationType.pdf.view })
172:         .asyncView(asyncOperation: self.$viewModel.asyncImageLoading,
173:                    loadingView: { AnimationType.pdf.view })
174:         .alertCameraPermission(isPresented: self.$viewModel.cameraPermissionDeniedShow)
175:         .addPasswordView(show: self.$viewModel.addPasswordShow,
176:                          addPasswordCallback: { self.viewModel.setPassword($0) })
177:         .addPasswordCompletedAlert(show: self.$viewModel.addPasswordCompletedShow,
178:                                    goToArchiveCallback: { self.viewModel.goToArchive() },
179:                                    sharePdfCallback: { self.viewModel.share() })
180:         .removePasswordCompletedAlert(show: self.$viewModel.removePasswordCompletedShow,
181:                                       goToArchiveCallback: { self.viewModel.goToArchive() },
182:                                       sharePdfCallback: { self.viewModel.share() })
183:         .showError(self.$viewModel.addPasswordError)
184:         .showError(self.$viewModel.removePasswordError)
185:         .showShareView(coordinator: self.viewModel.pdfShareCoordinator)
186:         .showMergeView(viewModel: self.viewModel.pdfMergeViewModel)
187:         .showSplitView(viewModel: self.viewModel.pdfSplitViewModel)
188:         .showReadView(viewModel: self.viewModel.pdfReadViewModel)
189:         .showUnlockView(viewModel: self.viewModel.pdfUnlockViewModel)
190:         .onReceive(NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification)) { _ in
191:             self.viewModel.onDidBecomeActive()
192:         }
193:     }
194:     
195:     @ViewBuilder func section(forItems items: [HomeItem],
196:                               sectionTitle: String,
197:                               aspectRatio: CGFloat = 1.0) -> some View {
198:         Section {
199:             ForEach(items, id: \.id) { item in
200:                 HomeItemView(title: item.title,
201:                              description: item.description,
202:                              imageName: item.imageName,
203:                              onButtonPressed: { self.viewModel.performHomeAction(item.homeAction) })
204:                 .aspectRatio(aspectRatio, contentMode: .fit)
205:                 .listRowSeparator(.hidden)
206:                 .listRowBackground(Color(.clear))
207:                 .listRowInsets(EdgeInsets())
208:             }
209:         } header: {
210:             Text(sectionTitle)
211:                 .font(forCategory: .headline)
212:                 .foregroundColor(ColorPalette.primaryText)
213:                 .frame(maxWidth: .infinity, alignment: .leading)
214:         }
215:     }
216: }
217: 
218: extension View {
219:     @ViewBuilder func addPasswordCompletedAlert(show: Binding<Bool>,
220:                                                 goToArchiveCallback: @escaping () -> (),
221:                                                 sharePdfCallback: @escaping () -> ()) -> some View {
222:         self.alert("PDF Protected!", isPresented: show, actions: {
223:             Button("Go to files", action: goToArchiveCallback)
224:             Button("Share pdf", action: sharePdfCallback)
225:         }, message: {
226:             Text("Your pdf has been successfully protected")
227:         })
228:     }
229:     
230:     @ViewBuilder func removePasswordCompletedAlert(show: Binding<Bool>,
231:                                                    goToArchiveCallback: @escaping () -> (),
232:                                                    sharePdfCallback: @escaping () -> ()) -> some View {
233:         self.alert("PDF Unlocked!", isPresented: show, actions: {
234:             Button("Go to files", action: goToArchiveCallback)
235:             Button("Share pdf", action: sharePdfCallback)
236:         }, message: {
237:             Text("Your pdf has been successfully unlocked")
238:         })
239:     }
240: }
241: 
242: extension ImportOptionGroup: FormSheetItem {
243:     var viewSize: CGSize {
244:         switch self {
245:         case .image: return CGSize(width: 400.0, height: 250.0)
246:         case .fileAndScan: return CGSize(width: 400.0, height: 220.0)
247:         }
248:     }
249: }
250: 
251: struct HomeView_Previews: PreviewProvider {
252:     static var previews: some View {
253:         NavigationStack {
254:             HomeView()
255:         }
256:         .background(ColorPalette.primaryBG)
257:     }
258: }
```

## File: pdfexpert/Views/ImportTutorial/ImportTutorialPageView.swift
```swift
 1: //
 2: //  ImportTutorialPageView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 08/05/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct ImportTutorialPageView: View {
11:     
12:     let title: String
13:     let imageName: String
14:     let description: String
15:     
16:     var body: some View {
17:         VStack(spacing: 0) {
18:             Spacer()
19:             Text(self.title)
20:                 .font(forCategory: .title2)
21:                 .foregroundColor(ColorPalette.primaryText)
22:                 .frame(maxWidth: .infinity)
23:                 .frame(height: 80, alignment: .top)
24:                 .padding([.leading, .trailing], 32)
25:                 .multilineTextAlignment(.center)
26:             Spacer().frame(height: 20)
27:             Image(self.imageName)
28:                 .resizable()
29:                 .aspectRatio(contentMode: .fit)
30:                 .frame(maxHeight: 600)
31:             Spacer().frame(height: 40)
32:             Text(self.description)
33:                 .font(forCategory: .body1)
34:                 .foregroundColor(ColorPalette.primaryText)
35:                 .frame(maxWidth: .infinity)
36:                 .frame(height: 80, alignment: .top)
37:                 .padding([.leading, .trailing], 32)
38:                 .multilineTextAlignment(.center)
39:             Spacer()
40:         }
41:     }
42: }
43: 
44: struct ImportTutorialPageView_Previews: PreviewProvider {
45:     
46:     static var previews: some View {
47:         ImportTutorialPageView(title: "Convert PDF from\nyour app",
48:                                imageName: "import_tutorial_1",
49:                                description: "Open the application that contains the pdf you want to convert")
50:         ImportTutorialPageView(title: "Convert PDF from\nyour app",
51:                                imageName: "import_tutorial_2",
52:                                description: "Select the pdf and press the button \"Open in\" or menu")
53:         ImportTutorialPageView(title: "Convert PDF from\nyour app",
54:                                imageName: "import_tutorial_3",
55:                                description: "Select the \(K.Misc.AppTitle) app to import the PDF")
56:     }
57: }
```

## File: pdfexpert/Views/ImportTutorial/ImportTutorialView.swift
```swift
 1: //
 2: //  ImportTutorialView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 08/05/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: import PagerTabStripView
11: 
12: struct ImportTutorialItem {
13:     let title: String
14:     let imageName: String
15:     let description: String
16: }
17: 
18: struct ImportTutorialView: View {
19:     
20:     static let items: [ImportTutorialItem] = [
21:         ImportTutorialItem(title: "Convert PDF from\nyour app",
22:                            imageName: "import_tutorial_1",
23:                            description: "Open the application that contains the pdf you want to convert"),
24:         ImportTutorialItem(title: "Convert PDF from\nyour app",
25:                            imageName: "import_tutorial_2",
26:                            description: "Select the pdf and press the button \"Open in\" or menu"),
27:         ImportTutorialItem(title: "Convert PDF from\nyour app",
28:                            imageName: "import_tutorial_3",
29:                            description: "Select the \(K.Misc.AppTitle) app to import the PDF"),
30:     ]
31:     
32:     var pageCount: Int { Self.items.count }
33:     
34:     @State var pageIndex: Int = 0
35:     @Environment(\.dismiss) var dismiss
36:     
37:     var body: some View {
38:         NavigationStack {
39:             VStack(spacing: 0) {
40:                 PagerTabStripView(
41:                     swipeGestureEnabled: .constant(false),
42:                     selection: self.$pageIndex
43:                 ) {
44:                     ForEach(Array(Self.items.enumerated()), id: \.offset) { index, item in
45:                         ImportTutorialPageView(title: item.title,
46:                                                imageName: item.imageName,
47:                                                description: item.description)
48:                         .pagerTabItem(tag: index) { }
49:                     }
50:                 }
51:                 .pagerTabStripViewStyle(.bar() { Color(.clear) })
52:                 PageControl(currentPageIndex: self.pageIndex,
53:                             numberOfPages: self.pageCount,
54:                             currentPageColor: ColorPalette.buttonGradientStart,
55:                             normalPageColor: ColorPalette.buttonGradientStart.opacity(0.3),
56:                             enableInteraction: false)
57:                 .frame(height: 40)
58:                 Spacer()
59:                 self.getDefaultButton(text: self.buttonText,
60:                                       onButtonPressed: self.onButtonPressed)
61:                 .padding([.leading, .trailing], 16)
62:             }
63:             .padding(.top, 16)
64:             .padding(.bottom, 30)
65:             .background(ColorPalette.primaryBG)
66:             .addSystemCloseButton(color: ColorPalette.primaryText, onPress: { self.dismiss() })
67:             .onAppear() {
68:                 Container.shared.analyticsManager().track(event: .reportScreen(.importTutorial))
69:             }
70:         }
71:         .background(ColorPalette.primaryBG)
72:     }
73:     
74:     private var buttonText: String {
75:         self.pageIndex + 1 < self.pageCount ? "Continue" : "Ok, I got it"
76:     }
77:     
78:     private func onButtonPressed() {
79:         if self.pageIndex + 1 < self.pageCount {
80:             self.pageIndex += 1
81:         } else {
82:             Container.shared.analyticsManager().track(event: .importTutorialCompleted)
83:             self.dismiss()
84:         }
85:     }
86: }
87: 
88: struct ImportTutorialView_Previews: PreviewProvider {
89:     static var previews: some View {
90:         ImportTutorialView()
91:     }
92: }
```

## File: pdfexpert/Views/Main/MainTabView.swift
```swift
  1: //
  2: //  MainTabView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 06/04/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: fileprivate extension MainTab {
 12:     
 13:     var name: String {
 14:         switch self {
 15:         case .archive: return "File"
 16:         case .home: return "Explore"
 17:         case .chatPdf: return "ChatPDF"
 18:         }
 19:     }
 20:     
 21:     var imageName: String {
 22:         switch self {
 23:         case .archive: return "tab_archive"
 24:         case .home: return "tab_home"
 25:         case .chatPdf: return "tab_chat_pdf"
 26:         }
 27:     }
 28: }
 29: 
 30: struct MainTabView: View {
 31:     
 32:     @InjectedObject(\.mainCoordinator) var mainCoordinator
 33:     
 34:     var body: some View {
 35:         TabView(selection: self.$mainCoordinator.tab) {
 36:             ForEach(MainTab.allCases, id:\.self) { tab in
 37:                 NavigationStack {
 38:                     self.getRootView(forTab: tab)
 39:                         .navigationTitle(tab.name)
 40:                         .navigationBarTitleDisplayMode(.inline)
 41:                         .toolbarBackground(ColorPalette.secondaryBG, for: .navigationBar)
 42:                         .toolbarBackground(.visible, for: .navigationBar)
 43:                         .settingsButton(showSettings: self.$mainCoordinator.settingsShow)
 44:                 }
 45:                 .tabItem {
 46:                     Label(tab.name, image: tab.imageName)
 47:                 }
 48:                 .tag(tab.rawValue)
 49:             }
 50:         }
 51:         .background(ColorPalette.primaryBG)
 52:         .pdfEditFlowView(pdfEditFlowData: self.$mainCoordinator.pdfEditFlowData)
 53:         .settingsView(showSettings: self.$mainCoordinator.settingsShow)
 54:     }
 55:     
 56:     @MainActor @ViewBuilder private func getRootView(forTab tab: MainTab) -> some View {
 57:         switch tab {
 58:         case .archive: ArchiveView()
 59:         case .home: HomeView()
 60:         case .chatPdf: ChatPdfSelectionView()
 61:         }
 62:     }
 63: }
 64: 
 65: fileprivate extension View {
 66:     
 67:     func pdfEditFlowView(pdfEditFlowData: Binding<PdfEditFlowData?>) -> some View {
 68:         self.fullScreenCover(item: pdfEditFlowData) { data in
 69:             PdfFlowView(
 70:                 pdf: data.pdf,
 71:                 startAction: data.startAction,
 72:                 shouldShowCloseWarning: data.isNewPdf
 73:             )
 74:         }
 75:     }
 76:     
 77:     func settingsView(showSettings: Binding<Bool>) -> some View {
 78:         self.fullScreenCover(isPresented: showSettings) {
 79:             NavigationStack {
 80:                 SettingsView()
 81:                     .navigationBarTitleDisplayMode(.inline)
 82:                     .navigationTitle("Settings")
 83:                     .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
 84:                         showSettings.wrappedValue = false
 85:                     })
 86:             }
 87:             .background(ColorPalette.primaryBG)
 88:         }
 89:     }
 90:     
 91:     func settingsButton(showSettings: Binding<Bool>) -> some View {
 92:         self.toolbar {
 93:             ToolbarItem(placement: .navigationBarTrailing) {
 94:                 Button(action: { showSettings.wrappedValue = true }) {
 95:                     Image(systemName: "gearshape")
 96:                         .foregroundColor(ColorPalette.primaryText)
 97:                 }
 98:             }
 99:         }
100:     }
101: }
102: 
103: struct MainTabView_Previews: PreviewProvider {
104:     static var previews: some View {
105:         MainTabView()
106:     }
107: }
```

## File: pdfexpert/Views/Navigation/Deeplink.swift
```swift
 1: //
 2: //  Deeplink.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 29/08/23.
 6: //
 7: 
 8: import Foundation
 9: 
10: enum Deeplink {
11:     case chatPdf
12:     
13:     init?(fromCustomUrl url: URL) {
14:         guard url.absoluteString.starts(with: SharedStorage.schema) else {
15:             return nil
16:         }
17:         
18:         switch url.absoluteString {
19:         case "\(SharedStorage.schema)chatpdf":
20:             self = .chatPdf
21:         default:
22:             return nil
23:         }
24:     }
25: }
```

## File: pdfexpert/Views/Navigation/MainCoordinator.swift
```swift
 1: //
 2: //  MainCoordinator.swift
 3: //  ChatAI
 4: //
 5: //  Created by Pcnaid Inc on 24/02/23.
 6: //
 7: 
 8: import Foundation
 9: import SwiftUI
10: import Factory
11: 
12: enum MainTab: Int, CaseIterable {
13:     case archive
14:     case home
15:     case chatPdf
16: }
17: 
18: struct PdfEditFlowData: Hashable, Identifiable {
19:     
20:     var id: Self { return self }
21:     
22:     let pdf: Pdf
23:     let startAction: PdfEditStartAction?
24:     let isNewPdf: Bool
25: }
26: 
27: class MainCoordinator: ObservableObject {
28:     
29:     enum RootView {
30:         case onboarding
31:         case main
32:     }
33:     
34:     enum Route: Hashable {
35:         case onboarding
36:     }
37:     
38:     @Published var rootView: RootView = .onboarding
39:     @Published var tab: MainTab = MainTab.home
40:     @Published var path: [Route] = []
41:     @Published var pdfEditFlowData: PdfEditFlowData? = nil
42:     @Published var settingsShow: Bool = false
43:     
44:     @Injected(\.cacheManager) private var cacheManager
45:     @Injected(\.reviewFlow) var reviewFlow
46:     
47:     init() {
48:         if self.cacheManager.onboardingShown {
49:             self.rootView = .main
50:         } else {
51:             self.rootView = .onboarding
52:         }
53:     }
54:     
55:     func showOnboarding() {
56:         self.path.append(.onboarding)
57:     }
58:     
59:     func goToMain() {
60:         self.rootView = .main
61:     }
62:     
63:     func goToArchive() {
64:         self.tab = MainTab.archive
65:     }
66:     
67:     func showPdfEditFlow(pdf: Pdf, startAction: PdfEditStartAction? = nil, isNewPdf: Bool) {
68:         self.pdfEditFlowData = PdfEditFlowData(pdf: pdf, startAction: startAction, isNewPdf: isNewPdf)
69:     }
70:     
71:     func closePdfEditFlow() {
72:         self.pdfEditFlowData = nil
73:     }
74:     
75:     func handleOpenUrl(url: URL) {
76:         if let deeplink = Deeplink(fromCustomUrl: url) {
77:             self.handleDeeplink(deeplink: deeplink)
78:         }
79:     }
80:     
81:     func startReview() {
82:         self.reviewFlow.startFlowIfNeeded()
83:     }
84:     
85:     private func handleDeeplink(deeplink: Deeplink) {
86:         switch deeplink {
87:         case .chatPdf:
88:             self.cacheManager.onboardingShown = true
89:             self.rootView = .main
90:             self.tab = .chatPdf
91:         }
92:     }
93: }
94: 
95: extension Container {
96:     var mainCoordinator: Factory<MainCoordinator> {
97:         self { MainCoordinator() }.singleton
98:     }
99: }
```

## File: pdfexpert/Views/Navigation/PdfCoordinator.swift
```swift
 1: //
 2: //  PdfCoordinator.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 11/04/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: 
11: class PdfCoordinator: ObservableObject {
12:     
13:     enum RootView {
14:         case edit
15:     }
16:     
17:     @Published var rootView: RootView = .edit
18:     
19:     @Injected(\.reviewFlow) var reviewFlow
20:     
21:     func startReview() {
22:         self.reviewFlow.startFlowIfNeeded()
23:     }
24: }
25: 
26: extension Container {
27:     var pdfCoordinator: Factory<PdfCoordinator> {
28:         self { PdfCoordinator() }.shared
29:     }
30: }
```

## File: pdfexpert/Views/Navigation/PdfShareCoordinator.swift
```swift
 1: //
 2: //  PdfShareCoordinator.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 31/07/23.
 6: //
 7: 
 8: import Foundation
 9: import Factory
10: 
11: extension Container {
12:     var pdfShareCoordinator: Factory<PdfShareCoordinator> {
13:         self { PdfShareCoordinator() }
14:     }
15: }
16: 
17: class PdfShareCoordinator: ObservableObject {
18:     
19:     @Published var monetizationShow: Bool = false
20:     @Published var pdfToBeShared: Pdf?
21:     
22:     var applyPostProcess: Bool = false
23:     var onComplete: () -> () = {}
24:     
25:     @Injected(\.analyticsManager) private var analyticsManager
26:     @Injected(\.store) private var store
27:     
28:     private var pdfWantToBeShared: Pdf? = nil
29:     
30:     func share(pdf: Pdf, applyPostProcess: Bool, onComplete: @escaping () -> ()) {
31:         self.analyticsManager.track(event: .pdfShared)
32:         self.applyPostProcess = applyPostProcess
33:         self.onComplete = onComplete
34:         if self.store.isPremium.value {
35:             self.pdfToBeShared = pdf
36:         } else {
37:             self.monetizationShow = true
38:             // Store pdf to share it after a successful subscription
39:             self.pdfWantToBeShared = pdf
40:         }
41:     }
42:     
43:     func onShareDismiss() {
44:         self.onComplete()
45:     }
46:     
47:     func onMonetizationClose() {
48:         if self.store.isPremium.value {
49:             // Share previously stored pdf, if existing.
50:             self.pdfToBeShared = self.pdfWantToBeShared
51:             self.pdfWantToBeShared = nil
52:         }
53:     }
54: }
```

## File: pdfexpert/Views/Onboarding/OnboardingPageView.swift
```swift
 1: //
 2: //  OnboardingPageView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 25/05/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct OnboardingPageView: View {
11:     
12:     let imageName: String
13:     let title: String
14:     let description: String
15:     
16:     var body: some View {
17:         VStack(spacing: 0) {
18:             Spacer()
19:             Image(self.imageName)
20:                 .resizable()
21:                 .aspectRatio(contentMode: .fit)
22:                 .frame(maxHeight: 600)
23:             Spacer().frame(height: 40)
24:             Text(self.title)
25:                 .font(forCategory: .title2)
26:                 .foregroundColor(ColorPalette.primaryText)
27:                 .frame(maxWidth: .infinity)
28:                 .frame(height: 70, alignment: .top)
29:                 .padding([.leading, .trailing], 32)
30:                 .multilineTextAlignment(.center)
31:             Spacer().frame(height: 16)
32:             Text(self.description)
33:                 .font(forCategory: .body1)
34:                 .foregroundColor(ColorPalette.primaryText)
35:                 .frame(maxWidth: .infinity)
36:                 .frame(height: 80, alignment: .top)
37:                 .padding([.leading, .trailing], 32)
38:                 .multilineTextAlignment(.center)
39:             Spacer()
40:         }
41:     }
42: }
43: 
44: struct OnboardingPageView_Previews: PreviewProvider {
45:     static var previews: some View {
46:         OnboardingPageView(
47:             imageName: "onboarding_chat_pdf",
48:             title: "Chat with any PDF files",
49:             description: "You can ask questions to any PDF and get quick insights and clarifications."
50:         )
51:         OnboardingPageView(
52:             imageName: "onboarding_convert",
53:             title: "Convert files\nto PDF",
54:             description: "You can convert to pdf a lot of file types from the programs you prefer."
55:         )
56:         OnboardingPageView(
57:             imageName: "onboarding_signature",
58:             title: "Enter and edit your\nsignature",
59:             description: "Insert your signature in the pdf you created with a single tap."
60:         )
61:         OnboardingPageView(
62:             imageName: "onboarding_password",
63:             title: "Protect your files with\npassword",
64:             description: "Enter a password to protect your pdf, you can delete it and change it whenever you want."
65:         )
66:     }
67: }
```

## File: pdfexpert/Views/Onboarding/OnboardingView.swift
```swift
 1: //
 2: //  OnboardingView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 25/05/23.
 6: //
 7: 
 8: import SwiftUI
 9: import PagerTabStripView
10: import Factory
11: 
12: struct OnboardingView: View {
13:     
14:     @InjectedObject(\.onboardingViewModel) var viewModel
15:     
16:     @State private var rect: CGRect = .zero
17:     
18:     var pageCount: Int { self.viewModel.items.count }
19:     
20:     @Environment(\.dismiss) var dismiss
21:     
22:     var body: some View {
23:         VStack(spacing: 0) {
24:             Spacer()
25:             PagerTabStripView(selection: self.$viewModel.pageIndex) {
26:                 ForEach(Array(self.viewModel.items.enumerated()), id: \.offset) { index, item in
27:                     OnboardingPageView(imageName: item.imageName,
28:                                        title: item.title,
29:                                        description: item.description)
30:                     .pagerTabItem(tag: index) { }
31:                 }
32:             }
33:             .pagerTabStripViewStyle(.bar() { Color(.clear) })
34:             Spacer()
35:             PageControl(currentPageIndex: self.viewModel.pageIndex,
36:                         numberOfPages: self.pageCount,
37:                         currentPageColor: ColorPalette.buttonGradientStart,
38:                         normalPageColor: ColorPalette.buttonGradientStart.opacity(0.3),
39:                         enableInteraction: false)
40:             .frame(height: 40)
41:             Spacer().frame(height: 40)
42:             self.getDefaultButton(text: "Continue",
43:                                   onButtonPressed: self.viewModel.continueButtonPressed)
44:             .padding([.leading, .trailing], 16)
45:         }
46:         .padding(.top, 16)
47:         .padding(.bottom, 64)
48:         .background(ColorPalette.primaryBG)
49:         .navigationBarBackButtonHidden()
50:         .toolbar {
51:             ToolbarItem(placement: .navigationBarTrailing) {
52:                 Button(action: { self.viewModel.skipButtonPressed() }) {
53:                     Text("Skip")
54:                         .font(forCategory: .body1)
55:                         .foregroundColor(ColorPalette.primaryText)
56:                 }
57:             }
58:         }
59:         .toolbarBackground(ColorPalette.primaryBG, for: .navigationBar)
60:         .onAppear() {
61:             Container.shared.analyticsManager().track(event: .reportScreen(.onboarding))
62:         }
63:         .fullScreenCover(isPresented: self.$viewModel.monetizationShow) {
64:             self.getSubscriptionView(onComplete: {
65:                 self.viewModel.onMonetizationClose()
66:             })
67:         }
68:     }
69: }
70: 
71: struct OnboardingView_Previews: PreviewProvider {
72:     static var previews: some View {
73:         OnboardingView()
74:     }
75: }
```

## File: pdfexpert/Views/Pdf/PdfCompressionPickerView.swift
```swift
  1: //
  2: //  PdfCompressionPickerView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 31/07/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct PdfCompressionPickerView: View {
 12:     
 13:     @Binding var compressionOption: CompressionOption
 14:     
 15:     @State var currentCompressionOption: CompressionOption
 16:     
 17:     @Environment(\.dismiss) var dismiss
 18:     
 19:     @Injected(\.analyticsManager) private var analyticsManager
 20:     
 21:     init(compressionOption: Binding<CompressionOption>) {
 22:         self._compressionOption = compressionOption
 23:         self._currentCompressionOption = State(initialValue: compressionOption.wrappedValue)
 24:     }
 25:     
 26:     var body: some View {
 27:         VStack(spacing: 16) {
 28:             ForEach(CompressionOption.orderedList, id:\.self) { option in
 29:                 Button(action: { self.currentCompressionOption = option }) {
 30:                     Group {
 31:                         HStack(spacing: 16) {
 32:                             VStack(spacing: 6) {
 33:                                 Text(option.titleText)
 34:                                     .font(forCategory: .body1)
 35:                                     .foregroundColor(ColorPalette.primaryText)
 36:                                     .frame(maxWidth: .infinity, alignment: .leading)
 37:                                 Text(option.descriptionText)
 38:                                     .font(forCategory: .callout)
 39:                                     .foregroundColor(ColorPalette.primaryText)
 40:                                     .frame(maxWidth: .infinity, alignment: .leading)
 41:                             }
 42:                             self.getCheckbox(forCompressionOption: option)
 43:                         }
 44:                         .padding(16)
 45:                     }
 46:                     .background(ColorPalette.secondaryBG)
 47:                     .overlay(RoundedRectangle(cornerRadius: 8)
 48:                         .strokeBorder(style: StrokeStyle(lineWidth: 1))
 49:                         .foregroundColor(ColorPalette.thirdText))
 50:                     .contentShape(RoundedRectangle(cornerRadius: 8))
 51:                 }
 52:                 .frame(height: 74)
 53:             }
 54:             Spacer()
 55:             self.getDefaultButton(text: "Finish", onButtonPressed: {
 56:                 self.compressionOption = self.currentCompressionOption
 57:                 self.dismiss()
 58:             })
 59:         }
 60:         .padding([.leading, .trailing], 16)
 61:         .padding(.top, 48)
 62:         .padding(.bottom, 80)
 63:         .navigationTitle("Choose a compression for your pdf")
 64:         .background(ColorPalette.primaryBG)
 65:         .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
 66:             self.dismiss()
 67:         })
 68:         .onAppear {
 69:             self.analyticsManager.track(event: .reportScreen(.compressionPicker))
 70:         }
 71:     }
 72:     
 73:     @ViewBuilder func getCheckbox(forCompressionOption compressionOption: CompressionOption) -> some View {
 74:         if compressionOption == self.currentCompressionOption {
 75:             ZStack {
 76:                 Image(systemName: "circle.fill")
 77:                     .resizable()
 78:                     .aspectRatio(1, contentMode: .fit)
 79:                     .frame(width: 20, height: 20)
 80:                     .foregroundColor(ColorPalette.secondaryText)
 81:                 Image(systemName: "checkmark")
 82:                     .font(.system(size: 10, weight: .bold))
 83:                     .frame(width: 10, height: 10)
 84:                     .foregroundColor(ColorPalette.primaryText)
 85:             }
 86:         } else {
 87:             Image(systemName: "circle")
 88:                 .resizable()
 89:                 .aspectRatio(1, contentMode: .fit)
 90:                 .frame(width: 20, height: 20)
 91:                 .foregroundColor(ColorPalette.primaryText)
 92:         }
 93:     }
 94: }
 95:                             
 96: fileprivate extension CompressionOption {
 97:     
 98:     var titleText: String {
 99:         switch self {
100:         case .high: return "Maximum compression"
101:         case .medium: return "Recommended compression"
102:         case .low: return "Low compression"
103:         case .noCompression: return "No compression"
104:         }
105:     }
106:     
107:     var descriptionText: String {
108:         switch self {
109:         case .high: return "Lower quality, higher compression"
110:         case .medium: return "Good quality, good compression"
111:         case .low: return "High quality, less compression"
112:         case .noCompression: return "Top quality, no compression"
113:         }
114:     }
115:     
116:     static var orderedList: [CompressionOption] {
117:         self.allCases.reversed()
118:     }
119: }
120: 
121: struct PdfCompressionPickerView_Previews: PreviewProvider {
122:     static var previews: some View {
123:         PdfCompressionPickerView(compressionOption: .constant(.noCompression))
124:     }
125: }
```

## File: pdfexpert/Views/Pdf/PdfEditView.swift
```swift
  1: //
  2: //  PdfEditView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 11/04/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: import PhotosUI
 11: 
 12: struct PdfEditView: View {
 13:     
 14:     fileprivate static let cellSide: CGFloat = 80.0
 15:     fileprivate static let selectedCellBorderWidth: CGFloat = 4.0
 16:     
 17:     @StateObject var viewModel: PdfEditViewModel
 18:     @State private var showingImageInputPicker = false
 19:     @State private var showingDeleteConfermation = false
 20:     
 21:     @State private var draggedImage: UIImage? = nil
 22:     
 23:     var body: some View {
 24:         VStack(spacing: 16) {
 25:             VStack(spacing: 16) {
 26:                 VStack(spacing: 0) {
 27:                     Spacer()
 28:                     self.pdfView
 29:                     Spacer()
 30:                 }
 31:                 self.pageListView
 32:                 self.editButtonsView
 33:             }
 34:             .padding([.leading, .trailing], 16)
 35:             self.editOptionsView
 36:         }
 37:         .navigationBarTitleDisplayMode(.inline)
 38:         .navigationTitle(self.$viewModel.pdfFilename)
 39:         .ignoresSafeArea(.keyboard)
 40:         .background(ColorPalette.primaryBG)
 41:         .toolbar {
 42:             ToolbarItemGroup(placement: .navigationBarTrailing) {
 43:                 if self.viewModel.pageImages.count > 0 {
 44:                     Button(action: { self.showingDeleteConfermation = true }) {
 45:                         Image(systemName: "trash")
 46:                             .foregroundColor(ColorPalette.primaryText)
 47:                     }
 48:                 }
 49:                 Button(action: { self.viewModel.editOptionListShow = true }) {
 50:                     Image(systemName: "ellipsis.circle")
 51:                         .foregroundColor(ColorPalette.primaryText)
 52:                 }
 53:             }
 54:         }
 55: 
 56:         .onAppear(perform:self.viewModel.onAppear)
 57:         // File picker
 58:         .filePicker(isPresented: self.$viewModel.filePickerShow,
 59:                     fileTypes: K.Misc.ImportFileTypesForAddPage,
 60:                     onPickedFiles: {
 61:             // Callback is called on modal dismiss, thus we can assign and convert in a row
 62:             self.viewModel.urlToFileToConvert = $0.first
 63:             self.viewModel.convert()
 64:         })
 65:         // Camera for image capture
 66:         .fullScreenCover(isPresented: self.$viewModel.cameraShow) {
 67:             CameraView(model: Container.shared.cameraViewModel({ uiImage in
 68:                 self.viewModel.cameraShow = false
 69:                 self.viewModel.imageToConvert = uiImage
 70:             })).onDisappear { self.viewModel.convert() }
 71:         }
 72:         // Photo gallery picker
 73:         .photosPicker(isPresented: self.$viewModel.imagePickerShow,
 74:                       selection: self.$viewModel.imageSelection,
 75:                       matching: .images)
 76:         // Scanner
 77:         .fullScreenCover(isPresented: self.$viewModel.scannerShow) {
 78:             ScannerView(onScannerResult: {
 79:                 self.viewModel.scannerShow = false
 80:                 self.viewModel.scannerResult = $0
 81:             }).onDisappear { self.viewModel.convert() }
 82:         }
 83:         .fullScreenCover(isPresented: self.$viewModel.signatureAddViewShow) {
 84:             let inputParameter = PdfSignatureViewModel
 85:                 .InputParameter(pdf: self.viewModel.pdf,
 86:                                 currentPageIndex: self.viewModel.pdfCurrentPageIndex,
 87:                                 onConfirm: { self.viewModel.updatePdf(pdf: $0) })
 88:             PdfSignatureView(viewModel: Container.shared.pdfSignatureViewModel(inputParameter))
 89:         }
 90:         .fullScreenCover(isPresented: self.$viewModel.fillFormViewShow) {
 91:             let inputParameter = PdfFillFormViewModel
 92:                 .InputParameter(pdf: self.viewModel.pdf,
 93:                                 currentPageIndex: self.viewModel.pdfCurrentPageIndex,
 94:                                 onConfirm: { self.viewModel.updatePdf(pdf: $0) })
 95:             PdfFillFormView(viewModel: Container.shared.pdfFillFormViewModel(inputParameter))
 96:         }
 97:         .fullScreenCover(isPresented: self.$viewModel.fillWidgetViewShow) {
 98:             let inputParameter = PdfFillWidgetViewModel
 99:                 .InputParameter(pdf: self.viewModel.pdf,
100:                                 currentPageIndex: self.viewModel.pdfCurrentPageIndex,
101:                                 onConfirm: { self.viewModel.updatePdf(pdf: $0) })
102:             PdfFillWidgetView(viewModel: Container.shared.pdfFillWidgetViewModel(inputParameter))
103:         }
104:         .fullScreenCover(isPresented: self.$viewModel.compressionShow) {
105:             PdfCompressionPickerView(compressionOption: self.$viewModel.compression)
106:         }
107:         .asyncView(asyncOperation: self.$viewModel.asyncPdf,
108:                    loadingView: { AnimationType.pdf.view })
109:         .asyncView(asyncOperation: self.$viewModel.asyncImageLoading,
110:                    loadingView: { AnimationType.pdf.view })
111:         .alertCameraPermission(isPresented: self.$viewModel.cameraPermissionDeniedShow)
112:         .alert("Info", isPresented: self.$viewModel.missingWidgetWarningShow, actions: {
113:             Button("Ok", role: .cancel, action: {})
114:         }, message: {
115:             Text("Your pdf has no  fields that you can fill in.")
116:         })
117:         .showError(self.$viewModel.pdfSaveError)
118:         .formSheet(isPresented: self.$viewModel.editOptionListShow,
119:                    size: CGSize(width: 400.0, height: 250.0)) {
120:             self.editListView
121:         }
122:         .saveSuccessfullAlert(show: self.$viewModel.saveSuccessfulAlertShow,
123:                              goToArchiveCallback: { self.viewModel.goToArchive() },
124:                              sharePdfCallback: { self.viewModel.share() })
125:         .removePasswordView(show: self.$viewModel.removePasswordAlertShow,
126:                             removePasswordCallback: self.viewModel.removePassword)
127:         .addPasswordView(show: self.$viewModel.passwordTextFieldShow,
128:                          addPasswordCallback: { self.viewModel.setPassword($0) })
129:         .showShareView(coordinator: self.viewModel.pdfShareCoordinator)
130:         .showUnlockView(viewModel: self.viewModel.pdfUnlockViewModel)
131:         .showSplitView(viewModel: self.viewModel.pdfSplitViewModel)
132:         .splitSuccessfulAlert(show: self.$viewModel.splitSuccessAlertShow,
133:                               goToArchiveCallback: { self.viewModel.goToArchive() })
134:     }
135:     
136:     @ViewBuilder var pdfView: some View {
137:         if self.viewModel.pageImages.count > 0 {
138:             TabView(selection: self.$viewModel.pdfCurrentPageIndex) {
139:                 ForEach(Array(self.viewModel.pageImages.enumerated()), id:\.offset) { (pageIndex, pageImage) in
140:                     ZStack {
141:                         Image(uiImage: pageImage)
142:                             .resizable()
143:                             .aspectRatio(contentMode: .fit)
144:                     }
145:                 }
146:             }
147:             .tabViewStyle(.page(indexDisplayMode: .never))
148:         } else {
149:             self.emptyView
150:         }
151:     }
152:     
153:     var emptyView: some View {
154:         VStack(spacing: 16) {
155:             Spacer()
156:             Image("archive_empty")
157:                 .resizable()
158:                 .aspectRatio(contentMode: .fit)
159:                 .frame(height: 80)
160:             Text("You have no pages")
161:                 .font(forCategory: .body1)
162:                 .foregroundColor(ColorPalette.primaryText)
163:                 .frame(maxWidth: .infinity, alignment: .center)
164:                 .multilineTextAlignment(.center)
165:             self.getDefaultButton(text: "Add a new page") {
166:                 self.showingImageInputPicker = true
167:             }
168:             Spacer()
169:         }
170:     }
171:     
172:     var editButtonsView: some View {
173:         HStack {
174:             self.getDefaultButton(text: "Save PDF") {
175:                 self.viewModel.save()
176:             }
177:             Button(action: { self.viewModel.share() }) {
178:                 Image(systemName: "square.and.arrow.up")
179:                     .frame(maxWidth: .infinity, maxHeight: .infinity)
180:                     .font(.system(size: 16).bold())
181:                     .foregroundColor(ColorPalette.primaryText)
182:                     .contentShape(Capsule())
183:             }
184:             .frame(width: 64, height: 48)
185:             .background(self.defaultGradientBackground)
186:             .cornerRadius(10)
187:         }
188:     }
189:     
190:     var pageListView: some View {
191:         ScrollView(.horizontal, showsIndicators: false) {
192:             LazyHStack {
193:                 ForEach(Array(self.viewModel.pdfThumbnails.enumerated()), id: \.offset) { index, image in
194:                     Button(action: {
195:                         self.viewModel.pdfCurrentPageIndex = index
196:                     }) {
197:                         self.getThumbnailCell(image: image)
198:                             .applyCellStyle(highlight: index == self.viewModel.pdfCurrentPageIndex)
199:                     }
200:                     .actionDialog(
201:                         Text("Action"),
202:                         isPresented: self.$showingDeleteConfermation,
203:                         titleVisibility: .visible
204:                     ) {
205:                         Button("Delete this page", role: .destructive) {
206:                             self.showingDeleteConfermation = false
207:                             withAnimation {
208:                                 self.viewModel.deleteCurrentPage()
209:                             }
210:                         }
211:                     }
212:                 }
213:             }
214:             .padding([.trailing, .leading], Self.selectedCellBorderWidth)
215:         }
216:         .frame(height: Self.cellSide + Self.selectedCellBorderWidth)
217:     }
218:     
219:     var editOptionsView: some View {
220:         HStack {
221:             self.addPageButton.frame(maxWidth: .infinity)
222:             self.showAddSignatureButton.frame(maxWidth: .infinity)
223:             self.showFillFormButton.frame(maxWidth: .infinity)
224:             self.showFillWidgetButton.frame(maxWidth: .infinity)
225:         }
226:         .padding([.trailing, .leading], 16)
227:         .frame(height: 100)
228:         .frame(maxWidth: .infinity)
229:         .background(ColorPalette.secondaryBG)
230:     }
231:     
232:     var addPageButton: some View {
233:         Button(action: {
234:             self.showingImageInputPicker = true
235:         }) {
236:             self.getEditOptionView(text: "Add page", imageName: "edit_add_file")
237:         }
238:         .actionDialog(
239:             Text("Choose your source"),
240:             isPresented: self.$showingImageInputPicker,
241:             titleVisibility: .visible
242:         ) {
243:             Button("Photo Gallery") {
244:                 self.viewModel.openGallery()
245:             }
246:             Button("Camera") {
247:                 self.viewModel.openCamera()
248:             }
249:             Button("File") {
250:                 self.viewModel.openFilePicker()
251:             }
252:             Button("Scan") {
253:                 self.viewModel.openScanner()
254:             }
255:             Button("Cancel", role: .cancel) {}
256:         }
257:     }
258:     
259:     func getThumbnailCell(image: UIImage) -> some View {
260:         return AnyView(
261:             Image(uiImage: image)
262:                 .resizable()
263:                 .aspectRatio(contentMode: .fill)
264:                 .onDrag {
265:                     self.draggedImage = image
266:                     return NSItemProvider()
267:                 }
268:                 .onDrop(of: [.image],
269:                         delegate: PdfEditDropViewDelegate(destinationItem: image,
270:                                                           draggedItem: self.$draggedImage,
271:                                                           viewModel: self.viewModel))
272:         )
273:     }
274:     
275:     var showFillWidgetButton: some View {
276:         Button(action: { self.viewModel.showFillWidget() }) {
277:             self.getEditOptionView(text: "Fill Form", imageName: "edit_fill_form")
278:         }
279:     }
280:     
281:     var showFillFormButton: some View {
282:         Button(action: { self.viewModel.showFillForm() }) {
283:             self.getEditOptionView(text: "Add text", imageName: "edit_add_text")
284:         }
285:     }
286:     
287:     var showAddSignatureButton: some View {
288:         Button(action: { self.viewModel.showAddSignature() }) {
289:             self.getEditOptionView(text: "Signature", imageName: "edit_signature")
290:         }
291:     }
292:     
293:     func getEditOptionView(text: String, imageName: String) -> some View {
294:         return VStack(spacing: 6) {
295:             Spacer()
296:             Image(imageName)
297:                 .resizable()
298:                 .aspectRatio(contentMode: .fill)
299:                 .frame(width: 32, height: 32)
300:                 .foregroundColor(ColorPalette.primaryText)
301:             Text(text)
302:                 .font(forCategory: .callout)
303:                 .foregroundColor(ColorPalette.primaryText)
304:             Spacer()
305:         }
306:     }
307:     
308:     @ViewBuilder var editListView: some View {
309:         OptionListView(title: "Edit pdf", items: EditAction.allCases.map { editAction in
310:             let callback = { self.viewModel.handleEditAction(editAction) }
311:             switch editAction {
312:             case .password:
313:                 if self.viewModel.pdf.password != nil {
314:                     return OptionItem(title: "Unlock",
315:                                       imageName: "edit_option_password_unlock",
316:                                       callBack: callback)
317:                 } else {
318:                     return OptionItem(title: "Protect",
319:                                       imageName: "edit_option_password_lock",
320:                                       callBack: callback)
321:                 }
322:             case .compression:
323:                 return OptionItem(title: "Compress",
324:                                   imageName: "edit_option_compress",
325:                                   callBack: callback)
326:             case .split:
327:                 return OptionItem(title: "Split",
328:                                   imageName: "edit_option_split",
329:                                   callBack: callback)
330:             }
331:         })
332:     }
333: }
334: 
335: fileprivate extension View {
336:     func applyCellStyle(highlight: Bool) -> some View {
337:         self
338:             .frame(width: PdfEditView.cellSide, height: PdfEditView.cellSide)
339:             .cornerRadius(16)
340:             .if(highlight) { view in
341:                 view.overlay(
342:                     RoundedRectangle(cornerRadius: 16)
343:                         .stroke(ColorPalette.buttonGradientStart,
344:                                 lineWidth: PdfEditView.selectedCellBorderWidth)
345:                 )
346:             }
347:     }
348:     
349:     @ViewBuilder func saveSuccessfullAlert(show: Binding<Bool>,
350:                                           goToArchiveCallback: @escaping () -> (),
351:                                           sharePdfCallback: @escaping () -> ()) -> some View {
352:         self.alert("PDF saved!", isPresented: show, actions: {
353:             Button("Go to files", action: goToArchiveCallback)
354:             Button("Share pdf", action: sharePdfCallback)
355:             Button("Continue edit", action: {})
356:         }, message: {
357:             Text("Your pdf has been successfully saved")
358:         })
359:     }
360:     
361:     func splitSuccessfulAlert(show: Binding<Bool>,
362:                               goToArchiveCallback: @escaping () -> ()) -> some View {
363:         self.alert("PDF split!", isPresented: show, actions: {
364:             Button("Go to files", action: goToArchiveCallback)
365:             Button("Continue edit", action: {})
366:         }, message: {
367:             Text("Your pdf has been successfully split and saved!")
368:         })
369:     }
370: }
371: 
372: fileprivate extension MarginsOption {
373:     
374:     var iconImage: some View {
375:         let insets: EdgeInsets = {
376:             switch self {
377:             case .noMargins: return EdgeInsets(top: 4, leading: 3, bottom: 4, trailing: 3)
378:             case .mediumMargins: return EdgeInsets(top: 8, leading: 6, bottom: 8, trailing: 6)
379:             case .heavyMargins: return EdgeInsets(top: 12, leading: 9, bottom: 12, trailing: 9)
380:             }
381:         }()
382:         return ColorPalette.fourthText
383:             .cornerRadius(4)
384:             .padding(insets)
385:             .overlay(RoundedRectangle(cornerRadius: 5).stroke(ColorPalette.primaryText, lineWidth: 2))
386:     }
387: }
388: 
389: struct PdfEditView_Previews: PreviewProvider {
390:     static var previews: some View {
391:         NavigationStack {
392:             if let pdf = K.Test.DebugPdf {
393:                 let inputParameter = PdfEditViewModel.InputParameter(pdf: pdf,
394:                                                                      startAction: nil,
395:                                                                      shouldShowCloseWarning: .constant(true))
396:                 AnyView(PdfEditView(viewModel: Container.shared.pdfEditViewModel(inputParameter)))
397:             } else {
398:                 AnyView(Spacer())
399:             }
400:         }
401:     }
402: }
403: 
404: fileprivate struct PdfEditDropViewDelegate: DropDelegate {
405:     
406:     let destinationItem: UIImage
407:     @Binding var draggedItem: UIImage?
408:     var viewModel: PdfEditViewModel
409:     
410:     func dropUpdated(info: DropInfo) -> DropProposal? {
411:         return DropProposal(operation: .move)
412:     }
413:     
414:     func performDrop(info: DropInfo) -> Bool {
415:         self.draggedItem = nil
416:         return true
417:     }
418:     
419:     func dropEntered(info: DropInfo) {
420:         // Swap Items
421:         if let draggedItem {
422:             let fromIndex = self.viewModel.pdfThumbnails.firstIndex(of: draggedItem)
423:             if let fromIndex {
424:                 let toIndex = self.viewModel.pdfThumbnails.firstIndex(of: self.destinationItem)
425:                 if let toIndex, fromIndex != toIndex {
426:                     self.viewModel.handlePageReordering(fromIndex: fromIndex, toIndex: toIndex)
427:                 }
428:             }
429:         }
430:     }
431: }
```

## File: pdfexpert/Views/Pdf/PdfFillFormView.swift
```swift
  1: //
  2: //  PdfFillFormView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 26/05/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: import PDFKit
 11: 
 12: struct PdfFillFormView: View {
 13:     
 14:     @StateObject var viewModel: PdfFillFormViewModel
 15:     @Environment(\.dismiss) var dismiss
 16:     @State var showCancelWarningDialog: Bool = false
 17:     
 18:     var body: some View {
 19:         NavigationStack {
 20:             VStack(spacing: 0) {
 21:                 VStack(spacing: 0) {
 22:                     Spacer()
 23:                     GeometryReader { parentGeometryReader in
 24:                         TabView(selection: self.$viewModel.pageIndex) {
 25:                             ForEach(Array(self.viewModel.pageImages.enumerated()), id:\.offset) { (pageIndex, page) in
 26:                                 GeometryReader { geometryReader in
 27:                                     HStack {
 28:                                         Spacer()
 29:                                         ZStack {
 30:                                             Image(uiImage: page)
 31:                                                 .resizable()
 32:                                                 .aspectRatio(contentMode: .fit)
 33:                                                 .ignoresSafeArea(.keyboard)
 34:                                             self.getAnnotationViews(forPageIndex: pageIndex)
 35:                                                 .ignoresSafeArea(.keyboard)
 36:                                         }
 37:                                         Spacer()
 38:                                     }
 39:                                     .onTapGesture {
 40:                                         self.viewModel.tapOnPdfView(positionInView: $0,
 41:                                                                     pageIndex: pageIndex,
 42:                                                                     pageViewSize: geometryReader.size)
 43:                                     }
 44:                                     .position(x: geometryReader.size.width / 2, y: geometryReader.size.height / 2)
 45:                                 }
 46:                             }
 47:                         }
 48:                         .tabViewStyle(.page(indexDisplayMode: .never))
 49:                         .position(x: parentGeometryReader.size.width / 2, y: parentGeometryReader.size.height / 2)
 50:                         .frame(width: parentGeometryReader.size.width,
 51:                                height: parentGeometryReader.size.height)
 52:                     }
 53:                     .background(ColorPalette.primaryBG)
 54:                     .navigationBarTitleDisplayMode(.inline)
 55:                     .navigationTitle("Tap where you wish to add text")
 56:                     Spacer()
 57:                 }
 58:                 self.pageCounter(currentPageIndex: self.viewModel.pageIndex,
 59:                                  totalPages: self.viewModel.pageImages.count)
 60:                 Spacer().frame(height: 50)
 61:                 self.getDefaultButton(text: "Finish", onButtonPressed: {
 62:                     self.viewModel.onConfirmButtonPressed()
 63:                     self.dismiss()
 64:                 })
 65:                 Spacer().frame(height: 60)
 66:             }
 67:             .padding([.leading, .trailing], 16)
 68:             .ignoresSafeArea(.keyboard)
 69:             .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
 70:                 if self.viewModel.unsavedChangesExist {
 71:                     self.showCancelWarningDialog = true
 72:                 } else {
 73:                     self.dismiss()
 74:                 }
 75:             })
 76:             .toolbar(content: {
 77:                 ToolbarItem(placement: .navigationBarTrailing) {
 78:                     Button(action: { self.viewModel.onSuggestedFieldsButtonPressed() }) {
 79:                         Image("suggested_fields")
 80:                             .foregroundColor(ColorPalette.primaryText)
 81:                     }
 82:                 }
 83:             })
 84:             .alert("Are you sure?",
 85:                    isPresented: self.$showCancelWarningDialog,
 86:                    actions: {
 87:                 Button("No", role: .cancel, action: {})
 88:                 Button("Yes", role: .destructive, action: {
 89:                     self.dismiss()
 90:                 })
 91:             }, message: { Text("If you quit, you will lose the changes you have just made.") })
 92:             .background(ColorPalette.primaryBG)
 93:         }
 94:         .onAppear(perform: self.viewModel.onAppear)
 95:         .fullScreenCover(isPresented: self.$viewModel.showSuggestedFields) {
 96:             SuggestedFieldsFormView()
 97:         }
 98:     }
 99:     
100:     @ViewBuilder func getAnnotationViews(forPageIndex pageIndex: Int) -> some View {
101:         ForEach(self.viewModel.getAnnotations(forPageIndex: pageIndex), id:\.self) { pageAnnotation in
102:             self.getView(forAnnotation: pageAnnotation)
103:         }
104:         if self.viewModel.editedPageIndex == pageIndex {
105:             TextResizableView(data: self.$viewModel.currentTextResizableViewData,
106:                               fontName: K.Misc.DefaultAnnotationTextFontName,
107:                               fontColor: .black,
108:                               color: .orange,
109:                               borderWidth: 4,
110:                               minSize: CGSize(width: 5, height: 5),
111:                               handleSize: 25,
112:                               handleTapSize: 50,
113:                               suggestedWords: self.viewModel.suggestedFields?.fields ?? [],
114:                               deleteCallback: self.viewModel.onDeleteAnnotationPressed)
115:         }
116:     }
117:     
118:     @ViewBuilder func getView(forAnnotation annotation: PDFAnnotation) -> some View {
119:         if let page = annotation.page {
120:             GeometryReader { geometryReader in
121:                 let annotationBounds = self.viewModel.convertRect(annotation.verticalCenteredTextBounds,
122:                                                                         viewSize: geometryReader.size,
123:                                                                         fromPage: page)
124:                 let position = CGPoint(x: annotationBounds.origin.x + annotationBounds.size.width / 2,
125:                                        y: annotationBounds.origin.y + annotationBounds.size.height / 2)
126:                 Text(annotation.contents ?? "")
127:                     .font(Font(UIFont.font(named: K.Misc.DefaultAnnotationTextFontName,
128:                                            fitting: annotation.contents ?? "",
129:                                            into: annotationBounds.size,
130:                                            with: [:],
131:                                            options: [])))
132:                     .foregroundColor(Color(annotation.fontColor ?? .black))
133:                     .frame(width: annotationBounds.width, height: annotationBounds.height)
134:                     .position(position)
135:             }
136:         }
137:     }
138: }
139: 
140: struct PdfFillFormView_Previews: PreviewProvider {
141:     static var previews: some View {
142:         if let pdf = K.Test.DebugPdf {
143:             let inputParameter = PdfFillFormViewModel.InputParameter(pdf: pdf,
144:                                                                      currentPageIndex: 0,
145:                                                                      onConfirm: { _ in })
146:             AnyView(PdfFillFormView(viewModel: Container.shared.pdfFillFormViewModel(inputParameter)))
147:         } else {
148:             AnyView(Spacer())
149:         }
150:     }
151: }
```

## File: pdfexpert/Views/Pdf/PdfFillWidgetView.swift
```swift
 1: //
 2: //  PdfFillWidgetView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 22/06/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct PdfFillWidgetView: View {
12:     
13:     @StateObject var viewModel: PdfFillWidgetViewModel
14:     @Environment(\.dismiss) var dismiss
15:     @State var showCancelWarningDialog: Bool = false
16:     
17:     var body: some View {
18:         NavigationStack {
19:             VStack(spacing: 0) {
20:                 VStack(spacing: 0) {
21:                     Spacer()
22:                     PdfKitViewBinder(
23:                         pdfView: self.$viewModel.pdfView,
24:                         singlePage: false,
25:                         pageMargins: UIEdgeInsets(top: 0, left: 0, bottom: 24, right: 0),
26:                         backgroundColor: UIColor(ColorPalette.primaryBG),
27:                         usePaginator: true
28:                     )
29:                     .padding([.leading, .trailing], 16)
30:                     .background(ColorPalette.primaryBG)
31:                     .navigationBarTitleDisplayMode(.inline)
32:                     .navigationTitle("Tap to fill in")
33:                     Spacer()
34:                 }
35:                 self.pageCounter(currentPageIndex: self.viewModel.pdfCurrentPageIndex,
36:                                  totalPages: self.viewModel.pdfDocument.pageCount)
37:                 Spacer().frame(height: 50)
38:                 self.getDefaultButton(text: "Finish", onButtonPressed: {
39:                     self.viewModel.onConfirmButtonPressed()
40:                     self.dismiss()
41:                 })
42:                 Spacer().frame(height: 60)
43:             }
44:             .ignoresSafeArea(.keyboard)
45:             .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
46:                 if self.viewModel.unsavedChangesExist {
47:                     self.showCancelWarningDialog = true
48:                 } else {
49:                     self.viewModel.onCancelButtonPressed()
50:                     self.dismiss()
51:                 }
52:             })
53:             .alert("Are you sure?",
54:                    isPresented: self.$showCancelWarningDialog,
55:                    actions: {
56:                 Button("No", role: .cancel, action: {})
57:                 Button("Yes", role: .destructive, action: {
58:                     self.viewModel.onCancelButtonPressed()
59:                     self.dismiss()
60:                 })
61:             }, message: { Text("If you quit, you will lose the changes you have just made.") })
62:         }
63:         .onAppear(perform: self.viewModel.onAppear)
64:     }
65: }
66: 
67: struct PdfFillWidgetView_Previews: PreviewProvider {
68:     static var previews: some View {
69:         if let pdf = K.Test.DebugPdf {
70:             let inputParameter = PdfFillWidgetViewModel.InputParameter(pdf: pdf,
71:                                                                        currentPageIndex: 0,
72:                                                                        onConfirm: { _ in })
73:             AnyView(PdfFillWidgetView(viewModel: Container.shared.pdfFillWidgetViewModel(inputParameter)))
74:         } else {
75:             AnyView(Spacer())
76:         }
77:     }
78: }
```

## File: pdfexpert/Views/Pdf/PdfFlowView.swift
```swift
 1: //
 2: //  PdfFlowView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 11/04/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct PdfFlowView: View {
12:     
13:     @InjectedObject(\.pdfCoordinator) var coordinator
14:     @Environment(\.dismiss) var dismiss
15:     let pdf: Pdf
16:     let startAction: PdfEditStartAction?
17:     
18:     @State var shouldShowCloseWarning: Bool
19:     @State var showCloseWarningDialog: Bool = false
20:     
21:     var body: some View {
22:         self.content
23:     }
24:     
25:     @ViewBuilder var content: some View {
26:         switch self.coordinator.rootView {
27:         case .edit:
28:             NavigationStack {
29:                 let inputParameter = PdfEditViewModel.InputParameter(pdf: self.pdf,
30:                                                                      startAction: self.startAction,
31:                                                                      shouldShowCloseWarning: self.$shouldShowCloseWarning)
32:                 PdfEditView(viewModel: Container.shared.pdfEditViewModel(inputParameter))
33:                     .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
34:                         if self.shouldShowCloseWarning {
35:                             self.showCloseWarningDialog = true
36:                         } else {
37:                             self.dismiss()
38:                         }
39:                     })
40:                     .alert("Are you sure?",
41:                            isPresented: self.$showCloseWarningDialog,
42:                            actions: {
43:                         Button("No", role: .cancel, action: {})
44:                         Button("Yes", role: .destructive, action: {
45:                             self.dismiss()
46:                         })
47:                     }, message: { Text("If you quit, you will lose the changes to your current file.") })
48:             }
49:             .reviewFlowView(flow: self.coordinator.reviewFlow)
50:         }
51:     }
52: }
53: 
54: struct PdfView_Previews: PreviewProvider {
55:     static var previews: some View {
56:         if let pdf = K.Test.DebugPdf {
57:             AnyView(PdfFlowView(pdf: pdf, startAction: nil, shouldShowCloseWarning: true))
58:         } else {
59:             AnyView(Color(.clear))
60:         }
61:     }
62: }
```

## File: pdfexpert/Views/Pdf/PdfSignatureCanvasView.swift
```swift
  1: //
  2: //  PdfSignatureCanvasView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 19/05/23.
  6: //
  7: 
  8: import SwiftUI
  9: import PencilKit
 10: import Factory
 11: 
 12: struct PdfSignatureCanvasView: View {
 13:     
 14:     @StateObject var viewModel: PdfSignatureCanvasViewModel
 15:     
 16:     var body: some View {
 17:         VStack(spacing: 0) {
 18:             Text("Add Signature")
 19:                 .font(forCategory: .body1)
 20:                 .foregroundColor(ColorPalette.secondaryBG)
 21:                 .frame(maxWidth: .infinity)
 22:             Spacer().frame(height: 10)
 23:             self.tabsView
 24:             Spacer().frame(height: 10)
 25:             Spacer()
 26:             self.contentView.frame(height: 120)
 27:             Spacer().frame(height: 40)
 28:             self.saveButton
 29:             Spacer().frame(height: 20)
 30:             self.getDefaultButton(text: "Confirm",
 31:                                   enabled: self.viewModel.confirmAllowed,
 32:                                   onButtonPressed: { self.viewModel.onConfirmButtonPressed() })
 33:         }
 34:         .padding(16)
 35:         .background(ColorPalette.primaryText)
 36:         .galleryImageProviderView(flow: self.viewModel.galleryImageProviderFlow)
 37:         .cameraImageProviderView(flow: self.viewModel.cameraImageProviderFlow)
 38:         .imageCropView(flow: self.viewModel.imageCropFlow)
 39:     }
 40:     
 41:     var tabsView: some View {
 42:         HStack(spacing: 16) {
 43:             ForEach(SignatureSource.allCases, id:\.self) { source in
 44:                 Button(action: { self.viewModel.source = source }) {
 45:                     Label(title: {
 46:                         Text(source.text)
 47:                             .lineLimit(1)
 48:                             .font(forCategory: .caption1)
 49:                             .foregroundColor(
 50:                                 self.viewModel.source == source
 51:                                 ? ColorPalette.secondaryText
 52:                                 : ColorPalette.primaryBG
 53:                             )
 54:                     }, icon: {
 55:                         source.icon
 56:                             .resizable()
 57:                             .scaledToFit()
 58:                             .frame(width: 16, height: 16)
 59:                             .foregroundColor(
 60:                                 self.viewModel.source == source
 61:                                 ? ColorPalette.secondaryText
 62:                                 : ColorPalette.primaryBG
 63:                             )
 64:                     })
 65:                 }
 66:             }
 67:         }
 68:     }
 69:     
 70:     @ViewBuilder var contentView: some View {
 71:         switch self.viewModel.source {
 72:         case .drawing: self.drawContentView
 73:         case .image: self.imageContentView
 74:         case .camera: self.cameraContentView
 75:         }
 76:     }
 77:     
 78:     var drawContentView: some View {
 79:         VStack(spacing: 0) {
 80:             HStack(spacing: 6) {
 81:                 Spacer().frame(width: 24)
 82:                 VStack(spacing: 0) {
 83:                     PencilKitView(canvasView: self.$viewModel.canvasView,
 84:                                   backgroundColor: ColorPalette.primaryText,
 85:                                   inkColor: .black,
 86:                                   onSaved: {})
 87:                     .frame(maxWidth: .infinity, maxHeight: .infinity)
 88:                     ColorPalette.thirdText.frame(height: 1)
 89:                 }
 90:                 Button(action: { self.viewModel.onClearButtonPressed() }) {
 91:                     Image(systemName: "xmark.circle.fill")
 92:                         .resizable()
 93:                         .foregroundColor(ColorPalette.thirdText)
 94:                         .frame(width: 24, height: 24)
 95:                         .scaledToFit()
 96:                 }
 97:             }
 98:             Spacer().frame(height: 6)
 99:             Text("Sign in here")
100:                 .font(forCategory: .body2)
101:                 .foregroundColor(ColorPalette.thirdText)
102:         }
103:     }
104:     
105:     var imageContentView: some View {
106:         VStack(spacing: 0) {
107:             Button(action: { self.viewModel.onSelectImageButtonPressed() }) {
108:                 if let uiImage = self.viewModel.signatureGalleryImage {
109:                     Image(uiImage: uiImage)
110:                         .resizable()
111:                         .scaledToFit()
112:                 } else {
113:                     Color.clear
114:                 }
115:             }
116:             .frame(maxHeight: .infinity)
117:             Spacer().frame(height: 6)
118:             Text("Select Image")
119:                 .font(forCategory: .body2)
120:                 .foregroundColor(ColorPalette.thirdText)
121:         }
122:     }
123:     
124:     var cameraContentView: some View {
125:         VStack(spacing: 0) {
126:             Button(action: { self.viewModel.onTakePictureButtonPressed() }) {
127:                 if let uiImage = self.viewModel.signatureCameraImage {
128:                     Image(uiImage: uiImage)
129:                         .resizable()
130:                         .scaledToFit()
131:                 } else {
132:                     Color.clear
133:                 }
134:             }
135:             .frame(maxHeight: .infinity)
136:             Spacer().frame(height: 6)
137:             Text("Take a Picture")
138:                 .font(forCategory: .body2)
139:                 .foregroundColor(ColorPalette.thirdText)
140:         }
141:     }
142:     
143:     var saveButton: some View {
144:         Button(action: { self.viewModel.toggleShouldSave() }) {
145:             Label {
146:                 Text("Memorize signature")
147:                     .padding(.trailing, 6)
148:             } icon: {
149:                 Image(
150:                     systemName: self.viewModel.shouldSaveSignature
151:                     ? "checkmark.circle.fill"
152:                     : "checkmark.circle"
153:                 )
154:                 .resizable()
155:                 .scaledToFit()
156:                 .padding([.top, .bottom, .leading], 6)
157:             }
158:             .font(forCategory: .callout)
159:             .foregroundColor(
160:                 self.viewModel.shouldSaveSignature
161:                 ? ColorPalette.buttonGradientStart
162:                 : ColorPalette.thirdText
163:             )
164:             .frame(height: 40)
165:         }
166:         .frame(height: 40)
167:         .overlay(Capsule().stroke(
168:             self.viewModel.shouldSaveSignature
169:             ? ColorPalette.buttonGradientStart
170:             : ColorPalette.thirdText,
171:             lineWidth: 1
172:         ))
173:     }
174: }
175: 
176: fileprivate extension SignatureSource {
177:     var text: String {
178:         switch self {
179:         case .drawing: return "Drawing"
180:         case .image: return "From Image"
181:         case .camera: return "From Camera"
182:         }
183:     }
184:     
185:     var icon: Image {
186:         switch self {
187:         case .drawing: return Image("sign_drawing")
188:         case .image: return Image(systemName: "photo")
189:         case .camera: return Image(systemName: "camera")
190:         }
191:     }
192: }
193: 
194: struct PdfSignatureCanvasView_Previews: PreviewProvider {
195:     
196:     static let drawing = PKDrawing()
197:     
198:     static var previews: some View {
199:         PdfSignatureCanvasView(viewModel: Container.shared
200:             .pdfSignatureCanvasViewModel({ _ in print("Confirm button pressed") }))
201:     }
202: }
```

## File: pdfexpert/Views/Pdf/PdfSignaturePickerView.swift
```swift
  1: //
  2: //  PdfSignaturePickerView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 28/08/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct PdfSignaturePickerView: View {
 12:     
 13:     @StateObject var viewModel: PdfSignaturePickerViewModel
 14:     
 15:     @State private var editMode: EditMode = .inactive
 16:     
 17:     var body: some View {
 18:         ZStack {
 19:             VStack(spacing: 0) {
 20:                 Spacer().frame(height: 16)
 21:                 Text("Your Signatures")
 22:                     .font(forCategory: .body1)
 23:                     .foregroundColor(ColorPalette.primaryBG)
 24:                 Spacer().frame(height: 16)
 25:                 self.content
 26:                 Spacer().frame(height: 16)
 27:                 self.addNewButton
 28:             }
 29:             if self.viewModel.isLoading {
 30:                 self.loadingView
 31:             }
 32:             self.getCloseButton(color: ColorPalette.primaryBG,
 33:                                 onClose: { self.viewModel.cancel() })
 34:             self.getEditButton(color: ColorPalette.buttonGradientStart,
 35:                                font: FontCategory.body1.font,
 36:                                editMode: self.$editMode)
 37:         }
 38:         .background(ColorPalette.primaryText)
 39:         .onAppear {
 40:             self.viewModel.onAppear()
 41:         }
 42:     }
 43:     
 44:     @ViewBuilder var content: some View {
 45:         switch self.viewModel.asyncItems.status {
 46:         case .empty: Spacer()
 47:         case .loading: self.loadingView
 48:         case .data(let items): self.getItemList(items: items)
 49:         case .error: self.errorView
 50:         }
 51:     }
 52:     
 53:     @ViewBuilder func getItemList(items: [Signature]) -> some View {
 54:         if items.count > 0 {
 55:             List {
 56:                 ForEach(items) { item in
 57:                     Button(action: {
 58:                         if self.editMode == .inactive {
 59:                             self.viewModel.pick(item: item)
 60:                         }
 61:                     }) {
 62:                         HStack(spacing: 0) {
 63:                             Spacer()
 64:                             Image(uiImage: item.image)
 65:                                 .resizable()
 66:                                 .scaledToFit()
 67:                                 .padding([.leading, .trailing], 16)
 68:                             Spacer()
 69:                         }
 70:                     }
 71:                     .padding([.top, .bottom], 16)
 72:                     .frame(height: 100)
 73:                     .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
 74:                     .listRowBackground(Color(.clear))
 75:                 }
 76:                 .onDelete { indexSet in
 77:                     self.viewModel.delete(indexSet: indexSet)
 78:                 }   
 79:             }
 80:             // Needed to use a custom background color in case of List with inset list style
 81:             .scrollContentBackground(.hidden)
 82:             .listStyle(.inset)
 83:             .environment(\.editMode, self.$editMode)
 84:         } else {
 85:             self.emptyView
 86:         }
 87:     }
 88:     
 89:     var emptyView: some View {
 90:         VStack(spacing: 16) {
 91:             Spacer()
 92:             Text("No signature added")
 93:                 .font(forCategory: .body1)
 94:                 .foregroundColor(ColorPalette.thirdText)
 95:                 .frame(maxWidth: .infinity, alignment: .center)
 96:                 .multilineTextAlignment(.center)
 97:             Spacer()
 98:         }
 99:         .padding([.leading, .trailing], 16)
100:     }
101:     
102:     var loadingView: some View {
103:         AnimationType.dots.view.background(Color(.black).opacity(0.3))
104:     }
105:     
106:     var errorView: some View {
107:         VStack(spacing: 16) {
108:             Spacer()
109:             Image("subscription_error")
110:                 .resizable()
111:                 .aspectRatio(contentMode: .fit)
112:                 .frame(height: 80)
113:             Text("Oh Know!")
114:                 .font(forCategory: .largeTitle)
115:                 .foregroundColor(ColorPalette.primaryBG)
116:                 .frame(maxWidth: .infinity, alignment: .center)
117:             Text("Something went wrong,\n Please try again.")
118:                 .font(forCategory: .body1)
119:                 .foregroundColor(ColorPalette.primaryBG)
120:                 .multilineTextAlignment(.center)
121:                 .frame(maxWidth: .infinity, alignment: .center)
122:             self.getDefaultButton(text: "Retry",
123:                                   onButtonPressed: self.viewModel.refresh)
124:             Spacer()
125:         }
126:         .padding([.leading, .trailing], 16)
127:     }
128:     
129:     var addNewButton: some View {
130:         HStack(spacing: 0) {
131:             Spacer()
132:             Button(action: { self.viewModel.createNewSignature() }) {
133:                 Label("Add new signature", systemImage: "plus.circle.fill")
134:                     .font(forCategory: .body1)
135:                     .foregroundColor(ColorPalette.buttonGradientStart)
136:             }
137:         }
138:         .frame(maxWidth: .infinity)
139:         .frame(height: 48)
140:         .padding(.trailing, 16)
141:     }
142: }
143: 
144: struct PdfSignaturePickerView_Previews: PreviewProvider {
145:     
146:     static let params = PdfSignaturePickerViewModel.Params(
147:         confirmationCallback: { _ in print("Signature confirmed!") },
148:         cancelCallback: { print("Signature selection cancelled") },
149:         createNewSignatureCallback: { print("Create new signature!") }
150:     )
151:     
152:     static var previews: some View {
153:         PdfSignaturePickerView(viewModel: Container.shared.pdfSignaturePickerViewModel(Self.params))
154:     }
155: }
```

## File: pdfexpert/Views/Pdf/PdfSignatureProviderFlowView.swift
```swift
 1: //
 2: //  PdfSignatureProviderFlowView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 29/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct PdfSignatureProviderFlowView: ViewModifier {
12:     
13:     @ObservedObject var flow: PdfSignaturePrioviderFlow
14: 
15:     func body(content: Content) -> some View {
16:         content
17:             .formSheet(isPresented: self.$flow.showSignatureCreation,
18:                        size: CGSize(width: 400, height: 385)) {
19:                 PdfSignatureCanvasView(viewModel: Container.shared.pdfSignatureCanvasViewModel({
20:                     self.flow.onSignatureSelected(signature: $0)
21:                 }))
22:                 .background(ColorPalette.primaryText)
23:             }.formSheet(isPresented: self.$flow.showSignaturePicker,
24:                         size: CGSize(width: 400, height: 700)) {
25:                 let params = PdfSignaturePickerViewModel.Params(confirmationCallback: {
26:                     self.flow.onSignatureSelected(signature: $0)
27:                 }, cancelCallback: {
28:                     self.flow.showSignaturePicker = false
29:                 }, createNewSignatureCallback: {
30:                     self.flow.onCreateNewSignature()
31:                 })
32:                 PdfSignaturePickerView(viewModel: Container.shared.pdfSignaturePickerViewModel(params))
33:                     .background(ColorPalette.primaryText)
34:             }
35:     }
36: }
37: 
38: extension View {
39:     func pdfSignatureProviderView(flow: PdfSignaturePrioviderFlow) -> some View {
40:         self.modifier(PdfSignatureProviderFlowView(flow: flow))
41:     }
42: }
```

## File: pdfexpert/Views/Pdf/PdfSignatureView.swift
```swift
  1: //
  2: //  PdfSignatureView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 10/05/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: import PDFKit
 11: 
 12: struct PdfSignatureView: View {
 13:     
 14:     @StateObject var viewModel: PdfSignatureViewModel
 15:     @Environment(\.dismiss) var dismiss
 16:     @State var showCancelWarningDialog: Bool = false
 17:     
 18:     var body: some View {
 19:         NavigationStack {
 20:             VStack(spacing: 0) {
 21:                 VStack(spacing: 0) {
 22:                     Spacer()
 23:                     self.pdfView
 24:                     Spacer()
 25:                 }
 26:                 self.pageCounter(currentPageIndex: self.viewModel.pageIndex,
 27:                                  totalPages: self.viewModel.pageImages.count)
 28:                 Spacer().frame(height: 50)
 29:                 self.getDefaultButton(text: "Finish", onButtonPressed: {
 30:                     self.viewModel.onConfirmButtonPressed()
 31:                     self.dismiss()
 32:                 })
 33:                 Spacer().frame(height: 60)
 34:             }
 35:             .background(ColorPalette.primaryBG)
 36:             .navigationBarTitleDisplayMode(.inline)
 37:             .navigationTitle("Tap where you wish to sign")
 38:             .addSystemCloseButton(color: ColorPalette.primaryText, onPress: {
 39:                 if self.viewModel.unsavedChangesExist {
 40:                     self.showCancelWarningDialog = true
 41:                 } else {
 42:                     self.dismiss()
 43:                 }
 44:             })
 45:             .pdfSignatureProviderView(flow: self.viewModel.pdfSignaturePrioviderFlow)
 46:             .alert("Are you sure?",
 47:                     isPresented: self.$showCancelWarningDialog,
 48:                     actions: {
 49:                 Button("No", role: .cancel, action: {})
 50:                 Button("Yes", role: .destructive, action: {
 51:                     self.dismiss()
 52:                 })
 53:             }, message: { Text("If you quit, you will lose the signatures you've just added.") })
 54:         }
 55:         .onAppear(perform: self.viewModel.onAppear)
 56:     }
 57:     
 58:     var pdfView: some View {
 59:         VStack(spacing: 0) {
 60:             Spacer()
 61:             GeometryReader { parentGeometryReader in
 62:                 TabView(selection: self.$viewModel.pageIndex) {
 63:                     ForEach(Array(self.viewModel.pageImages.enumerated()), id:\.offset) { (pageIndex, page) in
 64:                         GeometryReader { geometryReader in
 65:                             HStack {
 66:                                 Spacer()
 67:                                 ZStack {
 68:                                     Image(uiImage: page)
 69:                                         .resizable()
 70:                                         .aspectRatio(contentMode: .fit)
 71:                                         .ignoresSafeArea(.keyboard)
 72:                                     self.getAnnotationViews(forPageIndex: pageIndex)
 73:                                         .ignoresSafeArea(.keyboard)
 74:                                 }
 75:                                 Spacer()
 76:                             }
 77:                             .onTapGesture {
 78:                                 self.viewModel.tapOnPdfView(positionInView: $0,
 79:                                                             pageIndex: pageIndex,
 80:                                                             pageViewSize: geometryReader.size)
 81:                             }
 82:                             .position(x: geometryReader.size.width / 2, y: geometryReader.size.height / 2)
 83:                         }
 84:                     }
 85:                 }
 86:                 .tabViewStyle(.page(indexDisplayMode: .never))
 87:                 .position(x: parentGeometryReader.size.width / 2, y: parentGeometryReader.size.height / 2)
 88:                 .frame(width: parentGeometryReader.size.width,
 89:                        height: parentGeometryReader.size.height)
 90:             }
 91:             .background(ColorPalette.primaryBG)
 92:             .navigationBarTitleDisplayMode(.inline)
 93:             .navigationTitle("Tap where you wish to add text")
 94:             Spacer()
 95:         }
 96:     }
 97:     
 98:     @ViewBuilder func getAnnotationViews(forPageIndex pageIndex: Int) -> some View {
 99:         ForEach(self.viewModel.getAnnotations(forPageIndex: pageIndex), id:\.self) { pageAnnotation in
100:             self.getView(forAnnotation: pageAnnotation)
101:         }
102:         if self.viewModel.editedPageIndex == pageIndex, let signatureImage = self.viewModel.signatureImage {
103:             ImageResizableView(
104:                 uiImage: signatureImage,
105:                 imageRect: self.$viewModel.signatureRect,
106:                 borderColor: ColorPalette.thirdText,
107:                 borderWidth: 2,
108:                 handleColor: ColorPalette.buttonGradientStart,
109:                 handleSize: 10,
110:                 handleTapSize: 50,
111:                 keepAspectRatio: true
112:             )
113:             .contextMenu {
114:                 Button(role: .destructive) {
115:                     self.viewModel.onDeleteAnnotationPressed()
116:                 } label: {
117:                     Text("Delete")
118:                 }
119:                 Button {
120:                     self.viewModel.onReplaceAnnotationPressed()
121:                 } label: {
122:                     Text("Replace")
123:                 }
124:             }
125:         }
126:     }
127:     
128:     @ViewBuilder func getView(forAnnotation annotation: PDFAnnotation) -> some View {
129:         if let page = annotation.page {
130:             GeometryReader { geometryReader in
131:                 let annotationBounds = self.viewModel.convertRect(annotation.bounds,
132:                                                                   viewSize: geometryReader.size,
133:                                                                   fromPage: page)
134:                 let position = CGPoint(x: annotationBounds.origin.x + annotationBounds.size.width / 2,
135:                                        y: annotationBounds.origin.y + annotationBounds.size.height / 2)
136:                 Image(uiImage: annotation.image)
137:                     .resizable()
138:                     .frame(width: annotationBounds.width, height: annotationBounds.height)
139:                     .position(position)
140:             }
141:         }
142:     }
143: }
144: 
145: struct PdfSignatureView_Previews: PreviewProvider {
146:     static var previews: some View {
147:         if let pdf = K.Test.DebugPdf {
148:             let inputParameter = PdfSignatureViewModel.InputParameter(pdf: pdf,
149:                                                                       currentPageIndex: 0,
150:                                                                       onConfirm: { _ in })
151:             AnyView(PdfSignatureView(viewModel: Container.shared.pdfSignatureViewModel(inputParameter)))
152:         } else {
153:             AnyView(Spacer())
154:         }
155:     }
156: }
```

## File: pdfexpert/Views/Review/PreReviewPopupLowRateView.swift
```swift
  1: //
  2: //  PreReviewPopupLowRateView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 31/08/23.
  6: //
  7: 
  8: import SwiftUI
  9: 
 10: typealias PreReviewLowRateSendFeedbackCallback = ((String) -> ())
 11: 
 12: struct PreReviewPopupLowRateView: View {
 13:     
 14:     @Binding var isPresenting: Bool
 15:     let onSendFeedback: PreReviewLowRateSendFeedbackCallback
 16:     
 17:     @State var feedbackText: String
 18:     @State var remainingCharactersText: String
 19:     
 20:     init(isPresenting: Binding<Bool>,
 21:          initialFeedbackText: String = "",
 22:          onSendFeedback: @escaping PreReviewLowRateSendFeedbackCallback) {
 23:         self._isPresenting = isPresenting
 24:         self.onSendFeedback = onSendFeedback
 25:         self._feedbackText = .init(initialValue: initialFeedbackText)
 26:         self._remainingCharactersText = .init(initialValue: Self.getRemainigCharactersText(forFeedbackText: initialFeedbackText))
 27:     }
 28:     
 29:     var body: some View {
 30:         ZStack {
 31:             self.getCloseButton(
 32:                 color: ColorPalette.primaryText,
 33:                 leftSide: false,
 34:                 padding: 12
 35:             ) {
 36:                 self.isPresenting = false
 37:             }
 38:             VStack(spacing: 0) {
 39:                 Spacer().frame(height: 12)
 40:                 Image("review_low_rate")
 41:                     .resizable()
 42:                     .scaledToFit()
 43:                     .frame(height: 60)
 44:                     .foregroundColor(ColorPalette.extra)
 45:                 Spacer().frame(height: 30)
 46:                 Text("Your opinion matter to us!")
 47:                     .font(forCategory: .headline)
 48:                     .foregroundColor(ColorPalette.primaryText)
 49:                     .frame(maxWidth: .infinity)
 50:                 Spacer().frame(height: 8)
 51:                 Text("Would you like to share your feedback with us to improve the app?")
 52:                     .font(forCategory: .body2)
 53:                     .foregroundColor(ColorPalette.primaryText)
 54:                     .multilineTextAlignment(.center)
 55:                     .frame(maxWidth: .infinity)
 56:                 Spacer().frame(height: 18)
 57:                 VStack(spacing: 0) {
 58:                     ZStack {
 59:                         TextEditor(text: self.$feedbackText)
 60:                             .font(forCategory: .caption1)
 61:                             .foregroundColor(ColorPalette.primaryText)
 62:                             .scrollContentBackground(.hidden)
 63:                             .overlay(RoundedRectangle(cornerRadius: 10)
 64:                                 .stroke(ColorPalette.primaryBG, lineWidth: 1))
 65:                             .onChange(of: self.feedbackText) { newValue in
 66:                                 let maxLength = K.Review.FeedbackMaxCharacters
 67:                                 if newValue.count > maxLength  {
 68:                                     self.feedbackText = String(newValue.prefix(maxLength))
 69:                                 }
 70:                                 self.remainingCharactersText = Self.getRemainigCharactersText(forFeedbackText: self.feedbackText)
 71:                             }
 72:                         if self.feedbackText.isEmpty {
 73:                             VStack {
 74:                                 Text("Write your feedback here")
 75:                                     .font(forCategory: .caption1)
 76:                                     .foregroundColor(ColorPalette.thirdText)
 77:                                     .frame(maxWidth: .infinity, alignment: .leading)
 78:                                 Spacer()
 79:                             }
 80:                             .padding(.leading, 6)
 81:                             .padding(.top, 8)
 82:                         }
 83:                         VStack(spacing: 0) {
 84:                             Spacer()
 85:                             Text(self.remainingCharactersText)
 86:                                 .font(forCategory: .caption2)
 87:                                 .foregroundColor(ColorPalette.thirdText)
 88:                                 .frame(maxWidth: .infinity, alignment: .trailing)
 89:                                 .padding(.trailing, 6)
 90:                                 .padding(.bottom, 8)
 91:                         }
 92:                     }
 93:                     .frame(height: 100)
 94:                 }
 95:                 Spacer().frame(height: 20)
 96:                 self.getDefaultButton(text: "Send Feedback") {
 97:                     self.onSendFeedback(self.feedbackText)
 98:                 }
 99:             }
100:             .padding(16)
101:         }
102:         .frame(width: 340)
103:         .fixedSize(horizontal: false, vertical: true)
104:         .background(ColorPalette.secondaryBG)
105:         .cornerRadius(8)
106:     }
107:     
108:     private static func getRemainigCharactersText(forFeedbackText feedbackText: String) -> String {
109:         let maxLength = K.Review.FeedbackMaxCharacters
110:         let remainingCharacters = feedbackText.count
111:         return "\(remainingCharacters)/\(maxLength)"
112:     }
113: }
114: 
115: extension View {
116:     func preReviewLowRatePopup(
117:         isPresenting: Binding<Bool>,
118:         onSendFeedback: @escaping PreReviewLowRateSendFeedbackCallback
119:     ) -> some View {
120:         self.popup(isPresenting: isPresenting,
121:                    popupContent: { PreReviewPopupLowRateView(isPresenting: isPresenting,
122:                                                              onSendFeedback: onSendFeedback) })
123:     }
124: }
125: 
126: struct PreReviewPopupLowRateView_Previews: PreviewProvider {
127:     static var previews: some View {
128:         PreReviewPopupLowRateView(
129:             isPresenting: .constant(true),
130:             onSendFeedback: { result in print("Feedback: \(result)") }
131:         )
132:     }
133: }
```

## File: pdfexpert/Views/Review/PreReviewPopupView.swift
```swift
 1: //
 2: //  PreReviewPopupView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 31/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: typealias PreReviewResultCallback = ((Int) -> ())
11: 
12: struct PreReviewPopupView: View {
13:     
14:     @Binding var isPresenting: Bool
15:     let onConfirm: PreReviewResultCallback
16:     
17:     @State var selectedRate: Int? = nil
18:     
19:     var body: some View {
20:         ZStack {
21:             self.getCloseButton(
22:                 color: ColorPalette.primaryText,
23:                 leftSide: false,
24:                 padding: 12
25:             ) {
26:                 self.isPresenting = false
27:             }
28:             VStack(spacing: 0) {
29:                 Spacer().frame(height: 40)
30:                 Text("Do you like our app?")
31:                     .font(forCategory: .headline)
32:                     .foregroundColor(ColorPalette.primaryText)
33:                     .frame(maxWidth: .infinity)
34:                 Spacer().frame(height: 8)
35:                 Text("Give us a quick rating so we\nknow how you like it")
36:                     .font(forCategory: .body2)
37:                     .foregroundColor(ColorPalette.primaryText)
38:                     .multilineTextAlignment(.center)
39:                     .frame(maxWidth: .infinity)
40:                 Spacer().frame(height: 30)
41:                 HStack(spacing: 10) {
42:                     ForEach(1..<6) { rateValue in
43:                         self.getRateView(forRateValue: rateValue)
44:                     }
45:                 }
46:                 .frame(height: 32)
47:                 Spacer().frame(height: 44)
48:             }
49:             .padding(16)
50:         }
51:         .frame(width: 340)
52:         .fixedSize(horizontal: false, vertical: true)
53:         .background(ColorPalette.secondaryBG)
54:         .cornerRadius(8)
55:     }
56:     
57:     private func getRateView(forRateValue rateValue: Int) -> some View {
58:         Button(action: { self.onRateTapped(withRateValue: rateValue) }) {
59:             Image(systemName: self.getRateSystemName(forRateValue: rateValue))
60:                 .resizable()
61:                 .frame(width: 32, height: 32)
62:                 .foregroundColor(ColorPalette.extra)
63:         }
64:     }
65:     
66:     private func getRateSystemName(forRateValue rateValue: Int) -> String {
67:         if let selectedRate, selectedRate >= rateValue {
68:             return "star.fill"
69:         } else {
70:             return "star"
71:         }
72:     }
73:     
74:     private func onRateTapped(withRateValue rateValue: Int) {
75:         self.selectedRate = rateValue
76:         self.onConfirm(rateValue)
77:     }
78: }
79: 
80: extension View {
81:     func preReviewPopup(
82:         isPresenting: Binding<Bool>,
83:         onConfirm: @escaping PreReviewResultCallback
84:     ) -> some View {
85:         self.popup(isPresenting: isPresenting,
86:                    popupContent: { PreReviewPopupView(isPresenting: isPresenting,
87:                                                       onConfirm: onConfirm) })
88:     }
89: }
90: 
91: struct PreReviewPopupView_Previews: PreviewProvider {
92:     static var previews: some View {
93:         PreReviewPopupView(
94:             isPresenting: .constant(true),
95:             onConfirm: { result in print("Result: \(result)") }
96:         )
97:     }
98: }
```

## File: pdfexpert/Views/Review/ReviewFlowView.swift
```swift
 1: //
 2: //  ReviewFlowView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 31/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct ReviewFlowView: ViewModifier {
11:     
12:     @ObservedObject var flow: ReviewFlow
13:     
14:     @Environment(\.requestReview) var requestReview
15: 
16:     func body(content: Content) -> some View {
17:         content
18:             .preReviewPopup(isPresenting: self.$flow.showPreReviewView,
19:                             onConfirm: { preReviewRate in
20:                 self.flow.onPreReviewRateSelected(preReviewRate: preReviewRate,
21:                                                   nativeReviewCallback: { self.requestReview() })
22:             })
23:             .preReviewLowRatePopup(isPresenting: self.$flow.showLowReviewView,
24:                                    onSendFeedback: { feedback in
25:                 self.flow.onPreReviewLowRateFeedbackSent(feedback: feedback)
26:             })
27:     }
28: }
29: 
30: extension View {
31:     func reviewFlowView(flow: ReviewFlow) -> some View {
32:         self.modifier(ReviewFlowView(flow: flow))
33:     }
34: }
```

## File: pdfexpert/Views/Scan/ScannerView.swift
```swift
 1: //
 2: //  ScannerView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 31/03/23.
 6: //
 7: 
 8: import SwiftUI
 9: import VisionKit
10: 
11: struct ScannerView: UIViewControllerRepresentable {
12:     
13:     let onScannerResult: ScannerResultCallback
14:     
15:     func makeUIViewController(context: Context) -> some UIViewController {
16:         let controller = VNDocumentCameraViewController()
17:         controller.delegate = context.coordinator
18:         return controller
19:     }
20:     
21:     func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) {}
22:     
23:     func makeCoordinator() -> ScannerViewCoordinator {
24:         ScannerViewCoordinator(onScannerResult: self.onScannerResult)
25:     }
26: }
27: 
28: struct ScannerResult {
29:     let scan: VNDocumentCameraScan
30: }
31: 
32: typealias ScannerResultCallback = (ScannerResult) -> ()
33: 
34: class ScannerViewCoordinator: NSObject, VNDocumentCameraViewControllerDelegate {
35:     
36:     let onScannerResult: ScannerResultCallback
37: 
38:     init(onScannerResult: @escaping ScannerResultCallback) {
39:         self.onScannerResult = onScannerResult
40:     }
41:     
42:     func documentCameraViewController(_ controller: VNDocumentCameraViewController,
43:                                       didFinishWith scan: VNDocumentCameraScan) {
44:         self.onScannerResult(ScannerResult(scan: scan))
45:     }
46: }
47: 
48: struct ScannerView_Previews: PreviewProvider {
49:     static var previews: some View {
50:         ScannerView(onScannerResult: { _ in })
51:     }
52: }
```

## File: pdfexpert/Views/Settings/SettingsView.swift
```swift
 1: //
 2: //  SettingsView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 03/04/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct DisclamerItem: Hashable {
12:     let text: String
13:     let urlString: String
14: }
15: 
16: struct SettingsView: View {
17:     
18:     @Environment(\.dismiss) var dismiss
19:     
20:     private let disclamers = [
21:         DisclamerItem(text: "Privacy policy", urlString: K.Misc.PrivacyPolicyUrlString),
22:         DisclamerItem(text: "Terms and conditions", urlString: K.Misc.TermsAndConditionsUrlString)
23:     ]
24:     
25:     var body: some View {
26:         List(self.disclamers, id: \.self) { disclamer in
27:             Link(destination: URL(string: disclamer.urlString)!) {
28:                 HStack {
29:                     Text(disclamer.text)
30:                         .font(forCategory: .body1)
31:                         .foregroundColor(ColorPalette.primaryText)
32:                     Spacer()
33:                     Self.getSystemChevron(color: ColorPalette.primaryText,
34:                                           directionRight: true)
35:                 }
36:             }
37:             .listRowSeparator(.hidden)
38:             .listRowBackground(Color(.clear))
39:         }
40:         .padding(.top, 16)
41:         .listStyle(.plain)
42:         .background(ColorPalette.primaryBG)
43:         .onAppear() {
44:             Container.shared.analyticsManager().track(event: .reportScreen(.settings))
45:         }
46:     }
47: }
48: 
49: struct SettingsView_Previews: PreviewProvider {
50:     static var previews: some View {
51:         SettingsView()
52:     }
53: }
```

## File: pdfexpert/Views/Subscription/SubscriptionErrorView.swift
```swift
 1: //
 2: //  SubscriptionErrorView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 03/04/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct SubscriptionErrorView: View {
11:     
12:     var onButtonPressed: () -> ()
13:     
14:     var body: some View {
15:         VStack(spacing: 16) {
16:             Spacer()
17:             Image("subscription_error")
18:                 .resizable()
19:                 .aspectRatio(contentMode: .fit)
20:                 .frame(height: 80)
21:             Text("Oh Know!")
22:                 .font(forCategory: .largeTitle)
23:                 .foregroundColor(ColorPalette.primaryText)
24:                 .frame(maxWidth: .infinity, alignment: .center)
25:             Text("Something went wrong,\n Please try again.")
26:                 .font(forCategory: .body1)
27:                 .foregroundColor(ColorPalette.primaryText)
28:                 .multilineTextAlignment(.center)
29:                 .frame(maxWidth: .infinity, alignment: .center)
30:             Spacer()
31:             self.getDefaultButton(text: "Retry",
32:                                   onButtonPressed: self.onButtonPressed)
33:         }
34:         .padding([.leading, .trailing], 16)
35:         .padding([.top, .bottom], 64)
36:     }
37: }
38: 
39: struct SubscriptionErrorView_Previews: PreviewProvider {
40:     static var previews: some View {
41:         SubscriptionErrorView(onButtonPressed: {})
42:             .background(ColorPalette.primaryBG)
43:     }
44: }
```

## File: pdfexpert/Views/Subscription/SubscriptionFreeTrialToggleView.swift
```swift
 1: //
 2: //  SubscriptionFreeTrialToggleView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 09/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct SubscriptionFreeTrialToggleView: View {
11:     
12:     @Binding var isFreeTrial: Bool
13:     
14:     var body: some View {
15:         Button(action: {
16:             self.isFreeTrial.toggle()
17:         }) {
18:             HStack {
19:                 self.freeTrialDescriptionView
20:                 self.checkmark
21:             }
22:             .padding([.leading, .trailing], 16)
23:         }
24:         .frame(maxWidth: .infinity)
25:         .frame(height: 62)
26:         .background(RoundedRectangle(cornerRadius: 10)
27:             .foregroundColor(ColorPalette.secondaryBG))
28:         .overlay(RoundedRectangle(cornerRadius: 10)
29:             .stroke(self.isFreeTrial ? ColorPalette.buttonGradientStart : .clear, lineWidth: 2))
30:     }
31:     
32:     var freeTrialDescriptionView: some View {
33:         return VStack(spacing: 0) {
34:             Text("Not sure yet?")
35:                 .font(forCategory: .body1)
36:                 .foregroundColor(ColorPalette.primaryText)
37:                 .frame(maxWidth: .infinity, alignment: .leading)
38:             Spacer().frame(height: 4)
39:             Text("Enable the free trial")
40:                 .font(forCategory: .caption1)
41:                 .foregroundColor(ColorPalette.primaryText)
42:                 .frame(maxWidth: .infinity, alignment: .leading)
43:         }
44:     }
45:     
46:     var checkmark: some View {
47:         Group {
48:             if self.isFreeTrial {
49:                 Image(systemName: "checkmark.circle")
50:                     .resizable()
51:                     .foregroundColor(ColorPalette.buttonGradientStart)
52:             } else {
53:                 Image(systemName: "circle")
54:                     .resizable()
55:                     .foregroundColor(ColorPalette.thirdText)
56:             }
57:         }.frame(width: 22, height: 22)
58:     }
59: }
60: 
61: struct SubscriptionFreeTrialToggleView_Previews: PreviewProvider {
62:     static var previews: some View {
63:         SubscriptionFreeTrialToggleView(isFreeTrial: .constant(true))
64:     }
65: }
```

## File: pdfexpert/Views/Subscription/SubscriptionPairsItemView.swift
```swift
 1: //
 2: //  SubscriptionPairsItemView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 31/03/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct SubscriptionPairsItemView: View {
11:     
12:     let subscriptionPlan: SubscriptionPlanPairItem
13:     let isSelected: Bool
14:     let onTap: (() -> ())
15:     
16:     var body: some View {
17:         Button(action: {
18:             self.onTap()
19:         }) {
20:             VStack(spacing: 0) {
21:                 HStack(alignment: .top, spacing: 12) {
22:                     Text(self.subscriptionPlan.title)
23:                         .font(forCategory: .body1)
24:                         .foregroundColor(ColorPalette.primaryText)
25:                         .frame(maxWidth: 110, alignment: .leading)
26:                         .multilineTextAlignment(.leading)
27:                     Spacer()
28:                     self.checkmark
29:                 }
30:                 Spacer().frame(height: 6)
31:                 Text("Maximum flexibility, you decide when to cancel")
32:                     .font(forCategory: .caption2)
33:                     .foregroundColor(ColorPalette.thirdText)
34:                     .frame(maxWidth: .infinity, alignment: .leading)
35:                     .multilineTextAlignment(.leading)
36:                 Spacer(minLength: 12)
37:                 Text(self.subscriptionPlan.weeklyPriceAndPeriod)
38:                     .font(forCategory: .caption2)
39:                     .foregroundColor(ColorPalette.thirdText)
40:                     .frame(maxWidth: .infinity, alignment: .leading)
41:             }
42:             .frame(maxWidth: .infinity)
43:             .padding([.leading, .trailing, .top], 12)
44:             .padding(.bottom, 16)
45:         }
46:         .frame(maxWidth: .infinity)
47:         .background(RoundedRectangle(cornerRadius: 10).foregroundColor(ColorPalette.secondaryBG))
48:         .overlay(RoundedRectangle(cornerRadius: 10)
49:             .stroke(self.isSelected ? ColorPalette.buttonGradientStart : ColorPalette.thirdText, lineWidth: 2))
50:     }
51:     
52:     var checkmark: some View {
53:         Group {
54:             if self.isSelected {
55:                 AnyView(Image(systemName: "checkmark.circle")
56:                     .resizable()
57:                     .foregroundColor(ColorPalette.buttonGradientStart))
58:             } else {
59:                 AnyView(Spacer())
60:             }
61:         }.frame(width: 22, height: 22)
62:     }
63: }
64: 
65: struct SubscriptionPairsItemView_Previews: PreviewProvider {
66:     
67:     private static let subscriptionPlanYearly = {
68:         SubscriptionPlanPairItem(product: nil,
69:                                  title: "Premium 1 year",
70:                                  weeklyPriceAndPeriod: "$1,38/week",
71:                                  fullDescriptionText: "")
72:     }()
73:     private static let subscriptionPlanMonthly = {
74:         SubscriptionPlanPairItem(product: nil,
75:                                  title: "Premium 1 month",
76:                                  weeklyPriceAndPeriod: "$2,09/week",
77:                                  fullDescriptionText: "")
78:     }()
79:     
80:     static var previews: some View {
81:         HStack(spacing: 16) {
82:             SubscriptionPairsItemView(subscriptionPlan: Self.subscriptionPlanYearly,
83:                                  isSelected: true,
84:                                  onTap: {})
85:             SubscriptionPairsItemView(subscriptionPlan: Self.subscriptionPlanMonthly,
86:                                  isSelected: false,
87:                                  onTap: {})
88:         }
89:         .padding([.leading, .trailing], 16)
90:         .frame(minHeight: 161, maxHeight: 200)
91:     }
92: }
```

## File: pdfexpert/Views/Subscription/SubscriptionPairsView.swift
```swift
  1: //
  2: //  SubscriptionPairsView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 31/03/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct SubscriptionPairsView: View {
 12:     
 13:     @InjectedObject(\.subscribtionPairsViewModel) var viewModel
 14:     var onComplete: () -> ()
 15:     
 16:     var body: some View {
 17:         ZStack {
 18:             self.getCloseButton(color: ColorPalette.primaryText.opacity(0.3)) {
 19:                 self.onComplete()
 20:             }
 21:             self.content
 22:         }
 23:         .background(ColorPalette.primaryBG)
 24:         .asyncView(asyncOperation: self.$viewModel.purchaseRequest)
 25:         .asyncView(asyncOperation: self.$viewModel.restorePurchaseRequest)
 26:         .onAppear() {
 27:             self.viewModel.onAppear()
 28:         }
 29:         .onChange(of: self.viewModel.isPremium, perform: { newValue in
 30:             if newValue {
 31:                 self.onComplete()
 32:             }
 33:         })
 34:     }
 35:     
 36:     var content: some View {
 37:         switch self.viewModel.asyncSubscriptionPlanPairs.status {
 38:         case .empty: return AnyView(Spacer())
 39:         case .loading: return AnyView(AnimationType.dots.view)
 40:         case .data: return AnyView(self.mainView)
 41:         case .error: return AnyView(SubscriptionErrorView(onButtonPressed: {
 42:             self.viewModel.refresh()
 43:         }))
 44:         }
 45:     }
 46:     
 47:     var mainView: some View {
 48:         VStack(spacing: 0) {
 49:             self.restorePurchaseButton
 50:             VStack(spacing: 0) {
 51:                 Spacer()
 52:                 Spacer().frame(height: 20)
 53:                 Image("logo_large")
 54:                     .resizable()
 55:                     .aspectRatio(contentMode: .fit)
 56:                     .frame(maxHeight: 400)
 57:                 Spacer().frame(height: 20)
 58:                 Spacer()
 59:             }
 60:             VStack(spacing: 0) {
 61:                 Text(K.Misc.AppTitle)
 62:                     .font(forCategory: .largeTitle)
 63:                     .foregroundColor(ColorPalette.primaryText)
 64:                     .frame(maxWidth: .infinity, alignment: .leading)
 65:                 Spacer().frame(height: 16)
 66:                 Text("Edit, convert PDFs and receive constant updates and advanced Premium features. ")
 67:                     .font(forCategory: .body1)
 68:                     .foregroundColor(ColorPalette.primaryText)
 69:                     .lineLimit(2)
 70:                     .minimumScaleFactor(0.5)
 71:                     .frame(maxWidth: .infinity, alignment: .leading)
 72:                     .multilineTextAlignment(.leading)
 73:             }
 74:             VStack(spacing: 0) {
 75:                 Spacer().frame(height: 42)
 76:                 self.subscriptionPlanPairsView
 77:                 Spacer().frame(height: 16)
 78:             }
 79:             self.freeTrialView
 80:             self.getDefaultButton(text: "Continue",
 81:                                   onButtonPressed: { self.viewModel.subscribe() })
 82:             self.currentSubscriptionPlanView
 83:         }
 84:         .padding([.leading, .trailing], 16)
 85:     }
 86:     
 87:     var restorePurchaseButton: some View {
 88:         Button(action: { self.viewModel.restorePurchases() }) {
 89:             Text("Restore purchase")
 90:                 .frame(maxHeight: .infinity)
 91:                 .underline()
 92:                 .font(forCategory: .linkText)
 93:                 .foregroundColor(ColorPalette.primaryText)
 94:         }
 95:         .frame(maxWidth: .infinity)
 96:         .frame(height: 44)
 97:     }
 98:     
 99:     private var freeTrialView: some View {
100:         VStack(spacing: 0) {
101:             if let currentSubscriptionPlanPair = self.viewModel.currentSubscriptionPlanPair,
102:                currentSubscriptionPlanPair.standardSubscriptionPlan != nil,
103:                currentSubscriptionPlanPair.freeTrialSubscriptionPlan != nil {
104:                 SubscriptionFreeTrialToggleView(isFreeTrial: self.$viewModel.isFreeTrialEnabled)
105:                 Spacer().frame(height: 20)
106:             }
107:         }
108:     }
109:     
110:     var currentSubscriptionPlanView: some View {
111:         Text(self.viewModel.currentSubscriptionPlan?.fullDescriptionText ?? "")
112:             .font(forCategory: .headline)
113:             .foregroundColor(ColorPalette.primaryText)
114:             .frame(maxWidth: .infinity, alignment: .center)
115:             .frame(height: 40)
116:             .minimumScaleFactor(0.5)
117:     }
118:     
119:     var subscriptionPlanPairsView: some View {
120:         if let subscriptionPlanPairs = self.viewModel.asyncSubscriptionPlanPairs.data {
121:             return AnyView(HStack(spacing: 16) {
122:                 ForEach(Array(subscriptionPlanPairs.enumerated()), id: \.offset) { index, subscriptionPlanPair in
123:                     if let subscriptionPlan = self.getSubscriptionPlan(from: subscriptionPlanPair) {
124:                         SubscriptionPairsItemView(subscriptionPlan: subscriptionPlan,
125:                                              isSelected: self.viewModel.selectedSubscriptionPairIndex == index,
126:                                              onTap: { self.viewModel.selectedSubscriptionPairIndex = index })
127:                     }
128:                 }
129:             }
130:                 .frame(minHeight: 161, maxHeight: 200))
131:         } else {
132:             return AnyView(Spacer().frame(height: 1))
133:         }
134:     }
135:     
136:     func getSubscriptionPlan(from subscriptionPlanPair: SubscriptionPairsViewModel.PlanPair) -> SubscriptionPlanPairItem? {
137:         if self.viewModel.isFreeTrialEnabled {
138:             return subscriptionPlanPair.freeTrialSubscriptionPlan ?? subscriptionPlanPair.standardSubscriptionPlan
139:         } else {
140:             return subscriptionPlanPair.standardSubscriptionPlan ?? subscriptionPlanPair.freeTrialSubscriptionPlan
141:         }
142:     }
143: }
144: 
145: struct SubscriptionPairsView_Previews: PreviewProvider {
146:     static var previews: some View {
147:         SubscriptionPairsView(onComplete: {})
148:     }
149: }
```

## File: pdfexpert/Views/Subscription/SubscriptionPickerPlanListView.swift
```swift
 1: //
 2: //  SubscriptionPickerPlanListView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 10/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct SubscriptionPickerPlanListView: View {
12:     
13:     @ObservedObject var viewModel: SubscriptionPickerViewModel
14:     @Environment(\.dismiss) var dismiss
15:     
16:     var body: some View {
17:         VStack(spacing: 0) {
18:             Text("Choose period")
19:                 .font(forCategory: .button)
20:                 .foregroundColor(ColorPalette.primaryText)
21:                 .frame(maxWidth: .infinity, alignment: .leading)
22:             Spacer().frame(height: 20)
23:             ForEach(Array(self.viewModel.subscriptionPlans.enumerated()), id: \.offset) { index, item in
24:                 VStack(spacing: 0) {
25:                     self.getSubscriptionPlan(subscriptionPlan: item, index: index)
26:                     Spacer().frame(height: 21)
27:                 }
28:             }
29:         }
30:         .padding([.leading, .trailing], 16)
31:         .padding(.top, 20)
32:     }
33:     
34:     private func getSubscriptionPlan(subscriptionPlan: SubscriptionPlanPickerItem,
35:                                      index: Int) -> some View {
36:         ZStack {
37:             Button(action: {
38:                 self.dismiss()
39:                 self.viewModel.selectedSubscriptionPairIndex = index
40:             }) {
41:                 HStack(spacing: 0) {
42:                     Text(subscriptionPlan.period + " |")
43:                         .font(forCategory: .button)
44:                         .foregroundColor(ColorPalette.primaryText)
45:                     Spacer().frame(width: 6)
46:                     Text(subscriptionPlan.priceText)
47:                         .font(forCategory: .button)
48:                         .foregroundColor(ColorPalette.thirdText)
49:                     Spacer()
50:                     Text(subscriptionPlan.weeklyPriceAndPeriod)
51:                         .font(forCategory: .caption1)
52:                         .foregroundColor(ColorPalette.thirdText)
53:                 }
54:                 .padding(16)
55:             }
56:             .overlay(RoundedRectangle(cornerRadius: 10)
57:                 .stroke(
58:                     self.viewModel.selectedSubscriptionPairIndex == index
59:                     ? ColorPalette.buttonGradientStart
60:                     : ColorPalette.fourthText,
61:                     lineWidth: self.viewModel.selectedSubscriptionPairIndex == index ? 2 : 1)
62:             )
63:             if let bestDiscountText = subscriptionPlan.bestDiscountText {
64:                 HStack {
65:                     Spacer()
66:                     GeometryReader { geometry in
67:                         HStack {
68:                             Spacer()
69:                             Text(bestDiscountText)
70:                                 .font(forCategory: .callout)
71:                                 .foregroundColor(.black)
72:                                 .frame(alignment: .trailing)
73:                                 .padding([.leading, .trailing], 6)
74:                                 .padding([.bottom, .top], 2)
75:                                 .background(ColorPalette.extra)
76:                                 .cornerRadius(2)
77:                         }.position(x: geometry.size.width/2, y: 0)
78:                     }
79:                 }
80:                 .padding([.trailing], 16)
81:             }
82:         }
83:         .padding([.leading, .trailing], 1)
84:         .frame(maxWidth: .infinity)
85:         .frame(height: 48)
86:     }
87: }
88: 
89: struct SubscriptionPickerPlanListView_Previews: PreviewProvider {
90:     static var previews: some View {
91:         Color.white
92:             .sheetAutoHeight(isPresented: .constant(true),
93:                              backgroundColor: ColorPalette.secondaryBG,
94:                              topCornerRadius: 10) {
95:                 SubscriptionPickerPlanListView(viewModel: Container.shared.subscriptionPickerViewModel())
96:             }
97:     }
98: }
```

## File: pdfexpert/Views/Subscription/SubscriptionPickerPlanView.swift
```swift
 1: //
 2: //  SubscriptionPickerPlanView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 09/08/23.
 6: //
 7: 
 8: import SwiftUI
 9: 
10: struct SubscriptionPickerPlanView: View {
11:     
12:     let subscriptionPlanPickerItem: SubscriptionPlanPickerItem?
13:     let pickerButtonPressed: () -> ()
14:     
15:     var body: some View {
16:         Group {
17:             VStack(spacing: 0) {
18:                 HStack(alignment: .top, spacing: 12) {
19:                     Text(self.subscriptionPlanPickerItem?.title ?? "")
20:                         .font(forCategory: .body1)
21:                         .foregroundColor(ColorPalette.primaryText)
22:                         .multilineTextAlignment(.leading)
23:                     Spacer()
24:                     self.checkmark
25:                 }
26:                 Spacer()
27:                 Text("Maximum flexibility, you decide\nhow long to stay")
28:                     .font(forCategory: .caption2)
29:                     .foregroundColor(ColorPalette.thirdText)
30:                     .frame(maxWidth: .infinity, alignment: .leading)
31:                     .multilineTextAlignment(.leading)
32:                 Spacer()
33:                 HStack {
34:                     Text(self.subscriptionPlanPickerItem?.weeklyPriceAndPeriod ?? "")
35:                         .font(forCategory: .caption2)
36:                         .foregroundColor(ColorPalette.primaryText)
37:                         .frame(maxWidth: .infinity, alignment: .leading)
38:                     self.pickerView
39:                 }
40:             }
41:             .padding(16)
42:         }
43:         .frame(maxWidth: .infinity)
44:         .frame(height: 134)
45:         .background(RoundedRectangle(cornerRadius: 10).foregroundColor(ColorPalette.secondaryBG))
46:         .overlay(RoundedRectangle(cornerRadius: 10)
47:             .stroke(ColorPalette.buttonGradientStart, lineWidth: 2))
48:         .padding([.leading, .trailing], 1)
49:     }
50:     
51:     private var checkmark: some View {
52:         ZStack {
53:             Circle().fill(.white)
54:                 .padding(4)
55:             Image(systemName: "checkmark.circle.fill")
56:                 .resizable()
57:                 .foregroundColor(ColorPalette.buttonGradientStart)
58:         }.frame(width: 24, height: 24)
59:     }
60:     
61:     private var pickerView: some View {
62:         Button(action: { self.pickerButtonPressed() }) {
63:             HStack(spacing: 12) {
64:                 Text(self.subscriptionPlanPickerItem?.period ?? "")
65:                     .font(forCategory: .callout)
66:                     .foregroundColor(ColorPalette.primaryText)
67:                 Image(systemName: "chevron.down")
68:                     .foregroundColor(ColorPalette.primaryText)
69:             }
70:             .padding(.leading, 21)
71:             .padding(.trailing, 16)
72:         }
73:         .frame(height: 26)
74:         .background(Capsule().foregroundColor(ColorPalette.buttonGradientStart))
75:     }
76: }
77: 
78: struct SubscriptionPickerPlanView_Previews: PreviewProvider {
79:     
80:     private static let subscriptionPlanYearly = {
81:         SubscriptionPlanPickerItem(
82:             product: nil,
83:             title: "Premium 1 year",
84:             period: "Yearly",
85:             weeklyPriceAndPeriod: "$1,38/week",
86:             fullDescriptionText: "Free for 7 days, then $89.99/year",
87:             priceText: "$89.99",
88:             bestDiscountText: "53% DISCOUNT"
89:         )
90:     }()
91:     
92:     static var previews: some View {
93:         SubscriptionPickerPlanView(subscriptionPlanPickerItem: Self.subscriptionPlanYearly,
94:                                    pickerButtonPressed: { print("Picker Button Pressed") })
95:     }
96: }
```

## File: pdfexpert/Views/Subscription/SubscriptionPickerView.swift
```swift
  1: //
  2: //  SubscriptionPickerView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 08/08/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct SubscriptionPickerView: View {
 12:     
 13:     fileprivate struct SubscriptionFeature: Hashable {
 14:         let imageName: String
 15:         let text: String
 16:     }
 17:     
 18:     private let subscriptionFeatures: [SubscriptionFeature] = [
 19:         SubscriptionFeature(imageName: "subscription_feature_convert",
 20:                        text: "Convert file to PDF"),
 21:         SubscriptionFeature(imageName: "subscription_feature_chat_pdf",
 22:                        text: "Ask any question to PDF and get insights fast"),
 23:         SubscriptionFeature(imageName: "subscription_feature_signature",
 24:                        text: "Enter and edit your signature"),
 25:         SubscriptionFeature(imageName: "subscription_feature_password",
 26:                        text: "Protect your files with password"),
 27:         SubscriptionFeature(imageName: "subscription_feature_edit",
 28:                        text: "Edit, save and share your PDF"),
 29:     ]
 30:     
 31:     @InjectedObject(\.subscriptionPickerViewModel) var viewModel
 32:     
 33:     @State var showPlansPicker: Bool = false
 34:     
 35:     var onComplete: () -> ()
 36:     
 37:     var body: some View {
 38:         ZStack {
 39:             self.getCloseButton(color: ColorPalette.primaryText.opacity(0.3)) {
 40:                 self.onComplete()
 41:             }
 42:             self.content
 43:         }
 44:         .background(ColorPalette.primaryBG)
 45:         .asyncView(asyncItem: self.$viewModel.purchaseRequest)
 46:         .asyncView(asyncItem: self.$viewModel.restorePurchaseRequest)
 47:         .onAppear() {
 48:             self.viewModel.onAppear()
 49:         }
 50:         .sheetAutoHeight(isPresented: self.$showPlansPicker,
 51:                          backgroundColor: ColorPalette.secondaryBG,
 52:                          topCornerRadius: 10,
 53:                          content: {
 54:             SubscriptionPickerPlanListView(viewModel: self.viewModel)
 55:         })
 56:         .onChange(of: self.viewModel.isPremium, perform: { newValue in
 57:             if newValue {
 58:                 self.onComplete()
 59:             }
 60:         })
 61:     }
 62:     
 63:     @ViewBuilder var content: some View {
 64:         switch self.viewModel.asyncSubscriptionPlanPairs.status {
 65:         case .empty: Spacer()
 66:         case .loading: AnimationType.dots.view
 67:         case .data: self.mainView
 68:         case .error: SubscriptionErrorView(onButtonPressed: {
 69:             self.viewModel.refresh()
 70:         })
 71:         }
 72:     }
 73:     
 74:     var mainView: some View {
 75:         VStack(spacing: 0) {
 76:             self.restorePurchaseButton
 77:             ScrollView {
 78:                 VStack(spacing: 0) {
 79:                     Spacer().frame(height: 26)
 80:                     Text("Choose a plan")
 81:                         .font(forCategory: .body1)
 82:                         .foregroundColor(ColorPalette.primaryText)
 83:                         .frame(maxWidth: .infinity, alignment: .leading)
 84:                     Spacer().frame(height: 26)
 85:                     SubscriptionPickerPlanView(subscriptionPlanPickerItem: self.viewModel.currentSubscriptionPlan,
 86:                                                pickerButtonPressed: {
 87:                         self.showPlansPicker = true
 88:                     })
 89:                     Spacer().frame(height: 20)
 90:                     Spacer()
 91:                 }
 92:                 VStack(spacing: 0) {
 93:                     Text("What you get")
 94:                         .font(forCategory: .body1)
 95:                         .foregroundColor(ColorPalette.primaryText)
 96:                         .frame(maxWidth: .infinity, alignment: .leading)
 97:                     Spacer().frame(height: 16)
 98:                     ForEach(self.subscriptionFeatures, id:\.self) { feature in
 99:                         VStack(spacing: 0) {
100:                             self.getSubscriptionFeature(feature: feature)
101:                             ColorPalette.fourthText.frame(height: 1)
102:                         }
103:                     }
104:                 }
105:             }
106:             .scrollIndicators(.hidden)
107:             VStack(spacing: 0) {
108:                 self.freeTrialView
109:                 self.getDefaultButton(text: "Continue",
110:                                       onButtonPressed: { self.viewModel.subscribe() })
111:                 self.currentSubscriptionPlanView
112:             }
113:             .background(ColorPalette.primaryBG)
114:             .padding(.top, 16)
115:         }
116:         .padding([.leading, .trailing], 16)
117:     }
118:     
119:     private var restorePurchaseButton: some View {
120:         Button(action: { self.viewModel.restorePurchases() }) {
121:             Text("Restore purchase")
122:                 .frame(maxHeight: .infinity)
123:                 .underline()
124:                 .font(forCategory: .linkText)
125:                 .foregroundColor(ColorPalette.primaryText)
126:         }
127:         .frame(maxWidth: .infinity)
128:         .frame(height: 44)
129:     }
130:     
131:     private func getSubscriptionFeature(feature: SubscriptionFeature) -> some View {
132:         HStack(spacing: 16) {
133:             Image(feature.imageName)
134:                 .resizable()
135:                 .aspectRatio(contentMode: .fit)
136:                 .frame(width: 20, height: 20)
137:             Text(feature.text)
138:                 .font(forCategory: .caption1)
139:                 .foregroundColor(ColorPalette.primaryText)
140:                 .frame(maxWidth: .infinity, alignment: .leading)
141:             Image(systemName: "checkmark.circle")
142:                 .font(.system(size: 22).bold())
143:                 .foregroundColor(ColorPalette.buttonGradientStart)
144:         }
145:         .frame(height: 52)
146:     }
147:     
148:     private var freeTrialView: some View {
149:         VStack(spacing: 0) {
150:             if let currentSubscriptionPlanPair = self.viewModel.currentSubscriptionPlanPair,
151:                currentSubscriptionPlanPair.standardSubscriptionPlan != nil,
152:                currentSubscriptionPlanPair.freeTrialSubscriptionPlan != nil {
153:                 SubscriptionFreeTrialToggleView(isFreeTrial: self.$viewModel.isFreeTrialEnabled)
154:                 Spacer().frame(height: 20)
155:             }
156:         }
157:     }
158:     
159:     private var currentSubscriptionPlanView: some View {
160:         Text(self.viewModel.currentSubscriptionPlan?.fullDescriptionText ?? "")
161:             .font(forCategory: .headline)
162:             .foregroundColor(ColorPalette.primaryText)
163:             .frame(maxWidth: .infinity, alignment: .center)
164:             .frame(height: 40)
165:             .minimumScaleFactor(0.5)
166:     }
167: }
168: 
169: struct SubscriptionPickerView_Previews: PreviewProvider {
170:     static var previews: some View {
171:         SubscriptionPickerView(onComplete: {})
172:     }
173: }
```

## File: pdfexpert/Views/Subscription/SubscriptionVerticalItemView.swift
```swift
  1: //
  2: //  SubscriptionVerticalItemView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 12/04/23.
  6: //
  7: 
  8: import SwiftUI
  9: 
 10: struct SubscriptionVerticalItemView: View {
 11:     
 12:     let subscriptionPlan: SubscriptionPlanVerticalItem
 13:     let isSelected: Bool
 14:     let onTap: (() -> ())
 15:     
 16:     var body: some View {
 17:         Button(action: {
 18:             self.onTap()
 19:         }) {
 20:             ZStack {
 21:                 HStack(spacing: 12) {
 22:                     self.checkmark
 23:                     VStack(spacing: 4) {
 24:                         if let freeTrialText = self.subscriptionPlan.freeTrialText {
 25:                             Text(freeTrialText)
 26:                                 .font(forCategory: .body1)
 27:                                 .foregroundColor(ColorPalette.extra)
 28:                                 .frame(maxWidth: .infinity, alignment: .leading)
 29:                                 .lineLimit(1)
 30:                         }
 31:                         Text(self.subscriptionPlan.titleShort)
 32:                             .font(forCategory: .body2)
 33:                             .foregroundColor(ColorPalette.primaryText)
 34:                             .frame(maxWidth: .infinity, alignment: .leading)
 35:                             .lineLimit(1)
 36:                         if let discountText = self.subscriptionPlan.discountText {
 37:                             Text(discountText)
 38:                                 .font(forCategory: .caption2)
 39:                                 .foregroundColor(ColorPalette.thirdText)
 40:                                 .frame(maxWidth: .infinity, alignment: .leading)
 41:                                 .lineLimit(1)
 42:                         }
 43:                     }
 44:                 }
 45:                 .padding([.leading, .trailing], 16)
 46:                 .frame(maxHeight: .infinity)
 47:                 .background(RoundedRectangle(cornerRadius: 10).foregroundColor(isSelected ? ColorPalette.secondaryBG : .clear))
 48:                 .overlay(RoundedRectangle(cornerRadius: 10).stroke(
 49:                     ColorPalette.secondaryBG,
 50:                     lineWidth: 2)
 51:                 )
 52:                 if let bestDiscountText = self.subscriptionPlan.bestDiscountText {
 53:                     HStack {
 54:                         Spacer()
 55:                         GeometryReader { geometry in
 56:                             HStack {
 57:                                 Spacer()
 58:                                 Text(bestDiscountText)
 59:                                     .font(forCategory: .callout)
 60:                                     .foregroundColor(.black)
 61:                                     .frame(alignment: .trailing)
 62:                                     .padding([.leading, .trailing], 6)
 63:                                     .padding([.bottom, .top], 2)
 64:                                     .background(ColorPalette.extra)
 65:                                     .cornerRadius(2)
 66:                             }.position(x: geometry.size.width/2, y: 0)
 67:                         }
 68:                     }
 69:                     .padding([.trailing], 16)
 70:                 }
 71:             }
 72:         }
 73:         .frame(minHeight: self.viewHeight)
 74:     }
 75:     
 76:     var viewHeight: CGFloat {
 77:         self.subscriptionPlan.freeTrialText != nil ? 86 : 76
 78:     }
 79:     
 80:     var checkmark: some View {
 81:         ZStack {
 82:             if self.isSelected {
 83:                 Image(systemName: "circle.fill")
 84:                     .resizable()
 85:                     .foregroundColor(.white)
 86:                 Image(systemName: "checkmark.circle.fill")
 87:                     .resizable()
 88:                     .foregroundColor(ColorPalette.buttonGradientStart)
 89:             } else {
 90:                 Image(systemName: "circle")
 91:                     .resizable()
 92:                     .foregroundColor(ColorPalette.fourthText)
 93:             }
 94:         }.frame(width: 24, height: 24)
 95:     }
 96: }
 97: 
 98: struct SubscriptionVerticalItemView_Previews: PreviewProvider {
 99:     private static let subscriptionPlanYearly = {
100:         SubscriptionPlanVerticalItem(product: nil,
101:                                      titleShort: "Yearly",
102:                                      weeklyPriceAndPeriod: "$1,38/week",
103:                                      fullDescriptionText: "Free for 7 days, then $89.99/year",
104:                                      freeTrialText: "FREE TRIAL for 7 days",
105:                                      bestDiscountText: "53% DISCOUNT",
106:                                      discountText: "12 months at $1.99, save 53%"
107:         )
108:     }()
109:     private static let subscriptionPlanMonthly = {
110:         SubscriptionPlanVerticalItem(product: nil,
111:                                      titleShort: "Monthly",
112:                                      weeklyPriceAndPeriod: "$2,47/week",
113:                                      fullDescriptionText: "$89.99/month",
114:                                      freeTrialText: nil,
115:                                      bestDiscountText: nil,
116:                                      discountText: "4 weeks at $1.92, save 20%"
117:         )
118:     }()
119:     private static let subscriptionPlanWeekly = {
120:         SubscriptionPlanVerticalItem(product: nil,
121:                                      titleShort: "Weekly",
122:                                      weeklyPriceAndPeriod: "$4,99/week",
123:                                      fullDescriptionText: "$4,99/week",
124:                                      freeTrialText: nil,
125:                                      bestDiscountText: nil,
126:                                      discountText: nil
127:         )
128:     }()
129:     
130:     static var previews: some View {
131:         VStack(spacing: 16) {
132:             Spacer()
133:             SubscriptionVerticalItemView(subscriptionPlan: Self.subscriptionPlanYearly,
134:                                  isSelected: true,
135:                                  onTap: {})
136:             SubscriptionVerticalItemView(subscriptionPlan: Self.subscriptionPlanMonthly,
137:                                  isSelected: false,
138:                                  onTap: {})
139:             SubscriptionVerticalItemView(subscriptionPlan: Self.subscriptionPlanWeekly,
140:                                  isSelected: false,
141:                                  onTap: {})
142:             Spacer()
143:         }
144:         .padding([.leading, .trailing], 16)
145:         .background(ColorPalette.primaryBG)
146:     }
147: }
```

## File: pdfexpert/Views/Subscription/SubscriptionVerticalView.swift
```swift
  1: //
  2: //  SubscriptionVerticalView.swift
  3: //  PdfExpert
  4: //
  5: //  Created by Pcnaid Inc on 12/04/23.
  6: //
  7: 
  8: import SwiftUI
  9: import Factory
 10: 
 11: struct SubscriptionVerticalView: View {
 12:     
 13:     @StateObject var viewModel: SubscriptionVerticalViewModel
 14:     
 15:     var onComplete: () -> ()
 16:     
 17:     var body: some View {
 18:         ZStack {
 19:             self.getCloseButton(color: ColorPalette.primaryText.opacity(0.3)) {
 20:                 self.onComplete()
 21:             }
 22:             self.content
 23:         }
 24:         .background(ColorPalette.primaryBG)
 25:         .asyncView(asyncOperation: self.$viewModel.purchaseRequest)
 26:         .asyncView(asyncOperation: self.$viewModel.restorePurchaseRequest)
 27:         .onAppear() {
 28:             self.viewModel.onAppear()
 29:         }
 30:         .onChange(of: self.viewModel.isPremium, perform: { newValue in
 31:             if newValue {
 32:                 self.onComplete()
 33:             }
 34:         })
 35:     }
 36:     
 37:     var content: some View {
 38:         switch self.viewModel.asyncSubscriptionPlanList.status {
 39:         case .empty: return AnyView(Spacer())
 40:         case .loading: return AnyView(AnimationType.dots.view)
 41:         case .data: return AnyView(self.mainView)
 42:         case .error: return AnyView(SubscriptionErrorView(onButtonPressed: {
 43:             self.viewModel.refresh()
 44:         }))
 45:         }
 46:     }
 47:     
 48:     var mainView: some View {
 49:         VStack(spacing: 0) {
 50:             self.restorePurchaseButton
 51:             VStack(spacing: 0) {
 52:                 Spacer()
 53:                 Spacer().frame(height: 20)
 54:                 Image("logo_large")
 55:                     .resizable()
 56:                     .aspectRatio(contentMode: .fit)
 57:                     .frame(maxHeight: 400)
 58:                 Spacer().frame(height: 20)
 59:                 Spacer()
 60:             }
 61:             VStack(spacing: 0) {
 62:                 Text(K.Misc.AppTitle)
 63:                     .font(forCategory: .largeTitle)
 64:                     .foregroundColor(ColorPalette.primaryText)
 65:                     .frame(maxWidth: .infinity, alignment: .leading)
 66:                 Spacer().frame(height: 16)
 67:                 Text("No obligation, you can cancel whenever you want.")
 68:                     .font(forCategory: .body2)
 69:                     .foregroundColor(ColorPalette.primaryText)
 70:                     .lineLimit(2)
 71:                     .minimumScaleFactor(0.5)
 72:                     .frame(maxWidth: .infinity, alignment: .leading)
 73:                     .multilineTextAlignment(.leading)
 74:             }
 75:             VStack(spacing: 0) {
 76:                 Spacer().frame(height: 20)
 77:                 self.subscriptionPlansView
 78:                 Spacer().frame(height: 4)
 79:             }
 80:             self.getDefaultButton(text: "Continue",
 81:                                   onButtonPressed: { self.viewModel.subscribe() })
 82:             self.currentSubscriptionPlanView
 83:         }
 84:         .padding([.leading, .trailing], 16)
 85:     }
 86:     
 87:     var restorePurchaseButton: some View {
 88:         Button(action: { self.viewModel.restorePurchases() }) {
 89:             Text("Restore purchase")
 90:                 .frame(maxHeight: .infinity)
 91:                 .underline()
 92:                 .font(forCategory: .linkText)
 93:                 .foregroundColor(ColorPalette.primaryText)
 94:         }
 95:         .frame(maxWidth: .infinity)
 96:         .frame(height: 44)
 97:     }
 98:     
 99:     var currentSubscriptionPlanView: some View {
100:         Text(self.viewModel.currentSubscriptionPlan?.fullDescriptionText ?? "")
101:             .font(forCategory: .headline)
102:             .foregroundColor(ColorPalette.primaryText)
103:             .frame(maxWidth: .infinity, alignment: .center)
104:             .frame(height: 40)
105:             .minimumScaleFactor(0.5)
106:     }
107:     
108:     var subscriptionPlansView: some View {
109:         if let subscriptionPlanList = self.viewModel.asyncSubscriptionPlanList.data {
110:             return AnyView(
111:                 ForEach(Array(subscriptionPlanList.enumerated()), id: \.offset) { index, subscriptionPlanVerticalItem in
112:                     SubscriptionVerticalItemView(subscriptionPlan: subscriptionPlanVerticalItem,
113:                                                  isSelected: self.viewModel.selectedSubscriptionItemIndex == index,
114:                                                  onTap: { self.viewModel.selectedSubscriptionItemIndex = index })
115:                     .frame(maxHeight: 200)
116:                     Spacer().frame(height: 16)
117:                 }
118:             )
119:         } else {
120:             return AnyView(Spacer().frame(height: 1))
121:         }
122:     }
123: }
124: 
125: struct SubscriptionVerticalView_Previews: PreviewProvider {
126:     
127:     static let highlightLongPeriodViewModel = SubscriptionVerticalViewModel(mode: .highlightLongPeriod)
128:     static let highlightShortPeriodViewModel = SubscriptionVerticalViewModel(mode: .highlightShortPeriod)
129:     
130:     static var previews: some View {
131:         SubscriptionVerticalView(viewModel: Self.highlightLongPeriodViewModel,
132:                                  onComplete: { print("Complete!") })
133:         .previewDisplayName("Highlight Long Period")
134:         SubscriptionVerticalView(viewModel: Self.highlightShortPeriodViewModel,
135:                                  onComplete: { print("Complete!") })
136:         .previewDisplayName("Highlight Short Period")
137:     }
138: }
```

## File: pdfexpert/Views/Welcome/WelcomeView.swift
```swift
 1: //
 2: //  WelcomeView.swift
 3: //  PdfExpert
 4: //
 5: //  Created by Pcnaid Inc on 03/04/23.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct WelcomeView: View {
12:     
13:     @Injected(\.mainCoordinator) private var coordinator
14:     
15:     var body: some View {
16:         ZStack {
17:             GeometryReader { geometry in
18:                 VStack(spacing: 16) {
19:                     Image("logo_large")
20:                         .resizable()
21:                         .aspectRatio(contentMode: .fit)
22:                         .frame(maxHeight: 600)
23:                         .padding(60)
24:                     Text("Welcome in \(K.Misc.AppTitle):\nConvert & Edit")
25:                         .font(forCategory: .title1)
26:                         .foregroundColor(ColorPalette.primaryText)
27:                         .multilineTextAlignment(.center)
28:                         .frame(maxWidth: .infinity, alignment: .center)
29:                     Text("The PDF editor for iPhone")
30:                         .font(forCategory: .headline)
31:                         .foregroundColor(ColorPalette.primaryText)
32:                         .multilineTextAlignment(.center)
33:                         .frame(maxWidth: .infinity, alignment: .center)
34:                 }
35:                 .position(x: geometry.size.width/2, y: geometry.size.height/3)
36:             }
37:             VStack {
38:                 Spacer()
39:                 self.getDefaultButton(text: "Start",
40:                                       onButtonPressed: self.coordinator.showOnboarding)
41:             }
42:         }
43:         .padding([.leading, .trailing], 16)
44:         .padding([.top, .bottom], 64)
45:         .background(ColorPalette.primaryBG)
46:     }
47: }
48: 
49: struct WelcomeView_Previews: PreviewProvider {
50:     static var previews: some View {
51:         WelcomeView()
52:     }
53: }
```

## File: pdfexpert/Views/ContentView.swift
```swift
 1: //
 2: //  ContentView.swift
 3: //  OpenAI chat-dalle
 4: //
 5: //  Created by kz on 07/02/2023.
 6: //
 7: 
 8: import SwiftUI
 9: import Factory
10: 
11: struct ContentView: View {
12:     
13:     @Injected(\.appTrackingTransparancy) var appTrackingTransparency
14:     @InjectedObject(\.mainCoordinator) var coordinator
15:     @Injected(\.store) var store
16:     @Injected(\.configService) var configService
17:     @Injected(\.attibutionManager) var attibutionManager
18:     
19:     var body: some View {
20:         self.content
21:             .background(ColorPalette.primaryBG)
22:             .reviewFlowView(flow: self.coordinator.reviewFlow)
23:             .onReceive(NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification)) { _ in
24:                 Task {
25:                     await self.appTrackingTransparency.requestPermissionIfNeeded()
26:                 }
27:                 self.configService.onApplicationDidBecomeActive()
28:             }
29:             .onOpenURL { url in
30:                 self.coordinator.handleOpenUrl(url: url)
31:                 self.attibutionManager.onOpenUrl(url: url)
32:             }
33:     }
34:     
35:     var content: some View {
36:         switch self.coordinator.rootView {
37:         case .onboarding:
38:             return AnyView(
39:                 NavigationStack(path: self.$coordinator.path) {
40:                     WelcomeView()
41:                         .navigationDestination(for: MainCoordinator.Route.self) { route in
42:                             switch route {
43:                             case .onboarding:
44:                                 OnboardingView()
45:                             }
46:                         }
47:                 }
48:             )
49:         case .main:
50:             return AnyView(MainTabView())
51:         }
52:     }
53: }
54: 
55: struct ContentView_Previews: PreviewProvider {
56:     static var previews: some View {
57:         ContentView()
58:     }
59: }
```

## File: pdfexpert/PdfExpert.entitlements
```
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5: 	<key>aps-environment</key>
 6: 	<string>development</string>
 7: 	<key>com.apple.developer.associated-domains</key>
 8: 	<array>
 9: 		<string>webcredentials:pcnaid.com</string>
10: 		<string>applinks:cmrd2.app.link</string>
11: 		<string>applinks:cmrd2-alternate.app.link</string>
12: 		<string>applinks:cmrd2.test.app.link</string>
13: 	</array>
14: 	<key>com.apple.developer.icloud-container-identifiers</key>
15: 	<array>
16: 		<string>iCloud.pdfexpert</string>
17: 	</array>
18: 	<key>com.apple.developer.icloud-services</key>
19: 	<array>
20: 		<string>CloudKit</string>
21: 		<string>CloudDocuments</string>
22: 	</array>
23: 	<key>com.apple.developer.ubiquity-container-identifiers</key>
24: 	<array>
25: 		<string>iCloud.pdfexpert</string>
26: 	</array>
27: 	<key>com.apple.security.application-groups</key>
28: 	<array>
29: 		<string>group.pcnaid.pdfexpert</string>
30: 	</array>
31: </dict>
32: </plist>
```

## File: pdfexpert.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
```
  1: {
  2:   "pins" : [
  3:     {
  4:       "identity" : "abseil-cpp-binary",
  5:       "kind" : "remoteSourceControl",
  6:       "location" : "https://github.com/google/abseil-cpp-binary.git",
  7:       "state" : {
  8:         "revision" : "bfc0b6f81adc06ce5121eb23f628473638d67c5c",
  9:         "version" : "1.2022062300.0"
 10:       }
 11:     },
 12:     {
 13:       "identity" : "alamofire",
 14:       "kind" : "remoteSourceControl",
 15:       "location" : "https://github.com/Alamofire/Alamofire.git",
 16:       "state" : {
 17:         "revision" : "bc268c28fb170f494de9e9927c371b8342979ece",
 18:         "version" : "5.7.1"
 19:       }
 20:     },
 21:     {
 22:       "identity" : "cloudkitsyncmonitor",
 23:       "kind" : "remoteSourceControl",
 24:       "location" : "https://github.com/ggruen/CloudKitSyncMonitor.git",
 25:       "state" : {
 26:         "branch" : "main",
 27:         "revision" : "8f8de8e71928df27bf023cc6ed808a8b6270a0d3"
 28:       }
 29:     },
 30:     {
 31:       "identity" : "combineext",
 32:       "kind" : "remoteSourceControl",
 33:       "location" : "https://github.com/CombineCommunity/CombineExt.git",
 34:       "state" : {
 35:         "revision" : "d7b896fa9ca8b47fa7bcde6b43ef9b70bf8c1f56",
 36:         "version" : "1.8.1"
 37:       }
 38:     },
 39:     {
 40:       "identity" : "facebook-ios-sdk",
 41:       "kind" : "remoteSourceControl",
 42:       "location" : "https://github.com/facebook/facebook-ios-sdk",
 43:       "state" : {
 44:         "revision" : "5ed7a05695b2830fcfd97b62225272fad2f61043",
 45:         "version" : "16.1.3"
 46:       }
 47:     },
 48:     {
 49:       "identity" : "factory",
 50:       "kind" : "remoteSourceControl",
 51:       "location" : "https://github.com/hmlongco/Factory",
 52:       "state" : {
 53:         "revision" : "061b3afe0358a0da7ce568f8272c847910be3dd7",
 54:         "version" : "2.2.0"
 55:       }
 56:     },
 57:     {
 58:       "identity" : "firebase-ios-sdk",
 59:       "kind" : "remoteSourceControl",
 60:       "location" : "https://github.com/firebase/firebase-ios-sdk",
 61:       "state" : {
 62:         "branch" : "master",
 63:         "revision" : "d7173ec3c7850ebe0304e940d68a999b229ad37f"
 64:       }
 65:     },
 66:     {
 67:       "identity" : "googleappmeasurement",
 68:       "kind" : "remoteSourceControl",
 69:       "location" : "https://github.com/google/GoogleAppMeasurement.git",
 70:       "state" : {
 71:         "revision" : "0a226a8c50494c4cb877fbde27ab6374520a3354",
 72:         "version" : "10.12.0"
 73:       }
 74:     },
 75:     {
 76:       "identity" : "googledatatransport",
 77:       "kind" : "remoteSourceControl",
 78:       "location" : "https://github.com/google/GoogleDataTransport.git",
 79:       "state" : {
 80:         "revision" : "98a00258d4518b7521253a70b7f70bb76d2120fe",
 81:         "version" : "9.2.4"
 82:       }
 83:     },
 84:     {
 85:       "identity" : "googleutilities",
 86:       "kind" : "remoteSourceControl",
 87:       "location" : "https://github.com/google/GoogleUtilities.git",
 88:       "state" : {
 89:         "revision" : "4446686bc3714d49ce043d0f68318f42ed718cb6",
 90:         "version" : "7.11.4"
 91:       }
 92:     },
 93:     {
 94:       "identity" : "grpc-binary",
 95:       "kind" : "remoteSourceControl",
 96:       "location" : "https://github.com/google/grpc-binary.git",
 97:       "state" : {
 98:         "revision" : "f1b366129d1125be7db83247e003fc333104b569",
 99:         "version" : "1.50.2"
100:       }
101:     },
102:     {
103:       "identity" : "gtm-session-fetcher",
104:       "kind" : "remoteSourceControl",
105:       "location" : "https://github.com/google/gtm-session-fetcher.git",
106:       "state" : {
107:         "revision" : "d415594121c9e8a4f9d79cecee0965cf35e74dbd",
108:         "version" : "3.1.1"
109:       }
110:     },
111:     {
112:       "identity" : "ios-branch-sdk-spm",
113:       "kind" : "remoteSourceControl",
114:       "location" : "https://github.com/BranchMetrics/ios-branch-sdk-spm",
115:       "state" : {
116:         "revision" : "7fbe3085821c8e60241a2037098c6eed76fd2798",
117:         "version" : "2.2.0"
118:       }
119:     },
120:     {
121:       "identity" : "leveldb",
122:       "kind" : "remoteSourceControl",
123:       "location" : "https://github.com/firebase/leveldb.git",
124:       "state" : {
125:         "revision" : "0706abcc6b0bd9cedfbb015ba840e4a780b5159b",
126:         "version" : "1.22.2"
127:       }
128:     },
129:     {
130:       "identity" : "lottie-spm",
131:       "kind" : "remoteSourceControl",
132:       "location" : "https://github.com/airbnb/lottie-spm.git",
133:       "state" : {
134:         "branch" : "main",
135:         "revision" : "60ea4f82fba8b4cb21a75665a889e86ed4d81c6e"
136:       }
137:     },
138:     {
139:       "identity" : "mantis",
140:       "kind" : "remoteSourceControl",
141:       "location" : "https://github.com/guoyingtao/Mantis.git",
142:       "state" : {
143:         "revision" : "29783a4a73625acb42e58438fb1f9451fdcb0094",
144:         "version" : "2.14.1"
145:       }
146:     },
147:     {
148:       "identity" : "moya",
149:       "kind" : "remoteSourceControl",
150:       "location" : "https://github.com/Moya/Moya",
151:       "state" : {
152:         "revision" : "c263811c1f3dbf002be9bd83107f7cdc38992b26",
153:         "version" : "15.0.3"
154:       }
155:     },
156:     {
157:       "identity" : "nanopb",
158:       "kind" : "remoteSourceControl",
159:       "location" : "https://github.com/firebase/nanopb.git",
160:       "state" : {
161:         "revision" : "819d0a2173aff699fb8c364b6fb906f7cdb1a692",
162:         "version" : "2.30909.0"
163:       }
164:     },
165:     {
166:       "identity" : "pagertabstripview",
167:       "kind" : "remoteSourceControl",
168:       "location" : "https://github.com/xmartlabs/PagerTabStripView",
169:       "state" : {
170:         "revision" : "39ec00d2577adf75d82d1c7023c56950b96d2298",
171:         "version" : "4.0.0"
172:       }
173:     },
174:     {
175:       "identity" : "promises",
176:       "kind" : "remoteSourceControl",
177:       "location" : "https://github.com/google/promises.git",
178:       "state" : {
179:         "revision" : "c22f76b709dc4bb6d274398259e75c191e50998a",
180:         "version" : "2.3.0"
181:       }
182:     },
183:     {
184:       "identity" : "pspdfkit-sp",
185:       "kind" : "remoteSourceControl",
186:       "location" : "https://github.com/PSPDFKit/PSPDFKit-SP",
187:       "state" : {
188:         "branch" : "master",
189:         "revision" : "33f91d1c5cac1a68876582bf05b561a9155a410c"
190:       }
191:     },
192:     {
193:       "identity" : "reactiveswift",
194:       "kind" : "remoteSourceControl",
195:       "location" : "https://github.com/ReactiveCocoa/ReactiveSwift.git",
196:       "state" : {
197:         "revision" : "c43bae3dac73fdd3cb906bd5a1914686ca71ed3c",
198:         "version" : "6.7.0"
199:       }
200:     },
201:     {
202:       "identity" : "rxswift",
203:       "kind" : "remoteSourceControl",
204:       "location" : "https://github.com/ReactiveX/RxSwift.git",
205:       "state" : {
206:         "revision" : "9dcaa4b333db437b0fbfaf453fad29069044a8b4",
207:         "version" : "6.6.0"
208:       }
209:     },
210:     {
211:       "identity" : "swift-collections",
212:       "kind" : "remoteSourceControl",
213:       "location" : "https://github.com/apple/swift-collections.git",
214:       "state" : {
215:         "revision" : "937e904258d22af6e447a0b72c0bc67583ef64a2",
216:         "version" : "1.0.4"
217:       }
218:     },
219:     {
220:       "identity" : "swift-protobuf",
221:       "kind" : "remoteSourceControl",
222:       "location" : "https://github.com/apple/swift-protobuf.git",
223:       "state" : {
224:         "revision" : "f25867a208f459d3c5a06935dceb9083b11cd539",
225:         "version" : "1.22.0"
226:       }
227:     }
228:   ],
229:   "version" : 2
230: }
```

## File: pdfexpert.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
```
1: <?xml version="1.0" encoding="UTF-8"?>
2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
3: <plist version="1.0">
4: <dict>
5: 	<key>IDEDidComputeMac32BitWarning</key>
6: 	<true/>
7: </dict>
8: </plist>
```

## File: pdfexpert.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
```
1: <?xml version="1.0" encoding="UTF-8"?>
2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
3: <plist version="1.0">
4: <dict/>
5: </plist>
```

## File: pdfexpert.xcodeproj/project.xcworkspace/contents.xcworkspacedata
```
1: <?xml version="1.0" encoding="UTF-8"?>
2: <Workspace
3:    version = "1.0">
4:    <FileRef
5:       location = "self:">
6:    </FileRef>
7: </Workspace>
```

## File: pdfexpert.xcodeproj/xcshareddata/xcschemes/PdfExpert Staging.xcscheme
```
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <Scheme
 3:    LastUpgradeVersion = "1620"
 4:    version = "1.7">
 5:    <BuildAction
 6:       parallelizeBuildables = "YES"
 7:       buildImplicitDependencies = "YES">
 8:       <BuildActionEntries>
 9:          <BuildActionEntry
10:             buildForTesting = "YES"
11:             buildForRunning = "YES"
12:             buildForProfiling = "YES"
13:             buildForArchiving = "YES"
14:             buildForAnalyzing = "YES">
15:             <BuildableReference
16:                BuildableIdentifier = "primary"
17:                BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
18:                BuildableName = "PdfExpert.app"
19:                BlueprintName = "PdfExpert"
20:                ReferencedContainer = "container:pdfexpert.xcodeproj">
21:             </BuildableReference>
22:          </BuildActionEntry>
23:       </BuildActionEntries>
24:    </BuildAction>
25:    <TestAction
26:       buildConfiguration = "Staging Debug"
27:       selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
28:       selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
29:       shouldUseLaunchSchemeArgsEnv = "YES"
30:       shouldAutocreateTestPlan = "YES">
31:    </TestAction>
32:    <LaunchAction
33:       buildConfiguration = "Staging Debug"
34:       selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
35:       selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
36:       launchStyle = "0"
37:       useCustomWorkingDirectory = "NO"
38:       ignoresPersistentStateOnLaunch = "NO"
39:       debugDocumentVersioning = "YES"
40:       debugServiceExtension = "internal"
41:       allowLocationSimulation = "YES">
42:       <BuildableProductRunnable
43:          runnableDebuggingMode = "0">
44:          <BuildableReference
45:             BuildableIdentifier = "primary"
46:             BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
47:             BuildableName = "PdfExpert.app"
48:             BlueprintName = "PdfExpert"
49:             ReferencedContainer = "container:pdfexpert.xcodeproj">
50:          </BuildableReference>
51:       </BuildableProductRunnable>
52:       <CommandLineArguments>
53:          <CommandLineArgument
54:             argument = "-com.apple.CoreData.Logging.stderr 0"
55:             isEnabled = "YES">
56:          </CommandLineArgument>
57:          <CommandLineArgument
58:             argument = "-com.apple.CoreData.CloudKitDebug 0"
59:             isEnabled = "YES">
60:          </CommandLineArgument>
61:       </CommandLineArguments>
62:       <StoreKitConfigurationFileReference
63:          identifier = "../../PdfExpert/Resources/IAP/LocalStagingProducts.storekit">
64:       </StoreKitConfigurationFileReference>
65:    </LaunchAction>
66:    <ProfileAction
67:       buildConfiguration = "Staging Release"
68:       shouldUseLaunchSchemeArgsEnv = "YES"
69:       savedToolIdentifier = ""
70:       useCustomWorkingDirectory = "NO"
71:       debugDocumentVersioning = "YES">
72:       <BuildableProductRunnable
73:          runnableDebuggingMode = "0">
74:          <BuildableReference
75:             BuildableIdentifier = "primary"
76:             BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
77:             BuildableName = "PdfExpert.app"
78:             BlueprintName = "PdfExpert"
79:             ReferencedContainer = "container:pdfexpert.xcodeproj">
80:          </BuildableReference>
81:       </BuildableProductRunnable>
82:    </ProfileAction>
83:    <AnalyzeAction
84:       buildConfiguration = "Staging Debug">
85:    </AnalyzeAction>
86:    <ArchiveAction
87:       buildConfiguration = "Staging Release"
88:       revealArchiveInOrganizer = "YES">
89:    </ArchiveAction>
90: </Scheme>
```

## File: pdfexpert.xcodeproj/xcshareddata/xcschemes/PdfExpert.xcscheme
```
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <Scheme
 3:    LastUpgradeVersion = "1620"
 4:    version = "1.3">
 5:    <BuildAction
 6:       parallelizeBuildables = "YES"
 7:       buildImplicitDependencies = "YES">
 8:       <BuildActionEntries>
 9:          <BuildActionEntry
10:             buildForTesting = "YES"
11:             buildForRunning = "YES"
12:             buildForProfiling = "YES"
13:             buildForArchiving = "YES"
14:             buildForAnalyzing = "YES">
15:             <BuildableReference
16:                BuildableIdentifier = "primary"
17:                BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
18:                BuildableName = "PdfExpert.app"
19:                BlueprintName = "PdfExpert"
20:                ReferencedContainer = "container:pdfexpert.xcodeproj">
21:             </BuildableReference>
22:          </BuildActionEntry>
23:       </BuildActionEntries>
24:    </BuildAction>
25:    <TestAction
26:       buildConfiguration = "Production Debug"
27:       selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
28:       selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
29:       shouldUseLaunchSchemeArgsEnv = "YES">
30:       <Testables>
31:       </Testables>
32:    </TestAction>
33:    <LaunchAction
34:       buildConfiguration = "Production Debug"
35:       selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
36:       selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
37:       launchStyle = "0"
38:       useCustomWorkingDirectory = "NO"
39:       ignoresPersistentStateOnLaunch = "NO"
40:       debugDocumentVersioning = "YES"
41:       debugServiceExtension = "internal"
42:       allowLocationSimulation = "YES">
43:       <BuildableProductRunnable
44:          runnableDebuggingMode = "0">
45:          <BuildableReference
46:             BuildableIdentifier = "primary"
47:             BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
48:             BuildableName = "PdfExpert.app"
49:             BlueprintName = "PdfExpert"
50:             ReferencedContainer = "container:pdfexpert.xcodeproj">
51:          </BuildableReference>
52:       </BuildableProductRunnable>
53:       <CommandLineArguments>
54:          <CommandLineArgument
55:             argument = "-com.apple.CoreData.CloudKitDebug 0"
56:             isEnabled = "YES">
57:          </CommandLineArgument>
58:          <CommandLineArgument
59:             argument = "-FIRAnalyticsVerboseLoggingEnabled"
60:             isEnabled = "YES">
61:          </CommandLineArgument>
62:          <CommandLineArgument
63:             argument = "-FIRAnalyticsDebugEnabled"
64:             isEnabled = "YES">
65:          </CommandLineArgument>
66:          <CommandLineArgument
67:             argument = "-com.apple.CoreData.Logging.stderr 0"
68:             isEnabled = "YES">
69:          </CommandLineArgument>
70:       </CommandLineArguments>
71:       <StoreKitConfigurationFileReference
72:          identifier = "../../PdfExpert/Resources/IAP/LocalProductionProducts.storekit">
73:       </StoreKitConfigurationFileReference>
74:    </LaunchAction>
75:    <ProfileAction
76:       buildConfiguration = "Production Debug"
77:       shouldUseLaunchSchemeArgsEnv = "YES"
78:       savedToolIdentifier = ""
79:       useCustomWorkingDirectory = "NO"
80:       debugDocumentVersioning = "YES">
81:       <BuildableProductRunnable
82:          runnableDebuggingMode = "0">
83:          <BuildableReference
84:             BuildableIdentifier = "primary"
85:             BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
86:             BuildableName = "PdfExpert.app"
87:             BlueprintName = "PdfExpert"
88:             ReferencedContainer = "container:pdfexpert.xcodeproj">
89:          </BuildableReference>
90:       </BuildableProductRunnable>
91:    </ProfileAction>
92:    <AnalyzeAction
93:       buildConfiguration = "Production Debug">
94:    </AnalyzeAction>
95:    <ArchiveAction
96:       buildConfiguration = "Production Release"
97:       revealArchiveInOrganizer = "YES">
98:    </ArchiveAction>
99: </Scheme>
```

## File: pdfexpert.xcodeproj/xcshareddata/xcschemes/ShareFileExtension.xcscheme
```
  1: <?xml version="1.0" encoding="UTF-8"?>
  2: <Scheme
  3:    LastUpgradeVersion = "1620"
  4:    version = "2.0">
  5:    <BuildAction
  6:       parallelizeBuildables = "YES"
  7:       buildImplicitDependencies = "YES">
  8:       <BuildActionEntries>
  9:          <BuildActionEntry
 10:             buildForTesting = "YES"
 11:             buildForRunning = "YES"
 12:             buildForProfiling = "YES"
 13:             buildForArchiving = "YES"
 14:             buildForAnalyzing = "YES">
 15:             <BuildableReference
 16:                BuildableIdentifier = "primary"
 17:                BlueprintIdentifier = "895C1BAC2A04FA53005EA190"
 18:                BuildableName = "ShareFileExtension.appex"
 19:                BlueprintName = "ShareFileExtension"
 20:                ReferencedContainer = "container:pdfexpert.xcodeproj">
 21:             </BuildableReference>
 22:          </BuildActionEntry>
 23:          <BuildActionEntry
 24:             buildForTesting = "YES"
 25:             buildForRunning = "YES"
 26:             buildForProfiling = "YES"
 27:             buildForArchiving = "YES"
 28:             buildForAnalyzing = "YES">
 29:             <BuildableReference
 30:                BuildableIdentifier = "primary"
 31:                BlueprintIdentifier = "89847A382A1BA875000EC14B"
 32:                BuildableName = "PdfExpert Staging.app"
 33:                BlueprintName = "PdfExpert Staging"
 34:                ReferencedContainer = "container:pdfexpert.xcodeproj">
 35:             </BuildableReference>
 36:          </BuildActionEntry>
 37:          <BuildActionEntry
 38:             buildForTesting = "YES"
 39:             buildForRunning = "YES"
 40:             buildForProfiling = "YES"
 41:             buildForArchiving = "YES"
 42:             buildForAnalyzing = "YES">
 43:             <BuildableReference
 44:                BuildableIdentifier = "primary"
 45:                BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
 46:                BuildableName = "PdfExpert.app"
 47:                BlueprintName = "PdfExpert"
 48:                ReferencedContainer = "container:pdfexpert.xcodeproj">
 49:             </BuildableReference>
 50:          </BuildActionEntry>
 51:       </BuildActionEntries>
 52:    </BuildAction>
 53:    <TestAction
 54:       buildConfiguration = "Debug"
 55:       selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
 56:       selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
 57:       shouldUseLaunchSchemeArgsEnv = "YES"
 58:       shouldAutocreateTestPlan = "YES">
 59:    </TestAction>
 60:    <LaunchAction
 61:       buildConfiguration = "Debug"
 62:       selectedDebuggerIdentifier = ""
 63:       selectedLauncherIdentifier = "Xcode.IDEFoundation.Launcher.PosixSpawn"
 64:       launchStyle = "0"
 65:       askForAppToLaunch = "Yes"
 66:       useCustomWorkingDirectory = "NO"
 67:       ignoresPersistentStateOnLaunch = "NO"
 68:       debugDocumentVersioning = "YES"
 69:       debugServiceExtension = "internal"
 70:       allowLocationSimulation = "YES"
 71:       launchAutomaticallySubstyle = "2">
 72:       <BuildableProductRunnable
 73:          runnableDebuggingMode = "0">
 74:          <BuildableReference
 75:             BuildableIdentifier = "primary"
 76:             BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
 77:             BuildableName = "PdfExpert.app"
 78:             BlueprintName = "PdfExpert"
 79:             ReferencedContainer = "container:pdfexpert.xcodeproj">
 80:          </BuildableReference>
 81:       </BuildableProductRunnable>
 82:    </LaunchAction>
 83:    <ProfileAction
 84:       buildConfiguration = "Release"
 85:       shouldUseLaunchSchemeArgsEnv = "YES"
 86:       savedToolIdentifier = ""
 87:       useCustomWorkingDirectory = "NO"
 88:       debugDocumentVersioning = "YES"
 89:       askForAppToLaunch = "Yes"
 90:       launchAutomaticallySubstyle = "2">
 91:       <BuildableProductRunnable
 92:          runnableDebuggingMode = "0">
 93:          <BuildableReference
 94:             BuildableIdentifier = "primary"
 95:             BlueprintIdentifier = "89CD7A9529D32855003F1C3A"
 96:             BuildableName = "PdfExpert.app"
 97:             BlueprintName = "PdfExpert"
 98:             ReferencedContainer = "container:pdfexpert.xcodeproj">
 99:          </BuildableReference>
100:       </BuildableProductRunnable>
101:    </ProfileAction>
102:    <AnalyzeAction
103:       buildConfiguration = "Debug">
104:    </AnalyzeAction>
105:    <ArchiveAction
106:       buildConfiguration = "Release"
107:       revealArchiveInOrganizer = "YES">
108:    </ArchiveAction>
109: </Scheme>
```

## File: pdfexpert.xcodeproj/project.pbxproj
```
   1: // !$*UTF8*$!
   2: {
   3: 	archiveVersion = 1;
   4: 	classes = {
   5: 	};
   6: 	objectVersion = 56;
   7: 	objects = {
   8: 
   9: /* Begin PBXBuildFile section */
  10: 		8902898D29DC1F10007E6372 /* PageControl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8902898C29DC1F10007E6372 /* PageControl.swift */; };
  11: 		89127AA12A177E370059005F /* PencilKitView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89127AA02A177E370059005F /* PencilKitView.swift */; };
  12: 		89127AA32A177F170059005F /* PdfSignatureCanvasView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89127AA22A177F170059005F /* PdfSignatureCanvasView.swift */; };
  13: 		89127AA52A17A3600059005F /* PdfSignatureCanvasViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89127AA42A17A3600059005F /* PdfSignatureCanvasViewModel.swift */; };
  14: 		89127AA72A17C1980059005F /* PencilKit+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89127AA62A17C1980059005F /* PencilKit+Extensions.swift */; };
  15: 		891A07E929E028EE0002FA3A /* CloudKitSyncMonitor in Frameworks */ = {isa = PBXBuildFile; productRef = 891A07E829E028EE0002FA3A /* CloudKitSyncMonitor */; };
  16: 		891AE58B2A03E80300DBC246 /* ObservableObject+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 891AE58A2A03E80300DBC246 /* ObservableObject+Extensions.swift */; };
  17: 		892201D92A0BA64600832CF2 /* ImageAnnotationStamp.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892201D82A0BA64600832CF2 /* ImageAnnotationStamp.swift */; };
  18: 		892201DC2A0BA70300832CF2 /* PdfSignatureView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892201DB2A0BA70300832CF2 /* PdfSignatureView.swift */; };
  19: 		892201DE2A0BA72D00832CF2 /* PdfSignatureViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892201DD2A0BA72D00832CF2 /* PdfSignatureViewModel.swift */; };
  20: 		8928F3D12A30BAFB001C1853 /* PickedImage.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8928F3D02A30BAFB001C1853 /* PickedImage.swift */; };
  21: 		892CC6922AAA23AE000DEC21 /* CDSuggestedFields.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892CC6912AAA23AE000DEC21 /* CDSuggestedFields.swift */; };
  22: 		892CC6942AAA243E000DEC21 /* SuggestedFields+Persistable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892CC6932AAA243E000DEC21 /* SuggestedFields+Persistable.swift */; };
  23: 		892CC6962AAA2641000DEC21 /* SuggestedFieldsFormView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892CC6952AAA2641000DEC21 /* SuggestedFieldsFormView.swift */; };
  24: 		892CC6982AAA2660000DEC21 /* SuggestedFieldsFormViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892CC6972AAA2660000DEC21 /* SuggestedFieldsFormViewModel.swift */; };
  25: 		892E404F2A25E5D9000EEE23 /* PDFAnnotation+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 892E404E2A25E5D9000EEE23 /* PDFAnnotation+Extensions.swift */; };
  26: 		8932ECE52A20DC7700CBCD7A /* PdfFillFormView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8932ECE42A20DC7700CBCD7A /* PdfFillFormView.swift */; };
  27: 		8932ECE72A20DCB900CBCD7A /* PdfFillFormViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8932ECE62A20DCB900CBCD7A /* PdfFillFormViewModel.swift */; };
  28: 		8932ECE92A20F10500CBCD7A /* TextResizableView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8932ECE82A20F10500CBCD7A /* TextResizableView.swift */; };
  29: 		8933490C2A24AE880005D484 /* PdfKitViewBinder.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8933490B2A24AE880005D484 /* PdfKitViewBinder.swift */; };
  30: 		8934ACC72A6AE96700F6CDA8 /* ChatPdfInitParams.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8934ACC62A6AE96700F6CDA8 /* ChatPdfInitParams.swift */; };
  31: 		8936AA312A682812005F6C73 /* ProjectInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 8936AA302A682812005F6C73 /* ProjectInfo.plist */; };
  32: 		8936AA332A6828C9005F6C73 /* ProjectInfo.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA322A6828C9005F6C73 /* ProjectInfo.swift */; };
  33: 		8936AA382A68299B005F6C73 /* ChatPdfManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA352A68299B005F6C73 /* ChatPdfManager.swift */; };
  34: 		8936AA392A68299B005F6C73 /* ChatPdfManagerMock.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA362A68299B005F6C73 /* ChatPdfManagerMock.swift */; };
  35: 		8936AA3C2A682CDA005F6C73 /* ChatPdfSelectionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA3B2A682CDA005F6C73 /* ChatPdfSelectionView.swift */; };
  36: 		8936AA3E2A682F8E005F6C73 /* ChatPdfSelectionViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA3D2A682F8E005F6C73 /* ChatPdfSelectionViewModel.swift */; };
  37: 		8936AA402A683FB5005F6C73 /* ImportOption.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA3F2A683FB5005F6C73 /* ImportOption.swift */; };
  38: 		8936AA422A6840D1005F6C73 /* ChatPdfView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA412A6840D1005F6C73 /* ChatPdfView.swift */; };
  39: 		8936AA442A684128005F6C73 /* ChatPdfViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8936AA432A684128005F6C73 /* ChatPdfViewModel.swift */; };
  40: 		893875012A7BDD3B00267AFD /* LoadingView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893875002A7BDD3B00267AFD /* LoadingView.swift */; };
  41: 		893AAFCB2A39B2AF00EF9B00 /* FormSheet.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893AAFCA2A39B2AF00EF9B00 /* FormSheet.swift */; };
  42: 		893B04BD2AA9C2C100F86813 /* CoreGraphics+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893B04BC2AA9C2C100F86813 /* CoreGraphics+Extensions.swift */; };
  43: 		893BE52B2A6A7864004B05B9 /* CombineMoya in Frameworks */ = {isa = PBXBuildFile; productRef = 893BE52A2A6A7864004B05B9 /* CombineMoya */; };
  44: 		893BE52D2A6A78BB004B05B9 /* ChatPdfManagerImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893BE52C2A6A78BB004B05B9 /* ChatPdfManagerImpl.swift */; };
  45: 		893BE52F2A6A7C0C004B05B9 /* NetworkUtility.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893BE52E2A6A7C0C004B05B9 /* NetworkUtility.swift */; };
  46: 		893BE5352A6A96F5004B05B9 /* ChatPdfRef+Decodable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893BE5342A6A96F5004B05B9 /* ChatPdfRef+Decodable.swift */; };
  47: 		893BE5372A6A9708004B05B9 /* ChatPdfMessage+Decodable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893BE5362A6A9708004B05B9 /* ChatPdfMessage+Decodable.swift */; };
  48: 		893C8FC929DED190000E35BD /* ArchiveView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FC829DED190000E35BD /* ArchiveView.swift */; };
  49: 		893C8FCB29DED1AF000E35BD /* ArchiveViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FCA29DED1AF000E35BD /* ArchiveViewModel.swift */; };
  50: 		893C8FCE29DED254000E35BD /* AppCoreData.xcdatamodeld in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FCC29DED254000E35BD /* AppCoreData.xcdatamodeld */; };
  51: 		893C8FD029DED278000E35BD /* Persistence.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FCF29DED278000E35BD /* Persistence.swift */; };
  52: 		893C8FD329DED2E9000E35BD /* Repository.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FD129DED2E9000E35BD /* Repository.swift */; };
  53: 		893C8FD429DED2E9000E35BD /* RepositoryImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FD229DED2E9000E35BD /* RepositoryImpl.swift */; };
  54: 		893C8FDE29DED7F4000E35BD /* PdfUtility.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893C8FDD29DED7F4000E35BD /* PdfUtility.swift */; };
  55: 		893C8FE129DEDAF4000E35BD /* test.pdf in Resources */ = {isa = PBXBuildFile; fileRef = 893C8FE029DEDAF4000E35BD /* test.pdf */; };
  56: 		893DE8DA29E7F85C0043C02C /* SubscriptionPairsViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893DE8D929E7F85C0043C02C /* SubscriptionPairsViewModel.swift */; };
  57: 		893DE8DC29E7F9A10043C02C /* SubscriptionVerticalViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893DE8DB29E7F9A10043C02C /* SubscriptionVerticalViewModel.swift */; };
  58: 		893E849129D5874D00F6B99A /* CameraView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849029D5874D00F6B99A /* CameraView.swift */; };
  59: 		893E849429D5878E00F6B99A /* CameraViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849329D5878E00F6B99A /* CameraViewModel.swift */; };
  60: 		893E849C29D5944E00F6B99A /* PhotoCaptureProcessor.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849629D5944E00F6B99A /* PhotoCaptureProcessor.swift */; };
  61: 		893E849D29D5944E00F6B99A /* CameraService+Enums.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849729D5944E00F6B99A /* CameraService+Enums.swift */; };
  62: 		893E849E29D5944E00F6B99A /* CameraPreviewView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849829D5944E00F6B99A /* CameraPreviewView.swift */; };
  63: 		893E849F29D5944E00F6B99A /* ImageResizer.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849929D5944E00F6B99A /* ImageResizer.swift */; };
  64: 		893E84A029D5944E00F6B99A /* CameraService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849A29D5944E00F6B99A /* CameraService.swift */; };
  65: 		893E84A129D5944E00F6B99A /* CameraService+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E849B29D5944E00F6B99A /* CameraService+Extensions.swift */; };
  66: 		893E84A429D5BFBB00F6B99A /* PSPDFKit in Frameworks */ = {isa = PBXBuildFile; productRef = 893E84A329D5BFBB00F6B99A /* PSPDFKit */; };
  67: 		893E84A629D5C5E200F6B99A /* ActivityViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893E84A529D5C5E200F6B99A /* ActivityViewController.swift */; };
  68: 		893EB5012AA717B80066914E /* FacebookCore in Frameworks */ = {isa = PBXBuildFile; productRef = 893EB5002AA717B80066914E /* FacebookCore */; };
  69: 		893EB5032AA71FFD0066914E /* BranchAnalyticsPlatform.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893EB5022AA71FFD0066914E /* BranchAnalyticsPlatform.swift */; };
  70: 		893EB5052AA722EF0066914E /* StoreKit+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893EB5042AA722EF0066914E /* StoreKit+Extensions.swift */; };
  71: 		893EB5072AA723C80066914E /* AnalyticsDefaultParameters.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893EB5062AA723C80066914E /* AnalyticsDefaultParameters.swift */; };
  72: 		893ED9D02A6920F2004EE67C /* ChatPdfRef.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893ED9CF2A6920F2004EE67C /* ChatPdfRef.swift */; };
  73: 		893ED9D22A6926E8004EE67C /* ChatPdfMessage.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893ED9D12A6926E8004EE67C /* ChatPdfMessage.swift */; };
  74: 		893ED9D42A692805004EE67C /* CombineUtils.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893ED9D32A692805004EE67C /* CombineUtils.swift */; };
  75: 		893ED9D92A693013004EE67C /* MessageView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893ED9D72A693013004EE67C /* MessageView.swift */; };
  76: 		893ED9DA2A693013004EE67C /* MessageIndicatorView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 893ED9D82A693013004EE67C /* MessageIndicatorView.swift */; };
  77: 		89407EF12AA8ADD200169801 /* GalleryImageProviderFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EF02AA8ADD200169801 /* GalleryImageProviderFlow.swift */; };
  78: 		89407EF32AA8B0C800169801 /* GalleryImageProviderFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EF22AA8B0C800169801 /* GalleryImageProviderFlowView.swift */; };
  79: 		89407EF52AA8BDE600169801 /* CameraImageProviderFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EF42AA8BDE600169801 /* CameraImageProviderFlow.swift */; };
  80: 		89407EF72AA8BEC200169801 /* CameraImageProviderFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EF62AA8BEC200169801 /* CameraImageProviderFlowView.swift */; };
  81: 		89407EFA2AA8C4C400169801 /* Mantis in Frameworks */ = {isa = PBXBuildFile; productRef = 89407EF92AA8C4C400169801 /* Mantis */; };
  82: 		89407EFC2AA8D22D00169801 /* ImageCropFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EFB2AA8D22D00169801 /* ImageCropFlow.swift */; };
  83: 		89407EFE2AA8D23B00169801 /* ImageCropFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EFD2AA8D23B00169801 /* ImageCropFlowView.swift */; };
  84: 		89407F002AA8D54800169801 /* ImageCropper.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89407EFF2AA8D54800169801 /* ImageCropper.swift */; };
  85: 		8940FB912A710D8D00A00D8D /* AddPasswordView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8940FB902A710D8D00A00D8D /* AddPasswordView.swift */; };
  86: 		8942034529DC12BC004D610B /* PagerTabStripView in Frameworks */ = {isa = PBXBuildFile; productRef = 8942034429DC12BC004D610B /* PagerTabStripView */; };
  87: 		89429F862A9C8ECC00465420 /* PdfSignaturePickerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F852A9C8ECC00465420 /* PdfSignaturePickerView.swift */; };
  88: 		89429F882A9C8EFC00465420 /* PdfSignaturePickerViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F872A9C8EFC00465420 /* PdfSignaturePickerViewModel.swift */; };
  89: 		89429F8A2A9C937300465420 /* Signature.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F892A9C937300465420 /* Signature.swift */; };
  90: 		89429F8C2A9C937C00465420 /* CDSignature.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F8B2A9C937C00465420 /* CDSignature.swift */; };
  91: 		89429F912A9CFFDC00465420 /* Persistable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F902A9CFFDC00465420 /* Persistable.swift */; };
  92: 		89429F932A9CFFF100465420 /* Pdf+Persistable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F922A9CFFF100465420 /* Pdf+Persistable.swift */; };
  93: 		89429F952A9D001A00465420 /* Signature+Persistable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89429F942A9D001A00465420 /* Signature+Persistable.swift */; };
  94: 		89431FC62A9900740042A636 /* MathUtils.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89431FC52A9900740042A636 /* MathUtils.swift */; };
  95: 		89436AB829E5556600060605 /* PdfCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436AB729E5556600060605 /* PdfCoordinator.swift */; };
  96: 		89436ABB29E557D500060605 /* PdfFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436ABA29E557D500060605 /* PdfFlowView.swift */; };
  97: 		89436ABD29E5586600060605 /* PdfEditView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436ABC29E5586600060605 /* PdfEditView.swift */; };
  98: 		89436ABF29E55EA000060605 /* Pdf.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436ABE29E55EA000060605 /* Pdf.swift */; };
  99: 		89436AC329E59C0E00060605 /* PdfEditViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436AC229E59C0E00060605 /* PdfEditViewModel.swift */; };
 100: 		89436AC729E5B99100060605 /* PdfKitView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436AC629E5B99100060605 /* PdfKitView.swift */; };
 101: 		89436D192A936C9F000868B5 /* PdfReadView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D182A936C9F000868B5 /* PdfReadView.swift */; };
 102: 		89436D1B2A939CBB000868B5 /* PdfReadViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D1A2A939CBB000868B5 /* PdfReadViewModel.swift */; };
 103: 		89436D1D2A93AE76000868B5 /* PdfReaderView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D1C2A93AE76000868B5 /* PdfReaderView.swift */; };
 104: 		89436D1F2A93AEB4000868B5 /* PdfReaderViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D1E2A93AEB4000868B5 /* PdfReaderViewModel.swift */; };
 105: 		89436D212A93B97E000868B5 /* NSAttributedString+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D202A93B97E000868B5 /* NSAttributedString+Extensions.swift */; };
 106: 		89436D232A93C1CE000868B5 /* PdfPageSelectionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89436D222A93C1CE000868B5 /* PdfPageSelectionView.swift */; };
 107: 		8945D2BC2A03C41000AFF51A /* PdfScanUtility.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8945D2BB2A03C41000AFF51A /* PdfScanUtility.swift */; };
 108: 		89460C6029DAC36600E39BAC /* SubscriptionErrorView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89460C5F29DAC36600E39BAC /* SubscriptionErrorView.swift */; };
 109: 		89467AD72A9E4C6B00FC01FC /* Deeplink.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89467AD62A9E4C6B00FC01FC /* Deeplink.swift */; };
 110: 		894827B02AA5D65600030C4E /* BranchSDK in Frameworks */ = {isa = PBXBuildFile; productRef = 894827AF2AA5D65600030C4E /* BranchSDK */; };
 111: 		894827B22AA5D68D00030C4E /* AttributionManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894827B12AA5D68D00030C4E /* AttributionManager.swift */; };
 112: 		894827B42AA5D6FF00030C4E /* AttibutionManagerImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894827B32AA5D6FF00030C4E /* AttibutionManagerImpl.swift */; };
 113: 		894AC3642A02952A00BA5553 /* Foundation+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894AC3632A02952A00BA5553 /* Foundation+Extensions.swift */; };
 114: 		894B019F2A0902BC00FF6198 /* ImportTutorialView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894B019E2A0902BC00FF6198 /* ImportTutorialView.swift */; };
 115: 		894B01A12A09030000FF6198 /* ImportTutorialPageView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894B01A02A09030000FF6198 /* ImportTutorialPageView.swift */; };
 116: 		894C4A692AA0C04B0001F51E /* PopupView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894C4A682AA0C04B0001F51E /* PopupView.swift */; };
 117: 		894C4A6B2AA0C23F0001F51E /* PreReviewPopupView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894C4A6A2AA0C23F0001F51E /* PreReviewPopupView.swift */; };
 118: 		894C4A6E2AA0CB470001F51E /* ReviewFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894C4A6D2AA0CB470001F51E /* ReviewFlow.swift */; };
 119: 		894C4A702AA0CCFC0001F51E /* ReviewFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894C4A6F2AA0CCFC0001F51E /* ReviewFlowView.swift */; };
 120: 		894C4A722AA0DB9A0001F51E /* PreReviewPopupLowRateView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894C4A712AA0DB9A0001F51E /* PreReviewPopupLowRateView.swift */; };
 121: 		894CB09E2A851FE50008008A /* ChatPdfSetupData.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894CB09D2A851FE50008008A /* ChatPdfSetupData.swift */; };
 122: 		894CB0A02A8520AD0008008A /* ChatPdfSetupData+Decodable.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894CB09F2A8520AD0008008A /* ChatPdfSetupData+Decodable.swift */; };
 123: 		894D485829D42C9E002B0230 /* OptionItemView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894D485729D42C9D002B0230 /* OptionItemView.swift */; };
 124: 		894D485A29D42CC5002B0230 /* OptionListView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894D485929D42CC5002B0230 /* OptionListView.swift */; };
 125: 		894D485C29D42FE1002B0230 /* RoundedCorner.swift in Sources */ = {isa = PBXBuildFile; fileRef = 894D485B29D42FE1002B0230 /* RoundedCorner.swift */; };
 126: 		89504A462A448252000BCACD /* PdfFillWidgetView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89504A452A448252000BCACD /* PdfFillWidgetView.swift */; };
 127: 		89504A482A44829C000BCACD /* PdfFillWidgetViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89504A472A44829C000BCACD /* PdfFillWidgetViewModel.swift */; };
 128: 		8955ED922A1F61A9009985EE /* OnboardingView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8955ED912A1F61A9009985EE /* OnboardingView.swift */; };
 129: 		8955ED942A1F61BD009985EE /* OnboardingPageView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8955ED932A1F61BD009985EE /* OnboardingPageView.swift */; };
 130: 		8955ED962A1F73DC009985EE /* OnboardingViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8955ED952A1F73DC009985EE /* OnboardingViewModel.swift */; };
 131: 		8957FBA82A77C646008B31ED /* PdfShareCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8957FBA72A77C646008B31ED /* PdfShareCoordinator.swift */; };
 132: 		8957FBAA2A77E6F7008B31ED /* PdfShareView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8957FBA92A77E6F7008B31ED /* PdfShareView.swift */; };
 133: 		8957FBAC2A7801BA008B31ED /* PdfCompressionPickerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8957FBAB2A7801BA008B31ED /* PdfCompressionPickerView.swift */; };
 134: 		895C1BB02A04FA53005EA190 /* ShareViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895C1BAF2A04FA53005EA190 /* ShareViewController.swift */; };
 135: 		895C1BB32A04FA53005EA190 /* MainInterface.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 895C1BB12A04FA53005EA190 /* MainInterface.storyboard */; };
 136: 		895C1BC02A051261005EA190 /* SharedStorage.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895C1BBF2A051261005EA190 /* SharedStorage.swift */; };
 137: 		895C1BC12A051261005EA190 /* SharedStorage.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895C1BBF2A051261005EA190 /* SharedStorage.swift */; };
 138: 		895FE2C429D6D7E500A99D5B /* ScannerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895FE2C329D6D7E500A99D5B /* ScannerView.swift */; };
 139: 		895FE2C629D6E17600A99D5B /* AnimationPalette.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895FE2C529D6E17600A99D5B /* AnimationPalette.swift */; };
 140: 		895FE2CB29D6E9B800A99D5B /* SubscriptionPairsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895FE2CA29D6E9B800A99D5B /* SubscriptionPairsView.swift */; };
 141: 		895FE2CD29D724B900A99D5B /* SubscriptionPairsItemView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 895FE2CC29D724B900A99D5B /* SubscriptionPairsItemView.swift */; };
 142: 		895FE2D029D7392F00A99D5B /* Collections in Frameworks */ = {isa = PBXBuildFile; productRef = 895FE2CF29D7392F00A99D5B /* Collections */; };
 143: 		895FE2D229D7392F00A99D5B /* OrderedCollections in Frameworks */ = {isa = PBXBuildFile; productRef = 895FE2D129D7392F00A99D5B /* OrderedCollections */; };
 144: 		8962D6062A9E28FB008426A2 /* PdfSignaturePrioviderFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8962D6052A9E28FB008426A2 /* PdfSignaturePrioviderFlow.swift */; };
 145: 		8962D6082A9E2A57008426A2 /* PdfSignatureProviderFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8962D6072A9E2A57008426A2 /* PdfSignatureProviderFlowView.swift */; };
 146: 		8966B6F22AA9FCE0005E6DED /* SuggestedFields.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8966B6F12AA9FCE0005E6DED /* SuggestedFields.swift */; };
 147: 		8968761A2A7CE87A0014A320 /* PdfSplitViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896876192A7CE87A0014A320 /* PdfSplitViewModel.swift */; };
 148: 		8968761C2A7CEB650014A320 /* PdfImportViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8968761B2A7CEB650014A320 /* PdfImportViewModel.swift */; };
 149: 		8968761E2A7CEE320014A320 /* PdfImportView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8968761D2A7CEE320014A320 /* PdfImportView.swift */; };
 150: 		896876202A7CF1E10014A320 /* PdfImportMultipleViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8968761F2A7CF1E00014A320 /* PdfImportMultipleViewModel.swift */; };
 151: 		896876222A7CF3220014A320 /* PdfImportMultipleView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896876212A7CF3220014A320 /* PdfImportMultipleView.swift */; };
 152: 		896876242A7D05040014A320 /* PdfSplitView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896876232A7D05040014A320 /* PdfSplitView.swift */; };
 153: 		896876262A7D2EB80014A320 /* PdfPageRangeEditorViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896876252A7D2EB80014A320 /* PdfPageRangeEditorViewModel.swift */; };
 154: 		896876282A7D2EC20014A320 /* PdfPageRangeEditorView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896876272A7D2EC20014A320 /* PdfPageRangeEditorView.swift */; };
 155: 		896CCF6D2A28910B008F268E /* SizePrinter.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896CCF6C2A28910B008F268E /* SizePrinter.swift */; };
 156: 		896CCF6F2A28AEAC008F268E /* UIFont+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 896CCF6E2A28AEAC008F268E /* UIFont+Extensions.swift */; };
 157: 		897911ED29E70541008B7088 /* SubscriptionVerticalView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 897911EC29E70541008B7088 /* SubscriptionVerticalView.swift */; };
 158: 		897911EF29E70558008B7088 /* SubscriptionVerticalItemView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 897911EE29E70558008B7088 /* SubscriptionVerticalItemView.swift */; };
 159: 		897967862A73E59B00E91F8E /* URL+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 897967852A73E59B00E91F8E /* URL+Extensions.swift */; };
 160: 		89851B5E2A13DB1A00ABF58F /* ImageResizableView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89851B5D2A13DB1A00ABF58F /* ImageResizableView.swift */; };
 161: 		8991485129E851B500DD01F2 /* ConfigService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8991485029E851B500DD01F2 /* ConfigService.swift */; };
 162: 		8991485329E851BD00DD01F2 /* RemoteConfigManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8991485229E851BD00DD01F2 /* RemoteConfigManager.swift */; };
 163: 		8991485629E85DE500DD01F2 /* CombineExt in Frameworks */ = {isa = PBXBuildFile; productRef = 8991485529E85DE500DD01F2 /* CombineExt */; };
 164: 		89923E5F29D4350F00E246FC /* AppTrackingTransparencyImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89923E5D29D4350F00E246FC /* AppTrackingTransparencyImpl.swift */; };
 165: 		89923E6029D4350F00E246FC /* AppTrackingTransparency.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89923E5E29D4350F00E246FC /* AppTrackingTransparency.swift */; };
 166: 		89923E6729D437F500E246FC /* FirebasePerformance in Frameworks */ = {isa = PBXBuildFile; productRef = 89923E6629D437F500E246FC /* FirebasePerformance */; };
 167: 		89923E6929D46A9900E246FC /* FilePicker.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89923E6829D46A9900E246FC /* FilePicker.swift */; };
 168: 		89923E6B29D47B9E00E246FC /* pdf-scanning.json in Resources */ = {isa = PBXBuildFile; fileRef = 89923E6A29D47B9E00E246FC /* pdf-scanning.json */; };
 169: 		8995694229D33B1300566EF4 /* HomeItemView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8995694129D33B1300566EF4 /* HomeItemView.swift */; };
 170: 		8995694429D3450300566EF4 /* HomeViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8995694329D3450300566EF4 /* HomeViewModel.swift */; };
 171: 		899F484429DF128200E7E1E4 /* MainTabView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 899F484329DF128200E7E1E4 /* MainTabView.swift */; };
 172: 		89AAFEA129DB2672002D348E /* CacheManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89AAFE9F29DB2672002D348E /* CacheManager.swift */; };
 173: 		89AAFEA229DB2672002D348E /* CacheManagerImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89AAFEA029DB2672002D348E /* CacheManagerImpl.swift */; };
 174: 		89AAFEA729DB2AC4002D348E /* WelcomeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89AAFEA629DB2AC4002D348E /* WelcomeView.swift */; };
 175: 		89ABAA592A97B29C00721045 /* PdfDocument+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89ABAA582A97B29C00721045 /* PdfDocument+Extensions.swift */; };
 176: 		89B72A3329DADC790076884F /* SettingsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89B72A3229DADC790076884F /* SettingsView.swift */; };
 177: 		89BB2DB72A7A5EFC009E6738 /* PdfMergeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DB62A7A5EFC009E6738 /* PdfMergeView.swift */; };
 178: 		89BB2DB92A7A6050009E6738 /* PdfMergeViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DB82A7A6050009E6738 /* PdfMergeViewModel.swift */; };
 179: 		89BB2DBB2A7A7DD7009E6738 /* PdfUnlockViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DBA2A7A7DD7009E6738 /* PdfUnlockViewModel.swift */; };
 180: 		89BB2DBD2A7A80A8009E6738 /* PdfUnlockView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DBC2A7A80A8009E6738 /* PdfUnlockView.swift */; };
 181: 		89BB2DBF2A7AB0CE009E6738 /* PdfSortViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DBE2A7AB0CE009E6738 /* PdfSortViewModel.swift */; };
 182: 		89BB2DC12A7AB4A8009E6738 /* PdfSortView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89BB2DC02A7AB4A8009E6738 /* PdfSortView.swift */; };
 183: 		89C2500F2A72B2BC00184C45 /* CDPdf.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89C2500E2A72B2BC00184C45 /* CDPdf.swift */; };
 184: 		89CD7A9A29D32855003F1C3A /* PdfExpertApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7A9929D32855003F1C3A /* PdfExpertApp.swift */; };
 185: 		89CD7AA129D32856003F1C3A /* Preview Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 89CD7AA029D32856003F1C3A /* Preview Assets.xcassets */; };
 186: 		89CD7B3029D329B1003F1C3A /* Colors.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 89CD7AAE29D329B1003F1C3A /* Colors.xcassets */; };
 187: 		89CD7B3329D329B1003F1C3A /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 89CD7AB229D329B1003F1C3A /* Assets.xcassets */; };
 188: 		89CD7B3429D329B1003F1C3A /* Products.plist in Resources */ = {isa = PBXBuildFile; fileRef = 89CD7AB429D329B1003F1C3A /* Products.plist */; };
 189: 		89CD7B4A29D329B1003F1C3A /* loading.json in Resources */ = {isa = PBXBuildFile; fileRef = 89CD7ACC29D329B1003F1C3A /* loading.json */; };
 190: 		89CD7B4B29D329B1003F1C3A /* AsyncView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7ACF29D329B1003F1C3A /* AsyncView.swift */; };
 191: 		89CD7B4C29D329B1003F1C3A /* CircularProgressView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD029D329B1003F1C3A /* CircularProgressView.swift */; };
 192: 		89CD7B4D29D329B1003F1C3A /* UnderlyingError.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD129D329B1003F1C3A /* UnderlyingError.swift */; };
 193: 		89CD7B4E29D329B1003F1C3A /* LottieView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD229D329B1003F1C3A /* LottieView.swift */; };
 194: 		89CD7B4F29D329B1003F1C3A /* ParentalCheck.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD329D329B1003F1C3A /* ParentalCheck.swift */; };
 195: 		89CD7B5029D329B1003F1C3A /* String+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD529D329B1003F1C3A /* String+Extensions.swift */; };
 196: 		89CD7B5129D329B1003F1C3A /* UIApplication+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD629D329B1003F1C3A /* UIApplication+Extensions.swift */; };
 197: 		89CD7B5229D329B1003F1C3A /* View+Alert.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD729D329B1003F1C3A /* View+Alert.swift */; };
 198: 		89CD7B5329D329B1003F1C3A /* View+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD829D329B1003F1C3A /* View+Extensions.swift */; };
 199: 		89CD7B5429D329B1003F1C3A /* Color+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AD929D329B1003F1C3A /* Color+Extensions.swift */; };
 200: 		89CD7B5529D329B1003F1C3A /* Enum+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7ADA29D329B1003F1C3A /* Enum+Extensions.swift */; };
 201: 		89CD7B5629D329B1003F1C3A /* Async.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7ADB29D329B1003F1C3A /* Async.swift */; };
 202: 		89CD7B5729D329B1003F1C3A /* DebugUtils.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7ADC29D329B1003F1C3A /* DebugUtils.swift */; };
 203: 		89CD7B5F29D329B1003F1C3A /* StoreImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AE529D329B1003F1C3A /* StoreImpl.swift */; };
 204: 		89CD7B6529D329B1003F1C3A /* Store.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AEB29D329B1003F1C3A /* Store.swift */; };
 205: 		89CD7B6E29D329B1003F1C3A /* Constants.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AF629D329B1003F1C3A /* Constants.swift */; };
 206: 		89CD7B7029D329B1003F1C3A /* FontPalette.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AF929D329B1003F1C3A /* FontPalette.swift */; };
 207: 		89CD7B7129D329B1003F1C3A /* ColorPalette.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AFA29D329B1003F1C3A /* ColorPalette.swift */; };
 208: 		89CD7B7329D329B1003F1C3A /* SubscribeViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7AFD29D329B1003F1C3A /* SubscribeViewModel.swift */; };
 209: 		89CD7B9329D329B1003F1C3A /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7B2629D329B1003F1C3A /* ContentView.swift */; };
 210: 		89CD7B9729D329B1003F1C3A /* SharedErrors.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7B2C29D329B1003F1C3A /* SharedErrors.swift */; };
 211: 		89CD7B9829D329B1003F1C3A /* SubscriptionViewUtility.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7B2D29D329B1003F1C3A /* SubscriptionViewUtility.swift */; };
 212: 		89CD7B9929D329B1003F1C3A /* View+Preview.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7B2E29D329B1003F1C3A /* View+Preview.swift */; };
 213: 		89CD7B9A29D329B1003F1C3A /* View+Internal.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7B2F29D329B1003F1C3A /* View+Internal.swift */; };
 214: 		89CD7BA529D32C52003F1C3A /* Lottie in Frameworks */ = {isa = PBXBuildFile; productRef = 89CD7BA429D32C52003F1C3A /* Lottie */; };
 215: 		89CD7BA829D32C72003F1C3A /* Factory in Frameworks */ = {isa = PBXBuildFile; productRef = 89CD7BA729D32C72003F1C3A /* Factory */; };
 216: 		89CD7BAB29D32CE5003F1C3A /* FirebaseAnalyticsSwift in Frameworks */ = {isa = PBXBuildFile; productRef = 89CD7BAA29D32CE5003F1C3A /* FirebaseAnalyticsSwift */; };
 217: 		89CD7BAD29D32CE5003F1C3A /* FirebaseCrashlytics in Frameworks */ = {isa = PBXBuildFile; productRef = 89CD7BAC29D32CE5003F1C3A /* FirebaseCrashlytics */; };
 218: 		89CD7BB629D32E69003F1C3A /* MainCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7BB429D32E69003F1C3A /* MainCoordinator.swift */; };
 219: 		89CD7BBB29D330FB003F1C3A /* HomeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7BBA29D330FB003F1C3A /* HomeView.swift */; };
 220: 		89CD7BBD29D331AA003F1C3A /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89CD7BBC29D331AA003F1C3A /* AppDelegate.swift */; };
 221: 		89D1FE7E2A84D428009AC57C /* SubscriptionPickerPlanListView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89D1FE7D2A84D428009AC57C /* SubscriptionPickerPlanListView.swift */; };
 222: 		89D1FE802A84D76B009AC57C /* FullScreenClearBackground.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89D1FE7F2A84D76B009AC57C /* FullScreenClearBackground.swift */; };
 223: 		89D79DF82A654DC80086A8E5 /* Poppins-ExtraLightItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DE62A654DC70086A8E5 /* Poppins-ExtraLightItalic.ttf */; };
 224: 		89D79DF92A654DC80086A8E5 /* Poppins-SemiBold.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DE72A654DC70086A8E5 /* Poppins-SemiBold.ttf */; };
 225: 		89D79DFA2A654DC80086A8E5 /* Poppins-Black.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DE82A654DC80086A8E5 /* Poppins-Black.ttf */; };
 226: 		89D79DFB2A654DC80086A8E5 /* Poppins-ThinItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DE92A654DC80086A8E5 /* Poppins-ThinItalic.ttf */; };
 227: 		89D79DFC2A654DC80086A8E5 /* Poppins-Light.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DEA2A654DC80086A8E5 /* Poppins-Light.ttf */; };
 228: 		89D79DFD2A654DC80086A8E5 /* Poppins-BlackItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DEB2A654DC80086A8E5 /* Poppins-BlackItalic.ttf */; };
 229: 		89D79DFE2A654DC80086A8E5 /* Poppins-Medium.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DEC2A654DC80086A8E5 /* Poppins-Medium.ttf */; };
 230: 		89D79DFF2A654DC80086A8E5 /* Poppins-Italic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DED2A654DC80086A8E5 /* Poppins-Italic.ttf */; };
 231: 		89D79E002A654DC80086A8E5 /* Poppins-ExtraBold.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DEE2A654DC80086A8E5 /* Poppins-ExtraBold.ttf */; };
 232: 		89D79E012A654DC80086A8E5 /* Poppins-Thin.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DEF2A654DC80086A8E5 /* Poppins-Thin.ttf */; };
 233: 		89D79E022A654DC80086A8E5 /* Poppins-ExtraLight.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF02A654DC80086A8E5 /* Poppins-ExtraLight.ttf */; };
 234: 		89D79E032A654DC80086A8E5 /* Poppins-ExtraBoldItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF12A654DC80086A8E5 /* Poppins-ExtraBoldItalic.ttf */; };
 235: 		89D79E042A654DC80086A8E5 /* Poppins-LightItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF22A654DC80086A8E5 /* Poppins-LightItalic.ttf */; };
 236: 		89D79E052A654DC80086A8E5 /* Poppins-Regular.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF32A654DC80086A8E5 /* Poppins-Regular.ttf */; };
 237: 		89D79E062A654DC80086A8E5 /* Poppins-MediumItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF42A654DC80086A8E5 /* Poppins-MediumItalic.ttf */; };
 238: 		89D79E072A654DC80086A8E5 /* Poppins-BoldItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF52A654DC80086A8E5 /* Poppins-BoldItalic.ttf */; };
 239: 		89D79E082A654DC80086A8E5 /* Poppins-Bold.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF62A654DC80086A8E5 /* Poppins-Bold.ttf */; };
 240: 		89D79E092A654DC80086A8E5 /* Poppins-SemiBoldItalic.ttf in Resources */ = {isa = PBXBuildFile; fileRef = 89D79DF72A654DC80086A8E5 /* Poppins-SemiBoldItalic.ttf */; };
 241: 		89E55BDC29DC64840073F268 /* AnalyticsManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E55BD829DC64840073F268 /* AnalyticsManager.swift */; };
 242: 		89E55BDE29DC64840073F268 /* FirebaseAnalyticsPlatform.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E55BDA29DC64840073F268 /* FirebaseAnalyticsPlatform.swift */; };
 243: 		89E55BDF29DC64840073F268 /* AnalyticsManagerImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E55BDB29DC64840073F268 /* AnalyticsManagerImpl.swift */; };
 244: 		89E55BE229DC66240073F268 /* AnalyticsPlatform.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E55BE129DC66240073F268 /* AnalyticsPlatform.swift */; };
 245: 		89E601622A829556009492DA /* SubscriptionPickerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E601612A829556009492DA /* SubscriptionPickerView.swift */; };
 246: 		89E601642A8295A2009492DA /* SubscriptionPickerViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89E601632A8295A2009492DA /* SubscriptionPickerViewModel.swift */; };
 247: 		89EBC9052A83CC3000BDBBD4 /* SubscriptionFreeTrialToggleView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89EBC9042A83CC3000BDBBD4 /* SubscriptionFreeTrialToggleView.swift */; };
 248: 		89EBC9072A83D0DB00BDBBD4 /* SubscriptionPickerPlanView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89EBC9062A83D0DB00BDBBD4 /* SubscriptionPickerPlanView.swift */; };
 249: 		89ED72BB2A9F6B3A004F541F /* AdSupport.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 89ED72B82A9F69E5004F541F /* AdSupport.framework */; };
 250: 		89F9E4F92A95FEEE0001D48B /* PDFImageExtractor.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89F9E4F82A95FEED0001D48B /* PDFImageExtractor.swift */; };
 251: 		89F9E4FB2A9606ED0001D48B /* PdfImageViewerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89F9E4FA2A9606ED0001D48B /* PdfImageViewerView.swift */; };
 252: 		89F9E4FD2A9635EC0001D48B /* ZoomImageModifier.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89F9E4FC2A9635EC0001D48B /* ZoomImageModifier.swift */; };
 253: 		C999928D2DAF4C9B003C3643 /* GoogleService-Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = C999928C2DAF4C9B003C3643 /* GoogleService-Info.plist */; };
 254: 		C9CEF5DD2DAF973100980C8A /* Montserrat-ExtraBold.ttf in Resources */ = {isa = PBXBuildFile; fileRef = C9CEF5DC2DAF973100980C8A /* Montserrat-ExtraBold.ttf */; };
 255: 		C9CEF5DF2DAF974500980C8A /* Montserrat-Medium.ttf in Resources */ = {isa = PBXBuildFile; fileRef = C9CEF5DE2DAF974500980C8A /* Montserrat-Medium.ttf */; };
 256: 		C9CEF5E12DAF975200980C8A /* Montserrat-Regular.ttf in Resources */ = {isa = PBXBuildFile; fileRef = C9CEF5E02DAF975200980C8A /* Montserrat-Regular.ttf */; };
 257: 		C9CEF5E32DAF975A00980C8A /* Montserrat-Bold.ttf in Resources */ = {isa = PBXBuildFile; fileRef = C9CEF5E22DAF975A00980C8A /* Montserrat-Bold.ttf */; };
 258: 		C9CEF5E72DB02DBA00980C8A /* ShareFileExtension.appex in Embed Foundation Extensions */ = {isa = PBXBuildFile; fileRef = 895C1BAD2A04FA53005EA190 /* ShareFileExtension.appex */; settings = {ATTRIBUTES = (RemoveHeadersOnCopy, ); }; };
 259: 		C9CEF5EC2DB03CCE00980C8A /* SceneDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = C9CEF5EB2DB03CCB00980C8A /* SceneDelegate.swift */; };
 260: /* End PBXBuildFile section */
 261: 
 262: /* Begin PBXContainerItemProxy section */
 263: 		C9CEF5E82DB02DBA00980C8A /* PBXContainerItemProxy */ = {
 264: 			isa = PBXContainerItemProxy;
 265: 			containerPortal = 89CD7A8E29D32855003F1C3A /* Project object */;
 266: 			proxyType = 1;
 267: 			remoteGlobalIDString = 895C1BAC2A04FA53005EA190;
 268: 			remoteInfo = ShareFileExtension;
 269: 		};
 270: /* End PBXContainerItemProxy section */
 271: 
 272: /* Begin PBXCopyFilesBuildPhase section */
 273: 		C9CEF5EA2DB02DBB00980C8A /* Embed Foundation Extensions */ = {
 274: 			isa = PBXCopyFilesBuildPhase;
 275: 			buildActionMask = 2147483647;
 276: 			dstPath = "";
 277: 			dstSubfolderSpec = 13;
 278: 			files = (
 279: 				C9CEF5E72DB02DBA00980C8A /* ShareFileExtension.appex in Embed Foundation Extensions */,
 280: 			);
 281: 			name = "Embed Foundation Extensions";
 282: 			runOnlyForDeploymentPostprocessing = 0;
 283: 		};
 284: /* End PBXCopyFilesBuildPhase section */
 285: 
 286: /* Begin PBXFileReference section */
 287: 		8902898C29DC1F10007E6372 /* PageControl.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PageControl.swift; sourceTree = "<group>"; };
 288: 		89127AA02A177E370059005F /* PencilKitView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PencilKitView.swift; sourceTree = "<group>"; };
 289: 		89127AA22A177F170059005F /* PdfSignatureCanvasView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignatureCanvasView.swift; sourceTree = "<group>"; };
 290: 		89127AA42A17A3600059005F /* PdfSignatureCanvasViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignatureCanvasViewModel.swift; sourceTree = "<group>"; };
 291: 		89127AA62A17C1980059005F /* PencilKit+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "PencilKit+Extensions.swift"; sourceTree = "<group>"; };
 292: 		891AE58A2A03E80300DBC246 /* ObservableObject+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ObservableObject+Extensions.swift"; sourceTree = "<group>"; };
 293: 		892201D82A0BA64600832CF2 /* ImageAnnotationStamp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImageAnnotationStamp.swift; sourceTree = "<group>"; };
 294: 		892201DB2A0BA70300832CF2 /* PdfSignatureView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignatureView.swift; sourceTree = "<group>"; };
 295: 		892201DD2A0BA72D00832CF2 /* PdfSignatureViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignatureViewModel.swift; sourceTree = "<group>"; };
 296: 		8928F3D02A30BAFB001C1853 /* PickedImage.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PickedImage.swift; sourceTree = "<group>"; };
 297: 		892CC6912AAA23AE000DEC21 /* CDSuggestedFields.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CDSuggestedFields.swift; sourceTree = "<group>"; };
 298: 		892CC6932AAA243E000DEC21 /* SuggestedFields+Persistable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "SuggestedFields+Persistable.swift"; sourceTree = "<group>"; };
 299: 		892CC6952AAA2641000DEC21 /* SuggestedFieldsFormView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SuggestedFieldsFormView.swift; sourceTree = "<group>"; };
 300: 		892CC6972AAA2660000DEC21 /* SuggestedFieldsFormViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SuggestedFieldsFormViewModel.swift; sourceTree = "<group>"; };
 301: 		892E404E2A25E5D9000EEE23 /* PDFAnnotation+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "PDFAnnotation+Extensions.swift"; sourceTree = "<group>"; };
 302: 		8932ECE42A20DC7700CBCD7A /* PdfFillFormView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfFillFormView.swift; sourceTree = "<group>"; };
 303: 		8932ECE62A20DCB900CBCD7A /* PdfFillFormViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfFillFormViewModel.swift; sourceTree = "<group>"; };
 304: 		8932ECE82A20F10500CBCD7A /* TextResizableView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TextResizableView.swift; sourceTree = "<group>"; };
 305: 		8933490B2A24AE880005D484 /* PdfKitViewBinder.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfKitViewBinder.swift; sourceTree = "<group>"; };
 306: 		8934ACC62A6AE96700F6CDA8 /* ChatPdfInitParams.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfInitParams.swift; sourceTree = "<group>"; };
 307: 		8936AA2A2A67F975005F6C73 /* ci_post_clone.sh */ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = ci_post_clone.sh; sourceTree = "<group>"; };
 308: 		8936AA302A682812005F6C73 /* ProjectInfo.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = ProjectInfo.plist; sourceTree = "<group>"; };
 309: 		8936AA322A6828C9005F6C73 /* ProjectInfo.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ProjectInfo.swift; sourceTree = "<group>"; };
 310: 		8936AA352A68299B005F6C73 /* ChatPdfManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ChatPdfManager.swift; sourceTree = "<group>"; };
 311: 		8936AA362A68299B005F6C73 /* ChatPdfManagerMock.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ChatPdfManagerMock.swift; sourceTree = "<group>"; };
 312: 		8936AA3B2A682CDA005F6C73 /* ChatPdfSelectionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfSelectionView.swift; sourceTree = "<group>"; };
 313: 		8936AA3D2A682F8E005F6C73 /* ChatPdfSelectionViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfSelectionViewModel.swift; sourceTree = "<group>"; };
 314: 		8936AA3F2A683FB5005F6C73 /* ImportOption.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImportOption.swift; sourceTree = "<group>"; };
 315: 		8936AA412A6840D1005F6C73 /* ChatPdfView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfView.swift; sourceTree = "<group>"; };
 316: 		8936AA432A684128005F6C73 /* ChatPdfViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfViewModel.swift; sourceTree = "<group>"; };
 317: 		893875002A7BDD3B00267AFD /* LoadingView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LoadingView.swift; sourceTree = "<group>"; };
 318: 		893AAFCA2A39B2AF00EF9B00 /* FormSheet.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FormSheet.swift; sourceTree = "<group>"; };
 319: 		893B04BC2AA9C2C100F86813 /* CoreGraphics+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "CoreGraphics+Extensions.swift"; sourceTree = "<group>"; };
 320: 		893BE52C2A6A78BB004B05B9 /* ChatPdfManagerImpl.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfManagerImpl.swift; sourceTree = "<group>"; };
 321: 		893BE52E2A6A7C0C004B05B9 /* NetworkUtility.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NetworkUtility.swift; sourceTree = "<group>"; };
 322: 		893BE5342A6A96F5004B05B9 /* ChatPdfRef+Decodable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ChatPdfRef+Decodable.swift"; sourceTree = "<group>"; };
 323: 		893BE5362A6A9708004B05B9 /* ChatPdfMessage+Decodable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ChatPdfMessage+Decodable.swift"; sourceTree = "<group>"; };
 324: 		893C8FC829DED190000E35BD /* ArchiveView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ArchiveView.swift; sourceTree = "<group>"; };
 325: 		893C8FCA29DED1AF000E35BD /* ArchiveViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ArchiveViewModel.swift; sourceTree = "<group>"; };
 326: 		893C8FCD29DED254000E35BD /* PdfExpert.xcdatamodel */ = {isa = PBXFileReference; lastKnownFileType = wrapper.xcdatamodel; path = PdfExpert.xcdatamodel; sourceTree = "<group>"; };
 327: 		893C8FCF29DED278000E35BD /* Persistence.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Persistence.swift; sourceTree = "<group>"; };
 328: 		893C8FD129DED2E9000E35BD /* Repository.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Repository.swift; sourceTree = "<group>"; };
 329: 		893C8FD229DED2E9000E35BD /* RepositoryImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = RepositoryImpl.swift; sourceTree = "<group>"; };
 330: 		893C8FDD29DED7F4000E35BD /* PdfUtility.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfUtility.swift; sourceTree = "<group>"; };
 331: 		893C8FE029DEDAF4000E35BD /* test.pdf */ = {isa = PBXFileReference; lastKnownFileType = image.pdf; path = test.pdf; sourceTree = "<group>"; };
 332: 		893C8FE229DF0145000E35BD /* PdfExpert.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = PdfExpert.entitlements; sourceTree = "<group>"; };
 333: 		893DE8D929E7F85C0043C02C /* SubscriptionPairsViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPairsViewModel.swift; sourceTree = "<group>"; };
 334: 		893DE8DB29E7F9A10043C02C /* SubscriptionVerticalViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionVerticalViewModel.swift; sourceTree = "<group>"; };
 335: 		893DE8DD29E832B90043C02C /* LocalProductionProducts.storekit */ = {isa = PBXFileReference; lastKnownFileType = text; path = LocalProductionProducts.storekit; sourceTree = "<group>"; };
 336: 		893E849029D5874D00F6B99A /* CameraView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CameraView.swift; sourceTree = "<group>"; };
 337: 		893E849329D5878E00F6B99A /* CameraViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CameraViewModel.swift; sourceTree = "<group>"; };
 338: 		893E849629D5944E00F6B99A /* PhotoCaptureProcessor.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PhotoCaptureProcessor.swift; sourceTree = "<group>"; };
 339: 		893E849729D5944E00F6B99A /* CameraService+Enums.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "CameraService+Enums.swift"; sourceTree = "<group>"; };
 340: 		893E849829D5944E00F6B99A /* CameraPreviewView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CameraPreviewView.swift; sourceTree = "<group>"; };
 341: 		893E849929D5944E00F6B99A /* ImageResizer.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ImageResizer.swift; sourceTree = "<group>"; };
 342: 		893E849A29D5944E00F6B99A /* CameraService.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CameraService.swift; sourceTree = "<group>"; };
 343: 		893E849B29D5944E00F6B99A /* CameraService+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "CameraService+Extensions.swift"; sourceTree = "<group>"; };
 344: 		893E84A529D5C5E200F6B99A /* ActivityViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ActivityViewController.swift; sourceTree = "<group>"; };
 345: 		893EB5022AA71FFD0066914E /* BranchAnalyticsPlatform.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BranchAnalyticsPlatform.swift; sourceTree = "<group>"; };
 346: 		893EB5042AA722EF0066914E /* StoreKit+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "StoreKit+Extensions.swift"; sourceTree = "<group>"; };
 347: 		893EB5062AA723C80066914E /* AnalyticsDefaultParameters.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AnalyticsDefaultParameters.swift; sourceTree = "<group>"; };
 348: 		893ED9CF2A6920F2004EE67C /* ChatPdfRef.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfRef.swift; sourceTree = "<group>"; };
 349: 		893ED9D12A6926E8004EE67C /* ChatPdfMessage.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfMessage.swift; sourceTree = "<group>"; };
 350: 		893ED9D32A692805004EE67C /* CombineUtils.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CombineUtils.swift; sourceTree = "<group>"; };
 351: 		893ED9D72A693013004EE67C /* MessageView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MessageView.swift; sourceTree = "<group>"; };
 352: 		893ED9D82A693013004EE67C /* MessageIndicatorView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MessageIndicatorView.swift; sourceTree = "<group>"; };
 353: 		89407EF02AA8ADD200169801 /* GalleryImageProviderFlow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GalleryImageProviderFlow.swift; sourceTree = "<group>"; };
 354: 		89407EF22AA8B0C800169801 /* GalleryImageProviderFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GalleryImageProviderFlowView.swift; sourceTree = "<group>"; };
 355: 		89407EF42AA8BDE600169801 /* CameraImageProviderFlow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CameraImageProviderFlow.swift; sourceTree = "<group>"; };
 356: 		89407EF62AA8BEC200169801 /* CameraImageProviderFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CameraImageProviderFlowView.swift; sourceTree = "<group>"; };
 357: 		89407EFB2AA8D22D00169801 /* ImageCropFlow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImageCropFlow.swift; sourceTree = "<group>"; };
 358: 		89407EFD2AA8D23B00169801 /* ImageCropFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImageCropFlowView.swift; sourceTree = "<group>"; };
 359: 		89407EFF2AA8D54800169801 /* ImageCropper.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ImageCropper.swift; sourceTree = "<group>"; };
 360: 		8940FB902A710D8D00A00D8D /* AddPasswordView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AddPasswordView.swift; sourceTree = "<group>"; };
 361: 		89429F852A9C8ECC00465420 /* PdfSignaturePickerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignaturePickerView.swift; sourceTree = "<group>"; };
 362: 		89429F872A9C8EFC00465420 /* PdfSignaturePickerViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignaturePickerViewModel.swift; sourceTree = "<group>"; };
 363: 		89429F892A9C937300465420 /* Signature.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Signature.swift; sourceTree = "<group>"; };
 364: 		89429F8B2A9C937C00465420 /* CDSignature.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CDSignature.swift; sourceTree = "<group>"; };
 365: 		89429F902A9CFFDC00465420 /* Persistable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Persistable.swift; sourceTree = "<group>"; };
 366: 		89429F922A9CFFF100465420 /* Pdf+Persistable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Pdf+Persistable.swift"; sourceTree = "<group>"; };
 367: 		89429F942A9D001A00465420 /* Signature+Persistable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Signature+Persistable.swift"; sourceTree = "<group>"; };
 368: 		89431FC52A9900740042A636 /* MathUtils.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MathUtils.swift; sourceTree = "<group>"; };
 369: 		89436AB729E5556600060605 /* PdfCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfCoordinator.swift; sourceTree = "<group>"; };
 370: 		89436ABA29E557D500060605 /* PdfFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfFlowView.swift; sourceTree = "<group>"; };
 371: 		89436ABC29E5586600060605 /* PdfEditView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfEditView.swift; sourceTree = "<group>"; };
 372: 		89436ABE29E55EA000060605 /* Pdf.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Pdf.swift; sourceTree = "<group>"; };
 373: 		89436AC229E59C0E00060605 /* PdfEditViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfEditViewModel.swift; sourceTree = "<group>"; };
 374: 		89436AC629E5B99100060605 /* PdfKitView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfKitView.swift; sourceTree = "<group>"; };
 375: 		89436D182A936C9F000868B5 /* PdfReadView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfReadView.swift; sourceTree = "<group>"; };
 376: 		89436D1A2A939CBB000868B5 /* PdfReadViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfReadViewModel.swift; sourceTree = "<group>"; };
 377: 		89436D1C2A93AE76000868B5 /* PdfReaderView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfReaderView.swift; sourceTree = "<group>"; };
 378: 		89436D1E2A93AEB4000868B5 /* PdfReaderViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfReaderViewModel.swift; sourceTree = "<group>"; };
 379: 		89436D202A93B97E000868B5 /* NSAttributedString+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "NSAttributedString+Extensions.swift"; sourceTree = "<group>"; };
 380: 		89436D222A93C1CE000868B5 /* PdfPageSelectionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfPageSelectionView.swift; sourceTree = "<group>"; };
 381: 		8945D2BB2A03C41000AFF51A /* PdfScanUtility.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfScanUtility.swift; sourceTree = "<group>"; };
 382: 		89460C5F29DAC36600E39BAC /* SubscriptionErrorView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionErrorView.swift; sourceTree = "<group>"; };
 383: 		89467AD62A9E4C6B00FC01FC /* Deeplink.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Deeplink.swift; sourceTree = "<group>"; };
 384: 		894827B12AA5D68D00030C4E /* AttributionManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AttributionManager.swift; sourceTree = "<group>"; };
 385: 		894827B32AA5D6FF00030C4E /* AttibutionManagerImpl.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AttibutionManagerImpl.swift; sourceTree = "<group>"; };
 386: 		894827B82AA5DCE400030C4E /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
 387: 		894AC3632A02952A00BA5553 /* Foundation+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Foundation+Extensions.swift"; sourceTree = "<group>"; };
 388: 		894B019E2A0902BC00FF6198 /* ImportTutorialView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImportTutorialView.swift; sourceTree = "<group>"; };
 389: 		894B01A02A09030000FF6198 /* ImportTutorialPageView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImportTutorialPageView.swift; sourceTree = "<group>"; };
 390: 		894C4A682AA0C04B0001F51E /* PopupView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PopupView.swift; sourceTree = "<group>"; };
 391: 		894C4A6A2AA0C23F0001F51E /* PreReviewPopupView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PreReviewPopupView.swift; sourceTree = "<group>"; };
 392: 		894C4A6D2AA0CB470001F51E /* ReviewFlow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ReviewFlow.swift; sourceTree = "<group>"; };
 393: 		894C4A6F2AA0CCFC0001F51E /* ReviewFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ReviewFlowView.swift; sourceTree = "<group>"; };
 394: 		894C4A712AA0DB9A0001F51E /* PreReviewPopupLowRateView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PreReviewPopupLowRateView.swift; sourceTree = "<group>"; };
 395: 		894CB09D2A851FE50008008A /* ChatPdfSetupData.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatPdfSetupData.swift; sourceTree = "<group>"; };
 396: 		894CB09F2A8520AD0008008A /* ChatPdfSetupData+Decodable.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ChatPdfSetupData+Decodable.swift"; sourceTree = "<group>"; };
 397: 		894D485729D42C9D002B0230 /* OptionItemView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OptionItemView.swift; sourceTree = "<group>"; };
 398: 		894D485929D42CC5002B0230 /* OptionListView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OptionListView.swift; sourceTree = "<group>"; };
 399: 		894D485B29D42FE1002B0230 /* RoundedCorner.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RoundedCorner.swift; sourceTree = "<group>"; };
 400: 		89504A452A448252000BCACD /* PdfFillWidgetView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfFillWidgetView.swift; sourceTree = "<group>"; };
 401: 		89504A472A44829C000BCACD /* PdfFillWidgetViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfFillWidgetViewModel.swift; sourceTree = "<group>"; };
 402: 		8955ED912A1F61A9009985EE /* OnboardingView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OnboardingView.swift; sourceTree = "<group>"; };
 403: 		8955ED932A1F61BD009985EE /* OnboardingPageView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OnboardingPageView.swift; sourceTree = "<group>"; };
 404: 		8955ED952A1F73DC009985EE /* OnboardingViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OnboardingViewModel.swift; sourceTree = "<group>"; };
 405: 		8957FBA72A77C646008B31ED /* PdfShareCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfShareCoordinator.swift; sourceTree = "<group>"; };
 406: 		8957FBA92A77E6F7008B31ED /* PdfShareView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfShareView.swift; sourceTree = "<group>"; };
 407: 		8957FBAB2A7801BA008B31ED /* PdfCompressionPickerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfCompressionPickerView.swift; sourceTree = "<group>"; };
 408: 		895C1BAD2A04FA53005EA190 /* ShareFileExtension.appex */ = {isa = PBXFileReference; explicitFileType = "wrapper.app-extension"; includeInIndex = 0; path = ShareFileExtension.appex; sourceTree = BUILT_PRODUCTS_DIR; };
 409: 		895C1BAF2A04FA53005EA190 /* ShareViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ShareViewController.swift; sourceTree = "<group>"; };
 410: 		895C1BB22A04FA53005EA190 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/MainInterface.storyboard; sourceTree = "<group>"; };
 411: 		895C1BB42A04FA53005EA190 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
 412: 		895C1BBC2A04FD67005EA190 /* ShareFileExtension.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = ShareFileExtension.entitlements; sourceTree = "<group>"; };
 413: 		895C1BBF2A051261005EA190 /* SharedStorage.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SharedStorage.swift; sourceTree = "<group>"; };
 414: 		895FE2C329D6D7E500A99D5B /* ScannerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ScannerView.swift; sourceTree = "<group>"; };
 415: 		895FE2C529D6E17600A99D5B /* AnimationPalette.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AnimationPalette.swift; sourceTree = "<group>"; };
 416: 		895FE2C729D6E7D900A99D5B /* ProductionProducts.storekit */ = {isa = PBXFileReference; lastKnownFileType = text; path = ProductionProducts.storekit; sourceTree = "<group>"; };
 417: 		895FE2CA29D6E9B800A99D5B /* SubscriptionPairsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPairsView.swift; sourceTree = "<group>"; };
 418: 		895FE2CC29D724B900A99D5B /* SubscriptionPairsItemView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPairsItemView.swift; sourceTree = "<group>"; };
 419: 		8962D6052A9E28FB008426A2 /* PdfSignaturePrioviderFlow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignaturePrioviderFlow.swift; sourceTree = "<group>"; };
 420: 		8962D6072A9E2A57008426A2 /* PdfSignatureProviderFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSignatureProviderFlowView.swift; sourceTree = "<group>"; };
 421: 		8966B6F12AA9FCE0005E6DED /* SuggestedFields.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SuggestedFields.swift; sourceTree = "<group>"; };
 422: 		896876192A7CE87A0014A320 /* PdfSplitViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSplitViewModel.swift; sourceTree = "<group>"; };
 423: 		8968761B2A7CEB650014A320 /* PdfImportViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfImportViewModel.swift; sourceTree = "<group>"; };
 424: 		8968761D2A7CEE320014A320 /* PdfImportView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfImportView.swift; sourceTree = "<group>"; };
 425: 		8968761F2A7CF1E00014A320 /* PdfImportMultipleViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfImportMultipleViewModel.swift; sourceTree = "<group>"; };
 426: 		896876212A7CF3220014A320 /* PdfImportMultipleView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfImportMultipleView.swift; sourceTree = "<group>"; };
 427: 		896876232A7D05040014A320 /* PdfSplitView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSplitView.swift; sourceTree = "<group>"; };
 428: 		896876252A7D2EB80014A320 /* PdfPageRangeEditorViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfPageRangeEditorViewModel.swift; sourceTree = "<group>"; };
 429: 		896876272A7D2EC20014A320 /* PdfPageRangeEditorView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfPageRangeEditorView.swift; sourceTree = "<group>"; };
 430: 		896CCF6C2A28910B008F268E /* SizePrinter.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SizePrinter.swift; sourceTree = "<group>"; };
 431: 		896CCF6E2A28AEAC008F268E /* UIFont+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "UIFont+Extensions.swift"; sourceTree = "<group>"; };
 432: 		897911EC29E70541008B7088 /* SubscriptionVerticalView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionVerticalView.swift; sourceTree = "<group>"; };
 433: 		897911EE29E70558008B7088 /* SubscriptionVerticalItemView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionVerticalItemView.swift; sourceTree = "<group>"; };
 434: 		897967852A73E59B00E91F8E /* URL+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "URL+Extensions.swift"; sourceTree = "<group>"; };
 435: 		89847AE02A1BA947000EC14B /* GoogleService-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = "GoogleService-Info.plist"; sourceTree = "<group>"; };
 436: 		89851B5D2A13DB1A00ABF58F /* ImageResizableView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImageResizableView.swift; sourceTree = "<group>"; };
 437: 		89883B012A45CB9800E684B6 /* InfoTemplate.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = InfoTemplate.plist; sourceTree = "<group>"; };
 438: 		8991485029E851B500DD01F2 /* ConfigService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ConfigService.swift; sourceTree = "<group>"; };
 439: 		8991485229E851BD00DD01F2 /* RemoteConfigManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RemoteConfigManager.swift; sourceTree = "<group>"; };
 440: 		89923E5D29D4350F00E246FC /* AppTrackingTransparencyImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppTrackingTransparencyImpl.swift; sourceTree = "<group>"; };
 441: 		89923E5E29D4350F00E246FC /* AppTrackingTransparency.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppTrackingTransparency.swift; sourceTree = "<group>"; };
 442: 		89923E6829D46A9900E246FC /* FilePicker.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FilePicker.swift; sourceTree = "<group>"; };
 443: 		89923E6A29D47B9E00E246FC /* pdf-scanning.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = "pdf-scanning.json"; sourceTree = "<group>"; };
 444: 		8995694129D33B1300566EF4 /* HomeItemView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HomeItemView.swift; sourceTree = "<group>"; };
 445: 		8995694329D3450300566EF4 /* HomeViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HomeViewModel.swift; sourceTree = "<group>"; };
 446: 		899F484329DF128200E7E1E4 /* MainTabView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainTabView.swift; sourceTree = "<group>"; };
 447: 		89AA36082A1BC5FD0077A70A /* StagingProducts.storekit */ = {isa = PBXFileReference; lastKnownFileType = text; path = StagingProducts.storekit; sourceTree = "<group>"; };
 448: 		89AA360A2A1BC8560077A70A /* LocalStagingProducts.storekit */ = {isa = PBXFileReference; lastKnownFileType = text; path = LocalStagingProducts.storekit; sourceTree = "<group>"; };
 449: 		89AAFE9F29DB2672002D348E /* CacheManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CacheManager.swift; sourceTree = "<group>"; };
 450: 		89AAFEA029DB2672002D348E /* CacheManagerImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CacheManagerImpl.swift; sourceTree = "<group>"; };
 451: 		89AAFEA629DB2AC4002D348E /* WelcomeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WelcomeView.swift; sourceTree = "<group>"; };
 452: 		89ABAA582A97B29C00721045 /* PdfDocument+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "PdfDocument+Extensions.swift"; sourceTree = "<group>"; };
 453: 		89B72A2D29DACBBF0076884F /* EmptyProducts.storekit */ = {isa = PBXFileReference; lastKnownFileType = text; path = EmptyProducts.storekit; sourceTree = "<group>"; };
 454: 		89B72A3229DADC790076884F /* SettingsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsView.swift; sourceTree = "<group>"; };
 455: 		89BB2DB62A7A5EFC009E6738 /* PdfMergeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfMergeView.swift; sourceTree = "<group>"; };
 456: 		89BB2DB82A7A6050009E6738 /* PdfMergeViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfMergeViewModel.swift; sourceTree = "<group>"; };
 457: 		89BB2DBA2A7A7DD7009E6738 /* PdfUnlockViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfUnlockViewModel.swift; sourceTree = "<group>"; };
 458: 		89BB2DBC2A7A80A8009E6738 /* PdfUnlockView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfUnlockView.swift; sourceTree = "<group>"; };
 459: 		89BB2DBE2A7AB0CE009E6738 /* PdfSortViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSortViewModel.swift; sourceTree = "<group>"; };
 460: 		89BB2DC02A7AB4A8009E6738 /* PdfSortView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfSortView.swift; sourceTree = "<group>"; };
 461: 		89C2500E2A72B2BC00184C45 /* CDPdf.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CDPdf.swift; sourceTree = "<group>"; };
 462: 		89CD7A9629D32855003F1C3A /* PdfExpert.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = PdfExpert.app; sourceTree = BUILT_PRODUCTS_DIR; };
 463: 		89CD7A9929D32855003F1C3A /* PdfExpertApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfExpertApp.swift; sourceTree = "<group>"; };
 464: 		89CD7AA029D32856003F1C3A /* Preview Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = "Preview Assets.xcassets"; sourceTree = "<group>"; };
 465: 		89CD7AA729D32856003F1C3A /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
 466: 		89CD7AAE29D329B1003F1C3A /* Colors.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Colors.xcassets; sourceTree = "<group>"; };
 467: 		89CD7AB229D329B1003F1C3A /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
 468: 		89CD7AB429D329B1003F1C3A /* Products.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Products.plist; sourceTree = "<group>"; };
 469: 		89CD7ACC29D329B1003F1C3A /* loading.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = loading.json; sourceTree = "<group>"; };
 470: 		89CD7ACF29D329B1003F1C3A /* AsyncView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AsyncView.swift; sourceTree = "<group>"; };
 471: 		89CD7AD029D329B1003F1C3A /* CircularProgressView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CircularProgressView.swift; sourceTree = "<group>"; };
 472: 		89CD7AD129D329B1003F1C3A /* UnderlyingError.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = UnderlyingError.swift; sourceTree = "<group>"; };
 473: 		89CD7AD229D329B1003F1C3A /* LottieView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = LottieView.swift; sourceTree = "<group>"; };
 474: 		89CD7AD329D329B1003F1C3A /* ParentalCheck.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ParentalCheck.swift; sourceTree = "<group>"; };
 475: 		89CD7AD529D329B1003F1C3A /* String+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "String+Extensions.swift"; sourceTree = "<group>"; };
 476: 		89CD7AD629D329B1003F1C3A /* UIApplication+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "UIApplication+Extensions.swift"; sourceTree = "<group>"; };
 477: 		89CD7AD729D329B1003F1C3A /* View+Alert.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "View+Alert.swift"; sourceTree = "<group>"; };
 478: 		89CD7AD829D329B1003F1C3A /* View+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "View+Extensions.swift"; sourceTree = "<group>"; };
 479: 		89CD7AD929D329B1003F1C3A /* Color+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "Color+Extensions.swift"; sourceTree = "<group>"; };
 480: 		89CD7ADA29D329B1003F1C3A /* Enum+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "Enum+Extensions.swift"; sourceTree = "<group>"; };
 481: 		89CD7ADB29D329B1003F1C3A /* Async.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Async.swift; sourceTree = "<group>"; };
 482: 		89CD7ADC29D329B1003F1C3A /* DebugUtils.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = DebugUtils.swift; sourceTree = "<group>"; };
 483: 		89CD7AE529D329B1003F1C3A /* StoreImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = StoreImpl.swift; sourceTree = "<group>"; };
 484: 		89CD7AEB29D329B1003F1C3A /* Store.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Store.swift; sourceTree = "<group>"; };
 485: 		89CD7AF629D329B1003F1C3A /* Constants.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Constants.swift; sourceTree = "<group>"; };
 486: 		89CD7AF929D329B1003F1C3A /* FontPalette.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = FontPalette.swift; sourceTree = "<group>"; };
 487: 		89CD7AFA29D329B1003F1C3A /* ColorPalette.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ColorPalette.swift; sourceTree = "<group>"; };
 488: 		89CD7AFD29D329B1003F1C3A /* SubscribeViewModel.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SubscribeViewModel.swift; sourceTree = "<group>"; };
 489: 		89CD7B2629D329B1003F1C3A /* ContentView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
 490: 		89CD7B2C29D329B1003F1C3A /* SharedErrors.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SharedErrors.swift; sourceTree = "<group>"; };
 491: 		89CD7B2D29D329B1003F1C3A /* SubscriptionViewUtility.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SubscriptionViewUtility.swift; sourceTree = "<group>"; };
 492: 		89CD7B2E29D329B1003F1C3A /* View+Preview.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "View+Preview.swift"; sourceTree = "<group>"; };
 493: 		89CD7B2F29D329B1003F1C3A /* View+Internal.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "View+Internal.swift"; sourceTree = "<group>"; };
 494: 		89CD7BB429D32E69003F1C3A /* MainCoordinator.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MainCoordinator.swift; sourceTree = "<group>"; };
 495: 		89CD7BBA29D330FB003F1C3A /* HomeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HomeView.swift; sourceTree = "<group>"; };
 496: 		89CD7BBC29D331AA003F1C3A /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
 497: 		89D1FE7D2A84D428009AC57C /* SubscriptionPickerPlanListView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPickerPlanListView.swift; sourceTree = "<group>"; };
 498: 		89D1FE7F2A84D76B009AC57C /* FullScreenClearBackground.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FullScreenClearBackground.swift; sourceTree = "<group>"; };
 499: 		89D79DE62A654DC70086A8E5 /* Poppins-ExtraLightItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-ExtraLightItalic.ttf"; sourceTree = "<group>"; };
 500: 		89D79DE72A654DC70086A8E5 /* Poppins-SemiBold.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-SemiBold.ttf"; sourceTree = "<group>"; };
 501: 		89D79DE82A654DC80086A8E5 /* Poppins-Black.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Black.ttf"; sourceTree = "<group>"; };
 502: 		89D79DE92A654DC80086A8E5 /* Poppins-ThinItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-ThinItalic.ttf"; sourceTree = "<group>"; };
 503: 		89D79DEA2A654DC80086A8E5 /* Poppins-Light.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Light.ttf"; sourceTree = "<group>"; };
 504: 		89D79DEB2A654DC80086A8E5 /* Poppins-BlackItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-BlackItalic.ttf"; sourceTree = "<group>"; };
 505: 		89D79DEC2A654DC80086A8E5 /* Poppins-Medium.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Medium.ttf"; sourceTree = "<group>"; };
 506: 		89D79DED2A654DC80086A8E5 /* Poppins-Italic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Italic.ttf"; sourceTree = "<group>"; };
 507: 		89D79DEE2A654DC80086A8E5 /* Poppins-ExtraBold.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-ExtraBold.ttf"; sourceTree = "<group>"; };
 508: 		89D79DEF2A654DC80086A8E5 /* Poppins-Thin.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Thin.ttf"; sourceTree = "<group>"; };
 509: 		89D79DF02A654DC80086A8E5 /* Poppins-ExtraLight.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-ExtraLight.ttf"; sourceTree = "<group>"; };
 510: 		89D79DF12A654DC80086A8E5 /* Poppins-ExtraBoldItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-ExtraBoldItalic.ttf"; sourceTree = "<group>"; };
 511: 		89D79DF22A654DC80086A8E5 /* Poppins-LightItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-LightItalic.ttf"; sourceTree = "<group>"; };
 512: 		89D79DF32A654DC80086A8E5 /* Poppins-Regular.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Regular.ttf"; sourceTree = "<group>"; };
 513: 		89D79DF42A654DC80086A8E5 /* Poppins-MediumItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-MediumItalic.ttf"; sourceTree = "<group>"; };
 514: 		89D79DF52A654DC80086A8E5 /* Poppins-BoldItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-BoldItalic.ttf"; sourceTree = "<group>"; };
 515: 		89D79DF62A654DC80086A8E5 /* Poppins-Bold.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-Bold.ttf"; sourceTree = "<group>"; };
 516: 		89D79DF72A654DC80086A8E5 /* Poppins-SemiBoldItalic.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Poppins-SemiBoldItalic.ttf"; sourceTree = "<group>"; };
 517: 		89E55BD829DC64840073F268 /* AnalyticsManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AnalyticsManager.swift; sourceTree = "<group>"; };
 518: 		89E55BDA29DC64840073F268 /* FirebaseAnalyticsPlatform.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = FirebaseAnalyticsPlatform.swift; sourceTree = "<group>"; };
 519: 		89E55BDB29DC64840073F268 /* AnalyticsManagerImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AnalyticsManagerImpl.swift; sourceTree = "<group>"; };
 520: 		89E55BE129DC66240073F268 /* AnalyticsPlatform.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AnalyticsPlatform.swift; sourceTree = "<group>"; };
 521: 		89E601612A829556009492DA /* SubscriptionPickerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPickerView.swift; sourceTree = "<group>"; };
 522: 		89E601632A8295A2009492DA /* SubscriptionPickerViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPickerViewModel.swift; sourceTree = "<group>"; };
 523: 		89EBC9042A83CC3000BDBBD4 /* SubscriptionFreeTrialToggleView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionFreeTrialToggleView.swift; sourceTree = "<group>"; };
 524: 		89EBC9062A83D0DB00BDBBD4 /* SubscriptionPickerPlanView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SubscriptionPickerPlanView.swift; sourceTree = "<group>"; };
 525: 		89ED72B82A9F69E5004F541F /* AdSupport.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AdSupport.framework; path = System/Library/Frameworks/AdSupport.framework; sourceTree = SDKROOT; };
 526: 		89F9E4F82A95FEED0001D48B /* PDFImageExtractor.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PDFImageExtractor.swift; sourceTree = "<group>"; };
 527: 		89F9E4FA2A9606ED0001D48B /* PdfImageViewerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PdfImageViewerView.swift; sourceTree = "<group>"; };
 528: 		89F9E4FC2A9635EC0001D48B /* ZoomImageModifier.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ZoomImageModifier.swift; sourceTree = "<group>"; };
 529: 		C99992892DAF4C86003C3643 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
 530: 		C999928C2DAF4C9B003C3643 /* GoogleService-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "GoogleService-Info.plist"; sourceTree = "<group>"; };
 531: 		C9CEF5DC2DAF973100980C8A /* Montserrat-ExtraBold.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Montserrat-ExtraBold.ttf"; sourceTree = "<group>"; };
 532: 		C9CEF5DE2DAF974500980C8A /* Montserrat-Medium.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Montserrat-Medium.ttf"; sourceTree = "<group>"; };
 533: 		C9CEF5E02DAF975200980C8A /* Montserrat-Regular.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Montserrat-Regular.ttf"; sourceTree = "<group>"; };
 534: 		C9CEF5E22DAF975A00980C8A /* Montserrat-Bold.ttf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Montserrat-Bold.ttf"; sourceTree = "<group>"; };
 535: 		C9CEF5EB2DB03CCB00980C8A /* SceneDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SceneDelegate.swift; sourceTree = "<group>"; };
 536: /* End PBXFileReference section */
 537: 
 538: /* Begin PBXFrameworksBuildPhase section */
 539: 		895C1BAA2A04FA53005EA190 /* Frameworks */ = {
 540: 			isa = PBXFrameworksBuildPhase;
 541: 			buildActionMask = 2147483647;
 542: 			files = (
 543: 			);
 544: 			runOnlyForDeploymentPostprocessing = 0;
 545: 		};
 546: 		89CD7A9329D32855003F1C3A /* Frameworks */ = {
 547: 			isa = PBXFrameworksBuildPhase;
 548: 			buildActionMask = 2147483647;
 549: 			files = (
 550: 				894827B02AA5D65600030C4E /* BranchSDK in Frameworks */,
 551: 				893EB5012AA717B80066914E /* FacebookCore in Frameworks */,
 552: 				89407EFA2AA8C4C400169801 /* Mantis in Frameworks */,
 553: 				8942034529DC12BC004D610B /* PagerTabStripView in Frameworks */,
 554: 				895FE2D229D7392F00A99D5B /* OrderedCollections in Frameworks */,
 555: 				89CD7BAB29D32CE5003F1C3A /* FirebaseAnalyticsSwift in Frameworks */,
 556: 				893E84A429D5BFBB00F6B99A /* PSPDFKit in Frameworks */,
 557: 				8991485629E85DE500DD01F2 /* CombineExt in Frameworks */,
 558: 				89CD7BAD29D32CE5003F1C3A /* FirebaseCrashlytics in Frameworks */,
 559: 				891A07E929E028EE0002FA3A /* CloudKitSyncMonitor in Frameworks */,
 560: 				89923E6729D437F500E246FC /* FirebasePerformance in Frameworks */,
 561: 				89CD7BA529D32C52003F1C3A /* Lottie in Frameworks */,
 562: 				893BE52B2A6A7864004B05B9 /* CombineMoya in Frameworks */,
 563: 				895FE2D029D7392F00A99D5B /* Collections in Frameworks */,
 564: 				89CD7BA829D32C72003F1C3A /* Factory in Frameworks */,
 565: 				89ED72BB2A9F6B3A004F541F /* AdSupport.framework in Frameworks */,
 566: 			);
 567: 			runOnlyForDeploymentPostprocessing = 0;
 568: 		};
 569: /* End PBXFrameworksBuildPhase section */
 570: 
 571: /* Begin PBXGroup section */
 572: 		8936AA292A67F922005F6C73 /* ci_scripts */ = {
 573: 			isa = PBXGroup;
 574: 			children = (
 575: 				8936AA2A2A67F975005F6C73 /* ci_post_clone.sh */,
 576: 			);
 577: 			path = ci_scripts;
 578: 			sourceTree = "<group>";
 579: 		};
 580: 		8936AA3A2A682C71005F6C73 /* ChatPdf */ = {
 581: 			isa = PBXGroup;
 582: 			children = (
 583: 				8936AA3B2A682CDA005F6C73 /* ChatPdfSelectionView.swift */,
 584: 				8936AA412A6840D1005F6C73 /* ChatPdfView.swift */,
 585: 				893ED9D82A693013004EE67C /* MessageIndicatorView.swift */,
 586: 				893ED9D72A693013004EE67C /* MessageView.swift */,
 587: 			);
 588: 			path = ChatPdf;
 589: 			sourceTree = "<group>";
 590: 		};
 591: 		893BE5312A6A96BE004B05B9 /* Network */ = {
 592: 			isa = PBXGroup;
 593: 			children = (
 594: 				893BE5322A6A96D0004B05B9 /* ChatPdf */,
 595: 				893BE52E2A6A7C0C004B05B9 /* NetworkUtility.swift */,
 596: 			);
 597: 			path = Network;
 598: 			sourceTree = "<group>";
 599: 		};
 600: 		893BE5322A6A96D0004B05B9 /* ChatPdf */ = {
 601: 			isa = PBXGroup;
 602: 			children = (
 603: 				893BE5332A6A96E1004B05B9 /* Mapping */,
 604: 				8936AA352A68299B005F6C73 /* ChatPdfManager.swift */,
 605: 				8936AA362A68299B005F6C73 /* ChatPdfManagerMock.swift */,
 606: 				893BE52C2A6A78BB004B05B9 /* ChatPdfManagerImpl.swift */,
 607: 			);
 608: 			path = ChatPdf;
 609: 			sourceTree = "<group>";
 610: 		};
 611: 		893BE5332A6A96E1004B05B9 /* Mapping */ = {
 612: 			isa = PBXGroup;
 613: 			children = (
 614: 				893BE5342A6A96F5004B05B9 /* ChatPdfRef+Decodable.swift */,
 615: 				893BE5362A6A9708004B05B9 /* ChatPdfMessage+Decodable.swift */,
 616: 				894CB09F2A8520AD0008008A /* ChatPdfSetupData+Decodable.swift */,
 617: 			);
 618: 			path = Mapping;
 619: 			sourceTree = "<group>";
 620: 		};
 621: 		893C8FC729DED15B000E35BD /* Archive */ = {
 622: 			isa = PBXGroup;
 623: 			children = (
 624: 				893C8FC829DED190000E35BD /* ArchiveView.swift */,
 625: 			);
 626: 			path = Archive;
 627: 			sourceTree = "<group>";
 628: 		};
 629: 		893C8FDF29DEDAE8000E35BD /* Test */ = {
 630: 			isa = PBXGroup;
 631: 			children = (
 632: 				893C8FE029DEDAF4000E35BD /* test.pdf */,
 633: 			);
 634: 			path = Test;
 635: 			sourceTree = "<group>";
 636: 		};
 637: 		893E849229D5877800F6B99A /* Camera */ = {
 638: 			isa = PBXGroup;
 639: 			children = (
 640: 				893E849029D5874D00F6B99A /* CameraView.swift */,
 641: 			);
 642: 			path = Camera;
 643: 			sourceTree = "<group>";
 644: 		};
 645: 		893E849529D5943D00F6B99A /* Camera */ = {
 646: 			isa = PBXGroup;
 647: 			children = (
 648: 				893E849829D5944E00F6B99A /* CameraPreviewView.swift */,
 649: 				893E849A29D5944E00F6B99A /* CameraService.swift */,
 650: 				893E849729D5944E00F6B99A /* CameraService+Enums.swift */,
 651: 				893E849B29D5944E00F6B99A /* CameraService+Extensions.swift */,
 652: 				893E849929D5944E00F6B99A /* ImageResizer.swift */,
 653: 				893E849629D5944E00F6B99A /* PhotoCaptureProcessor.swift */,
 654: 			);
 655: 			path = Camera;
 656: 			sourceTree = "<group>";
 657: 		};
 658: 		89429F8D2A9C94A300465420 /* Persistence */ = {
 659: 			isa = PBXGroup;
 660: 			children = (
 661: 				89429F8E2A9C94BD00465420 /* CoreData */,
 662: 				89AAFE9F29DB2672002D348E /* CacheManager.swift */,
 663: 				89AAFEA029DB2672002D348E /* CacheManagerImpl.swift */,
 664: 				893C8FD129DED2E9000E35BD /* Repository.swift */,
 665: 				893C8FD229DED2E9000E35BD /* RepositoryImpl.swift */,
 666: 			);
 667: 			path = Persistence;
 668: 			sourceTree = "<group>";
 669: 		};
 670: 		89429F8E2A9C94BD00465420 /* CoreData */ = {
 671: 			isa = PBXGroup;
 672: 			children = (
 673: 				89429F8F2A9CFFC500465420 /* Persistable */,
 674: 				89C2500E2A72B2BC00184C45 /* CDPdf.swift */,
 675: 				89429F8B2A9C937C00465420 /* CDSignature.swift */,
 676: 				892CC6912AAA23AE000DEC21 /* CDSuggestedFields.swift */,
 677: 				893C8FCF29DED278000E35BD /* Persistence.swift */,
 678: 			);
 679: 			path = CoreData;
 680: 			sourceTree = "<group>";
 681: 		};
 682: 		89429F8F2A9CFFC500465420 /* Persistable */ = {
 683: 			isa = PBXGroup;
 684: 			children = (
 685: 				89429F902A9CFFDC00465420 /* Persistable.swift */,
 686: 				89429F922A9CFFF100465420 /* Pdf+Persistable.swift */,
 687: 				89429F942A9D001A00465420 /* Signature+Persistable.swift */,
 688: 				892CC6932AAA243E000DEC21 /* SuggestedFields+Persistable.swift */,
 689: 			);
 690: 			path = Persistable;
 691: 			sourceTree = "<group>";
 692: 		};
 693: 		89436AB929E5578300060605 /* Pdf */ = {
 694: 			isa = PBXGroup;
 695: 			children = (
 696: 				89436ABA29E557D500060605 /* PdfFlowView.swift */,
 697: 				89436ABC29E5586600060605 /* PdfEditView.swift */,
 698: 				892201DB2A0BA70300832CF2 /* PdfSignatureView.swift */,
 699: 				89429F852A9C8ECC00465420 /* PdfSignaturePickerView.swift */,
 700: 				89127AA22A177F170059005F /* PdfSignatureCanvasView.swift */,
 701: 				8962D6072A9E2A57008426A2 /* PdfSignatureProviderFlowView.swift */,
 702: 				8932ECE42A20DC7700CBCD7A /* PdfFillFormView.swift */,
 703: 				89504A452A448252000BCACD /* PdfFillWidgetView.swift */,
 704: 				8957FBAB2A7801BA008B31ED /* PdfCompressionPickerView.swift */,
 705: 			);
 706: 			path = Pdf;
 707: 			sourceTree = "<group>";
 708: 		};
 709: 		894827B52AA5DCA900030C4E /* Resources */ = {
 710: 			isa = PBXGroup;
 711: 			children = (
 712: 				894827B72AA5DCB800030C4E /* Production */,
 713: 				894827B62AA5DCB200030C4E /* Staging */,
 714: 			);
 715: 			path = Resources;
 716: 			sourceTree = "<group>";
 717: 		};
 718: 		894827B62AA5DCB200030C4E /* Staging */ = {
 719: 			isa = PBXGroup;
 720: 			children = (
 721: 				894827B82AA5DCE400030C4E /* Info.plist */,
 722: 			);
 723: 			path = Staging;
 724: 			sourceTree = "<group>";
 725: 		};
 726: 		894827B72AA5DCB800030C4E /* Production */ = {
 727: 			isa = PBXGroup;
 728: 			children = (
 729: 				895C1BB42A04FA53005EA190 /* Info.plist */,
 730: 			);
 731: 			path = Production;
 732: 			sourceTree = "<group>";
 733: 		};
 734: 		894B019D2A0902A000FF6198 /* ImportTutorial */ = {
 735: 			isa = PBXGroup;
 736: 			children = (
 737: 				894B019E2A0902BC00FF6198 /* ImportTutorialView.swift */,
 738: 				894B01A02A09030000FF6198 /* ImportTutorialPageView.swift */,
 739: 			);
 740: 			path = ImportTutorial;
 741: 			sourceTree = "<group>";
 742: 		};
 743: 		894C4A6C2AA0C2F40001F51E /* Review */ = {
 744: 			isa = PBXGroup;
 745: 			children = (
 746: 				894C4A6A2AA0C23F0001F51E /* PreReviewPopupView.swift */,
 747: 				894C4A712AA0DB9A0001F51E /* PreReviewPopupLowRateView.swift */,
 748: 				894C4A6F2AA0CCFC0001F51E /* ReviewFlowView.swift */,
 749: 			);
 750: 			path = Review;
 751: 			sourceTree = "<group>";
 752: 		};
 753: 		895C1BAE2A04FA53005EA190 /* ShareFileExtension */ = {
 754: 			isa = PBXGroup;
 755: 			children = (
 756: 				895C1BBC2A04FD67005EA190 /* ShareFileExtension.entitlements */,
 757: 				895C1BAF2A04FA53005EA190 /* ShareViewController.swift */,
 758: 				895C1BB12A04FA53005EA190 /* MainInterface.storyboard */,
 759: 				894827B52AA5DCA900030C4E /* Resources */,
 760: 			);
 761: 			path = ShareFileExtension;
 762: 			sourceTree = "<group>";
 763: 		};
 764: 		895FE2C229D6D7D800A99D5B /* Scan */ = {
 765: 			isa = PBXGroup;
 766: 			children = (
 767: 				895FE2C329D6D7E500A99D5B /* ScannerView.swift */,
 768: 			);
 769: 			path = Scan;
 770: 			sourceTree = "<group>";
 771: 		};
 772: 		895FE2C929D6E98100A99D5B /* Subscription */ = {
 773: 			isa = PBXGroup;
 774: 			children = (
 775: 				895FE2CA29D6E9B800A99D5B /* SubscriptionPairsView.swift */,
 776: 				895FE2CC29D724B900A99D5B /* SubscriptionPairsItemView.swift */,
 777: 				89460C5F29DAC36600E39BAC /* SubscriptionErrorView.swift */,
 778: 				897911EC29E70541008B7088 /* SubscriptionVerticalView.swift */,
 779: 				897911EE29E70558008B7088 /* SubscriptionVerticalItemView.swift */,
 780: 				89E601612A829556009492DA /* SubscriptionPickerView.swift */,
 781: 				89EBC9062A83D0DB00BDBBD4 /* SubscriptionPickerPlanView.swift */,
 782: 				89D1FE7D2A84D428009AC57C /* SubscriptionPickerPlanListView.swift */,
 783: 				89EBC9042A83CC3000BDBBD4 /* SubscriptionFreeTrialToggleView.swift */,
 784: 			);
 785: 			path = Subscription;
 786: 			sourceTree = "<group>";
 787: 		};
 788: 		89847ADE2A1BA8CC000EC14B /* Production */ = {
 789: 			isa = PBXGroup;
 790: 			children = (
 791: 				89CD7AA729D32856003F1C3A /* Info.plist */,
 792: 				C999928C2DAF4C9B003C3643 /* GoogleService-Info.plist */,
 793: 			);
 794: 			path = Production;
 795: 			sourceTree = "<group>";
 796: 		};
 797: 		89847ADF2A1BA8CC000EC14B /* Staging */ = {
 798: 			isa = PBXGroup;
 799: 			children = (
 800: 				C99992892DAF4C86003C3643 /* Info.plist */,
 801: 				89847AE02A1BA947000EC14B /* GoogleService-Info.plist */,
 802: 			);
 803: 			path = Staging;
 804: 			sourceTree = "<group>";
 805: 		};
 806: 		89923E6529D437F500E246FC /* Frameworks */ = {
 807: 			isa = PBXGroup;
 808: 			children = (
 809: 				89ED72B82A9F69E5004F541F /* AdSupport.framework */,
 810: 			);
 811: 			name = Frameworks;
 812: 			sourceTree = "<group>";
 813: 		};
 814: 		8995694829D3473E00566EF4 /* Common */ = {
 815: 			isa = PBXGroup;
 816: 			children = (
 817: 				894D485729D42C9D002B0230 /* OptionItemView.swift */,
 818: 				894D485929D42CC5002B0230 /* OptionListView.swift */,
 819: 				8936AA3F2A683FB5005F6C73 /* ImportOption.swift */,
 820: 				8940FB902A710D8D00A00D8D /* AddPasswordView.swift */,
 821: 				89BB2DBC2A7A80A8009E6738 /* PdfUnlockView.swift */,
 822: 				8957FBA92A77E6F7008B31ED /* PdfShareView.swift */,
 823: 				89BB2DB62A7A5EFC009E6738 /* PdfMergeView.swift */,
 824: 				896876232A7D05040014A320 /* PdfSplitView.swift */,
 825: 				89BB2DC02A7AB4A8009E6738 /* PdfSortView.swift */,
 826: 				8968761D2A7CEE320014A320 /* PdfImportView.swift */,
 827: 				896876212A7CF3220014A320 /* PdfImportMultipleView.swift */,
 828: 				896876272A7D2EC20014A320 /* PdfPageRangeEditorView.swift */,
 829: 				89436D182A936C9F000868B5 /* PdfReadView.swift */,
 830: 				89436D1C2A93AE76000868B5 /* PdfReaderView.swift */,
 831: 				89436D222A93C1CE000868B5 /* PdfPageSelectionView.swift */,
 832: 				89F9E4FA2A9606ED0001D48B /* PdfImageViewerView.swift */,
 833: 				89407EF22AA8B0C800169801 /* GalleryImageProviderFlowView.swift */,
 834: 				89407EF62AA8BEC200169801 /* CameraImageProviderFlowView.swift */,
 835: 				89407EFD2AA8D23B00169801 /* ImageCropFlowView.swift */,
 836: 				892CC6952AAA2641000DEC21 /* SuggestedFieldsFormView.swift */,
 837: 			);
 838: 			path = Common;
 839: 			sourceTree = "<group>";
 840: 		};
 841: 		899F484229DF123B00E7E1E4 /* Main */ = {
 842: 			isa = PBXGroup;
 843: 			children = (
 844: 				899F484329DF128200E7E1E4 /* MainTabView.swift */,
 845: 			);
 846: 			path = Main;
 847: 			sourceTree = "<group>";
 848: 		};
 849: 		89AAFE9A29DB1823002D348E /* Onboarding */ = {
 850: 			isa = PBXGroup;
 851: 			children = (
 852: 				8955ED912A1F61A9009985EE /* OnboardingView.swift */,
 853: 				8955ED932A1F61BD009985EE /* OnboardingPageView.swift */,
 854: 			);
 855: 			path = Onboarding;
 856: 			sourceTree = "<group>";
 857: 		};
 858: 		89AAFEA829DB3098002D348E /* Welcome */ = {
 859: 			isa = PBXGroup;
 860: 			children = (
 861: 				89AAFEA629DB2AC4002D348E /* WelcomeView.swift */,
 862: 			);
 863: 			path = Welcome;
 864: 			sourceTree = "<group>";
 865: 		};
 866: 		89B72A3129DADC6E0076884F /* Settings */ = {
 867: 			isa = PBXGroup;
 868: 			children = (
 869: 				89B72A3229DADC790076884F /* SettingsView.swift */,
 870: 			);
 871: 			path = Settings;
 872: 			sourceTree = "<group>";
 873: 		};
 874: 		89CD7A8D29D32855003F1C3A = {
 875: 			isa = PBXGroup;
 876: 			children = (
 877: 				8936AA292A67F922005F6C73 /* ci_scripts */,
 878: 				89CD7A9829D32855003F1C3A /* PdfExpert */,
 879: 				895C1BAE2A04FA53005EA190 /* ShareFileExtension */,
 880: 				89CD7A9729D32855003F1C3A /* Products */,
 881: 				89923E6529D437F500E246FC /* Frameworks */,
 882: 			);
 883: 			sourceTree = "<group>";
 884: 		};
 885: 		89CD7A9729D32855003F1C3A /* Products */ = {
 886: 			isa = PBXGroup;
 887: 			children = (
 888: 				89CD7A9629D32855003F1C3A /* PdfExpert.app */,
 889: 				895C1BAD2A04FA53005EA190 /* ShareFileExtension.appex */,
 890: 			);
 891: 			name = Products;
 892: 			sourceTree = "<group>";
 893: 		};
 894: 		89CD7A9829D32855003F1C3A /* PdfExpert */ = {
 895: 			isa = PBXGroup;
 896: 			children = (
 897: 				893C8FE229DF0145000E35BD /* PdfExpert.entitlements */,
 898: 				89CD7AF529D329B1003F1C3A /* Applicaction */,
 899: 				89CD7ADD29D329B1003F1C3A /* Models */,
 900: 				89CD7AFB29D329B1003F1C3A /* ViewModels */,
 901: 				89CD7B0329D329B1003F1C3A /* Views */,
 902: 				89CD7AF829D329B1003F1C3A /* Style */,
 903: 				89CD7B2B29D329B1003F1C3A /* InternalUtils */,
 904: 				89CD7ACD29D329B1003F1C3A /* Utils */,
 905: 				89CD7AAD29D329B1003F1C3A /* Resources */,
 906: 				89CD7A9F29D32856003F1C3A /* Preview Content */,
 907: 				C9CEF5DC2DAF973100980C8A /* Montserrat-ExtraBold.ttf */,
 908: 				C9CEF5DE2DAF974500980C8A /* Montserrat-Medium.ttf */,
 909: 				C9CEF5E02DAF975200980C8A /* Montserrat-Regular.ttf */,
 910: 				C9CEF5E22DAF975A00980C8A /* Montserrat-Bold.ttf */,
 911: 			);
 912: 			path = PdfExpert;
 913: 			sourceTree = "<group>";
 914: 		};
 915: 		89CD7A9F29D32856003F1C3A /* Preview Content */ = {
 916: 			isa = PBXGroup;
 917: 			children = (
 918: 				89CD7AA029D32856003F1C3A /* Preview Assets.xcassets */,
 919: 			);
 920: 			path = "Preview Content";
 921: 			sourceTree = "<group>";
 922: 		};
 923: 		89CD7AAD29D329B1003F1C3A /* Resources */ = {
 924: 			isa = PBXGroup;
 925: 			children = (
 926: 				8936AA302A682812005F6C73 /* ProjectInfo.plist */,
 927: 				89883B012A45CB9800E684B6 /* InfoTemplate.plist */,
 928: 				89847ADE2A1BA8CC000EC14B /* Production */,
 929: 				89847ADF2A1BA8CC000EC14B /* Staging */,
 930: 				893C8FDF29DEDAE8000E35BD /* Test */,
 931: 				893C8FCC29DED254000E35BD /* AppCoreData.xcdatamodeld */,
 932: 				89CD7AAE29D329B1003F1C3A /* Colors.xcassets */,
 933: 				89CD7AB229D329B1003F1C3A /* Assets.xcassets */,
 934: 				89CD7AB329D329B1003F1C3A /* IAP */,
 935: 				89CD7AB729D329B1003F1C3A /* Fonts */,
 936: 				89CD7ACB29D329B1003F1C3A /* Animations */,
 937: 			);
 938: 			path = Resources;
 939: 			sourceTree = "<group>";
 940: 		};
 941: 		89CD7AB329D329B1003F1C3A /* IAP */ = {
 942: 			isa = PBXGroup;
 943: 			children = (
 944: 				89CD7AB429D329B1003F1C3A /* Products.plist */,
 945: 				895FE2C729D6E7D900A99D5B /* ProductionProducts.storekit */,
 946: 				89AA36082A1BC5FD0077A70A /* StagingProducts.storekit */,
 947: 				893DE8DD29E832B90043C02C /* LocalProductionProducts.storekit */,
 948: 				89AA360A2A1BC8560077A70A /* LocalStagingProducts.storekit */,
 949: 				89B72A2D29DACBBF0076884F /* EmptyProducts.storekit */,
 950: 			);
 951: 			path = IAP;
 952: 			sourceTree = "<group>";
 953: 		};
 954: 		89CD7AB729D329B1003F1C3A /* Fonts */ = {
 955: 			isa = PBXGroup;
 956: 			children = (
 957: 				89D79DE82A654DC80086A8E5 /* Poppins-Black.ttf */,
 958: 				89D79DEB2A654DC80086A8E5 /* Poppins-BlackItalic.ttf */,
 959: 				89D79DF62A654DC80086A8E5 /* Poppins-Bold.ttf */,
 960: 				89D79DF52A654DC80086A8E5 /* Poppins-BoldItalic.ttf */,
 961: 				89D79DEE2A654DC80086A8E5 /* Poppins-ExtraBold.ttf */,
 962: 				89D79DF12A654DC80086A8E5 /* Poppins-ExtraBoldItalic.ttf */,
 963: 				89D79DF02A654DC80086A8E5 /* Poppins-ExtraLight.ttf */,
 964: 				89D79DE62A654DC70086A8E5 /* Poppins-ExtraLightItalic.ttf */,
 965: 				89D79DED2A654DC80086A8E5 /* Poppins-Italic.ttf */,
 966: 				89D79DEA2A654DC80086A8E5 /* Poppins-Light.ttf */,
 967: 				89D79DF22A654DC80086A8E5 /* Poppins-LightItalic.ttf */,
 968: 				89D79DEC2A654DC80086A8E5 /* Poppins-Medium.ttf */,
 969: 				89D79DF42A654DC80086A8E5 /* Poppins-MediumItalic.ttf */,
 970: 				89D79DF32A654DC80086A8E5 /* Poppins-Regular.ttf */,
 971: 				89D79DE72A654DC70086A8E5 /* Poppins-SemiBold.ttf */,
 972: 				89D79DF72A654DC80086A8E5 /* Poppins-SemiBoldItalic.ttf */,
 973: 				89D79DEF2A654DC80086A8E5 /* Poppins-Thin.ttf */,
 974: 				89D79DE92A654DC80086A8E5 /* Poppins-ThinItalic.ttf */,
 975: 			);
 976: 			path = Fonts;
 977: 			sourceTree = "<group>";
 978: 		};
 979: 		89CD7ACB29D329B1003F1C3A /* Animations */ = {
 980: 			isa = PBXGroup;
 981: 			children = (
 982: 				89923E6A29D47B9E00E246FC /* pdf-scanning.json */,
 983: 				89CD7ACC29D329B1003F1C3A /* loading.json */,
 984: 			);
 985: 			path = Animations;
 986: 			sourceTree = "<group>";
 987: 		};
 988: 		89CD7ACD29D329B1003F1C3A /* Utils */ = {
 989: 			isa = PBXGroup;
 990: 			children = (
 991: 				C9CEF5ED2DB0679B00980C8A /* Protocols */,
 992: 				893E849529D5943D00F6B99A /* Camera */,
 993: 				89CD7ACE29D329B1003F1C3A /* UI */,
 994: 				89CD7AD329D329B1003F1C3A /* ParentalCheck.swift */,
 995: 				89CD7AD429D329B1003F1C3A /* Extensions */,
 996: 				89CD7ADB29D329B1003F1C3A /* Async.swift */,
 997: 				89CD7ADC29D329B1003F1C3A /* DebugUtils.swift */,
 998: 				893ED9D32A692805004EE67C /* CombineUtils.swift */,
 999: 				89F9E4F82A95FEED0001D48B /* PDFImageExtractor.swift */,
1000: 				89431FC52A9900740042A636 /* MathUtils.swift */,
1001: 			);
1002: 			path = Utils;
1003: 			sourceTree = "<group>";
1004: 		};
1005: 		89CD7ACE29D329B1003F1C3A /* UI */ = {
1006: 			isa = PBXGroup;
1007: 			children = (
1008: 				89CD7ACF29D329B1003F1C3A /* AsyncView.swift */,
1009: 				893875002A7BDD3B00267AFD /* LoadingView.swift */,
1010: 				89CD7AD029D329B1003F1C3A /* CircularProgressView.swift */,
1011: 				89CD7AD129D329B1003F1C3A /* UnderlyingError.swift */,
1012: 				89CD7AD229D329B1003F1C3A /* LottieView.swift */,
1013: 				894D485B29D42FE1002B0230 /* RoundedCorner.swift */,
1014: 				89923E6829D46A9900E246FC /* FilePicker.swift */,
1015: 				893E84A529D5C5E200F6B99A /* ActivityViewController.swift */,
1016: 				8902898C29DC1F10007E6372 /* PageControl.swift */,
1017: 				89436AC629E5B99100060605 /* PdfKitView.swift */,
1018: 				8933490B2A24AE880005D484 /* PdfKitViewBinder.swift */,
1019: 				89127AA02A177E370059005F /* PencilKitView.swift */,
1020: 				892201D82A0BA64600832CF2 /* ImageAnnotationStamp.swift */,
1021: 				89851B5D2A13DB1A00ABF58F /* ImageResizableView.swift */,
1022: 				8932ECE82A20F10500CBCD7A /* TextResizableView.swift */,
1023: 				896CCF6C2A28910B008F268E /* SizePrinter.swift */,
1024: 				893AAFCA2A39B2AF00EF9B00 /* FormSheet.swift */,
1025: 				89D1FE7F2A84D76B009AC57C /* FullScreenClearBackground.swift */,
1026: 				89F9E4FC2A9635EC0001D48B /* ZoomImageModifier.swift */,
1027: 				894C4A682AA0C04B0001F51E /* PopupView.swift */,
1028: 			);
1029: 			path = UI;
1030: 			sourceTree = "<group>";
1031: 		};
1032: 		89CD7AD429D329B1003F1C3A /* Extensions */ = {
1033: 			isa = PBXGroup;
1034: 			children = (
1035: 				89CD7AD529D329B1003F1C3A /* String+Extensions.swift */,
1036: 				89CD7AD629D329B1003F1C3A /* UIApplication+Extensions.swift */,
1037: 				89CD7AD729D329B1003F1C3A /* View+Alert.swift */,
1038: 				89CD7AD829D329B1003F1C3A /* View+Extensions.swift */,
1039: 				89CD7AD929D329B1003F1C3A /* Color+Extensions.swift */,
1040: 				89CD7ADA29D329B1003F1C3A /* Enum+Extensions.swift */,
1041: 				894AC3632A02952A00BA5553 /* Foundation+Extensions.swift */,
1042: 				893B04BC2AA9C2C100F86813 /* CoreGraphics+Extensions.swift */,
1043: 				891AE58A2A03E80300DBC246 /* ObservableObject+Extensions.swift */,
1044: 				89127AA62A17C1980059005F /* PencilKit+Extensions.swift */,
1045: 				896CCF6E2A28AEAC008F268E /* UIFont+Extensions.swift */,
1046: 				892E404E2A25E5D9000EEE23 /* PDFAnnotation+Extensions.swift */,
1047: 				897967852A73E59B00E91F8E /* URL+Extensions.swift */,
1048: 				89436D202A93B97E000868B5 /* NSAttributedString+Extensions.swift */,
1049: 				89ABAA582A97B29C00721045 /* PdfDocument+Extensions.swift */,
1050: 				893EB5042AA722EF0066914E /* StoreKit+Extensions.swift */,
1051: 			);
1052: 			path = Extensions;
1053: 			sourceTree = "<group>";
1054: 		};
1055: 		89CD7ADD29D329B1003F1C3A /* Models */ = {
1056: 			isa = PBXGroup;
1057: 			children = (
1058: 				89CD7AEF29D329B1003F1C3A /* Entities */,
1059: 				89E55BE029DC66170073F268 /* Analytics */,
1060: 				89429F8D2A9C94A300465420 /* Persistence */,
1061: 				89CD7AEB29D329B1003F1C3A /* Store.swift */,
1062: 				89CD7AE529D329B1003F1C3A /* StoreImpl.swift */,
1063: 				89923E5E29D4350F00E246FC /* AppTrackingTransparency.swift */,
1064: 				89923E5D29D4350F00E246FC /* AppTrackingTransparencyImpl.swift */,
1065: 				894827B12AA5D68D00030C4E /* AttributionManager.swift */,
1066: 				894827B32AA5D6FF00030C4E /* AttibutionManagerImpl.swift */,
1067: 				8991485029E851B500DD01F2 /* ConfigService.swift */,
1068: 				8991485229E851BD00DD01F2 /* RemoteConfigManager.swift */,
1069: 				893BE5312A6A96BE004B05B9 /* Network */,
1070: 			);
1071: 			path = Models;
1072: 			sourceTree = "<group>";
1073: 		};
1074: 		89CD7AEF29D329B1003F1C3A /* Entities */ = {
1075: 			isa = PBXGroup;
1076: 			children = (
1077: 				89436ABE29E55EA000060605 /* Pdf.swift */,
1078: 				89429F892A9C937300465420 /* Signature.swift */,
1079: 				8928F3D02A30BAFB001C1853 /* PickedImage.swift */,
1080: 				8936AA322A6828C9005F6C73 /* ProjectInfo.swift */,
1081: 				893ED9CF2A6920F2004EE67C /* ChatPdfRef.swift */,
1082: 				893ED9D12A6926E8004EE67C /* ChatPdfMessage.swift */,
1083: 				894CB09D2A851FE50008008A /* ChatPdfSetupData.swift */,
1084: 				8934ACC62A6AE96700F6CDA8 /* ChatPdfInitParams.swift */,
1085: 				8966B6F12AA9FCE0005E6DED /* SuggestedFields.swift */,
1086: 			);
1087: 			path = Entities;
1088: 			sourceTree = "<group>";
1089: 		};
1090: 		89CD7AF529D329B1003F1C3A /* Applicaction */ = {
1091: 			isa = PBXGroup;
1092: 			children = (
1093: 				C9CEF5EB2DB03CCB00980C8A /* SceneDelegate.swift */,
1094: 				89CD7BBC29D331AA003F1C3A /* AppDelegate.swift */,
1095: 				89CD7AF629D329B1003F1C3A /* Constants.swift */,
1096: 				89CD7A9929D32855003F1C3A /* PdfExpertApp.swift */,
1097: 			);
1098: 			path = Applicaction;
1099: 			sourceTree = "<group>";
1100: 		};
1101: 		89CD7AF829D329B1003F1C3A /* Style */ = {
1102: 			isa = PBXGroup;
1103: 			children = (
1104: 				89CD7AF929D329B1003F1C3A /* FontPalette.swift */,
1105: 				89CD7AFA29D329B1003F1C3A /* ColorPalette.swift */,
1106: 				895FE2C529D6E17600A99D5B /* AnimationPalette.swift */,
1107: 			);
1108: 			path = Style;
1109: 			sourceTree = "<group>";
1110: 		};
1111: 		89CD7AFB29D329B1003F1C3A /* ViewModels */ = {
1112: 			isa = PBXGroup;
1113: 			children = (
1114: 				8995694329D3450300566EF4 /* HomeViewModel.swift */,
1115: 				89CD7AFD29D329B1003F1C3A /* SubscribeViewModel.swift */,
1116: 				893DE8D929E7F85C0043C02C /* SubscriptionPairsViewModel.swift */,
1117: 				893DE8DB29E7F9A10043C02C /* SubscriptionVerticalViewModel.swift */,
1118: 				89E601632A8295A2009492DA /* SubscriptionPickerViewModel.swift */,
1119: 				893E849329D5878E00F6B99A /* CameraViewModel.swift */,
1120: 				8955ED952A1F73DC009985EE /* OnboardingViewModel.swift */,
1121: 				893C8FCA29DED1AF000E35BD /* ArchiveViewModel.swift */,
1122: 				8936AA3D2A682F8E005F6C73 /* ChatPdfSelectionViewModel.swift */,
1123: 				8936AA432A684128005F6C73 /* ChatPdfViewModel.swift */,
1124: 				89436AC229E59C0E00060605 /* PdfEditViewModel.swift */,
1125: 				892201DD2A0BA72D00832CF2 /* PdfSignatureViewModel.swift */,
1126: 				8932ECE62A20DCB900CBCD7A /* PdfFillFormViewModel.swift */,
1127: 				89127AA42A17A3600059005F /* PdfSignatureCanvasViewModel.swift */,
1128: 				89429F872A9C8EFC00465420 /* PdfSignaturePickerViewModel.swift */,
1129: 				89504A472A44829C000BCACD /* PdfFillWidgetViewModel.swift */,
1130: 				89BB2DB82A7A6050009E6738 /* PdfMergeViewModel.swift */,
1131: 				89BB2DBA2A7A7DD7009E6738 /* PdfUnlockViewModel.swift */,
1132: 				89BB2DBE2A7AB0CE009E6738 /* PdfSortViewModel.swift */,
1133: 				896876192A7CE87A0014A320 /* PdfSplitViewModel.swift */,
1134: 				8968761B2A7CEB650014A320 /* PdfImportViewModel.swift */,
1135: 				8968761F2A7CF1E00014A320 /* PdfImportMultipleViewModel.swift */,
1136: 				896876252A7D2EB80014A320 /* PdfPageRangeEditorViewModel.swift */,
1137: 				89436D1A2A939CBB000868B5 /* PdfReadViewModel.swift */,
1138: 				89436D1E2A93AEB4000868B5 /* PdfReaderViewModel.swift */,
1139: 				892CC6972AAA2660000DEC21 /* SuggestedFieldsFormViewModel.swift */,
1140: 				8962D6052A9E28FB008426A2 /* PdfSignaturePrioviderFlow.swift */,
1141: 				89407EF02AA8ADD200169801 /* GalleryImageProviderFlow.swift */,
1142: 				89407EF42AA8BDE600169801 /* CameraImageProviderFlow.swift */,
1143: 				89407EFB2AA8D22D00169801 /* ImageCropFlow.swift */,
1144: 				894C4A6D2AA0CB470001F51E /* ReviewFlow.swift */,
1145: 			);
1146: 			path = ViewModels;
1147: 			sourceTree = "<group>";
1148: 		};
1149: 		89CD7B0329D329B1003F1C3A /* Views */ = {
1150: 			isa = PBXGroup;
1151: 			children = (
1152: 				89CD7BB229D32E69003F1C3A /* Navigation */,
1153: 				8995694829D3473E00566EF4 /* Common */,
1154: 				89AAFEA829DB3098002D348E /* Welcome */,
1155: 				89AAFE9A29DB1823002D348E /* Onboarding */,
1156: 				895FE2C929D6E98100A99D5B /* Subscription */,
1157: 				89436AB929E5578300060605 /* Pdf */,
1158: 				899F484229DF123B00E7E1E4 /* Main */,
1159: 				893C8FC729DED15B000E35BD /* Archive */,
1160: 				8936AA3A2A682C71005F6C73 /* ChatPdf */,
1161: 				89CD7BB729D330B2003F1C3A /* Home */,
1162: 				89B72A3129DADC6E0076884F /* Settings */,
1163: 				895FE2C229D6D7D800A99D5B /* Scan */,
1164: 				893E849229D5877800F6B99A /* Camera */,
1165: 				894B019D2A0902A000FF6198 /* ImportTutorial */,
1166: 				894C4A6C2AA0C2F40001F51E /* Review */,
1167: 				89CD7B2629D329B1003F1C3A /* ContentView.swift */,
1168: 			);
1169: 			path = Views;
1170: 			sourceTree = "<group>";
1171: 		};
1172: 		89CD7B2B29D329B1003F1C3A /* InternalUtils */ = {
1173: 			isa = PBXGroup;
1174: 			children = (
1175: 				89CD7B2C29D329B1003F1C3A /* SharedErrors.swift */,
1176: 				89CD7B2D29D329B1003F1C3A /* SubscriptionViewUtility.swift */,
1177: 				89CD7B2E29D329B1003F1C3A /* View+Preview.swift */,
1178: 				89CD7B2F29D329B1003F1C3A /* View+Internal.swift */,
1179: 				893C8FDD29DED7F4000E35BD /* PdfUtility.swift */,
1180: 				8945D2BB2A03C41000AFF51A /* PdfScanUtility.swift */,
1181: 				895C1BBF2A051261005EA190 /* SharedStorage.swift */,
1182: 				89407EFF2AA8D54800169801 /* ImageCropper.swift */,
1183: 			);
1184: 			path = InternalUtils;
1185: 			sourceTree = "<group>";
1186: 		};
1187: 		89CD7BB229D32E69003F1C3A /* Navigation */ = {
1188: 			isa = PBXGroup;
1189: 			children = (
1190: 				89CD7BB429D32E69003F1C3A /* MainCoordinator.swift */,
1191: 				89436AB729E5556600060605 /* PdfCoordinator.swift */,
1192: 				8957FBA72A77C646008B31ED /* PdfShareCoordinator.swift */,
1193: 				89467AD62A9E4C6B00FC01FC /* Deeplink.swift */,
1194: 			);
1195: 			path = Navigation;
1196: 			sourceTree = "<group>";
1197: 		};
1198: 		89CD7BB729D330B2003F1C3A /* Home */ = {
1199: 			isa = PBXGroup;
1200: 			children = (
1201: 				89CD7BBA29D330FB003F1C3A /* HomeView.swift */,
1202: 				8995694129D33B1300566EF4 /* HomeItemView.swift */,
1203: 			);
1204: 			path = Home;
1205: 			sourceTree = "<group>";
1206: 		};
1207: 		89E55BE029DC66170073F268 /* Analytics */ = {
1208: 			isa = PBXGroup;
1209: 			children = (
1210: 				89E55BDB29DC64840073F268 /* AnalyticsManagerImpl.swift */,
1211: 				89E55BD829DC64840073F268 /* AnalyticsManager.swift */,
1212: 				89E55BDA29DC64840073F268 /* FirebaseAnalyticsPlatform.swift */,
1213: 				893EB5022AA71FFD0066914E /* BranchAnalyticsPlatform.swift */,
1214: 				89E55BE129DC66240073F268 /* AnalyticsPlatform.swift */,
1215: 				893EB5062AA723C80066914E /* AnalyticsDefaultParameters.swift */,
1216: 			);
1217: 			path = Analytics;
1218: 			sourceTree = "<group>";
1219: 		};
1220: 		C9CEF5ED2DB0679B00980C8A /* Protocols */ = {
1221: 			isa = PBXGroup;
1222: 			children = (
1223: 			);
1224: 			path = Protocols;
1225: 			sourceTree = "<group>";
1226: 		};
1227: /* End PBXGroup section */
1228: 
1229: /* Begin PBXNativeTarget section */
1230: 		895C1BAC2A04FA53005EA190 /* ShareFileExtension */ = {
1231: 			isa = PBXNativeTarget;
1232: 			buildConfigurationList = 895C1BBB2A04FA54005EA190 /* Build configuration list for PBXNativeTarget "ShareFileExtension" */;
1233: 			buildPhases = (
1234: 				895C1BA92A04FA53005EA190 /* Sources */,
1235: 				895C1BAA2A04FA53005EA190 /* Frameworks */,
1236: 				895C1BAB2A04FA53005EA190 /* Resources */,
1237: 			);
1238: 			buildRules = (
1239: 			);
1240: 			dependencies = (
1241: 			);
1242: 			name = ShareFileExtension;
1243: 			productName = ShareFileExtension;
1244: 			productReference = 895C1BAD2A04FA53005EA190 /* ShareFileExtension.appex */;
1245: 			productType = "com.apple.product-type.app-extension";
1246: 		};
1247: 		89CD7A9529D32855003F1C3A /* PdfExpert */ = {
1248: 			isa = PBXNativeTarget;
1249: 			buildConfigurationList = 89CD7AAA29D32856003F1C3A /* Build configuration list for PBXNativeTarget "PdfExpert" */;
1250: 			buildPhases = (
1251: 				89CD7A9229D32855003F1C3A /* Sources */,
1252: 				89CD7A9329D32855003F1C3A /* Frameworks */,
1253: 				89AA36072A1BB0280077A70A /* Setup Firebase Environment GoogleService-Info.plist */,
1254: 				89CD7A9429D32855003F1C3A /* Resources */,
1255: 				89923E6429D437B400E246FC /* ShellScript */,
1256: 				C9CEF5EA2DB02DBB00980C8A /* Embed Foundation Extensions */,
1257: 			);
1258: 			buildRules = (
1259: 			);
1260: 			dependencies = (
1261: 				C9CEF5E92DB02DBA00980C8A /* PBXTargetDependency */,
1262: 			);
1263: 			name = PdfExpert;
1264: 			packageProductDependencies = (
1265: 				89CD7BA429D32C52003F1C3A /* Lottie */,
1266: 				89CD7BA729D32C72003F1C3A /* Factory */,
1267: 				89CD7BAA29D32CE5003F1C3A /* FirebaseAnalyticsSwift */,
1268: 				89CD7BAC29D32CE5003F1C3A /* FirebaseCrashlytics */,
1269: 				89923E6629D437F500E246FC /* FirebasePerformance */,
1270: 				893E84A329D5BFBB00F6B99A /* PSPDFKit */,
1271: 				895FE2CF29D7392F00A99D5B /* Collections */,
1272: 				895FE2D129D7392F00A99D5B /* OrderedCollections */,
1273: 				8942034429DC12BC004D610B /* PagerTabStripView */,
1274: 				891A07E829E028EE0002FA3A /* CloudKitSyncMonitor */,
1275: 				8991485529E85DE500DD01F2 /* CombineExt */,
1276: 				893BE52A2A6A7864004B05B9 /* CombineMoya */,
1277: 				894827AF2AA5D65600030C4E /* BranchSDK */,
1278: 				893EB5002AA717B80066914E /* FacebookCore */,
1279: 				89407EF92AA8C4C400169801 /* Mantis */,
1280: 			);
1281: 			productName = PdfExpert;
1282: 			productReference = 89CD7A9629D32855003F1C3A /* PdfExpert.app */;
1283: 			productType = "com.apple.product-type.application";
1284: 		};
1285: /* End PBXNativeTarget section */
1286: 
1287: /* Begin PBXProject section */
1288: 		89CD7A8E29D32855003F1C3A /* Project object */ = {
1289: 			isa = PBXProject;
1290: 			attributes = {
1291: 				BuildIndependentTargetsInParallel = 1;
1292: 				LastSwiftUpdateCheck = 1430;
1293: 				LastUpgradeCheck = 1620;
1294: 				TargetAttributes = {
1295: 					895C1BAC2A04FA53005EA190 = {
1296: 						CreatedOnToolsVersion = 14.3;
1297: 					};
1298: 					89CD7A9529D32855003F1C3A = {
1299: 						CreatedOnToolsVersion = 14.2;
1300: 					};
1301: 				};
1302: 			};
1303: 			buildConfigurationList = 89CD7A9129D32855003F1C3A /* Build configuration list for PBXProject "pdfexpert" */;
1304: 			compatibilityVersion = "Xcode 14.0";
1305: 			developmentRegion = en;
1306: 			hasScannedForEncodings = 0;
1307: 			knownRegions = (
1308: 				en,
1309: 				Base,
1310: 			);
1311: 			mainGroup = 89CD7A8D29D32855003F1C3A;
1312: 			packageReferences = (
1313: 				89CD7BA329D32C52003F1C3A /* XCRemoteSwiftPackageReference "lottie-spm" */,
1314: 				89CD7BA629D32C72003F1C3A /* XCRemoteSwiftPackageReference "Factory" */,
1315: 				89CD7BA929D32CE5003F1C3A /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */,
1316: 				893E84A229D5BFBB00F6B99A /* XCRemoteSwiftPackageReference "PSPDFKit-SP" */,
1317: 				895FE2CE29D7392E00A99D5B /* XCRemoteSwiftPackageReference "swift-collections" */,
1318: 				8942034329DC12BC004D610B /* XCRemoteSwiftPackageReference "PagerTabStripView" */,
1319: 				891A07E729E028EE0002FA3A /* XCRemoteSwiftPackageReference "CloudKitSyncMonitor" */,
1320: 				8991485429E85DE500DD01F2 /* XCRemoteSwiftPackageReference "CombineExt" */,
1321: 				893BE5292A6A7864004B05B9 /* XCRemoteSwiftPackageReference "Moya" */,
1322: 				894827AE2AA5D65600030C4E /* XCRemoteSwiftPackageReference "ios-branch-sdk-spm" */,
1323: 				893EB4FF2AA717B80066914E /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */,
1324: 				89407EF82AA8C4C400169801 /* XCRemoteSwiftPackageReference "Mantis" */,
1325: 			);
1326: 			productRefGroup = 89CD7A9729D32855003F1C3A /* Products */;
1327: 			projectDirPath = "";
1328: 			projectRoot = "";
1329: 			targets = (
1330: 				89CD7A9529D32855003F1C3A /* PdfExpert */,
1331: 				895C1BAC2A04FA53005EA190 /* ShareFileExtension */,
1332: 			);
1333: 		};
1334: /* End PBXProject section */
1335: 
1336: /* Begin PBXResourcesBuildPhase section */
1337: 		895C1BAB2A04FA53005EA190 /* Resources */ = {
1338: 			isa = PBXResourcesBuildPhase;
1339: 			buildActionMask = 2147483647;
1340: 			files = (
1341: 				895C1BB32A04FA53005EA190 /* MainInterface.storyboard in Resources */,
1342: 			);
1343: 			runOnlyForDeploymentPostprocessing = 0;
1344: 		};
1345: 		89CD7A9429D32855003F1C3A /* Resources */ = {
1346: 			isa = PBXResourcesBuildPhase;
1347: 			buildActionMask = 2147483647;
1348: 			files = (
1349: 				89CD7B3029D329B1003F1C3A /* Colors.xcassets in Resources */,
1350: 				89D79DFC2A654DC80086A8E5 /* Poppins-Light.ttf in Resources */,
1351: 				89CD7AA129D32856003F1C3A /* Preview Assets.xcassets in Resources */,
1352: 				89D79E092A654DC80086A8E5 /* Poppins-SemiBoldItalic.ttf in Resources */,
1353: 				C999928D2DAF4C9B003C3643 /* GoogleService-Info.plist in Resources */,
1354: 				C9CEF5DD2DAF973100980C8A /* Montserrat-ExtraBold.ttf in Resources */,
1355: 				89D79E012A654DC80086A8E5 /* Poppins-Thin.ttf in Resources */,
1356: 				89D79E032A654DC80086A8E5 /* Poppins-ExtraBoldItalic.ttf in Resources */,
1357: 				C9CEF5DF2DAF974500980C8A /* Montserrat-Medium.ttf in Resources */,
1358: 				89CD7B3429D329B1003F1C3A /* Products.plist in Resources */,
1359: 				8936AA312A682812005F6C73 /* ProjectInfo.plist in Resources */,
1360: 				89D79DF82A654DC80086A8E5 /* Poppins-ExtraLightItalic.ttf in Resources */,
1361: 				89D79E082A654DC80086A8E5 /* Poppins-Bold.ttf in Resources */,
1362: 				89923E6B29D47B9E00E246FC /* pdf-scanning.json in Resources */,
1363: 				89D79DF92A654DC80086A8E5 /* Poppins-SemiBold.ttf in Resources */,
1364: 				89CD7B4A29D329B1003F1C3A /* loading.json in Resources */,
1365: 				89D79DFD2A654DC80086A8E5 /* Poppins-BlackItalic.ttf in Resources */,
1366: 				89D79DFE2A654DC80086A8E5 /* Poppins-Medium.ttf in Resources */,
1367: 				C9CEF5E12DAF975200980C8A /* Montserrat-Regular.ttf in Resources */,
1368: 				89D79DFF2A654DC80086A8E5 /* Poppins-Italic.ttf in Resources */,
1369: 				C9CEF5E32DAF975A00980C8A /* Montserrat-Bold.ttf in Resources */,
1370: 				893C8FE129DEDAF4000E35BD /* test.pdf in Resources */,
1371: 				89D79DFA2A654DC80086A8E5 /* Poppins-Black.ttf in Resources */,
1372: 				89D79E072A654DC80086A8E5 /* Poppins-BoldItalic.ttf in Resources */,
1373: 				89D79E022A654DC80086A8E5 /* Poppins-ExtraLight.ttf in Resources */,
1374: 				89D79E042A654DC80086A8E5 /* Poppins-LightItalic.ttf in Resources */,
1375: 				89D79DFB2A654DC80086A8E5 /* Poppins-ThinItalic.ttf in Resources */,
1376: 				89D79E002A654DC80086A8E5 /* Poppins-ExtraBold.ttf in Resources */,
1377: 				89D79E052A654DC80086A8E5 /* Poppins-Regular.ttf in Resources */,
1378: 				89D79E062A654DC80086A8E5 /* Poppins-MediumItalic.ttf in Resources */,
1379: 				89CD7B3329D329B1003F1C3A /* Assets.xcassets in Resources */,
1380: 			);
1381: 			runOnlyForDeploymentPostprocessing = 0;
1382: 		};
1383: /* End PBXResourcesBuildPhase section */
1384: 
1385: /* Begin PBXShellScriptBuildPhase section */
1386: 		89923E6429D437B400E246FC /* ShellScript */ = {
1387: 			isa = PBXShellScriptBuildPhase;
1388: 			buildActionMask = 2147483647;
1389: 			files = (
1390: 			);
1391: 			inputFileListPaths = (
1392: 			);
1393: 			inputPaths = (
1394: 				"${DWARF_DSYM_FOLDER_PATH}/${DWARF_DSYM_FILE_NAME}/Contents/Resources/DWARF/${TARGET_NAME}",
1395: 			);
1396: 			outputFileListPaths = (
1397: 			);
1398: 			outputPaths = (
1399: 			);
1400: 			runOnlyForDeploymentPostprocessing = 0;
1401: 			shellPath = /bin/sh;
1402: 			shellScript = "# Type a script or drag a script file from your workspace to insert its path.\n\"${BUILD_DIR%/Build/*}/SourcePackages/checkouts/firebase-ios-sdk/Crashlytics/run\"\n";
1403: 		};
1404: 		89AA36072A1BB0280077A70A /* Setup Firebase Environment GoogleService-Info.plist */ = {
1405: 			isa = PBXShellScriptBuildPhase;
1406: 			alwaysOutOfDate = 1;
1407: 			buildActionMask = 2147483647;
1408: 			files = (
1409: 			);
1410: 			inputFileListPaths = (
1411: 			);
1412: 			inputPaths = (
1413: 			);
1414: 			name = "Setup Firebase Environment GoogleService-Info.plist";
1415: 			outputFileListPaths = (
1416: 			);
1417: 			outputPaths = (
1418: 			);
1419: 			runOnlyForDeploymentPostprocessing = 0;
1420: 			shellPath = /bin/sh;
1421: 			shellScript = "# Name of the resource we're selectively copying\nGOOGLESERVICE_INFO_PLIST=GoogleService-Info.plist\n\n# Get references to dev and prod versions of the GoogleService-Info.plist\n# NOTE: These should only live on the file system and should NOT be part of the target (since we'll be adding them to the target manually)\nGOOGLESERVICE_INFO_STAGING=${PROJECT_DIR}/${TARGET_NAME}/Resources/Staging/${GOOGLESERVICE_INFO_PLIST}\nGOOGLESERVICE_INFO_PROD=${PROJECT_DIR}/${TARGET_NAME}/Resources/Production/${GOOGLESERVICE_INFO_PLIST}\n\n# Make sure the staging version of GoogleService-Info.plist exists\necho \"Looking for ${GOOGLESERVICE_INFO_PLIST} in ${GOOGLESERVICE_INFO_STAGING}\"\nif [ ! -f $GOOGLESERVICE_INFO_STAGING ]\nthen\n    echo \"No Staging GoogleService-Info.plist found. Please ensure it's in the proper directory.\"\n    exit 1\nfi\n\n# Make sure the prod version of GoogleService-Info.plist exists\necho \"Looking for ${GOOGLESERVICE_INFO_PLIST} in ${GOOGLESERVICE_INFO_PROD}\"\nif [ ! -f $GOOGLESERVICE_INFO_PROD ]\nthen\n    echo \"No Production GoogleService-Info.plist found. Please ensure it's in the proper directory.\"\n    exit 1\nfi\n\n# Get a reference to the destination location for the GoogleService-Info.plist\nPLIST_DESTINATION=${BUILT_PRODUCTS_DIR}/${PRODUCT_NAME}.app\necho \"Will copy ${GOOGLESERVICE_INFO_PLIST} to final destination: ${PLIST_DESTINATION}\"\n\n# Copy over the prod GoogleService-Info.plist for Production builds\nif [ \"${CONFIGURATION}\" == \"Production Release\" ] || [ \"${CONFIGURATION}\" == \"Production Debug\" ]\nthen\n    echo \"Using ${GOOGLESERVICE_INFO_PROD}\"\n    cp \"${GOOGLESERVICE_INFO_PROD}\" \"${PLIST_DESTINATION}\"\nelse\n    echo \"Using ${GOOGLESERVICE_INFO_STAGING}\"\n    cp \"${GOOGLESERVICE_INFO_STAGING}\" \"${PLIST_DESTINATION}\"\nfi\n";
1422: 		};
1423: /* End PBXShellScriptBuildPhase section */
1424: 
1425: /* Begin PBXSourcesBuildPhase section */
1426: 		895C1BA92A04FA53005EA190 /* Sources */ = {
1427: 			isa = PBXSourcesBuildPhase;
1428: 			buildActionMask = 2147483647;
1429: 			files = (
1430: 				895C1BC12A051261005EA190 /* SharedStorage.swift in Sources */,
1431: 				895C1BB02A04FA53005EA190 /* ShareViewController.swift in Sources */,
1432: 			);
1433: 			runOnlyForDeploymentPostprocessing = 0;
1434: 		};
1435: 		89CD7A9229D32855003F1C3A /* Sources */ = {
1436: 			isa = PBXSourcesBuildPhase;
1437: 			buildActionMask = 2147483647;
1438: 			files = (
1439: 				893EB5072AA723C80066914E /* AnalyticsDefaultParameters.swift in Sources */,
1440: 				8932ECE92A20F10500CBCD7A /* TextResizableView.swift in Sources */,
1441: 				89AAFEA129DB2672002D348E /* CacheManager.swift in Sources */,
1442: 				89CD7B5529D329B1003F1C3A /* Enum+Extensions.swift in Sources */,
1443: 				8932ECE72A20DCB900CBCD7A /* PdfFillFormViewModel.swift in Sources */,
1444: 				892CC6942AAA243E000DEC21 /* SuggestedFields+Persistable.swift in Sources */,
1445: 				89429F8C2A9C937C00465420 /* CDSignature.swift in Sources */,
1446: 				89436ABF29E55EA000060605 /* Pdf.swift in Sources */,
1447: 				8955ED962A1F73DC009985EE /* OnboardingViewModel.swift in Sources */,
1448: 				8936AA422A6840D1005F6C73 /* ChatPdfView.swift in Sources */,
1449: 				89436D1B2A939CBB000868B5 /* PdfReadViewModel.swift in Sources */,
1450: 				89AAFEA229DB2672002D348E /* CacheManagerImpl.swift in Sources */,
1451: 				89431FC62A9900740042A636 /* MathUtils.swift in Sources */,
1452: 				89436AC329E59C0E00060605 /* PdfEditViewModel.swift in Sources */,
1453: 				89407EF32AA8B0C800169801 /* GalleryImageProviderFlowView.swift in Sources */,
1454: 				893ED9D42A692805004EE67C /* CombineUtils.swift in Sources */,
1455: 				89CD7B9A29D329B1003F1C3A /* View+Internal.swift in Sources */,
1456: 				89BB2DB72A7A5EFC009E6738 /* PdfMergeView.swift in Sources */,
1457: 				89407EF72AA8BEC200169801 /* CameraImageProviderFlowView.swift in Sources */,
1458: 				89436D232A93C1CE000868B5 /* PdfPageSelectionView.swift in Sources */,
1459: 				89BB2DBF2A7AB0CE009E6738 /* PdfSortViewModel.swift in Sources */,
1460: 				89C2500F2A72B2BC00184C45 /* CDPdf.swift in Sources */,
1461: 				8928F3D12A30BAFB001C1853 /* PickedImage.swift in Sources */,
1462: 				894AC3642A02952A00BA5553 /* Foundation+Extensions.swift in Sources */,
1463: 				891AE58B2A03E80300DBC246 /* ObservableObject+Extensions.swift in Sources */,
1464: 				89429F952A9D001A00465420 /* Signature+Persistable.swift in Sources */,
1465: 				89CD7B5029D329B1003F1C3A /* String+Extensions.swift in Sources */,
1466: 				8968761E2A7CEE320014A320 /* PdfImportView.swift in Sources */,
1467: 				89429F932A9CFFF100465420 /* Pdf+Persistable.swift in Sources */,
1468: 				893B04BD2AA9C2C100F86813 /* CoreGraphics+Extensions.swift in Sources */,
1469: 				8936AA402A683FB5005F6C73 /* ImportOption.swift in Sources */,
1470: 				89429F912A9CFFDC00465420 /* Persistable.swift in Sources */,
1471: 				89CD7B5729D329B1003F1C3A /* DebugUtils.swift in Sources */,
1472: 				892E404F2A25E5D9000EEE23 /* PDFAnnotation+Extensions.swift in Sources */,
1473: 				893E849D29D5944E00F6B99A /* CameraService+Enums.swift in Sources */,
1474: 				89CD7BBB29D330FB003F1C3A /* HomeView.swift in Sources */,
1475: 				895C1BC02A051261005EA190 /* SharedStorage.swift in Sources */,
1476: 				89CD7B7329D329B1003F1C3A /* SubscribeViewModel.swift in Sources */,
1477: 				893E849129D5874D00F6B99A /* CameraView.swift in Sources */,
1478: 				89504A482A44829C000BCACD /* PdfFillWidgetViewModel.swift in Sources */,
1479: 				894B019F2A0902BC00FF6198 /* ImportTutorialView.swift in Sources */,
1480: 				893E849F29D5944E00F6B99A /* ImageResizer.swift in Sources */,
1481: 				893E849E29D5944E00F6B99A /* CameraPreviewView.swift in Sources */,
1482: 				893DE8DC29E7F9A10043C02C /* SubscriptionVerticalViewModel.swift in Sources */,
1483: 				893AAFCB2A39B2AF00EF9B00 /* FormSheet.swift in Sources */,
1484: 				89436D1F2A93AEB4000868B5 /* PdfReaderViewModel.swift in Sources */,
1485: 				895FE2CD29D724B900A99D5B /* SubscriptionPairsItemView.swift in Sources */,
1486: 				892201D92A0BA64600832CF2 /* ImageAnnotationStamp.swift in Sources */,
1487: 				894C4A6E2AA0CB470001F51E /* ReviewFlow.swift in Sources */,
1488: 				896876262A7D2EB80014A320 /* PdfPageRangeEditorViewModel.swift in Sources */,
1489: 				89EBC9072A83D0DB00BDBBD4 /* SubscriptionPickerPlanView.swift in Sources */,
1490: 				8962D6082A9E2A57008426A2 /* PdfSignatureProviderFlowView.swift in Sources */,
1491: 				897911EF29E70558008B7088 /* SubscriptionVerticalItemView.swift in Sources */,
1492: 				896876282A7D2EC20014A320 /* PdfPageRangeEditorView.swift in Sources */,
1493: 				89CD7B5629D329B1003F1C3A /* Async.swift in Sources */,
1494: 				89CD7B5129D329B1003F1C3A /* UIApplication+Extensions.swift in Sources */,
1495: 				89BB2DBB2A7A7DD7009E6738 /* PdfUnlockViewModel.swift in Sources */,
1496: 				8995694429D3450300566EF4 /* HomeViewModel.swift in Sources */,
1497: 				89CD7B9829D329B1003F1C3A /* SubscriptionViewUtility.swift in Sources */,
1498: 				89BB2DB92A7A6050009E6738 /* PdfMergeViewModel.swift in Sources */,
1499: 				89127AA32A177F170059005F /* PdfSignatureCanvasView.swift in Sources */,
1500: 				8933490C2A24AE880005D484 /* PdfKitViewBinder.swift in Sources */,
1501: 				893C8FD329DED2E9000E35BD /* Repository.swift in Sources */,
1502: 				89923E6929D46A9900E246FC /* FilePicker.swift in Sources */,
1503: 				893ED9D22A6926E8004EE67C /* ChatPdfMessage.swift in Sources */,
1504: 				894D485829D42C9E002B0230 /* OptionItemView.swift in Sources */,
1505: 				896876202A7CF1E10014A320 /* PdfImportMultipleViewModel.swift in Sources */,
1506: 				8936AA392A68299B005F6C73 /* ChatPdfManagerMock.swift in Sources */,
1507: 				89CD7B4B29D329B1003F1C3A /* AsyncView.swift in Sources */,
1508: 				C9CEF5EC2DB03CCE00980C8A /* SceneDelegate.swift in Sources */,
1509: 				89407EFC2AA8D22D00169801 /* ImageCropFlow.swift in Sources */,
1510: 				8991485129E851B500DD01F2 /* ConfigService.swift in Sources */,
1511: 				89E55BDF29DC64840073F268 /* AnalyticsManagerImpl.swift in Sources */,
1512: 				89407EF12AA8ADD200169801 /* GalleryImageProviderFlow.swift in Sources */,
1513: 				892CC6922AAA23AE000DEC21 /* CDSuggestedFields.swift in Sources */,
1514: 				896876222A7CF3220014A320 /* PdfImportMultipleView.swift in Sources */,
1515: 				895FE2C629D6E17600A99D5B /* AnimationPalette.swift in Sources */,
1516: 				8957FBAA2A77E6F7008B31ED /* PdfShareView.swift in Sources */,
1517: 				89436AB829E5556600060605 /* PdfCoordinator.swift in Sources */,
1518: 				89CD7B7029D329B1003F1C3A /* FontPalette.swift in Sources */,
1519: 				893BE52D2A6A78BB004B05B9 /* ChatPdfManagerImpl.swift in Sources */,
1520: 				895FE2CB29D6E9B800A99D5B /* SubscriptionPairsView.swift in Sources */,
1521: 				894C4A702AA0CCFC0001F51E /* ReviewFlowView.swift in Sources */,
1522: 				89923E5F29D4350F00E246FC /* AppTrackingTransparencyImpl.swift in Sources */,
1523: 				893C8FCB29DED1AF000E35BD /* ArchiveViewModel.swift in Sources */,
1524: 				89407EF52AA8BDE600169801 /* CameraImageProviderFlow.swift in Sources */,
1525: 				89E55BDE29DC64840073F268 /* FirebaseAnalyticsPlatform.swift in Sources */,
1526: 				895FE2C429D6D7E500A99D5B /* ScannerView.swift in Sources */,
1527: 				89CD7B4E29D329B1003F1C3A /* LottieView.swift in Sources */,
1528: 				8991485329E851BD00DD01F2 /* RemoteConfigManager.swift in Sources */,
1529: 				893875012A7BDD3B00267AFD /* LoadingView.swift in Sources */,
1530: 				89436D1D2A93AE76000868B5 /* PdfReaderView.swift in Sources */,
1531: 				89436D192A936C9F000868B5 /* PdfReadView.swift in Sources */,
1532: 				89CD7B5F29D329B1003F1C3A /* StoreImpl.swift in Sources */,
1533: 				893C8FD429DED2E9000E35BD /* RepositoryImpl.swift in Sources */,
1534: 				893E84A129D5944E00F6B99A /* CameraService+Extensions.swift in Sources */,
1535: 				897967862A73E59B00E91F8E /* URL+Extensions.swift in Sources */,
1536: 				89127AA52A17A3600059005F /* PdfSignatureCanvasViewModel.swift in Sources */,
1537: 				89CD7B9729D329B1003F1C3A /* SharedErrors.swift in Sources */,
1538: 				893E849429D5878E00F6B99A /* CameraViewModel.swift in Sources */,
1539: 				892201DE2A0BA72D00832CF2 /* PdfSignatureViewModel.swift in Sources */,
1540: 				8968761C2A7CEB650014A320 /* PdfImportViewModel.swift in Sources */,
1541: 				89460C6029DAC36600E39BAC /* SubscriptionErrorView.swift in Sources */,
1542: 				89BB2DBD2A7A80A8009E6738 /* PdfUnlockView.swift in Sources */,
1543: 				896CCF6D2A28910B008F268E /* SizePrinter.swift in Sources */,
1544: 				89127AA12A177E370059005F /* PencilKitView.swift in Sources */,
1545: 				894827B42AA5D6FF00030C4E /* AttibutionManagerImpl.swift in Sources */,
1546: 				89CD7BBD29D331AA003F1C3A /* AppDelegate.swift in Sources */,
1547: 				8968761A2A7CE87A0014A320 /* PdfSplitViewModel.swift in Sources */,
1548: 				893ED9D02A6920F2004EE67C /* ChatPdfRef.swift in Sources */,
1549: 				89CD7BB629D32E69003F1C3A /* MainCoordinator.swift in Sources */,
1550: 				89407F002AA8D54800169801 /* ImageCropper.swift in Sources */,
1551: 				899F484429DF128200E7E1E4 /* MainTabView.swift in Sources */,
1552: 				894D485A29D42CC5002B0230 /* OptionListView.swift in Sources */,
1553: 				89923E6029D4350F00E246FC /* AppTrackingTransparency.swift in Sources */,
1554: 				89CD7B9929D329B1003F1C3A /* View+Preview.swift in Sources */,
1555: 				8957FBA82A77C646008B31ED /* PdfShareCoordinator.swift in Sources */,
1556: 				894CB09E2A851FE50008008A /* ChatPdfSetupData.swift in Sources */,
1557: 				893DE8DA29E7F85C0043C02C /* SubscriptionPairsViewModel.swift in Sources */,
1558: 				89436AC729E5B99100060605 /* PdfKitView.swift in Sources */,
1559: 				894C4A722AA0DB9A0001F51E /* PreReviewPopupLowRateView.swift in Sources */,
1560: 				89CD7B5429D329B1003F1C3A /* Color+Extensions.swift in Sources */,
1561: 				897911ED29E70541008B7088 /* SubscriptionVerticalView.swift in Sources */,
1562: 				8936AA442A684128005F6C73 /* ChatPdfViewModel.swift in Sources */,
1563: 				89CD7B4D29D329B1003F1C3A /* UnderlyingError.swift in Sources */,
1564: 				89436D212A93B97E000868B5 /* NSAttributedString+Extensions.swift in Sources */,
1565: 				89B72A3329DADC790076884F /* SettingsView.swift in Sources */,
1566: 				896CCF6F2A28AEAC008F268E /* UIFont+Extensions.swift in Sources */,
1567: 				89D1FE802A84D76B009AC57C /* FullScreenClearBackground.swift in Sources */,
1568: 				8945D2BC2A03C41000AFF51A /* PdfScanUtility.swift in Sources */,
1569: 				89429F882A9C8EFC00465420 /* PdfSignaturePickerViewModel.swift in Sources */,
1570: 				89CD7B6E29D329B1003F1C3A /* Constants.swift in Sources */,
1571: 				8962D6062A9E28FB008426A2 /* PdfSignaturePrioviderFlow.swift in Sources */,
1572: 				893EB5032AA71FFD0066914E /* BranchAnalyticsPlatform.swift in Sources */,
1573: 				89436ABB29E557D500060605 /* PdfFlowView.swift in Sources */,
1574: 				89CD7B6529D329B1003F1C3A /* Store.swift in Sources */,
1575: 				893E849C29D5944E00F6B99A /* PhotoCaptureProcessor.swift in Sources */,
1576: 				894C4A692AA0C04B0001F51E /* PopupView.swift in Sources */,
1577: 				89407EFE2AA8D23B00169801 /* ImageCropFlowView.swift in Sources */,
1578: 				89F9E4FB2A9606ED0001D48B /* PdfImageViewerView.swift in Sources */,
1579: 				894B01A12A09030000FF6198 /* ImportTutorialPageView.swift in Sources */,
1580: 				892201DC2A0BA70300832CF2 /* PdfSignatureView.swift in Sources */,
1581: 				893E84A029D5944E00F6B99A /* CameraService.swift in Sources */,
1582: 				893C8FDE29DED7F4000E35BD /* PdfUtility.swift in Sources */,
1583: 				8995694229D33B1300566EF4 /* HomeItemView.swift in Sources */,
1584: 				894D485C29D42FE1002B0230 /* RoundedCorner.swift in Sources */,
1585: 				89EBC9052A83CC3000BDBBD4 /* SubscriptionFreeTrialToggleView.swift in Sources */,
1586: 				89E601622A829556009492DA /* SubscriptionPickerView.swift in Sources */,
1587: 				8934ACC72A6AE96700F6CDA8 /* ChatPdfInitParams.swift in Sources */,
1588: 				8966B6F22AA9FCE0005E6DED /* SuggestedFields.swift in Sources */,
1589: 				89CD7B4C29D329B1003F1C3A /* CircularProgressView.swift in Sources */,
1590: 				89E55BE229DC66240073F268 /* AnalyticsPlatform.swift in Sources */,
1591: 				893ED9D92A693013004EE67C /* MessageView.swift in Sources */,
1592: 				893C8FC929DED190000E35BD /* ArchiveView.swift in Sources */,
1593: 				89467AD72A9E4C6B00FC01FC /* Deeplink.swift in Sources */,
1594: 				89F9E4FD2A9635EC0001D48B /* ZoomImageModifier.swift in Sources */,
1595: 				89AAFEA729DB2AC4002D348E /* WelcomeView.swift in Sources */,
1596: 				8955ED922A1F61A9009985EE /* OnboardingView.swift in Sources */,
1597: 				89851B5E2A13DB1A00ABF58F /* ImageResizableView.swift in Sources */,
1598: 				89ABAA592A97B29C00721045 /* PdfDocument+Extensions.swift in Sources */,
1599: 				89BB2DC12A7AB4A8009E6738 /* PdfSortView.swift in Sources */,
1600: 				89429F862A9C8ECC00465420 /* PdfSignaturePickerView.swift in Sources */,
1601: 				8936AA3C2A682CDA005F6C73 /* ChatPdfSelectionView.swift in Sources */,
1602: 				8936AA332A6828C9005F6C73 /* ProjectInfo.swift in Sources */,
1603: 				893C8FD029DED278000E35BD /* Persistence.swift in Sources */,
1604: 				893BE5352A6A96F5004B05B9 /* ChatPdfRef+Decodable.swift in Sources */,
1605: 				89CD7B5229D329B1003F1C3A /* View+Alert.swift in Sources */,
1606: 				89E601642A8295A2009492DA /* SubscriptionPickerViewModel.swift in Sources */,
1607: 				893C8FCE29DED254000E35BD /* AppCoreData.xcdatamodeld in Sources */,
1608: 				89436ABD29E5586600060605 /* PdfEditView.swift in Sources */,
1609: 				89CD7B9329D329B1003F1C3A /* ContentView.swift in Sources */,
1610: 				89127AA72A17C1980059005F /* PencilKit+Extensions.swift in Sources */,
1611: 				89F9E4F92A95FEEE0001D48B /* PDFImageExtractor.swift in Sources */,
1612: 				893E84A629D5C5E200F6B99A /* ActivityViewController.swift in Sources */,
1613: 				8940FB912A710D8D00A00D8D /* AddPasswordView.swift in Sources */,
1614: 				8936AA3E2A682F8E005F6C73 /* ChatPdfSelectionViewModel.swift in Sources */,
1615: 				8932ECE52A20DC7700CBCD7A /* PdfFillFormView.swift in Sources */,
1616: 				893BE52F2A6A7C0C004B05B9 /* NetworkUtility.swift in Sources */,
1617: 				89D1FE7E2A84D428009AC57C /* SubscriptionPickerPlanListView.swift in Sources */,
1618: 				89CD7B5329D329B1003F1C3A /* View+Extensions.swift in Sources */,
1619: 				892CC6962AAA2641000DEC21 /* SuggestedFieldsFormView.swift in Sources */,
1620: 				8957FBAC2A7801BA008B31ED /* PdfCompressionPickerView.swift in Sources */,
1621: 				893BE5372A6A9708004B05B9 /* ChatPdfMessage+Decodable.swift in Sources */,
1622: 				89429F8A2A9C937300465420 /* Signature.swift in Sources */,
1623: 				892CC6982AAA2660000DEC21 /* SuggestedFieldsFormViewModel.swift in Sources */,
1624: 				8902898D29DC1F10007E6372 /* PageControl.swift in Sources */,
1625: 				894CB0A02A8520AD0008008A /* ChatPdfSetupData+Decodable.swift in Sources */,
1626: 				89E55BDC29DC64840073F268 /* AnalyticsManager.swift in Sources */,
1627: 				89CD7B4F29D329B1003F1C3A /* ParentalCheck.swift in Sources */,
1628: 				893ED9DA2A693013004EE67C /* MessageIndicatorView.swift in Sources */,
1629: 				8936AA382A68299B005F6C73 /* ChatPdfManager.swift in Sources */,
1630: 				89CD7A9A29D32855003F1C3A /* PdfExpertApp.swift in Sources */,
1631: 				89CD7B7129D329B1003F1C3A /* ColorPalette.swift in Sources */,
1632: 				89504A462A448252000BCACD /* PdfFillWidgetView.swift in Sources */,
1633: 				894C4A6B2AA0C23F0001F51E /* PreReviewPopupView.swift in Sources */,
1634: 				893EB5052AA722EF0066914E /* StoreKit+Extensions.swift in Sources */,
1635: 				896876242A7D05040014A320 /* PdfSplitView.swift in Sources */,
1636: 				8955ED942A1F61BD009985EE /* OnboardingPageView.swift in Sources */,
1637: 				894827B22AA5D68D00030C4E /* AttributionManager.swift in Sources */,
1638: 			);
1639: 			runOnlyForDeploymentPostprocessing = 0;
1640: 		};
1641: /* End PBXSourcesBuildPhase section */
1642: 
1643: /* Begin PBXTargetDependency section */
1644: 		C9CEF5E92DB02DBA00980C8A /* PBXTargetDependency */ = {
1645: 			isa = PBXTargetDependency;
1646: 			target = 895C1BAC2A04FA53005EA190 /* ShareFileExtension */;
1647: 			targetProxy = C9CEF5E82DB02DBA00980C8A /* PBXContainerItemProxy */;
1648: 		};
1649: /* End PBXTargetDependency section */
1650: 
1651: /* Begin PBXVariantGroup section */
1652: 		895C1BB12A04FA53005EA190 /* MainInterface.storyboard */ = {
1653: 			isa = PBXVariantGroup;
1654: 			children = (
1655: 				895C1BB22A04FA53005EA190 /* Base */,
1656: 			);
1657: 			name = MainInterface.storyboard;
1658: 			sourceTree = "<group>";
1659: 		};
1660: /* End PBXVariantGroup section */
1661: 
1662: /* Begin XCBuildConfiguration section */
1663: 		895C1BB92A04FA53005EA190 /* Production Debug */ = {
1664: 			isa = XCBuildConfiguration;
1665: 			buildSettings = {
1666: 				CODE_SIGN_ENTITLEMENTS = ShareFileExtension/ShareFileExtension.entitlements;
1667: 				CODE_SIGN_STYLE = Automatic;
1668: 				CURRENT_PROJECT_VERSION = 1;
1669: 				DEBUG_INFORMATION_FORMAT = dwarf;
1670: 				DEVELOPMENT_TEAM = KQM6GWHKY3;
1671: 				GENERATE_INFOPLIST_FILE = YES;
1672: 				INFOPLIST_FILE = ShareFileExtension/Resources/Production/Info.plist;
1673: 				INFOPLIST_KEY_CFBundleDisplayName = ShareFileExtension;
1674: 				INFOPLIST_KEY_NSHumanReadableCopyright = "";
1675: 				IPHONEOS_DEPLOYMENT_TARGET = 16.4;
1676: 				LD_RUNPATH_SEARCH_PATHS = (
1677: 					"$(inherited)",
1678: 					"@executable_path/Frameworks",
1679: 					"@executable_path/../../Frameworks",
1680: 				);
1681: 				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert.ShareFileExtension;
1682: 				PRODUCT_NAME = "$(TARGET_NAME)";
1683: 				SKIP_INSTALL = YES;
1684: 				SWIFT_EMIT_LOC_STRINGS = YES;
1685: 				SWIFT_VERSION = 5.0;
1686: 				TARGETED_DEVICE_FAMILY = "1,2";
1687: 			};
1688: 			name = "Production Debug";
1689: 		};
1690: 		895C1BBA2A04FA53005EA190 /* Production Release */ = {
1691: 			isa = XCBuildConfiguration;
1692: 			buildSettings = {
1693: 				CODE_SIGN_ENTITLEMENTS = ShareFileExtension/ShareFileExtension.entitlements;
1694: 				CODE_SIGN_STYLE = Automatic;
1695: 				CURRENT_PROJECT_VERSION = 1;
1696: 				DEVELOPMENT_TEAM = KQM6GWHKY3;
1697: 				GENERATE_INFOPLIST_FILE = YES;
1698: 				INFOPLIST_FILE = ShareFileExtension/Resources/Production/Info.plist;
1699: 				INFOPLIST_KEY_CFBundleDisplayName = ShareFileExtension;
1700: 				INFOPLIST_KEY_NSHumanReadableCopyright = "";
1701: 				IPHONEOS_DEPLOYMENT_TARGET = 16.4;
1702: 				LD_RUNPATH_SEARCH_PATHS = (
1703: 					"$(inherited)",
1704: 					"@executable_path/Frameworks",
1705: 					"@executable_path/../../Frameworks",
1706: 				);
1707: 				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert.ShareFileExtension;
1708: 				PRODUCT_NAME = "$(TARGET_NAME)";
1709: 				SKIP_INSTALL = YES;
1710: 				SWIFT_EMIT_LOC_STRINGS = YES;
1711: 				SWIFT_VERSION = 5.0;
1712: 				TARGETED_DEVICE_FAMILY = "1,2";
1713: 			};
1714: 			name = "Production Release";
1715: 		};
1716: 		89AA35FE2A1BAC100077A70A /* Staging Debug */ = {
1717: 			isa = XCBuildConfiguration;
1718: 			buildSettings = {
1719: 				ALWAYS_SEARCH_USER_PATHS = NO;
1720: 				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
1721: 				CLANG_ANALYZER_NONNULL = YES;
1722: 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
1723: 				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
1724: 				CLANG_ENABLE_MODULES = YES;
1725: 				CLANG_ENABLE_OBJC_ARC = YES;
1726: 				CLANG_ENABLE_OBJC_WEAK = YES;
1727: 				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
1728: 				CLANG_WARN_BOOL_CONVERSION = YES;
1729: 				CLANG_WARN_COMMA = YES;
1730: 				CLANG_WARN_CONSTANT_CONVERSION = YES;
1731: 				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
1732: 				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
1733: 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
1734: 				CLANG_WARN_EMPTY_BODY = YES;
1735: 				CLANG_WARN_ENUM_CONVERSION = YES;
1736: 				CLANG_WARN_INFINITE_RECURSION = YES;
1737: 				CLANG_WARN_INT_CONVERSION = YES;
1738: 				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
1739: 				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
1740: 				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
1741: 				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
1742: 				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
1743: 				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
1744: 				CLANG_WARN_STRICT_PROTOTYPES = YES;
1745: 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
1746: 				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
1747: 				CLANG_WARN_UNREACHABLE_CODE = YES;
1748: 				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
1749: 				COPY_PHASE_STRIP = NO;
1750: 				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
1751: 				ENABLE_STRICT_OBJC_MSGSEND = YES;
1752: 				ENABLE_TESTABILITY = YES;
1753: 				GCC_C_LANGUAGE_STANDARD = gnu11;
1754: 				GCC_DYNAMIC_NO_PIC = NO;
1755: 				GCC_NO_COMMON_BLOCKS = YES;
1756: 				GCC_OPTIMIZATION_LEVEL = 0;
1757: 				GCC_PREPROCESSOR_DEFINITIONS = (
1758: 					"DEBUG=1",
1759: 					"$(inherited)",
1760: 				);
1761: 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
1762: 				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
1763: 				GCC_WARN_UNDECLARED_SELECTOR = YES;
1764: 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
1765: 				GCC_WARN_UNUSED_FUNCTION = YES;
1766: 				GCC_WARN_UNUSED_VARIABLE = YES;
1767: 				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
1768: 				IPHONEOS_DEPLOYMENT_TARGET = 16.2;
1769: 				MARKETING_VERSION = 1.26;
1770: 				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
1771: 				MTL_FAST_MATH = YES;
1772: 				ONLY_ACTIVE_ARCH = YES;
1773: 				OTHER_LDFLAGS = "-ObjC";
1774: 				OTHER_SWIFT_FLAGS = " \"-D\" \"FACEBOOK\" \"-D\" \"STAGING\"";
1775: 				SDKROOT = iphoneos;
1776: 				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
1777: 				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
1778: 			};
1779: 			name = "Staging Debug";
1780: 		};
1781: 		89AA35FF2A1BAC100077A70A /* Staging Debug */ = {
1782: 			isa = XCBuildConfiguration;
1783: 			buildSettings = {
1784: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIconStaging;
1785: 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
1786: 				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
1787: 				CODE_SIGN_ENTITLEMENTS = PdfExpert/PdfExpert.entitlements;
1788: 				CODE_SIGN_STYLE = Automatic;
1789: 				CURRENT_PROJECT_VERSION = 1;
1790: 				DEVELOPMENT_ASSET_PATHS = "\"PdfExpert/Preview Content\"";
1791: 				DEVELOPMENT_TEAM = KQM6GWHKY3;
1792: 				DISPLAY_NAME = "PDF Pro Staging";
1793: 				ENABLE_PREVIEWS = YES;
1794: 				GENERATE_INFOPLIST_FILE = YES;
1795: 				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
1796: 				INFOPLIST_KEY_CFBundleDisplayName = AtlasPDF;
1797: 				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.productivity";
1798: 				INFOPLIST_KEY_NSCameraUsageDescription = "The app need to access your camera in order to scan documents or to take pictures to convert to pdf";
1799: 				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Recording sound annotations requires the microphone.";
1800: 				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "The app need to access your photo library in order to convert your pictures to pdf";
1801: 				INFOPLIST_KEY_NSUserTrackingUsageDescription = "Your data will be used to facilitate access and show you content that is more relevant to you.";
1802: 				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
1803: 				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
1804: 				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
1805: 				INFOPLIST_KEY_UIRequiresFullScreen = YES;
1806: 				INFOPLIST_KEY_UIStatusBarStyle = UIStatusBarStyleLightContent;
1807: 				INFOPLIST_KEY_UISupportedInterfaceOrientations = UIInterfaceOrientationPortrait;
1808: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UIInterfaceOrientationPortrait";
1809: 				INFOPLIST_KEY_UIUserInterfaceStyle = Dark;
1810: 				IPHONEOS_DEPLOYMENT_TARGET = 16.6;
1811: 				LD_RUNPATH_SEARCH_PATHS = (
1812: 					"$(inherited)",
1813: 					"@executable_path/Frameworks",
1814: 				);
1815: 				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert;
1816: 				PRODUCT_NAME = "$(TARGET_NAME)";
1817: 				STRIP_INSTALLED_PRODUCT = NO;
1818: 				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
1819: 				SUPPORTS_MACCATALYST = NO;
1820: 				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
1821: 				SWIFT_EMIT_LOC_STRINGS = YES;
1822: 				SWIFT_VERSION = 5.0;
1823: 				TARGETED_DEVICE_FAMILY = "1,2";
1824: 			};
1825: 			name = "Staging Debug";
1826: 		};
1827: 		89AA36002A1BAC100077A70A /* Staging Debug */ = {
1828: 			isa = XCBuildConfiguration;
1829: 			buildSettings = {
1830: 				CODE_SIGN_ENTITLEMENTS = ShareFileExtension/ShareFileExtension.entitlements;
1831: 				CODE_SIGN_STYLE = Automatic;
1832: 				CURRENT_PROJECT_VERSION = 1;
1833: 				DEBUG_INFORMATION_FORMAT = dwarf;
1834: 				DEVELOPMENT_TEAM = KQM6GWHKY3;
1835: 				GENERATE_INFOPLIST_FILE = YES;
1836: 				INFOPLIST_FILE = ShareFileExtension/Resources/Production/Info.plist;
1837: 				INFOPLIST_KEY_CFBundleDisplayName = ShareFileExtension;
1838: 				INFOPLIST_KEY_NSHumanReadableCopyright = "";
1839: 				IPHONEOS_DEPLOYMENT_TARGET = 16.4;
1840: 				LD_RUNPATH_SEARCH_PATHS = (
1841: 					"$(inherited)",
1842: 					"@executable_path/Frameworks",
1843: 					"@executable_path/../../Frameworks",
1844: 				);
1845: 				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert.ShareFileExtension;
1846: 				PRODUCT_NAME = "$(TARGET_NAME)";
1847: 				SKIP_INSTALL = YES;
1848: 				SWIFT_EMIT_LOC_STRINGS = YES;
1849: 				SWIFT_VERSION = 5.0;
1850: 				TARGETED_DEVICE_FAMILY = "1,2";
1851: 			};
1852: 			name = "Staging Debug";
1853: 		};
1854: 		89AA36022A1BAC1A0077A70A /* Staging Release */ = {
1855: 			isa = XCBuildConfiguration;
1856: 			buildSettings = {
1857: 				ALWAYS_SEARCH_USER_PATHS = NO;
1858: 				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
1859: 				CLANG_ANALYZER_NONNULL = YES;
1860: 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
1861: 				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
1862: 				CLANG_ENABLE_MODULES = YES;
1863: 				CLANG_ENABLE_OBJC_ARC = YES;
1864: 				CLANG_ENABLE_OBJC_WEAK = YES;
1865: 				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
1866: 				CLANG_WARN_BOOL_CONVERSION = YES;
1867: 				CLANG_WARN_COMMA = YES;
1868: 				CLANG_WARN_CONSTANT_CONVERSION = YES;
1869: 				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
1870: 				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
1871: 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
1872: 				CLANG_WARN_EMPTY_BODY = YES;
1873: 				CLANG_WARN_ENUM_CONVERSION = YES;
1874: 				CLANG_WARN_INFINITE_RECURSION = YES;
1875: 				CLANG_WARN_INT_CONVERSION = YES;
1876: 				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
1877: 				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
1878: 				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
1879: 				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
1880: 				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
1881: 				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
1882: 				CLANG_WARN_STRICT_PROTOTYPES = YES;
1883: 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
1884: 				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
1885: 				CLANG_WARN_UNREACHABLE_CODE = YES;
1886: 				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
1887: 				COPY_PHASE_STRIP = NO;
1888: 				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
1889: 				ENABLE_NS_ASSERTIONS = NO;
1890: 				ENABLE_STRICT_OBJC_MSGSEND = YES;
1891: 				GCC_C_LANGUAGE_STANDARD = gnu11;
1892: 				GCC_NO_COMMON_BLOCKS = YES;
1893: 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
1894: 				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
1895: 				GCC_WARN_UNDECLARED_SELECTOR = YES;
1896: 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
1897: 				GCC_WARN_UNUSED_FUNCTION = YES;
1898: 				GCC_WARN_UNUSED_VARIABLE = YES;
1899: 				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
1900: 				IPHONEOS_DEPLOYMENT_TARGET = 16.2;
1901: 				MARKETING_VERSION = 1.26;
1902: 				MTL_ENABLE_DEBUG_INFO = NO;
1903: 				MTL_FAST_MATH = YES;
1904: 				OTHER_LDFLAGS = "-ObjC";
1905: 				OTHER_SWIFT_FLAGS = " \"-D\" \"FACEBOOK\" \"-D\" \"STAGING\"";
1906: 				SDKROOT = iphoneos;
1907: 				SWIFT_COMPILATION_MODE = wholemodule;
1908: 				SWIFT_OPTIMIZATION_LEVEL = "-O";
1909: 				VALIDATE_PRODUCT = YES;
1910: 			};
1911: 			name = "Staging Release";
1912: 		};
1913: 		89AA36032A1BAC1A0077A70A /* Staging Release */ = {
1914: 			isa = XCBuildConfiguration;
1915: 			buildSettings = {
1916: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIconStaging;
1917: 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
1918: 				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
1919: 				CODE_SIGN_ENTITLEMENTS = PdfExpert/PdfExpert.entitlements;
1920: 				CODE_SIGN_STYLE = Automatic;
1921: 				CURRENT_PROJECT_VERSION = 1;
1922: 				DEVELOPMENT_ASSET_PATHS = "\"PdfExpert/Preview Content\"";
1923: 				DEVELOPMENT_TEAM = KQM6GWHKY3;
1924: 				DISPLAY_NAME = "PDF Pro Staging";
1925: 				ENABLE_PREVIEWS = YES;
1926: 				GENERATE_INFOPLIST_FILE = YES;
1927: 				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
1928: 				INFOPLIST_KEY_CFBundleDisplayName = AtlasPDF;
1929: 				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.productivity";
1930: 				INFOPLIST_KEY_NSCameraUsageDescription = "The app need to access your camera in order to scan documents or to take pictures to convert to pdf";
1931: 				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Recording sound annotations requires the microphone.";
1932: 				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "The app need to access your photo library in order to convert your pictures to pdf";
1933: 				INFOPLIST_KEY_NSUserTrackingUsageDescription = "Your data will be used to facilitate access and show you content that is more relevant to you.";
1934: 				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
1935: 				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
1936: 				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
1937: 				INFOPLIST_KEY_UIRequiresFullScreen = YES;
1938: 				INFOPLIST_KEY_UIStatusBarStyle = UIStatusBarStyleLightContent;
1939: 				INFOPLIST_KEY_UISupportedInterfaceOrientations = UIInterfaceOrientationPortrait;
1940: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UIInterfaceOrientationPortrait";
1941: 				INFOPLIST_KEY_UIUserInterfaceStyle = Dark;
1942: 				IPHONEOS_DEPLOYMENT_TARGET = 16.6;
1943: 				LD_RUNPATH_SEARCH_PATHS = (
1944: 					"$(inherited)",
1945: 					"@executable_path/Frameworks",
1946: 				);
1947: 				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert;
1948: 				PRODUCT_NAME = "$(TARGET_NAME)";
1949: 				STRIP_INSTALLED_PRODUCT = NO;
1950: 				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
1951: 				SUPPORTS_MACCATALYST = NO;
1952: 				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
1953: 				SWIFT_EMIT_LOC_STRINGS = YES;
1954: 				SWIFT_VERSION = 5.0;
1955: 				TARGETED_DEVICE_FAMILY = "1,2";
1956: 			};
1957: 			name = "Staging Release";
1958: 		};
1959: 		89AA36042A1BAC1A0077A70A /* Staging Release */ = {
1960: 			isa = XCBuildConfiguration;
1961: 			buildSettings = {
1962: 				CODE_SIGN_ENTITLEMENTS = ShareFileExtension/ShareFileExtension.entitlements;
1963: 				CODE_SIGN_STYLE = Automatic;
1964: 				CURRENT_PROJECT_VERSION = 1;
1965: 				DEVELOPMENT_TEAM = KQM6GWHKY3;
1966: 				GENERATE_INFOPLIST_FILE = YES;
1967: 				INFOPLIST_FILE = ShareFileExtension/Resources/Production/Info.plist;
1968: 				INFOPLIST_KEY_CFBundleDisplayName = ShareFileExtension;
1969: 				INFOPLIST_KEY_NSHumanReadableCopyright = "";
1970: 				IPHONEOS_DEPLOYMENT_TARGET = 16.4;
1971: 				LD_RUNPATH_SEARCH_PATHS = (
1972: 					"$(inherited)",
1973: 					"@executable_path/Frameworks",
1974: 					"@executable_path/../../Frameworks",
1975: 				);
1976: 				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert.ShareFileExtension;
1977: 				PRODUCT_NAME = "$(TARGET_NAME)";
1978: 				SKIP_INSTALL = YES;
1979: 				SWIFT_EMIT_LOC_STRINGS = YES;
1980: 				SWIFT_VERSION = 5.0;
1981: 				TARGETED_DEVICE_FAMILY = "1,2";
1982: 			};
1983: 			name = "Staging Release";
1984: 		};
1985: 		89CD7AA829D32856003F1C3A /* Production Debug */ = {
1986: 			isa = XCBuildConfiguration;
1987: 			buildSettings = {
1988: 				ALWAYS_SEARCH_USER_PATHS = NO;
1989: 				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
1990: 				CLANG_ANALYZER_NONNULL = YES;
1991: 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
1992: 				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
1993: 				CLANG_ENABLE_MODULES = YES;
1994: 				CLANG_ENABLE_OBJC_ARC = YES;
1995: 				CLANG_ENABLE_OBJC_WEAK = YES;
1996: 				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
1997: 				CLANG_WARN_BOOL_CONVERSION = YES;
1998: 				CLANG_WARN_COMMA = YES;
1999: 				CLANG_WARN_CONSTANT_CONVERSION = YES;
2000: 				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
2001: 				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
2002: 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
2003: 				CLANG_WARN_EMPTY_BODY = YES;
2004: 				CLANG_WARN_ENUM_CONVERSION = YES;
2005: 				CLANG_WARN_INFINITE_RECURSION = YES;
2006: 				CLANG_WARN_INT_CONVERSION = YES;
2007: 				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
2008: 				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
2009: 				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
2010: 				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
2011: 				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
2012: 				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
2013: 				CLANG_WARN_STRICT_PROTOTYPES = YES;
2014: 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
2015: 				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
2016: 				CLANG_WARN_UNREACHABLE_CODE = YES;
2017: 				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
2018: 				COPY_PHASE_STRIP = NO;
2019: 				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
2020: 				ENABLE_STRICT_OBJC_MSGSEND = YES;
2021: 				ENABLE_TESTABILITY = YES;
2022: 				GCC_C_LANGUAGE_STANDARD = gnu11;
2023: 				GCC_DYNAMIC_NO_PIC = NO;
2024: 				GCC_NO_COMMON_BLOCKS = YES;
2025: 				GCC_OPTIMIZATION_LEVEL = 0;
2026: 				GCC_PREPROCESSOR_DEFINITIONS = (
2027: 					"DEBUG=1",
2028: 					"$(inherited)",
2029: 				);
2030: 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
2031: 				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
2032: 				GCC_WARN_UNDECLARED_SELECTOR = YES;
2033: 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
2034: 				GCC_WARN_UNUSED_FUNCTION = YES;
2035: 				GCC_WARN_UNUSED_VARIABLE = YES;
2036: 				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
2037: 				IPHONEOS_DEPLOYMENT_TARGET = 16.2;
2038: 				MARKETING_VERSION = 1.26;
2039: 				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
2040: 				MTL_FAST_MATH = YES;
2041: 				ONLY_ACTIVE_ARCH = YES;
2042: 				OTHER_LDFLAGS = "-ObjC";
2043: 				OTHER_SWIFT_FLAGS = " \"-D\" \"FACEBOOK\" \"-D\" \"PRODUCTION\"";
2044: 				SDKROOT = iphoneos;
2045: 				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
2046: 				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
2047: 			};
2048: 			name = "Production Debug";
2049: 		};
2050: 		89CD7AA929D32856003F1C3A /* Production Release */ = {
2051: 			isa = XCBuildConfiguration;
2052: 			buildSettings = {
2053: 				ALWAYS_SEARCH_USER_PATHS = NO;
2054: 				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
2055: 				CLANG_ANALYZER_NONNULL = YES;
2056: 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
2057: 				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
2058: 				CLANG_ENABLE_MODULES = YES;
2059: 				CLANG_ENABLE_OBJC_ARC = YES;
2060: 				CLANG_ENABLE_OBJC_WEAK = YES;
2061: 				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
2062: 				CLANG_WARN_BOOL_CONVERSION = YES;
2063: 				CLANG_WARN_COMMA = YES;
2064: 				CLANG_WARN_CONSTANT_CONVERSION = YES;
2065: 				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
2066: 				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
2067: 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
2068: 				CLANG_WARN_EMPTY_BODY = YES;
2069: 				CLANG_WARN_ENUM_CONVERSION = YES;
2070: 				CLANG_WARN_INFINITE_RECURSION = YES;
2071: 				CLANG_WARN_INT_CONVERSION = YES;
2072: 				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
2073: 				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
2074: 				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
2075: 				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
2076: 				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
2077: 				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
2078: 				CLANG_WARN_STRICT_PROTOTYPES = YES;
2079: 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
2080: 				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
2081: 				CLANG_WARN_UNREACHABLE_CODE = YES;
2082: 				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
2083: 				COPY_PHASE_STRIP = NO;
2084: 				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
2085: 				ENABLE_NS_ASSERTIONS = NO;
2086: 				ENABLE_STRICT_OBJC_MSGSEND = YES;
2087: 				GCC_C_LANGUAGE_STANDARD = gnu11;
2088: 				GCC_NO_COMMON_BLOCKS = YES;
2089: 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
2090: 				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
2091: 				GCC_WARN_UNDECLARED_SELECTOR = YES;
2092: 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
2093: 				GCC_WARN_UNUSED_FUNCTION = YES;
2094: 				GCC_WARN_UNUSED_VARIABLE = YES;
2095: 				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
2096: 				IPHONEOS_DEPLOYMENT_TARGET = 16.2;
2097: 				MARKETING_VERSION = 1.26;
2098: 				MTL_ENABLE_DEBUG_INFO = NO;
2099: 				MTL_FAST_MATH = YES;
2100: 				OTHER_LDFLAGS = "-ObjC";
2101: 				OTHER_SWIFT_FLAGS = " \"-D\" \"FACEBOOK\" \"-D\" \"PRODUCTION\"";
2102: 				SDKROOT = iphoneos;
2103: 				SWIFT_COMPILATION_MODE = wholemodule;
2104: 				SWIFT_OPTIMIZATION_LEVEL = "-O";
2105: 				VALIDATE_PRODUCT = YES;
2106: 			};
2107: 			name = "Production Release";
2108: 		};
2109: 		89CD7AAB29D32856003F1C3A /* Production Debug */ = {
2110: 			isa = XCBuildConfiguration;
2111: 			buildSettings = {
2112: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
2113: 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
2114: 				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
2115: 				CODE_SIGN_ENTITLEMENTS = PdfExpert/PdfExpert.entitlements;
2116: 				CODE_SIGN_STYLE = Automatic;
2117: 				CURRENT_PROJECT_VERSION = 1;
2118: 				DEVELOPMENT_ASSET_PATHS = "\"PdfExpert/Preview Content\"";
2119: 				DEVELOPMENT_TEAM = KQM6GWHKY3;
2120: 				DISPLAY_NAME = "PDF Pro";
2121: 				ENABLE_PREVIEWS = YES;
2122: 				GENERATE_INFOPLIST_FILE = YES;
2123: 				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
2124: 				INFOPLIST_KEY_CFBundleDisplayName = AtlasPDF;
2125: 				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.productivity";
2126: 				INFOPLIST_KEY_NSCameraUsageDescription = "The app need to access your camera in order to scan documents or to take pictures to convert to pdf";
2127: 				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Recording sound annotations requires the microphone.";
2128: 				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "The app need to access your photo library in order to convert your pictures to pdf";
2129: 				INFOPLIST_KEY_NSUserTrackingUsageDescription = "Your data will be used to facilitate access and show you content that is more relevant to you.";
2130: 				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
2131: 				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
2132: 				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
2133: 				INFOPLIST_KEY_UIRequiresFullScreen = YES;
2134: 				INFOPLIST_KEY_UIStatusBarStyle = UIStatusBarStyleLightContent;
2135: 				INFOPLIST_KEY_UISupportedInterfaceOrientations = UIInterfaceOrientationPortrait;
2136: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UIInterfaceOrientationPortrait";
2137: 				INFOPLIST_KEY_UIUserInterfaceStyle = Dark;
2138: 				IPHONEOS_DEPLOYMENT_TARGET = 16.6;
2139: 				LD_RUNPATH_SEARCH_PATHS = (
2140: 					"$(inherited)",
2141: 					"@executable_path/Frameworks",
2142: 				);
2143: 				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert;
2144: 				PRODUCT_NAME = "$(TARGET_NAME)";
2145: 				STRIP_INSTALLED_PRODUCT = NO;
2146: 				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
2147: 				SUPPORTS_MACCATALYST = NO;
2148: 				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
2149: 				SWIFT_EMIT_LOC_STRINGS = YES;
2150: 				SWIFT_VERSION = 5.0;
2151: 				TARGETED_DEVICE_FAMILY = "1,2";
2152: 			};
2153: 			name = "Production Debug";
2154: 		};
2155: 		89CD7AAC29D32856003F1C3A /* Production Release */ = {
2156: 			isa = XCBuildConfiguration;
2157: 			buildSettings = {
2158: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
2159: 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
2160: 				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
2161: 				CODE_SIGN_ENTITLEMENTS = PdfExpert/PdfExpert.entitlements;
2162: 				CODE_SIGN_STYLE = Automatic;
2163: 				CURRENT_PROJECT_VERSION = 1;
2164: 				DEVELOPMENT_ASSET_PATHS = "\"PdfExpert/Preview Content\"";
2165: 				DEVELOPMENT_TEAM = KQM6GWHKY3;
2166: 				DISPLAY_NAME = "PDF Pro";
2167: 				ENABLE_PREVIEWS = YES;
2168: 				GENERATE_INFOPLIST_FILE = YES;
2169: 				INFOPLIST_FILE = PdfExpert/Resources/Production/Info.plist;
2170: 				INFOPLIST_KEY_CFBundleDisplayName = AtlasPDF;
2171: 				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.productivity";
2172: 				INFOPLIST_KEY_NSCameraUsageDescription = "The app need to access your camera in order to scan documents or to take pictures to convert to pdf";
2173: 				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Recording sound annotations requires the microphone.";
2174: 				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "The app need to access your photo library in order to convert your pictures to pdf";
2175: 				INFOPLIST_KEY_NSUserTrackingUsageDescription = "Your data will be used to facilitate access and show you content that is more relevant to you.";
2176: 				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
2177: 				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
2178: 				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
2179: 				INFOPLIST_KEY_UIRequiresFullScreen = YES;
2180: 				INFOPLIST_KEY_UIStatusBarStyle = UIStatusBarStyleLightContent;
2181: 				INFOPLIST_KEY_UISupportedInterfaceOrientations = UIInterfaceOrientationPortrait;
2182: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UIInterfaceOrientationPortrait";
2183: 				INFOPLIST_KEY_UIUserInterfaceStyle = Dark;
2184: 				IPHONEOS_DEPLOYMENT_TARGET = 16.6;
2185: 				LD_RUNPATH_SEARCH_PATHS = (
2186: 					"$(inherited)",
2187: 					"@executable_path/Frameworks",
2188: 				);
2189: 				PRODUCT_BUNDLE_IDENTIFIER = com.pcnaid.pdfexpert;
2190: 				PRODUCT_NAME = "$(TARGET_NAME)";
2191: 				STRIP_INSTALLED_PRODUCT = NO;
2192: 				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
2193: 				SUPPORTS_MACCATALYST = NO;
2194: 				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
2195: 				SWIFT_EMIT_LOC_STRINGS = YES;
2196: 				SWIFT_VERSION = 5.0;
2197: 				TARGETED_DEVICE_FAMILY = "1,2";
2198: 			};
2199: 			name = "Production Release";
2200: 		};
2201: /* End XCBuildConfiguration section */
2202: 
2203: /* Begin XCConfigurationList section */
2204: 		895C1BBB2A04FA54005EA190 /* Build configuration list for PBXNativeTarget "ShareFileExtension" */ = {
2205: 			isa = XCConfigurationList;
2206: 			buildConfigurations = (
2207: 				895C1BB92A04FA53005EA190 /* Production Debug */,
2208: 				89AA36002A1BAC100077A70A /* Staging Debug */,
2209: 				895C1BBA2A04FA53005EA190 /* Production Release */,
2210: 				89AA36042A1BAC1A0077A70A /* Staging Release */,
2211: 			);
2212: 			defaultConfigurationIsVisible = 0;
2213: 			defaultConfigurationName = "Production Release";
2214: 		};
2215: 		89CD7A9129D32855003F1C3A /* Build configuration list for PBXProject "pdfexpert" */ = {
2216: 			isa = XCConfigurationList;
2217: 			buildConfigurations = (
2218: 				89CD7AA829D32856003F1C3A /* Production Debug */,
2219: 				89AA35FE2A1BAC100077A70A /* Staging Debug */,
2220: 				89CD7AA929D32856003F1C3A /* Production Release */,
2221: 				89AA36022A1BAC1A0077A70A /* Staging Release */,
2222: 			);
2223: 			defaultConfigurationIsVisible = 0;
2224: 			defaultConfigurationName = "Production Release";
2225: 		};
2226: 		89CD7AAA29D32856003F1C3A /* Build configuration list for PBXNativeTarget "PdfExpert" */ = {
2227: 			isa = XCConfigurationList;
2228: 			buildConfigurations = (
2229: 				89CD7AAB29D32856003F1C3A /* Production Debug */,
2230: 				89AA35FF2A1BAC100077A70A /* Staging Debug */,
2231: 				89CD7AAC29D32856003F1C3A /* Production Release */,
2232: 				89AA36032A1BAC1A0077A70A /* Staging Release */,
2233: 			);
2234: 			defaultConfigurationIsVisible = 0;
2235: 			defaultConfigurationName = "Production Release";
2236: 		};
2237: /* End XCConfigurationList section */
2238: 
2239: /* Begin XCRemoteSwiftPackageReference section */
2240: 		891A07E729E028EE0002FA3A /* XCRemoteSwiftPackageReference "CloudKitSyncMonitor" */ = {
2241: 			isa = XCRemoteSwiftPackageReference;
2242: 			repositoryURL = "https://github.com/ggruen/CloudKitSyncMonitor.git";
2243: 			requirement = {
2244: 				branch = main;
2245: 				kind = branch;
2246: 			};
2247: 		};
2248: 		893BE5292A6A7864004B05B9 /* XCRemoteSwiftPackageReference "Moya" */ = {
2249: 			isa = XCRemoteSwiftPackageReference;
2250: 			repositoryURL = "https://github.com/Moya/Moya";
2251: 			requirement = {
2252: 				kind = upToNextMajorVersion;
2253: 				minimumVersion = 15.0.0;
2254: 			};
2255: 		};
2256: 		893E84A229D5BFBB00F6B99A /* XCRemoteSwiftPackageReference "PSPDFKit-SP" */ = {
2257: 			isa = XCRemoteSwiftPackageReference;
2258: 			repositoryURL = "https://github.com/PSPDFKit/PSPDFKit-SP";
2259: 			requirement = {
2260: 				branch = master;
2261: 				kind = branch;
2262: 			};
2263: 		};
2264: 		893EB4FF2AA717B80066914E /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */ = {
2265: 			isa = XCRemoteSwiftPackageReference;
2266: 			repositoryURL = "https://github.com/facebook/facebook-ios-sdk";
2267: 			requirement = {
2268: 				kind = upToNextMajorVersion;
2269: 				minimumVersion = 16.0.0;
2270: 			};
2271: 		};
2272: 		89407EF82AA8C4C400169801 /* XCRemoteSwiftPackageReference "Mantis" */ = {
2273: 			isa = XCRemoteSwiftPackageReference;
2274: 			repositoryURL = "https://github.com/guoyingtao/Mantis.git";
2275: 			requirement = {
2276: 				kind = upToNextMajorVersion;
2277: 				minimumVersion = 2.0.0;
2278: 			};
2279: 		};
2280: 		8942034329DC12BC004D610B /* XCRemoteSwiftPackageReference "PagerTabStripView" */ = {
2281: 			isa = XCRemoteSwiftPackageReference;
2282: 			repositoryURL = "https://github.com/xmartlabs/PagerTabStripView";
2283: 			requirement = {
2284: 				kind = upToNextMajorVersion;
2285: 				minimumVersion = 4.0.0;
2286: 			};
2287: 		};
2288: 		894827AE2AA5D65600030C4E /* XCRemoteSwiftPackageReference "ios-branch-sdk-spm" */ = {
2289: 			isa = XCRemoteSwiftPackageReference;
2290: 			repositoryURL = "https://github.com/BranchMetrics/ios-branch-sdk-spm";
2291: 			requirement = {
2292: 				kind = upToNextMajorVersion;
2293: 				minimumVersion = 2.0.0;
2294: 			};
2295: 		};
2296: 		895FE2CE29D7392E00A99D5B /* XCRemoteSwiftPackageReference "swift-collections" */ = {
2297: 			isa = XCRemoteSwiftPackageReference;
2298: 			repositoryURL = "https://github.com/apple/swift-collections.git";
2299: 			requirement = {
2300: 				kind = upToNextMajorVersion;
2301: 				minimumVersion = 1.0.0;
2302: 			};
2303: 		};
2304: 		8991485429E85DE500DD01F2 /* XCRemoteSwiftPackageReference "CombineExt" */ = {
2305: 			isa = XCRemoteSwiftPackageReference;
2306: 			repositoryURL = "https://github.com/CombineCommunity/CombineExt.git";
2307: 			requirement = {
2308: 				kind = upToNextMajorVersion;
2309: 				minimumVersion = 1.0.0;
2310: 			};
2311: 		};
2312: 		89CD7BA329D32C52003F1C3A /* XCRemoteSwiftPackageReference "lottie-spm" */ = {
2313: 			isa = XCRemoteSwiftPackageReference;
2314: 			repositoryURL = "https://github.com/airbnb/lottie-spm.git";
2315: 			requirement = {
2316: 				branch = main;
2317: 				kind = branch;
2318: 			};
2319: 		};
2320: 		89CD7BA629D32C72003F1C3A /* XCRemoteSwiftPackageReference "Factory" */ = {
2321: 			isa = XCRemoteSwiftPackageReference;
2322: 			repositoryURL = "https://github.com/hmlongco/Factory";
2323: 			requirement = {
2324: 				kind = upToNextMajorVersion;
2325: 				minimumVersion = 2.0.0;
2326: 			};
2327: 		};
2328: 		89CD7BA929D32CE5003F1C3A /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */ = {
2329: 			isa = XCRemoteSwiftPackageReference;
2330: 			repositoryURL = "https://github.com/firebase/firebase-ios-sdk";
2331: 			requirement = {
2332: 				branch = master;
2333: 				kind = branch;
2334: 			};
2335: 		};
2336: /* End XCRemoteSwiftPackageReference section */
2337: 
2338: /* Begin XCSwiftPackageProductDependency section */
2339: 		891A07E829E028EE0002FA3A /* CloudKitSyncMonitor */ = {
2340: 			isa = XCSwiftPackageProductDependency;
2341: 			package = 891A07E729E028EE0002FA3A /* XCRemoteSwiftPackageReference "CloudKitSyncMonitor" */;
2342: 			productName = CloudKitSyncMonitor;
2343: 		};
2344: 		893BE52A2A6A7864004B05B9 /* CombineMoya */ = {
2345: 			isa = XCSwiftPackageProductDependency;
2346: 			package = 893BE5292A6A7864004B05B9 /* XCRemoteSwiftPackageReference "Moya" */;
2347: 			productName = CombineMoya;
2348: 		};
2349: 		893E84A329D5BFBB00F6B99A /* PSPDFKit */ = {
2350: 			isa = XCSwiftPackageProductDependency;
2351: 			package = 893E84A229D5BFBB00F6B99A /* XCRemoteSwiftPackageReference "PSPDFKit-SP" */;
2352: 			productName = PSPDFKit;
2353: 		};
2354: 		893EB5002AA717B80066914E /* FacebookCore */ = {
2355: 			isa = XCSwiftPackageProductDependency;
2356: 			package = 893EB4FF2AA717B80066914E /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */;
2357: 			productName = FacebookCore;
2358: 		};
2359: 		89407EF92AA8C4C400169801 /* Mantis */ = {
2360: 			isa = XCSwiftPackageProductDependency;
2361: 			package = 89407EF82AA8C4C400169801 /* XCRemoteSwiftPackageReference "Mantis" */;
2362: 			productName = Mantis;
2363: 		};
2364: 		8942034429DC12BC004D610B /* PagerTabStripView */ = {
2365: 			isa = XCSwiftPackageProductDependency;
2366: 			package = 8942034329DC12BC004D610B /* XCRemoteSwiftPackageReference "PagerTabStripView" */;
2367: 			productName = PagerTabStripView;
2368: 		};
2369: 		894827AF2AA5D65600030C4E /* BranchSDK */ = {
2370: 			isa = XCSwiftPackageProductDependency;
2371: 			package = 894827AE2AA5D65600030C4E /* XCRemoteSwiftPackageReference "ios-branch-sdk-spm" */;
2372: 			productName = BranchSDK;
2373: 		};
2374: 		895FE2CF29D7392F00A99D5B /* Collections */ = {
2375: 			isa = XCSwiftPackageProductDependency;
2376: 			package = 895FE2CE29D7392E00A99D5B /* XCRemoteSwiftPackageReference "swift-collections" */;
2377: 			productName = Collections;
2378: 		};
2379: 		895FE2D129D7392F00A99D5B /* OrderedCollections */ = {
2380: 			isa = XCSwiftPackageProductDependency;
2381: 			package = 895FE2CE29D7392E00A99D5B /* XCRemoteSwiftPackageReference "swift-collections" */;
2382: 			productName = OrderedCollections;
2383: 		};
2384: 		8991485529E85DE500DD01F2 /* CombineExt */ = {
2385: 			isa = XCSwiftPackageProductDependency;
2386: 			package = 8991485429E85DE500DD01F2 /* XCRemoteSwiftPackageReference "CombineExt" */;
2387: 			productName = CombineExt;
2388: 		};
2389: 		89923E6629D437F500E246FC /* FirebasePerformance */ = {
2390: 			isa = XCSwiftPackageProductDependency;
2391: 			package = 89CD7BA929D32CE5003F1C3A /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
2392: 			productName = FirebasePerformance;
2393: 		};
2394: 		89CD7BA429D32C52003F1C3A /* Lottie */ = {
2395: 			isa = XCSwiftPackageProductDependency;
2396: 			package = 89CD7BA329D32C52003F1C3A /* XCRemoteSwiftPackageReference "lottie-spm" */;
2397: 			productName = Lottie;
2398: 		};
2399: 		89CD7BA729D32C72003F1C3A /* Factory */ = {
2400: 			isa = XCSwiftPackageProductDependency;
2401: 			package = 89CD7BA629D32C72003F1C3A /* XCRemoteSwiftPackageReference "Factory" */;
2402: 			productName = Factory;
2403: 		};
2404: 		89CD7BAA29D32CE5003F1C3A /* FirebaseAnalyticsSwift */ = {
2405: 			isa = XCSwiftPackageProductDependency;
2406: 			package = 89CD7BA929D32CE5003F1C3A /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
2407: 			productName = FirebaseAnalyticsSwift;
2408: 		};
2409: 		89CD7BAC29D32CE5003F1C3A /* FirebaseCrashlytics */ = {
2410: 			isa = XCSwiftPackageProductDependency;
2411: 			package = 89CD7BA929D32CE5003F1C3A /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
2412: 			productName = FirebaseCrashlytics;
2413: 		};
2414: /* End XCSwiftPackageProductDependency section */
2415: 
2416: /* Begin XCVersionGroup section */
2417: 		893C8FCC29DED254000E35BD /* AppCoreData.xcdatamodeld */ = {
2418: 			isa = XCVersionGroup;
2419: 			children = (
2420: 				893C8FCD29DED254000E35BD /* PdfExpert.xcdatamodel */,
2421: 			);
2422: 			currentVersion = 893C8FCD29DED254000E35BD /* PdfExpert.xcdatamodel */;
2423: 			path = AppCoreData.xcdatamodeld;
2424: 			sourceTree = "<group>";
2425: 			versionGroupType = wrapper.xcdatamodel;
2426: 		};
2427: /* End XCVersionGroup section */
2428: 	};
2429: 	rootObject = 89CD7A8E29D32855003F1C3A /* Project object */;
2430: }
```

## File: ShareFileExtension/Base.lproj/MainInterface.storyboard
```
  1: <?xml version="1.0" encoding="UTF-8"?>
  2: <document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="23504" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="j1y-V4-xli">
  3:     <device id="retina6_12" orientation="portrait" appearance="dark"/>
  4:     <dependencies>
  5:         <deployment identifier="iOS"/>
  6:         <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="23506"/>
  7:         <capability name="Named colors" minToolsVersion="9.0"/>
  8:         <capability name="Safe area layout guides" minToolsVersion="9.0"/>
  9:         <capability name="System colors in document resources" minToolsVersion="11.0"/>
 10:         <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
 11:     </dependencies>
 12:     <customFonts key="customFonts">
 13:         <array key="Montserrat-Bold.ttf">
 14:             <string>Montserrat-Bold</string>
 15:         </array>
 16:         <array key="Montserrat-Regular.ttf">
 17:             <string>Montserrat-Regular</string>
 18:         </array>
 19:     </customFonts>
 20:     <scenes>
 21:         <!--Share View Controller-->
 22:         <scene sceneID="ceB-am-kn3">
 23:             <objects>
 24:                 <viewController id="j1y-V4-xli" customClass="ShareViewController" customModule="ShareFileExtension" sceneMemberID="viewController">
 25:                     <view key="view" opaque="NO" contentMode="scaleToFill" id="wbc-yd-nQP">
 26:                         <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>
 27:                         <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
 28:                         <subviews>
 29:                             <view contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="Udp-n4-U3L" userLabel="Pdf Container View">
 30:                                 <rect key="frame" x="0.0" y="159" width="393" height="559"/>
 31:                                 <color key="backgroundColor" systemColor="systemBackgroundColor"/>
 32:                             </view>
 33:                             <activityIndicatorView opaque="NO" contentMode="scaleToFill" horizontalHuggingPriority="750" verticalHuggingPriority="750" style="medium" translatesAutoresizingMaskIntoConstraints="NO" id="LoB-cg-3Nl" userLabel="Activity Indicator View">
 34:                                 <rect key="frame" x="186.66666666666666" y="428.66666666666669" width="20" height="20"/>
 35:                             </activityIndicatorView>
 36:                             <stackView opaque="NO" contentMode="scaleToFill" axis="vertical" spacing="30" translatesAutoresizingMaskIntoConstraints="NO" id="LWe-jE-eXY" userLabel="Password View">
 37:                                 <rect key="frame" x="61.333333333333343" y="397.33333333333331" width="270.33333333333326" height="82.666666666666686"/>
 38:                                 <subviews>
 39:                                     <label opaque="NO" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="This document is password protected" textAlignment="natural" lineBreakMode="tailTruncation" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="TEi-fC-wqT" userLabel="Password Description Label">
 40:                                         <rect key="frame" x="0.0" y="0.0" width="270.33333333333331" height="18.666666666666668"/>
 41:                                         <fontDescription key="fontDescription" name="Montserrat-Regular" family="Montserrat" pointSize="16"/>
 42:                                         <color key="textColor" name="PrimaryText"/>
 43:                                         <nil key="highlightedColor"/>
 44:                                     </label>
 45:                                     <textField opaque="NO" contentMode="scaleToFill" horizontalHuggingPriority="248" contentHorizontalAlignment="left" contentVerticalAlignment="center" borderStyle="roundedRect" placeholder="Password" textAlignment="natural" minimumFontSize="17" translatesAutoresizingMaskIntoConstraints="NO" id="Mhr-1M-pA1" userLabel="Password Text Field">
 46:                                         <rect key="frame" x="0.0" y="48.666666666666686" width="270.33333333333331" height="34"/>
 47:                                         <color key="backgroundColor" name="SecondaryBG"/>
 48:                                         <color key="textColor" name="PrimaryText"/>
 49:                                         <fontDescription key="fontDescription" type="system" pointSize="14"/>
 50:                                         <textInputTraits key="textInputTraits" autocorrectionType="no" secureTextEntry="YES" textContentType="password"/>
 51:                                     </textField>
 52:                                 </subviews>
 53:                             </stackView>
 54:                             <button opaque="NO" contentMode="scaleToFill" contentHorizontalAlignment="center" contentVerticalAlignment="center" lineBreakMode="middleTruncation" translatesAutoresizingMaskIntoConstraints="NO" id="md1-kw-C6s" userLabel="Button">
 55:                                 <rect key="frame" x="133" y="740" width="127" height="48"/>
 56:                                 <color key="backgroundColor" name="ButtonGradientEnd"/>
 57:                                 <constraints>
 58:                                     <constraint firstAttribute="height" constant="48" id="jhC-lL-wjN"/>
 59:                                 </constraints>
 60:                                 <fontDescription key="fontDescription" name="Montserrat-Bold" family="Montserrat" pointSize="16"/>
 61:                                 <inset key="imageEdgeInsets" minX="0.0" minY="0.0" maxX="2.2250738585072014e-308" maxY="0.0"/>
 62:                                 <state key="normal" title="Open in AtlasPDF"/>
 63:                                 <userDefinedRuntimeAttributes>
 64:                                     <userDefinedRuntimeAttribute type="number" keyPath="layer.cornerRadius">
 65:                                         <integer key="value" value="10"/>
 66:                                     </userDefinedRuntimeAttribute>
 67:                                 </userDefinedRuntimeAttributes>
 68:                             </button>
 69:                         </subviews>
 70:                         <viewLayoutGuide key="safeArea" id="1Xd-am-t49"/>
 71:                         <color key="backgroundColor" systemColor="systemBackgroundColor"/>
 72:                         <constraints>
 73:                             <constraint firstItem="LWe-jE-eXY" firstAttribute="centerY" secondItem="1Xd-am-t49" secondAttribute="centerY" id="5aa-8c-GSl"/>
 74:                             <constraint firstItem="Udp-n4-U3L" firstAttribute="leading" secondItem="1Xd-am-t49" secondAttribute="leading" id="6vG-gl-vKq"/>
 75:                             <constraint firstItem="LoB-cg-3Nl" firstAttribute="centerY" secondItem="1Xd-am-t49" secondAttribute="centerY" id="PSB-Qe-bRS"/>
 76:                             <constraint firstItem="Udp-n4-U3L" firstAttribute="top" secondItem="1Xd-am-t49" secondAttribute="top" constant="100" id="WE5-10-z7f"/>
 77:                             <constraint firstItem="LoB-cg-3Nl" firstAttribute="centerX" secondItem="1Xd-am-t49" secondAttribute="centerX" id="Y6X-rb-27W"/>
 78:                             <constraint firstItem="1Xd-am-t49" firstAttribute="bottom" secondItem="md1-kw-C6s" secondAttribute="bottom" constant="30" id="b0O-G2-bVJ"/>
 79:                             <constraint firstItem="LWe-jE-eXY" firstAttribute="centerX" secondItem="1Xd-am-t49" secondAttribute="centerX" id="d9B-XK-8hX"/>
 80:                             <constraint firstItem="1Xd-am-t49" firstAttribute="trailing" secondItem="Udp-n4-U3L" secondAttribute="trailing" id="jD3-5L-qBn"/>
 81:                             <constraint firstItem="md1-kw-C6s" firstAttribute="centerX" secondItem="1Xd-am-t49" secondAttribute="centerX" id="zl2-pc-a5K"/>
 82:                             <constraint firstItem="1Xd-am-t49" firstAttribute="bottom" secondItem="Udp-n4-U3L" secondAttribute="bottom" constant="100" id="zr2-mg-6uf"/>
 83:                         </constraints>
 84:                     </view>
 85:                     <connections>
 86:                         <outlet property="activityIndicatorView" destination="LoB-cg-3Nl" id="7Id-do-2HB"/>
 87:                         <outlet property="button" destination="md1-kw-C6s" id="dU4-XV-0F1"/>
 88:                         <outlet property="passwordTextField" destination="Mhr-1M-pA1" id="k55-QT-b18"/>
 89:                         <outlet property="passwordView" destination="LWe-jE-eXY" id="Keg-cJ-2PI"/>
 90:                         <outlet property="pdfContainerView" destination="Udp-n4-U3L" id="IKz-ab-Rq7"/>
 91:                     </connections>
 92:                 </viewController>
 93:                 <placeholder placeholderIdentifier="IBFirstResponder" id="CEy-Cv-SGf" userLabel="First Responder" sceneMemberID="firstResponder"/>
 94:             </objects>
 95:             <point key="canvasLocation" x="140" y="-2"/>
 96:         </scene>
 97:     </scenes>
 98:     <resources>
 99:         <namedColor name="ButtonGradientEnd">
100:             <color red="0.24705882352941178" green="0.56862745098039214" blue="0.97254901960784312" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
101:         </namedColor>
102:         <namedColor name="PrimaryText">
103:             <color red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
104:         </namedColor>
105:         <namedColor name="SecondaryBG">
106:             <color red="0.13725490196078433" green="0.14117647058823529" blue="0.14901960784313725" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
107:         </namedColor>
108:         <systemColor name="systemBackgroundColor">
109:             <color white="1" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
110:         </systemColor>
111:     </resources>
112: </document>
```

## File: ShareFileExtension/Resources/Production/Info.plist
```
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5: 	<key>CFBundleShortVersionString</key>
 6: 	<string>1.0</string>
 7: 	<key>CFBundleVersion</key>
 8: 	<string>1.26</string>
 9: 	<key>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
10: &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
11: &lt;plist version=&quot;1.0&quot;&gt;
12: &lt;string&gt;&lt;/string&gt;
13: &lt;/plist&gt;
14: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
15: &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
16: &lt;plist version=&quot;1.0&quot;&gt;
17: &lt;string&gt;&lt;/string&gt;
18: &lt;/plist&gt;
19: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
20: &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
21: &lt;plist version=&quot;1.0&quot;&gt;
22: &lt;string&gt;&lt;/string&gt;
23: &lt;/plist&gt;
24: </key>
25: 	<string></string>
26: 	<key>LSApplicationQueriesSchemes</key>
27: 	<array>
28: 		<string>pdfpro</string>
29: 	</array>
30: 	<key>NSExtension</key>
31: 	<dict>
32: 		<key>NSExtensionAttributes</key>
33: 		<dict>
34: 			<key>NSExtensionActivationRule</key>
35: 			<string>SUBQUERY (
36:     extensionItems,
37:     $extensionItem,
38:     SUBQUERY (
39:         $extensionItem.attachments,
40:         $attachment,
41:         ANY $attachment.registeredTypeIdentifiers UTI-CONFORMS-TO &quot;com.adobe.pdf&quot;
42:     ).@count == $extensionItem.attachments.@count
43: ).@count == 1</string>
44: 		</dict>
45: 		<key>NSExtensionMainStoryboard</key>
46: 		<string>MainInterface</string>
47: 		<key>NSExtensionPointIdentifier</key>
48: 		<string>com.apple.share-services</string>
49: 	</dict>
50: </dict>
51: </plist>
```

## File: ShareFileExtension/Resources/Staging/Info.plist
```
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5: 	<key>LSApplicationQueriesSchemes</key>
 6: 	<array>
 7: 		<string>pdfprostaging</string>
 8: 	</array>
 9: 	<key>NSExtension</key>
10: 	<dict>
11: 		<key>NSExtensionAttributes</key>
12: 		<dict>
13: 			<key>NSExtensionActivationRule</key>
14: 			<string>SUBQUERY (
15:     extensionItems,
16:     $extensionItem,
17:     SUBQUERY (
18:         $extensionItem.attachments,
19:         $attachment,
20:         ANY $attachment.registeredTypeIdentifiers UTI-CONFORMS-TO "com.adobe.pdf"
21:     ).@count == $extensionItem.attachments.@count
22: ).@count == 1</string>
23: 		</dict>
24: 		<key>NSExtensionMainStoryboard</key>
25: 		<string>MainInterface</string>
26: 		<key>NSExtensionPointIdentifier</key>
27: 		<string>com.apple.share-services</string>
28: 	</dict>
29: </dict>
30: </plist>
```

## File: ShareFileExtension/ShareFileExtension.entitlements
```
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5: 	<key>aps-environment</key>
 6: 	<string>development</string>
 7: 	<key>com.apple.developer.icloud-container-identifiers</key>
 8: 	<array>
 9: 		<string>iCloud.pdfexpert</string>
10: 	</array>
11: 	<key>com.apple.developer.icloud-services</key>
12: 	<array>
13: 		<string>CloudKit</string>
14: 		<string>CloudDocuments</string>
15: 	</array>
16: 	<key>com.apple.developer.ubiquity-container-identifiers</key>
17: 	<array>
18: 		<string>iCloud.pdfexpert</string>
19: 	</array>
20: 	<key>com.apple.security.application-groups</key>
21: 	<array>
22: 		<string>group.pcnaid.pdfexpert</string>
23: 	</array>
24: </dict>
25: </plist>
```

## File: ShareFileExtension/ShareViewController.swift
```swift
  1: //
  2: //  ShareViewController.swift
  3: //  ShareFileExtension
  4: //
  5: //  Created by Pcnaid Inc on 05/05/23.
  6: //
  7: 
  8: import UIKit
  9: import UniformTypeIdentifiers
 10: import PDFKit
 11: 
 12: class ShareViewController: UIViewController {
 13: 
 14:     @IBOutlet weak var pdfContainerView: UIView!
 15:     @IBOutlet weak var activityIndicatorView: UIActivityIndicatorView!
 16:     @IBOutlet weak var button: UIButton!
 17:     @IBOutlet weak var passwordView: UIStackView!
 18:     @IBOutlet weak var passwordTextField: UITextField!
 19:     
 20:     private let pdfView = PDFView()
 21:     
 22:     private var confirmedPassword: String?
 23:     private var buttonOriginalText: String = ""
 24:     
 25:     override func viewDidLoad() {
 26:         super.viewDidLoad()
 27: 
 28:         self.activityIndicatorView.startAnimating()
 29:         
 30:         self.button.addTarget(self, action: #selector(self.onButtonPressed), for: .touchUpInside)
 31:         
 32:         self.buttonOriginalText = self.button.title(for: .normal) ?? ""
 33:         
 34:         self.pdfContainerView.addSubview(self.pdfView)
 35:         self.pdfView.translatesAutoresizingMaskIntoConstraints = false
 36:         self.pdfContainerView.addConstraint(NSLayoutConstraint(item: self.pdfView,
 37:                                                                attribute: .top,
 38:                                                                relatedBy: .equal,
 39:                                                                toItem: self.pdfContainerView,
 40:                                                                attribute: .top,
 41:                                                                multiplier: 1,
 42:                                                                constant: 0))
 43:         self.pdfContainerView.addConstraint(NSLayoutConstraint(item: self.pdfView,
 44:                                                                attribute: .bottom,
 45:                                                                relatedBy: .equal,
 46:                                                                toItem: self.pdfContainerView,
 47:                                                                attribute:.bottom,
 48:                                                                multiplier: 1,
 49:                                                                constant: 0))
 50:         self.pdfContainerView.addConstraint(NSLayoutConstraint(item: self.pdfView,
 51:                                                                attribute: .leading,
 52:                                                                relatedBy: .equal,
 53:                                                                toItem: self.pdfContainerView,
 54:                                                                attribute: .leading,
 55:                                                                multiplier: 1, constant: 0))
 56:         self.pdfContainerView.addConstraint(NSLayoutConstraint(item: self.pdfView, attribute: .trailing,
 57:                                                                relatedBy: .equal,
 58:                                                                toItem: self.pdfContainerView,
 59:                                                                attribute: .trailing,
 60:                                                                multiplier: 1,
 61:                                                                constant: 0))
 62:         
 63:         self.passwordTextField.delegate = self
 64:         
 65:         self.updateUI()
 66:         self.loadFile()
 67:     }
 68:     
 69:     override func viewDidAppear(_ animated: Bool) {
 70:         super.viewDidAppear(animated)
 71:     }
 72:     
 73:     // MARK: - Private Methods
 74:     
 75:     private func loadFile() {
 76:         
 77:         if let extensionContext = self.extensionContext {
 78:             debugPrint("ShareViewController - Extension Context exist...")
 79:             if let item = extensionContext.inputItems.first as? NSExtensionItem, let itemProvider = item.attachments?.first {
 80:                 
 81:                 if itemProvider.hasItemConformingToTypeIdentifier(UTType.pdf.identifier) {
 82:                     itemProvider.loadItem(
 83:                         forTypeIdentifier: UTType.pdf.identifier,
 84:                         options: nil,
 85:                         completionHandler: { [weak self](result, error) in
 86:                             
 87:                             guard let result = result else {
 88:                                 debugPrint("ShareViewController - Missing results")
 89:                                 return
 90:                             }
 91:                             
 92:                             if let error = error {
 93:                                 debugPrint("ShareViewController - Coulnd't load file. Error: \(error.localizedDescription)")
 94:                                 return
 95:                             }
 96:                             
 97:                             var pdfDocument: PDFDocument?
 98:                             
 99:                             if let url = result as? URL {
100:                                 pdfDocument = PDFDocument(url: url)
101:                             }
102:                             
103:                             if let data = result as? Data {
104:                                 pdfDocument = PDFDocument(data: data)
105:                             }
106:                             
107:                             if let pdfDocument = pdfDocument {
108:                                 debugPrint("ShareViewController - Successfully retreived pdf through action extension!")
109:                                 DispatchQueue.main.async {
110:                                     self?.pdfView.document = pdfDocument
111:                                     self?.pdfView.autoScales = true
112:                                     self?.updateUI()
113:                                 }
114:                             } else {
115:                                 debugPrint("ShareViewController - Failed to convert file to pdf!")
116:                             }
117:                         })
118:                 }
119:             }
120:         }
121:     }
122:     
123:     private func updateUI() {
124:         if let pdfDocument = self.pdfView.document {
125:             if pdfDocument.isLocked {
126:                 self.pdfContainerView.isHidden = true
127:                 self.activityIndicatorView.isHidden = true
128:                 self.button.isHidden = false
129:                 self.passwordView.isHidden = false
130:                 self.button.setTitle("Unlock", for: .normal)
131:             } else {
132:                 self.pdfContainerView.isHidden = false
133:                 self.activityIndicatorView.isHidden = true
134:                 self.button.isHidden = false
135:                 self.passwordView.isHidden = true
136:                 self.button.setTitle(self.buttonOriginalText, for: .normal)
137:             }
138:         } else {
139:             self.pdfContainerView.isHidden = true
140:             self.activityIndicatorView.isHidden = false
141:             self.button.isHidden = true
142:             self.passwordView.isHidden = true
143:         }
144:     }
145:     
146:     private func unlockPdf(pdfDocument: PDFDocument) {
147:         let password = self.passwordTextField.text ?? ""
148:         if pdfDocument.unlock(withPassword: password) {
149:             debugPrint("Share Extension - Pdf Unlocked!")
150:             self.confirmedPassword = password
151:             self.updateUI()
152:         } else {
153:             self.passwordTextField.text = nil
154:             let alert = UIAlertController(title: "Error", message: "Wrong Password", preferredStyle: .alert)
155:             alert.addAction(UIAlertAction(title: "OK", style: .default))
156:             self.present(alert, animated: true, completion: nil)
157:         }
158:     }
159:     
160:     private func sharePdf(pdfDocument: PDFDocument) {
161:         guard let extensionContext = self.extensionContext else {
162:             assertionFailure("Missing expected extensionContext")
163:             return
164:         }
165:         
166:         guard let url = URL(string: SharedStorage.schema) else {
167:             assertionFailure("Cannot create url to app")
168:             return
169:         }
170:         
171:         guard let pdfData = pdfDocument.dataRepresentation() else {
172:             assertionFailure("Missing expected pdf document data")
173:             self.showGenericErrorAlert()
174:             return
175:         }
176:         
177:         SharedStorage.pdfDataShareExtensionExistanceFlag = true
178:         SharedStorage.pdfDataShareExtension = pdfData
179:         if let confirmedPassword = self.confirmedPassword {
180:             SharedStorage.pdfDataShareExtensionPassword = confirmedPassword
181:         }
182:         let fileSizeWithUnit = ByteCountFormatter.string(fromByteCount: Int64(pdfData.count), countStyle: .file)
183:         debugPrint("Share Extension - Saved pdf data with size: \(fileSizeWithUnit)")
184:         if self.openURL(url) {
185:             extensionContext.completeRequest(returningItems: [], completionHandler: nil)
186:         } else {
187:             assertionFailure("Failed to open containing app")
188:         }
189:     }
190:     
191:     private func showGenericErrorAlert() {
192:         let alert = UIAlertController(title: "Ooops!", message: "Something went wrong! Please try again later.", preferredStyle: .alert)
193:         alert.addAction(UIAlertAction(title: "Ok", style: .default))
194:         self.present(alert, animated: true, completion: nil)
195:     }
196:     
197:     // MARK: - Actions
198:     
199:     @objc fileprivate func onButtonPressed() {
200:         guard let pdfDocument = self.pdfView.document else {
201:             assertionFailure("Missing expected pdf document")
202:             return
203:         }
204:         
205:         if pdfDocument.isLocked {
206:             self.unlockPdf(pdfDocument: pdfDocument)
207:         } else {
208:             self.sharePdf(pdfDocument: pdfDocument)
209:         }
210:     }
211:     
212:     //  Function must be named exactly like this so a selector can be found by the compiler!
213:     //  Anyway - it's another selector in another instance that would be "performed" instead.
214:     @objc func openURL(_ url: URL) -> Bool {
215:         var responder: UIResponder? = self
216:         while responder != nil {
217:             if let application = responder as? UIApplication {
218:                 return application.perform(#selector(openURL(_:)), with: url) != nil
219:             }
220:             responder = responder?.next
221:         }
222:         return false
223:     }
224: }
225: 
226: extension ShareViewController: UITextFieldDelegate {
227:     func textFieldShouldReturn(_ textField: UITextField) -> Bool {
228:         self.onButtonPressed()
229:         return true
230:     }
231: }
```

## File: .gitignore
```
 1: # Xcode
 2: #
 3: # gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore
 4: 
 5: ## Build generated
 6: build/
 7: DerivedData/
 8: 
 9: ## Various settings
10: *.pbxuser
11: !default.pbxuser
12: *.mode1v3
13: !default.mode1v3
14: *.mode2v3
15: !default.mode2v3
16: *.perspectivev3
17: !default.perspectivev3
18: xcuserdata/
19: 
20: ## Other
21: *.moved-aside
22: *.xccheckout
23: *.xcscmblueprint
24: 
25: ## Obj-C/Swift specific
26: *.hmap
27: *.ipa
28: *.dSYM.zip
29: *.dSYM
30: 
31: ## Playgrounds
32: timeline.xctimeline
33: playground.xcworkspace
34: 
35: # Swift Package Manager
36: #
37: # Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
38: # Packages/
39: # Package.pins
40: # Package.resolved
41: .build/
42: 
43: # CocoaPods
44: #
45: # We recommend against adding the Pods directory to your .gitignore. However
46: # you should judge for yourself, the pros and cons are mentioned at:
47: # https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
48: #
49: # Pods/
50: 
51: # Carthage
52: #
53: # Add this line if you want to avoid checking in source code from Carthage dependencies.
54: # Carthage/Checkouts
55: 
56: Carthage/Build
57: 
58: # Firebase
59: PdfExpert/**/GoogleService-Info.plist
60: # Info Plist
61: PdfExpert/**/Info.plist
62: # ProjectInfo Plist
63: PdfExpert/**/ProjectInfo.plist
```

## File: README.md
```markdown
 1: # AtlasPDF
 2: AtlasPDF is an iOS app for iPhones that allow users to edit and manage their pdf files.
 3: 
 4: # Main features
 5: 
 6: ## Conversion and Import
 7: 1. Conversion of Word, Pages, PowerPoint, Keynote, Excel and Numbers files to pdf.
 8: 2. Image acquistion from gallery, camera and File app, and conversion to pdf.
 9: 3. Import pdf (from within the app and through app extension).
10: 4. Scan documents to pdf.
11: 
12: ## Edit
13: 1. Add margins.
14: 2. Change compression quality.
15: 3. Add pages.
16: 4. Reorder pages.
17: 5. Delete pages.
18: 6. Add text annotations.
19: 7. Fill editable fields.
20: 8. Add signature.
21: 9. Remove/add password.
22: 
23: ## Other
24: 1. Share of pdf files.
25: 2. Subscription to unlock share feature.
26: 3. Stored created pdf through iCloud.
27: 4. Deletion of created pdfs.
28: 5. Onboarding with tutorial.
29: 6. Tutorial to open pdf from outside the app through app extension.
30: 
31: # Technologies Used
32: 1. SwiftUI
33: 2. StoreKit 2
34: 3. Core Data
35: 4. iCloud
36: 5. PDFKit
37: 6. Firebase Analytics
38: 7. Firebase Remote Config (used to switch between two type of subscription screens)
39: 8. VisionKit (used for the scanner feature)
40: 9. PencilKit (used to take the user's signature)
```
